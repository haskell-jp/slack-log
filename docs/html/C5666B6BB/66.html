<!DOCTYPE html><html><head><meta charset="utf-8"><title>haskell-jp / questions #66</title><link rel="stylesheet" href="../../main.css" type="text/css" media="screen"></head><body><div class="ui container"><h1>haskell-jp / questions #66</h1><div class="pager ui pagination menu"><a href="../../html/C5666B6BB/65.html" class="pager__previous item">Previous</a><a href="../../" class="pager__top item">Top</a><a href="../../html/C5666B6BB/67.html" class="pager__next item">Next</a></div><div class="message_list ui feed"><div class="message event" id="message-1564031792.030700"><div class="content"><div class="summary"><div class="message__header user">notogawa</div><div class="message__timestamp date"><a class="date" href="#message-1564031792.030700">2019-07-25&nbsp;14:16:32 +0900</a></div></div><div class="message__body description">型の上で計算するだけで終わりにしていいのならそのように大概のことはできるんですが，今やろうとしているのは証明であり，値レベルで云々する(≒singletonsとかでゴニョゴニョする)必要があります．たとえば，<br/><pre>
sNatToNat' :: Sing n -&gt; Sing (ConvertNat n)
sNat'ToNat :: Sing (ConvertNat n) -&gt; Sing n
</pre><br/>みたいな部品が必要になると思いますが，コレを定義してやろうとすると正攻法では詰むと思います．</div></div></div><div class="message event" id="message-1564183015.031300"><div class="content"><div class="summary"><div class="message__header user">shunkichi.sato</div><div class="message__timestamp date"><a class="date" href="#message-1564183015.031300">2019-07-27&nbsp;08:16:55 +0900</a></div></div><div class="message__body description">@shunkichi.sato has joined the channel</div></div></div><div class="message event" id="message-1564196017.031600"><div class="content"><div class="summary"><div class="message__header user">woodsondelhia88</div><div class="message__timestamp date"><a class="date" href="#message-1564196017.031600">2019-07-27&nbsp;11:53:37 +0900</a></div></div><div class="message__body description">@woodsondelhia88 has joined the channel</div></div></div><div class="message event" id="message-1564202852.031900"><div class="content"><div class="summary"><div class="message__header user">ogahiro0720</div><div class="message__timestamp date"><a class="date" href="#message-1564202852.031900">2019-07-27&nbsp;13:47:32 +0900</a></div></div><div class="message__body description">@ogahiro0720 has joined the channel</div></div></div><div class="message event" id="message-1564202948.032200"><div class="content"><div class="summary"><div class="message__header user">yama_aoi</div><div class="message__timestamp date"><a class="date" href="#message-1564202948.032200">2019-07-27&nbsp;13:49:08 +0900</a></div></div><div class="message__body description">@yama_aoi has joined the channel</div></div></div><div class="message event" id="message-1564202962.032500"><div class="content"><div class="summary"><div class="message__header user">cj.bc-sd</div><div class="message__timestamp date"><a class="date" href="#message-1564202962.032500">2019-07-27&nbsp;13:49:22 +0900</a></div></div><div class="message__body description">@cj.bc-sd has joined the channel</div></div></div><div class="message event" id="message-1564203079.032800"><div class="content"><div class="summary"><div class="message__header user">wuthering1118</div><div class="message__timestamp date"><a class="date" href="#message-1564203079.032800">2019-07-27&nbsp;13:51:19 +0900</a></div></div><div class="message__body description">@wuthering1118 has joined the channel</div></div></div><div class="message event" id="message-1564207277.033100"><div class="content"><div class="summary"><div class="message__header user">k.kent8192</div><div class="message__timestamp date"><a class="date" href="#message-1564207277.033100">2019-07-27&nbsp;15:01:17 +0900</a></div></div><div class="message__body description">@k.kent8192 has joined the channel</div></div></div><div class="message event" id="message-1564208415.033400"><div class="content"><div class="summary"><div class="message__header user">drmaruyama</div><div class="message__timestamp date"><a class="date" href="#message-1564208415.033400">2019-07-27&nbsp;15:20:15 +0900</a></div></div><div class="message__body description">@drmaruyama has joined the channel</div></div></div><div class="message event" id="message-1564213476.035800"><div class="content"><div class="summary"><div class="message__header user">lotz</div><div class="message__timestamp date"><a class="date" href="#message-1564213476.035800">2019-07-27&nbsp;16:44:36 +0900</a></div></div><div class="message__body description">質問です :raising_hand:<br/>cassavaを使ってCSV をパースした結果をextensibleのRecordにしようとしてるのですが<br/><pre>
readCSV :: WrapForall Csv.FromField Vector xs =&gt; FilePath -&gt; IO (RecordOf Vector xs)
readCSV filepath = do
    csvBs &lt;- BL.readFile filepath
    case Csv.decode Csv.HasHeader csvBs :: Either String (Vector (Record xs)) of
        Left reason -&gt; error reason
        Right vs -&gt; undefined
</pre><br/>以下のような感じでカインドが合わないと怒られてしまいます…<br/><pre>
....hs:36:82: error:
    • Expected kind '[membership-0:Type.Membership.Internal.Assoc
                        k0 *]',
        but 'xs' has kind '[*]'
    • In the second argument of 'RecordOf', namely 'xs'
      In the first argument of 'IO', namely '(RecordOf Vector xs)'
      In the type signature:
        readCSV :: WrapForall Csv.FromField Vector xs =&gt;
                   FilePath -&gt; IO (RecordOf Vector xs)
   |
36 | readCSV :: WrapForall Csv.FromField Vector xs =&gt; FilePath -&gt; IO (RecordOf Vector xs)
   |   
</pre><br/>どなたか対処方法を教えていただけませんでしょうか :bow:</div></div></div><div class="message event" id="message-1564213875.036200"><div class="content"><div class="summary"><div class="message__header user">lotz</div><div class="message__timestamp date"><a class="date" href="#message-1564213875.036200">2019-07-27&nbsp;16:51:15 +0900</a></div></div><div class="message__body description">@igrep<br/><pre>
{-# LANGUAGE PolyKinds #-}
</pre><br/>試したけどできず…</div></div></div><div class="message event" id="message-1564213935.036400"><div class="content"><div class="summary"><div class="message__header user">fumieval</div><div class="message__timestamp date"><a class="date" href="#message-1564213935.036400">2019-07-27&nbsp;16:52:15 +0900</a></div></div><div class="message__body description"><code>WrapForall Csv.FromField Vector</code>がxsの種を <code>[*]</code> に固定する原因となっています。 <code>Forall (KeyValue KnownSymbol (Instance1 Csv.FromField Vector)) xs</code>としてはどうでしょう</div></div></div><div class="message event" id="message-1564214375.037100"><div class="content"><div class="summary"><div class="message__header user">lotz</div><div class="message__timestamp date"><a class="date" href="#message-1564214375.037100">2019-07-27&nbsp;16:59:35 +0900</a></div></div><div class="message__body description">@fumieval ありがとうございます！今度は以下のようなエラーメッセージになりました:bow:<br/><pre>
....hs:30:125: error:
    • Expected kind '[membership-0:Type.Membership.Internal.Assoc
                        * *]',
        but 'xs' has kind '[membership-0:Type.Membership.Internal.Assoc
                              ghc-prim-0.5.3:GHC.Types.Symbol *]'
    • In the first argument of 'DataFrame', namely 'xs'
      In the first argument of 'IO', namely '(DataFrame xs)'
      In the type signature:
        readCSV :: Forall (KeyValue KnownSymbol (Instance1 Csv.FromField Vector)) xs =&gt;
                   FilePath -&gt; IO (DataFrame xs)
</pre></div></div></div><div class="message event" id="message-1564214540.037300"><div class="content"><div class="summary"><div class="message__header user">fumieval</div><div class="message__timestamp date"><a class="date" href="#message-1564214540.037300">2019-07-27&nbsp;17:02:20 +0900</a></div></div><div class="message__body description">今度こそPolyKinds事案に見えますね… :thinking_face:</div></div></div><div class="message event" id="message-1564215334.037500"><div class="content"><div class="summary"><div class="message__header user">lotz</div><div class="message__timestamp date"><a class="date" href="#message-1564215334.037500">2019-07-27&nbsp;17:15:34 +0900</a></div></div><div class="message__body description">PolyKindsを入れたらエラーが変わりました…！ :pray:<br/><pre>
readCSV :: Forall (KeyValue KnownSymbol (Instance1 Csv.FromField Vector)) xs =&gt; FilePath -&gt; IO (RecordOf Vector xs)
readCSV filepath = do
    csvBs &lt;- BL.readFile filepath
    case Csv.decode Csv.HasHeader csvBs :: Either String (Vector (Record xs)) of
        Left reason -&gt; error reason
        Right vs -&gt; undefined
</pre><br/><br/><pre>
...hs:52:10: error:
    • Could not deduce (Forall
                          (Instance1 Csv.FromField (Field Identity)) xs1)
        arising from a use of 'Csv.decode'
      from the context: Forall
                          (KeyValue KnownSymbol (Instance1 Csv.FromField Vector)) xs
        bound by the type signature for:
                   readCSV :: forall (xs :: [membership-0:Type.Membership.Internal.Assoc
                                               ghc-prim-0.5.3:GHC.Types.Symbol *]).
                              Forall
                                (KeyValue KnownSymbol (Instance1 Csv.FromField Vector)) xs =&gt;
                              FilePath -&gt; IO (RecordOf Vector xs)
        at src/Data/Frame/Reader.hs:49:1-115
    • In the expression:
          Csv.decode Csv.HasHeader csvBs ::
            Either String (Vector (Record xs))
      In a stmt of a 'do' block:
        case  Csv.decode Csv.HasHeader csvBs ::
                Either String (Vector (Record xs))
        of
          Left reason -&gt; error reason
          Right vs -&gt; undefined
      In the expression:
        do csvBs &lt;- BL.readFile filepath
           case  Csv.decode Csv.HasHeader csvBs ::
                   Either String (Vector (Record xs))
           of
             Left reason -&gt; error reason
             Right vs -&gt; undefined
   |
52 |     case Csv.decode Csv.HasHeader csvBs :: Either String (Vector (Record xs)) of
   |          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
</pre></div></div></div><div class="message event" id="message-1564215360.037700"><div class="content"><div class="summary"><div class="message__header user">lotz</div><div class="message__timestamp date"><a class="date" href="#message-1564215360.037700">2019-07-27&nbsp;17:16:00 +0900</a></div></div><div class="message__body description">インスタンスの導出が出来てない… :thinking_face:</div></div></div><div class="message event" id="message-1564215435.037900"><div class="content"><div class="summary"><div class="message__header user">fumieval</div><div class="message__timestamp date"><a class="date" href="#message-1564215435.037900">2019-07-27&nbsp;17:17:15 +0900</a></div></div><div class="message__body description">ScopedTypeVariablesとRankNTypesでxsを束縛していないような雰囲気…？</div></div></div><div class="message event" id="message-1564215645.038100"><div class="content"><div class="summary"><div class="message__header user">lotz</div><div class="message__timestamp date"><a class="date" href="#message-1564215645.038100">2019-07-27&nbsp;17:20:45 +0900</a></div></div><div class="message__body description">あ、LANGUAGEも含めて貼りますね :bow:</div></div></div><div class="message event" id="message-1564215690.038300"><div class="content"><div class="summary"><div class="message__header user">lotz</div><div class="message__timestamp date"><a class="date" href="#message-1564215690.038300">2019-07-27&nbsp;17:21:30 +0900</a></div></div><div class="message__body description"><pre>
{-# LANGUAGE DataKinds #-}
{-# LANGUAGE FlexibleContexts #-}
{-# LANGUAGE PolyKinds #-}
{-# LANGUAGE RankNTypes #-}
{-# LANGUAGE ScopedTypeVariables #-}
{-# LANGUAGE TypeOperators #-}

module Data.Frame.Reader where

import qualified Data.ByteString.Lazy as BL

import qualified Data.Csv as Csv
import Data.Extensible 
import Data.Vector (Vector)

readCSV :: forall xs. Forall (KeyValue KnownSymbol (Instance1 Csv.FromField Vector)) xs =&gt; FilePath -&gt; IO (RecordOf Vector xs)
readCSV filepath = do
    csvBs &lt;- BL.readFile filepath
    case Csv.decode Csv.HasHeader csvBs :: Either String (Vector (Record xs)) of
        Left reason -&gt; error reason
        Right vs -&gt; undefined
</pre><br/><br/><pre>
.hs:19:10: error:
    • Could not deduce (Forall
                          (Instance1 Csv.FromField (Field Identity)) xs)
        arising from a use of 'Csv.decode'
      from the context: Forall
                          (KeyValue KnownSymbol (Instance1 Csv.FromField Vector)) xs
        bound by the type signature for:
                   readCSV :: forall (xs :: [Assoc
                                               ghc-prim-0.5.3:GHC.Types.Symbol *]).
                              Forall
                                (KeyValue KnownSymbol (Instance1 Csv.FromField Vector)) xs =&gt;
                              FilePath -&gt; IO (RecordOf Vector xs)
        at src/Data/Frame/Reader.hs:16:1-126
    • In the expression:
          Csv.decode Csv.HasHeader csvBs ::
            Either String (Vector (Record xs))
      In a stmt of a 'do' block:
        case  Csv.decode Csv.HasHeader csvBs ::
                Either String (Vector (Record xs))
        of
          Left reason -&gt; error reason
          Right vs -&gt; undefined
      In the expression:
        do csvBs &lt;- BL.readFile filepath
           case  Csv.decode Csv.HasHeader csvBs ::
                   Either String (Vector (Record xs))
           of
             Left reason -&gt; error reason
             Right vs -&gt; undefined
</pre></div></div></div><div class="message event" id="message-1564215718.038500"><div class="content"><div class="summary"><div class="message__header user">lotz</div><div class="message__timestamp date"><a class="date" href="#message-1564215718.038500">2019-07-27&nbsp;17:21:58 +0900</a></div></div><div class="message__body description">現状このような感じです！</div></div></div><div class="message event" id="message-1564216168.038700"><div class="content"><div class="summary"><div class="message__header user">fumieval</div><div class="message__timestamp date"><a class="date" href="#message-1564216168.038700">2019-07-27&nbsp;17:29:28 +0900</a></div></div><div class="message__body description">ああ、無名のレコードと互換性がないと言うだけのことでした！こんな感じにすると通ります <pre>
readCSV :: forall xs. Forall (KeyValue KnownSymbol (Instance1 Csv.FromField Identity)) xs =&gt; FilePath -&gt; IO (RecordOf Vector xs)
readCSV filepath = do
    csvBs &lt;- BL.readFile filepath
    case Csv.decodeByName csvBs :: Either String (Csv.Header, Vector (Record xs)) of
        Left reason -&gt; error reason
        Right vs -&gt; undefined
</pre></div></div></div><div class="message event" id="message-1564216303.038900"><div class="content"><div class="summary"><div class="message__header user">lotz</div><div class="message__timestamp date"><a class="date" href="#message-1564216303.038900">2019-07-27&nbsp;17:31:43 +0900</a></div></div><div class="message__body description">通りました!!<br/>そうか、インスタンスにするべきは Vector じゃなくて Identity とだったんですね。<br/>いただいたコードを参考にしながら勉強します :pray:<br/>ありがとうございました :bow:</div></div></div><div class="message event" id="message-1564216854.039100"><div class="content"><div class="summary"><div class="message__header user">lotz</div><div class="message__timestamp date"><a class="date" href="#message-1564216854.039100">2019-07-27&nbsp;17:40:54 +0900</a></div></div><div class="message__body description">なるほど！<br/>FromRecord と FromNamedRecord の差ですか…！<br/><a href='https://gyazo.com/59a3a33419ebec83181cf24c6d42c972'>https://gyazo.com/59a3a33419ebec83181cf24c6d42c972</a><br/><br/>今パースしたいCSV、ヘッダーついてないんですよね… :sweat_smile:</div></div></div><div class="message event" id="message-1564216965.039400"><div class="content"><div class="summary"><div class="message__header user">lotz</div><div class="message__timestamp date"><a class="date" href="#message-1564216965.039400">2019-07-27&nbsp;17:42:45 +0900</a></div></div><div class="message__body description">CSVのByteStringの頭に無理やりヘッダー行追加するか :thinking_face:</div></div></div><div class="message event" id="message-1564218058.039600"><div class="content"><div class="summary"><div class="message__header user">fumieval</div><div class="message__timestamp date"><a class="date" href="#message-1564218058.039600">2019-07-27&nbsp;18:00:58 +0900</a></div></div><div class="message__body description">なるほど…その場合こんな感じですかね　```readCSV :: forall xs. (Forall (Instance1 Csv.FromField (Field Identity)) xs) =&gt; FilePath -&gt; IO (RecordOf Vector xs)<br/>readCSV filepath = do<br/>    csvBs &lt;- BL.readFile filepath<br/>    case Csv.decode Csv.HasHeader csvBs :: Either String (Vector (Record xs)) of<br/>        Left reason -&gt; error reason<br/>        Right vs -&gt; undefined<br/>```</div></div></div><div class="message event" id="message-1564218142.039800"><div class="content"><div class="summary"><div class="message__header user">lotz</div><div class="message__timestamp date"><a class="date" href="#message-1564218142.039800">2019-07-27&nbsp;18:02:22 +0900</a></div></div><div class="message__body description">すごい！！出来るんですね！！<br/>型クラス制約の定義読んで勉強します :sob: :arigatougozaimasu:</div></div></div><div class="message event" id="message-1564218159.040000"><div class="content"><div class="summary"><div class="message__header user">lotz</div><div class="message__timestamp date"><a class="date" href="#message-1564218159.040000">2019-07-27&nbsp;18:02:39 +0900</a></div></div><div class="message__body description">（手元でもコンパイル通りました!! :bow: ）</div></div></div><div class="message event" id="message-1564218172.040300"><div class="content"><div class="summary"><div class="message__header user">gan13027830</div><div class="message__timestamp date"><a class="date" href="#message-1564218172.040300">2019-07-27&nbsp;18:02:52 +0900</a></div></div><div class="message__body description">@gan13027830 has joined the channel</div></div></div><div class="message event" id="message-1564274912.041100"><div class="content"><div class="summary"><div class="message__header user">nnhixi</div><div class="message__timestamp date"><a class="date" href="#message-1564274912.041100">2019-07-28&nbsp;09:48:32 +0900</a></div></div><div class="message__body description">@nnhixi has joined the channel</div></div></div><div class="message event" id="message-1564303895.041500"><div class="content"><div class="summary"><div class="message__header user">alliswellthatendswell</div><div class="message__timestamp date"><a class="date" href="#message-1564303895.041500">2019-07-28&nbsp;17:51:35 +0900</a></div></div><div class="message__body description">@alliswellthatendswell has joined the channel</div></div></div><div class="message event" id="message-1564340963.043600"><div class="content"><div class="summary"><div class="message__header user">kakkun61</div><div class="message__timestamp date"><a class="date" href="#message-1564340963.043600">2019-07-29&nbsp;04:09:23 +0900</a></div></div><div class="message__body description">定作用形についてブログ書くかと書いてたら分からなくなってきました<br/><pre>
fact3 :: Int -&gt; Integer
fact3 = (map fact' [0..] !!)
  where
    fact' 0 = 1
    fact' n = fromIntegral n * fact' (n-1)
</pre><br/><code>fact3</code> はなんで CAF なんでしょう？ <code>map</code> は定数でもなければコンビネーターでもない変数なような……<br/><a href='https://kakkun61.hatenablog.com/entry/2019/07/29/%E9%96%A2%E6%95%B0%E3%81%AE%E3%83%A1%E3%83%A2%E5%8C%96'>https://kakkun61.hatenablog.com/entry/2019/07/29/%E9%96%A2%E6%95%B0%E3%81%AE%E3%83%A1%E3%83%A2%E5%8C%96</a></div></div></div><div class="message event" id="message-1564380382.044200"><div class="content"><div class="summary"><div class="message__header user">dusty.trombone</div><div class="message__timestamp date"><a class="date" href="#message-1564380382.044200">2019-07-29&nbsp;15:06:22 +0900</a></div></div><div class="message__body description">@dusty.trombone has joined the channel</div></div></div><div class="message event" id="message-1564381544.044400"><div class="content"><div class="summary"><div class="message__header user">igrep</div><div class="message__timestamp date"><a class="date" href="#message-1564381544.044400">2019-07-29&nbsp;15:25:44 +0900</a></div></div><div class="message__body description">CAFかどうかと関係あるかわからない、かつ自信がないので元記事のコメントではなくここで。<br/>ちょうど途中まで読んでたこの話 <a href='https://treszkai.github.io/2019/07/13/haskell-eval'>https://treszkai.github.io/2019/07/13/haskell-eval</a> がすごく関係ありそうな気がします。</div></div></div><div class="message event" id="message-1564385022.044700"><div class="content"><div class="summary"><div class="message__header user">mizunashi-mana</div><div class="message__timestamp date"><a class="date" href="#message-1564385022.044700">2019-07-29&nbsp;16:23:42 +0900</a></div></div><div class="message__body description">スーパーコンビネータは，一般の文脈では確かにコンビネータで部分項がスーパーコンビネータであるものを指しますが， CAF の文脈では，<br/>• ラムダ式でない<br/>• ローカル関数が全てグローバルに出しても問題ない定義になっている<br/>だと思うのが良いと思います．厳密には，<br/><a href='https://gitlab.haskell.org/ghc/ghc/wikis/commentary/rts/storage/gc/CAFs'>https://gitlab.haskell.org/ghc/ghc/wikis/commentary/rts/storage/gc/CAFs</a><br/>に書いてある通り，要はサンクとなる static closure のことを指しています．<br/><br/>ところでメモ化の要因は，確かに <code>fact3</code> が CAF であることもありますが，一番の要因として， Core では関数適用の引数は let を通して変数に束縛されることになるので，実際にはこのプログラムは<br/><pre>
fact3 = (!!) fact3'
   where
       fact3' = map fact' l
       l = [0..]
       fact' 0 = 1
       fact' n = ...
</pre><br/>みたいなものと等価になります (厳密にはこれも怪しいですが) ．で， fact3' が CAF となるからというのが大きいですね (なお実際 GHC 8.6.5 では fact3' が floating out されていて， fact3 自体は最終的に eta expand されて <code>fact3 = \x -&gt; (!!) fact3' x</code> という形になっていました)</div></div></div><div class="message event" id="message-1564412515.047300"><div class="content"><div class="summary"><div class="message__header user">yharuhi39</div><div class="message__timestamp date"><a class="date" href="#message-1564412515.047300">2019-07-30&nbsp;00:01:55 +0900</a></div></div><div class="message__body description">はっきりと質問というわけでもないですがrandomよりは質問よりなのでこちらで。  ghc でアノテーション(カスタムアノテーションも含む)が削除されるタイミングっていつなんですかね？ Cmmの段階まで保持されるんですかね？</div></div></div><div class="message event" id="message-1564414903.047400"><div class="content"><div class="summary"><div class="message__header user">yharuhi39</div><div class="message__timestamp date"><a class="date" href="#message-1564414903.047400">2019-07-30&nbsp;00:41:43 +0900</a></div></div><div class="message__body description">あ、これ色々質問が間違ってるや。 そもそも アノテーションではなくプラグマだし。 一般のプラグマに関しては言及不可なやつでしたね。。。すみません。 質問の意図としては。 たとえばLiquid Haskell を用いて ある評価木の一部（またはすべて）の範囲で値が一定の範囲収まるといった情報を知った上でレジスタの配置とかそういった最適化（？）みたいなのができるのかなと思い質問しました。</div></div></div><div class="message event" id="message-1564453083.047800"><div class="content"><div class="summary"><div class="message__header user">igrep</div><div class="message__timestamp date"><a class="date" href="#message-1564453083.047800">2019-07-30&nbsp;11:18:03 +0900</a></div></div><div class="message__body description">これをめっちゃざっくりJSで例えてみました。<br/><a href='https://gist.github.com/igrep/afcf4789d88da3b3995308e2e12c59df'>https://gist.github.com/igrep/afcf4789d88da3b3995308e2e12c59df</a><br/>要するに、メモ化に使うリストをラムダ式の中で定義するか、外で定義してキャッシュするか、という違いですよね？</div></div></div><div class="message event" id="message-1564453085.048000"><div class="content"><div class="summary"><div class="message__header user">igrep</div><div class="message__timestamp date"><a class="date" href="#message-1564453085.048000">2019-07-30&nbsp;11:18:05 +0900</a></div></div><div class="message__body description"></div></div></div><div class="message event" id="message-1564453849.049000"><div class="content"><div class="summary"><div class="message__header user">igrep</div><div class="message__timestamp date"><a class="date" href="#message-1564453849.049000">2019-07-30&nbsp;11:30:49 +0900</a></div></div><div class="message__body description">:point_up: スレッドへの返信でGistを張っただけなのにこっちにも出てくるのか... 驚かせてたらすみません。 :bow:</div></div></div><div class="message event" id="message-1564458305.049200"><div class="content"><div class="summary"><div class="message__header user">kakkun61</div><div class="message__timestamp date"><a class="date" href="#message-1564458305.049200">2019-07-30&nbsp;12:45:05 +0900</a></div></div><div class="message__body description">違うような<br/>（意味論上は同じにもかかわらず）中で定義しても、形によってキャッシュされたりされなかったりという違いかと<br/>理論上は参照透過だから一度計算したものは全部保存してもいいんだけど、現実はメモリーの制約があるから基本的には捨てていて、ただ CAF の形式のときは保存している、という話だと認識している</div></div></div><div class="message event" id="message-1564458874.049400"><div class="content"><div class="summary"><div class="message__header user">igrep</div><div class="message__timestamp date"><a class="date" href="#message-1564458874.049400">2019-07-30&nbsp;12:54:34 +0900</a></div></div><div class="message__body description">すみません、付け加えた言葉がまずかった。「JavaScriptで強引に例えるならあたかも外で定義してキャッシュするかのように振る舞う（Haskellの場合実際には、最初に呼ばれたときにキャッシュされる）」みたいなことを言いたかった。</div></div></div><div class="message event" id="message-1564459211.049600"><div class="content"><div class="summary"><div class="message__header user">igrep</div><div class="message__timestamp date"><a class="date" href="#message-1564459211.049600">2019-07-30&nbsp;13:00:11 +0900</a></div></div><div class="message__body description">外で定義して、っていうか <code>fact3</code> を定義したときに、というべきか。</div></div></div><div class="message event" id="message-1564459462.049800"><div class="content"><div class="summary"><div class="message__header user">igrep</div><div class="message__timestamp date"><a class="date" href="#message-1564459462.049800">2019-07-30&nbsp;13:04:22 +0900</a></div></div><div class="message__body description">少し修正して実態に近づけてみた</div></div></div><div class="message event" id="message-1564460182.050100"><div class="content"><div class="summary"><div class="message__header user">kakkun61</div><div class="message__timestamp date"><a class="date" href="#message-1564460182.050100">2019-07-30&nbsp;13:16:22 +0900</a></div></div><div class="message__body description">13章が読むリスト積まれた <a href='https://www.microsoft.com/en-us/research/publication/the-implementation-of-functional-programming-languages/'>https://www.microsoft.com/en-us/research/publication/the-implementation-of-functional-programming-languages/</a></div></div></div><div class="message event" id="message-1564492113.050600"><div class="content"><div class="summary"><div class="message__header user">niszet0016</div><div class="message__timestamp date"><a class="date" href="#message-1564492113.050600">2019-07-30&nbsp;22:08:33 +0900</a></div></div><div class="message__body description">@niszet0016 has joined the channel</div></div></div><div class="message event" id="message-1564495379.050800"><div class="content"><div class="summary"><div class="message__header user">cutsea110</div><div class="message__timestamp date"><a class="date" href="#message-1564495379.050800">2019-07-30&nbsp;23:02:59 +0900</a></div></div><div class="message__body description">この辺の分かりやすい説明はHaskell High Perfomance Programmingのchaper 1に書いてあります.<br/>blog記事にも出てたので持っている前提で書きますがp8です.<br/><br/>fib_memとfib_mem_argとを比較して<br/>「map fib [0..]は引数に依存せずメモ化することが可能だけれど関数に引数を適用すると暗黙のうちに以前の関数適用からの式へのポインタを持つことができない新しい式を作ってしまうからです」<br/>つまりwhereで定義しているローカル関数fibはfib_memにぶら下がっているのに対してfib_mem_argの方はfib_mem_arg n(というnに適用した式)に対してローカル関数fibがぶらさがっている.つまりnが適用される都度別のfibになるとみなすとよい(のかな).<br/>結果としてmap fib [0..]のfibは毎度違ってしまう.</div></div></div><div class="message event" id="message-1564496016.051100"><div class="content"><div class="summary"><div class="message__header user">cutsea110</div><div class="message__timestamp date"><a class="date" href="#message-1564496016.051100">2019-07-30&nbsp;23:13:36 +0900</a></div></div><div class="message__body description">CAFsがポイントになるのは結局トップレベルにリフトできるからで,トップレベルから掴んでいられるから評価が進めばサンクが潰れて値に置き換わって再利用できるということで,fib_mem_argのようにトップレベルに着地できうに宙に浮いてしまってたら一度評価したものも失われるのでメモ化されない.<br/>逆に言えばメモリを解放する手段がないわけだからメモリリーク(と言っていいのかどうかいまだに私は迷うのだけど)している.<br/>なので速度は出るけどメモリは食い続ける一方でGCできないはず.<br/>というわけで,やっぱりtabulationするのが一番いいんじゃないかと思うけどそれはまた別の話か.</div></div></div><div class="message event" id="message-1564530659.054900"><div class="content"><div class="summary"><div class="message__header user">cutsea110</div><div class="message__timestamp date"><a class="date" href="#message-1564530659.054900">2019-07-31&nbsp;08:50:59 +0900</a></div></div><div class="message__body description"><a href='https://wiki.haskell.org/Let_vs._Where'>https://wiki.haskell.org/Let_vs._Where</a><br/>このページはテーマはlet vs whereですがlast sectionのProblem with whereで全く同じ話題を扱っていて,結論としてはh2p2の通りですが,whereをletで書き換えるとfib’が引数ごとにredefineされるのが分かるだろと解説してあって,これでも良いかもね.</div></div></div><div class="message event" id="message-1564532647.062900"><div class="content"><div class="summary"><div class="message__header user">cutsea110</div><div class="message__timestamp date"><a class="date" href="#message-1564532647.062900">2019-07-31&nbsp;09:24:07 +0900</a></div></div><div class="message__body description">CAFsだからキャシュしてるんじゃなく,サンクが評価されて値になるものは常に次アクセスされたらちゃんとキャッシュされた値が使われる.<br/>CAFsになってればトップレベルにリフトしてくれて,そのためにキャッシュされた式にアクセスできるからキャッシュを効かせられる.<br/>一方CAFsじゃないやつは毎回新しい式になるので以前の評価済みの式ではないから再評価する必要があって結果キャッシュを効かせられてない.<br/>と言う説明になるんじゃないかな.</div></div></div><div class="message event" id="message-1564539553.063300"><div class="content"><div class="summary"><div class="message__header user">kakkun61</div><div class="message__timestamp date"><a class="date" href="#message-1564539553.063300">2019-07-31&nbsp;11:19:13 +0900</a></div></div><div class="message__body description"><blockquote>whereで定義しているローカル関数fibはfib_memにぶら下がっているのに対してfib_mem_argの方はfib_mem_arg nに対してローカル関数fibがぶらさがっている．</blockquote>なるほどー これしっくりきました</div></div></div></div><div class="pager ui pagination menu"><a href="../../html/C5666B6BB/65.html" class="pager__previous item">Previous</a><a href="../../" class="pager__top item">Top</a><a href="../../html/C5666B6BB/67.html" class="pager__next item">Next</a></div></div></body></html>