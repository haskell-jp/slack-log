[
    {
        "ts": "1542858379.064700",
        "text": "例えば、\"Applicative f =&gt; (a -&gt; f b) -&gt; s -&gt; f t\"で検索したらlensパッケージのTraversalがヒットして欲しい、みたいな具合です",
        "user": "U7907NMGF",
        "type": "message"
    },
    {
        "ts": "1542859709.064900",
        "text": "型シノニムだけ結果に表示するようなオプションは見つけられませんでした…\n型変数名が同じなら Google は一応見つけてくれましたが、不便は不便ですね。\n<https://www.google.co.jp/search?q=%22Applicative+f+%3D%3E+%28a+-%3E+f+b%29+-%3E+s+-%3E+f+t%22>",
        "user": "U578W9676",
        "type": "message"
    },
    {
        "ts": "1542862734.065200",
        "text": "なるほど。。。Haddockに直接相談しないとどうにもならなさそうですね。。。 :disappointed_relieved:",
        "user": "U4LGTMTMK",
        "type": "message"
    },
    {
        "ts": "1542877932.066700",
        "text": "この関数って安全ではない気がするんですが、型レベルの分岐が出来る仕組み (Type Families とか) がプリミティブじゃないので大丈夫、だったりするんですか？ <http://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Type-Equality.html#v:inner>",
        "user": "U5LEE6C1J",
        "type": "message"
    },
    {
        "ts": "1542882884.067200",
        "text": "これを見る限りは，value type constructorとtype functionは明確に区別されていて，primitiveのreflexive axiomはvalue type constructorのみに提供されているように見えますね(今はkind equalityが入ってるのでそっちで大丈夫なのか分からないですが)\n<https://www.microsoft.com/en-us/research/wp-content/uploads/2007/01/tldi22-sulzmann-with-appendix.pdf>",
        "user": "U57D08Z9U",
        "type": "message"
    },
    {
        "ts": "1542915925.067500",
        "text": "<@UEBLMNJP8> has joined the channel",
        "user": "UEBLMNJP8",
        "type": "message"
    },
    {
        "ts": "1543138178.067700",
        "text": "ありがとうございます！読んでみます",
        "user": "U5LEE6C1J",
        "type": "message"
    },
    {
        "ts": "1543144528.068000",
        "text": "<@UEB8VS15H> has joined the channel",
        "user": "UEB8VS15H",
        "type": "message"
    },
    {
        "ts": "1543177906.072700",
        "text": "<@UEBAETNPM> has joined the channel",
        "user": "UEBAETNPM",
        "type": "message"
    },
    {
        "ts": "1543202611.075500",
        "text": "stackって「特定のbinをstackローカルのbinパス以外にインストールする」という用途は想定していないんですかね。stack環境無しでも動くexeを作って圧縮して配布、みたいな事を考えた場合はcabalでビルドする事を考えないと駄目でしょうか",
        "user": "U570660KX",
        "type": "message"
    },
    {
        "ts": "1543202651.075600",
        "text": "今やろうとしてるのはbinじゃなくてdllなんですが、それだと更にハードルがいくつかありそうです",
        "user": "U570660KX",
        "type": "message"
    },
    {
        "ts": "1543202789.075800",
        "text": "`stack  --local-bin-path /path/to/install install hoge` ではダメなんですかね。\ndllはわからないですが。。。",
        "user": "U4LGTMTMK",
        "type": "message"
    },
    {
        "ts": "1543203863.076200",
        "text": "ああ、 `--local-bin-path` でインストールされた奴はstack execなしでも動きますね。.stack-work/install以下と混同してたっぽいです。",
        "user": "U570660KX",
        "type": "message"
    },
    {
        "ts": "1543203951.076400",
        "text": "libとかincludeはそこにインストールされないんですが、それはdll固有の問題のようです",
        "user": "U570660KX",
        "type": "message"
    },
    {
        "ts": "1543242506.078600",
        "text": "ああ、これすれば、Windows eshell でstack install した時に現在ディレクトリに~ とかいう謎ディレクトリが作られるの抑えられるのかな？",
        "user": "U9XHWQX7Z",
        "type": "message"
    },
    {
        "ts": "1543274173.078800",
        "text": "stackのconfig.yaml（Windowsだとデフォルトで C:\\sr\\config.yaml になるはず）で、 `local-bin-path`で指定すれば、オプションで指定しなくてもそうなるはずです。 <https://docs.haskellstack.org/en/stable/yaml_configuration/#local-bin-path>",
        "user": "U4LGTMTMK",
        "type": "message"
    }
]