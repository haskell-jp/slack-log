<!DOCTYPE html><html><head><meta charset="utf-8"><title>haskell-jp / questions #52</title><link rel="stylesheet" href="/slack-log/messages.css" type="text/css" media="screen"></head><body><h1>haskell-jp / questions #52</h1><div class="pager"><a href="/slack-log/html/C5666B6BB/51.html" class="pager__previous">Previous</a><a href="/slack-log/" class="pager__top">Top</a><a href="/slack-log/html/C5666B6BB/53.html" class="pager__next">Next</a></div><div class="message_list"><div class="message" id="message-1552105357.220800"><div class="message__timestamp">2019-03-09<br/>13:22:37 +0900</div><div class="message__header">shinji.hatayama709</div><div class="message__body">@shinji.hatayama709 has joined the channel</div></div><div class="message" id="message-1552105775.221100"><div class="message__timestamp">2019-03-09<br/>13:29:35 +0900</div><div class="message__header">fuuzetsu</div><div class="message__body">@fuuzetsu has joined the channel</div></div><div class="message" id="message-1552106757.221400"><div class="message__timestamp">2019-03-09<br/>13:45:57 +0900</div><div class="message__header">oswald_boc</div><div class="message__body">@oswald_boc has joined the channel</div></div><div class="message" id="message-1552113528.221800"><div class="message__timestamp">2019-03-09<br/>15:38:48 +0900</div><div class="message__header">viktor.kronvall</div><div class="message__body">@viktor.kronvall has joined the channel</div></div><div class="message" id="message-1552113596.222100"><div class="message__timestamp">2019-03-09<br/>15:39:56 +0900</div><div class="message__header">onwarmermusic</div><div class="message__body">@onwarmermusic has joined the channel</div></div><div class="message" id="message-1552118643.222300"><div class="message__timestamp">2019-03-09<br/>17:04:03 +0900</div><div class="message__header">hexirp</div><div class="message__body">逆アセンブリした結果は以下のようになりました（一部分だけ）<br/><pre>
00000000004fb010 &lt;Main_boolzuvar1_closure&gt;:
  4fb010: b8 c2 4b 00 00        mov    $0x4bc2,%eax
  4fb015: 00 00                 add    %al,(%rax)
  ...

00000000004fb018 &lt;Main_zdtrModule3_closure&gt;:
  4fb018: f8                    clc
  4fb019: c2 4b 00              retq   $0x4b
  4fb01c: 00 00                 add    %al,(%rax)
  4fb01e: 00 00                 add    %al,(%rax)
  4fb020: 00 90 50 00 00 00     add    %dl,0x50(%rax)
  ...

00000000004fb028 &lt;Main_zdtrModule1_closure&gt;:
  4fb028: f8                    clc
  4fb029: c2 4b 00              retq   $0x4b
  4fb02c: 00 00                 add    %al,(%rax)
  4fb02e: 00 00                 add    %al,(%rax)
</pre></div></div><div class="message" id="message-1552119504.222500"><div class="message__timestamp">2019-03-09<br/>17:18:24 +0900</div><div class="message__header">hexirp</div><div class="message__body">んー、Cmm と asm の時点では +9 があるんですが、バイナリから +9 が消えているみたい？</div></div><div class="message" id="message-1552121881.222800"><div class="message__timestamp">2019-03-09<br/>17:58:01 +0900</div><div class="message__header">ramin.honary</div><div class="message__body">@ramin.honary has joined the channel</div></div><div class="message" id="message-1552122975.223000"><div class="message__timestamp">2019-03-09<br/>18:16:15 +0900</div><div class="message__header">hexirp</div><div class="message__body">違いますね。アセンブリ言語に関する知識がなくて頭の中がクエスチョンマークだらけです</div></div><div class="message" id="message-1552124089.223300"><div class="message__timestamp">2019-03-09<br/>18:34:49 +0900</div><div class="message__header">hexirp</div><div class="message__body">あー、とても単純なところを勘違いしていました…… バイナリの中で True_closure+9 である 4fb019 の所を指していることと、実行結果も 0000000000004bc2 である 19394 が表示されることを確認しました。回答していただいたみなさん、ありがとうございました！</div></div><div class="message" id="message-1552137027.224400"><div class="message__timestamp">2019-03-09<br/>22:10:27 +0900</div><div class="message__header">mizunashi-mana</div><div class="message__body">このような string literal をコンパイルできる環境を探してます．どういう条件でコンパイルすると通るんでしょう？<br/><a href='https://gitlab.haskell.org/ghc/ghc/blob/master/compiler/main/GHC.hs#L1063'>https://gitlab.haskell.org/ghc/ghc/blob/master/compiler/main/GHC.hs#L1063</a><br/>( 今後 master は変更されるかもなので， GHC 8.6.4 版のリンクも貼っておきます: <a href='https://gitlab.haskell.org/ghc/ghc/blob/ghc-8.6.4-release/compiler/main/GHC.hs#L1055'>https://gitlab.haskell.org/ghc/ghc/blob/ghc-8.6.4-release/compiler/main/GHC.hs#L1055</a> )</div></div><div class="message" id="message-1552137098.224600"><div class="message__timestamp">2019-03-09<br/>22:11:38 +0900</div><div class="message__header">mizunashi-mana</div><div class="message__body">Haskell2010 上だと， <code>\</code> の後に空白(改行を含む)を続けて再度 <code>\</code> があるとそこの部分が無視されるのは知ってるんですが，終わりの <code>\</code> も無いようですし</div></div><div class="message" id="message-1552137235.224900"><div class="message__timestamp">2019-03-09<br/>22:13:55 +0900</div><div class="message__header">mizunashi-mana</div><div class="message__body">ついでに，素の GHC 8.6.3 の GHCi 上で<br/><br/><pre>
&gt;&gt;&gt; :{
s = "a\
   \b"
:}
&gt;&gt;&gt; s
"ab"
&gt;&gt;&gt; :{
s = "a\
   b"
:}

&lt;interactive&gt;:8:3: error:
    lexical error in string/character literal at character 'b'
</pre><br/><br/>となるのは試しました</div></div><div class="message" id="message-1552137701.225200"><div class="message__timestamp">2019-03-09<br/>22:21:41 +0900</div><div class="message__header">myuon_myon</div><div class="message__body">これCPPの効果だって某所で聞いた記憶が</div></div><div class="message" id="message-1552137873.225700"><div class="message__timestamp">2019-03-09<br/>22:24:33 +0900</div><div class="message__header">mizunashi-mana</div><div class="message__body">なるほど，今それありそうだなって思ってやってみてます</div></div><div class="message" id="message-1552137990.225900"><div class="message__timestamp">2019-03-09<br/>22:26:30 +0900</div><div class="message__header">myuon_myon</div><div class="message__body">(例のghc-compiler-notesプロジェクトやってたときに、わどさんが同じ箇所で引っかかってCPPによるものみたいです、って教えてもらった)</div></div><div class="message" id="message-1552138058.226100"><div class="message__timestamp">2019-03-09<br/>22:27:38 +0900</div><div class="message__header">mizunashi-mana</div><div class="message__body">(今まさに ghc-compiler-notes の書き直しをやってて引っかかってます)</div></div><div class="message" id="message-1552138918.226500"><div class="message__timestamp">2019-03-09<br/>22:41:58 +0900</div><div class="message__header">mizunashi-mana</div><div class="message__body">なるほど，こんな話があるんですね( CPP 使ってる場合 string gap が使えないので， CPP のこの機能を使わざるを得ない)<br/><a href='https://downloads.haskell.org/~ghc/8.6.4/docs/html/users_guide/phases.html?#cpp-and-string-gaps'>https://downloads.haskell.org/~ghc/8.6.4/docs/html/users_guide/phases.html?#cpp-and-string-gaps</a></div></div><div class="message" id="message-1552200201.227400"><div class="message__timestamp">2019-03-10<br/>15:43:21 +0900</div><div class="message__header">okimoto</div><div class="message__body">@okimoto has joined the channel</div></div><div class="message" id="message-1552204525.227700"><div class="message__timestamp">2019-03-10<br/>16:55:25 +0900</div><div class="message__header">jesper</div><div class="message__body">@jesper has joined the channel</div></div><div class="message" id="message-1552366344.228300"><div class="message__timestamp">2019-03-12<br/>13:52:24 +0900</div><div class="message__header">cutsea110</div><div class="message__body">@nobsun もしかしてcata . ana合成したhyloだと中間データ構造を作ってしまい,hyloの再帰型だとDeforestationされると理解して良い?…んだよね?</div></div><div class="message" id="message-1552377393.228500"><div class="message__timestamp">2019-03-12<br/>16:56:33 +0900</div><div class="message__header">nobsun</div><div class="message__body">はい．そうです．</div></div><div class="message" id="message-1552377731.228700"><div class="message__timestamp">2019-03-12<br/>17:02:11 +0900</div><div class="message__header">nobsun</div><div class="message__body">さらに hyloを展開してしまって， 直截再帰的に定義してしまえば，psiで生成するMaybe (b,a) も生成しなくていいよね．</div></div><div class="message" id="message-1552378070.228900"><div class="message__timestamp">2019-03-12<br/>17:07:50 +0900</div><div class="message__header">nobsun</div><div class="message__body"><pre>
buildMap :: (Ord key) =&gt; ([Maybe key], [Maybe val]) -&gt; Maybe (Map key val)
buildMap = \ case
  (Just k : ks, Just v : vs) -&gt; Map.insert k v &lt;$&gt; buildMap (ks, vs)
  (Nothing : _, _)           -&gt; Nothing
  (_, Nothing : _)           -&gt; Nothing
  ([], [])                   -&gt; Just (Map.empty)
  (_:ks, [])                 -&gt; const (Map.empty) &lt;$&gt; buildMap (ks, [])
  (e@[], _:vs)               -&gt; asTypeOf (Map.empty) &lt;$&gt; buildMap ([], vs)
</pre></div></div><div class="message" id="message-1552378342.230000"><div class="message__timestamp">2019-03-12<br/>17:12:22 +0900</div><div class="message__header">cutsea110</div><div class="message__body">おお、ありがとうございます</div></div><div class="message" id="message-1552379168.234800"><div class="message__timestamp">2019-03-12<br/>17:26:08 +0900</div><div class="message__header">nobsun</div><div class="message__body">``mkMap :: Ord k =&gt; ([Maybe k], [Maybe v]) -&gt; Maybe (Map k v)``を定義しようとして，<br/>```<br/>mkMap :: Ord k =&gt; ([Maybe k], [Maybe v]) -&gt; Maybe (Map k v)<br/>mkMap ([], v:vs) = const Map.empty &lt;$&gt; mkMap ([], vs)<br/>```<br/>とすると，この部分で以下のようなエラーがでるのですが，なぜ推論できないんでしょうか？<br/>(ghc-8.6.4)<br/><br/>```<br/>/home/nobsun/work/ny-sketch-book/src/BuildMap.hs:57:40: error:<br/>    • Could not deduce (Ord k0) arising from a use of ‘mkMap’<br/>      from the context: Ord k<br/>        bound by the type signature for:<br/>                   mkMap :: forall k v.<br/>                            Ord k =&gt;<br/>                            ([Maybe k], [Maybe v]) -&gt; Maybe (Map k v)<br/>        at /home/nobsun/work/ny-sketch-book/src/BuildMap.hs:56:1-59<br/>      The type variable ‘k0’ is ambiguous<br/>      These potential instances exist:<br/>        instance (Ord a, Ord b) =&gt; Ord (Either a b)<br/>          -- Defined in ‘Data.Either’<br/>        instance forall k (s :: k). Ord (Proxy s)<br/>          -- Defined in ‘Data.Proxy’<br/>        instance forall k (a :: k) (b :: k). Ord (a :~: b)<br/>          -- Defined in ‘Data.Type.Equality’<br/>        ...plus 28 others<br/>        ...plus 12 instances involving out-of-scope types<br/>        (use -fprint-potential-instances to see them all)<br/>    • In the second argument of ‘(&lt;$&gt;)’, namely ‘mkMap ([], vs)’<br/>      In the expression: const Map.empty &lt;$&gt; mkMap ([], vs)<br/>      In an equation for ‘mkMap’:<br/>          mkMap ([], v : vs) = const Map.empty &lt;$&gt; mkMap ([], vs)<br/>   |<br/>57 | mkMap ([], v:vs) = const Map.empty &lt;$&gt; mkMap ([], vs)<br/>   |                                        ^^^^^^^^^^^^^^<br/>Failed, no modules loaded.<br/>```</div></div><div class="message" id="message-1552379699.235000"><div class="message__timestamp">2019-03-12<br/>17:34:59 +0900</div><div class="message__header">igrep</div><div class="message__body">ぱっと思いつくのは、 <code>const Map.empty ....</code> と、戻り値を必ず <code>Map.empty</code> にしてしまっているからではないかと。<br/><code>asTypeOf</code> に変えたら通りましたし。</div></div><div class="message" id="message-1552379872.235200"><div class="message__timestamp">2019-03-12<br/>17:37:52 +0900</div><div class="message__header">igrep</div><div class="message__body">これ、ひょっとして本当にやりたいことは <code>const</code> ではなく <code>Map.union</code> ではないでしょうか？再帰の基底部で必ず <code>Map.empty</code> を返してしまったら意味がないような...</div></div><div class="message" id="message-1552381203.235400"><div class="message__timestamp">2019-03-12<br/>18:00:03 +0900</div><div class="message__header">nobsun</div><div class="message__body">やりたいことは，<br/><a href='https://haskell-jp.slack.com/archives/C5666B6BB/p1552378070228900?thread_ts=1551956556.140300&amp;cid=C5666B6BB'>https://haskell-jp.slack.com/archives/C5666B6BB/p1552378070228900?thread_ts=1551956556.140300&amp;cid=C5666B6BB</a><br/> です．Map.unionをつかっても同じ意図を実装できますが，なぜ，上の書き方でだめなのかが理解できていません．</div></div><div class="message" id="message-1552381431.235900"><div class="message__timestamp">2019-03-12<br/>18:03:51 +0900</div><div class="message__header">kakkun61</div><div class="message__body"><code>mkMap ([], vs) :: Maybe (Map k v)</code> の <code>k</code> と <code>mkMap :: Ord k =&gt; …</code> の <code>k</code> が同じだということが分からないような</div></div><div class="message" id="message-1552382069.236200"><div class="message__timestamp">2019-03-12<br/>18:14:29 +0900</div><div class="message__header">nobsun</div><div class="message__body">Map.unionを使うと判るのは．．．なぜだろう．．．:thinking_face:</div></div><div class="message" id="message-1552382278.236600"><div class="message__timestamp">2019-03-12<br/>18:17:58 +0900</div><div class="message__header">igrep</div><div class="message__body"><code>const</code> は <code>a -&gt; b -&gt; a</code> という型なので <code>mkMap ([], vs) :: Maybe (Map k v)</code> の <code>k</code> が <code>Map.empty</code> の型と同じとは限りませんが、<br/><code>Map.union</code> （や、 <code>asTypeOf</code> ）は戻り値も引数もすべて同じ型なのでわかる、ということではないでしょうか？</div></div><div class="message" id="message-1552382472.236800"><div class="message__timestamp">2019-03-12<br/>18:21:12 +0900</div><div class="message__header">nobsun</div><div class="message__body">:sweat_smile:ああそうかなるほど！ありがとうございます．</div></div><div class="message" id="message-1552383160.237200"><div class="message__timestamp">2019-03-12<br/>18:32:40 +0900</div><div class="message__header">nobsun</div><div class="message__body">あらっ？ mkMap ([], vs) :: Maybe (Map k v) みたいな型注釈をつけてもいけそうなんだけど．．．だめなのか．．．:open_mouth:</div></div><div class="message" id="message-1552383286.237500"><div class="message__timestamp">2019-03-12<br/>18:34:46 +0900</div><div class="message__header">igrep</div><div class="message__body"><code>ScopedTypeVariables</code> の出番ですかね。 :smirk:</div></div><div class="message" id="message-1552383318.237700"><div class="message__timestamp">2019-03-12<br/>18:35:18 +0900</div><div class="message__header">nobsun</div><div class="message__body">それを指定したんだけど．．．だめみたい．</div></div><div class="message" id="message-1552383378.237900"><div class="message__timestamp">2019-03-12<br/>18:36:18 +0900</div><div class="message__header">igrep</div><div class="message__body"><code>forall</code> を書き忘れるというミスを犯してませんか... （経験者談 :sweat_smile:</div></div><div class="message" id="message-1552383771.238100"><div class="message__timestamp">2019-03-12<br/>18:42:51 +0900</div><div class="message__header">nobsun</div><div class="message__body">:sweat_smile: おもいっきりヤラカしてました．ありがとうございます．</div></div><div class="message" id="message-1552390790.238700"><div class="message__timestamp">2019-03-12<br/>20:39:50 +0900</div><div class="message__header">vqgofndplhjr</div><div class="message__body">@vqgofndplhjr has joined the channel</div></div><div class="message" id="message-1552455593.238900"><div class="message__timestamp">2019-03-13<br/>14:39:53 +0900</div><div class="message__header">nobsun</div><div class="message__body">なにがカッコイイかはよく判らないけれど，プログラムの判りやすさと，時間性能は hylo 版も直接再帰版もオリジナルに敵わないです．</div></div><div class="message" id="message-1552461489.239100"><div class="message__timestamp">2019-03-13<br/>16:18:09 +0900</div><div class="message__header">as_capabl</div><div class="message__body">@nobsun 時間性能については、オリジナル版はallとfromListでリストを二回なめているため、hylo版の方が速いかと</div></div><div class="message" id="message-1552462767.239400"><div class="message__timestamp">2019-03-13<br/>16:39:27 +0900</div><div class="message__header">khibino</div><div class="message__body">ScopedTypeVariables は型変数のスコープの開始を forall で指定するという仕様なのです。</div></div><div class="message" id="message-1552477977.243800"><div class="message__timestamp">2019-03-13<br/>20:52:57 +0900</div><div class="message__header">chinsan514</div><div class="message__body">@chinsan514 has joined the channel</div></div><div class="message" id="message-1552478495.244100"><div class="message__timestamp">2019-03-13<br/>21:01:35 +0900</div><div class="message__header">nobsun</div><div class="message__body">オーダーとしては線形で同じなので，あとは実測値でどうかということになると思います．10^6くらいサイズならオリジナルの方が速いみたいですよ．</div></div><div class="message" id="message-1552478989.246200"><div class="message__timestamp">2019-03-13<br/>21:09:49 +0900</div><div class="message__header">as_capabl</div><div class="message__body">あー、もしかしてfromListならソートして一気にマップ作れるのに対して、全部insertでやってるから遅いんじゃないですかね</div></div><div class="message" id="message-1552479742.246800"><div class="message__timestamp">2019-03-13<br/>21:22:22 +0900</div><div class="message__header">autotaker</div><div class="message__body">末尾再帰になっていないのがよくない気がします。</div></div><div class="message" id="message-1552479768.247100"><div class="message__timestamp">2019-03-13<br/>21:22:48 +0900</div><div class="message__header">nobsun</div><div class="message__body">リストのソートもMapへのinsertもオーダーとしてはO(n log n)だから，基本オペレーションの性能かでしょうかね．</div></div><div class="message" id="message-1552479963.249600"><div class="message__timestamp">2019-03-13<br/>21:26:03 +0900</div><div class="message__header">autotaker</div><div class="message__body">fromListもfoldで実装されてますね<br/><pre>
fromList :: Ord k =&gt; [(k,a)] -&gt; Map k a 
fromList xs       
  = foldlStrict ins empty xs
  where
    ins t (k,x) = insert k x t
</pre></div></div><div class="message" id="message-1552480147.252900"><div class="message__timestamp">2019-03-13<br/>21:29:07 +0900</div><div class="message__header">as_capabl</div><div class="message__body">insertなのか、ちょっと意外です。赤黒木とかならソートしてやった方が速かった木がするんですが、フィンガーツリーだと違うのか</div></div><div class="message" id="message-1552480210.253500"><div class="message__timestamp">2019-03-13<br/>21:30:10 +0900</div><div class="message__header">as_capabl</div><div class="message__body">木がするとは</div></div></div><div class="pager"><a href="/slack-log/html/C5666B6BB/51.html" class="pager__previous">Previous</a><a href="/slack-log/" class="pager__top">Top</a><a href="/slack-log/html/C5666B6BB/53.html" class="pager__next">Next</a></div></body></html>