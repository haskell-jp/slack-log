[
    {
        "ts": "1603582003.075300",
        "text": "そのやり方をしたら今度は `reply b msg`  の部分で型推論できなくてエラーになっちゃいましたorz\nどうすれば・・・",
        "user": "U8G16FA59",
        "type": "message"
    },
    {
        "ts": "1603596663.075500",
        "text": "```data AnyBot env = forall b. (Bot b, Dep b env) =&gt; AnyBot b\ninstance Bot (AnyBot env) where\n  type Dep (AnyBot env) a = (a ~ env)\n  name (AnyBot b) = name b\n  reply (AnyBot b) msg = reply b msg```\nこれで通りますがもしかしてDep b envが足りなかったのでしょうか？",
        "user": "U4KUNQF9N",
        "type": "message"
    },
    {
        "ts": "1603600377.078900",
        "text": "わあ！まさにその通りでした！ありがとございます！！\n\nさっぱりどうしていいかわからなかったのですが、どのように思考したらそうなるんですか！？\nたけのこは型推論の流れみたいなものを学べばこれを理解できるようになるんでしょうか？༼;´༎ຶ ༎ຶ༽",
        "user": "U8G16FA59",
        "type": "message"
    },
    {
        "ts": "1603603642.079100",
        "text": "AnyBotにパターンマッチしたとき使えるのは、AnyBotの宣言で量化している制約のみで、一方replyが要求する制約はDep b envを含んでいるので、そこに食い違いがあることがわかります。一般論として、何が要求されていて、それを満たすためにはどこを変えればよいかをエラーメッセージなどなら見極めることが大切だと思います",
        "user": "U4KUNQF9N",
        "type": "message"
    },
    {
        "ts": "1603606670.081500",
        "text": "ライブラリーを作るときに、ライブラリーで提供する型は、特に理由がなければ `Generic` や `NFData` （あと、多分テストで使う都合で `Eq` や `Show` も）のインスタンスにしておいた方がいいでしょうか？\n他にもこれはインスタンスにしておくと助かるなぁ、という型クラスがあれば教えてください！",
        "user": "U4LGTMTMK",
        "type": "message"
    },
    {
        "ts": "1603607652.081600",
        "text": "コンストラクタを隠したいなどそうしない明確な理由がなければそうすべき、という立場です。<http://hackage.haskell.org/package/base-4.14.0.0/docs/Data-Proxy.html> Proxy や、　<http://hackage.haskell.org/package/aeson-1.5.4.1/docs/Data-Aeson.html#t:Value> aesonのValue型あたりが参考になると思います",
        "user": "U4KUNQF9N",
        "type": "message"
    },
    {
        "ts": "1603633807.081900",
        "text": "確かに状況はこの通りですけど、間もなくJsaddleのアプリがWebGHC・Wasmで動作させることができると思います。例えば「<https://commonmark-wasm.srid.ca/>」「<https://github.com/WebGHC/example-jsaddle-project>」",
        "user": "U5U5RDTA4",
        "type": "message"
    },
    {
        "ts": "1603848067.083800",
        "text": "自分が少し関わっているパッケージにこんなpull requestが来て気になったのですが、いくつ前のGHCまでサポートするか、についてのガイドラインってどこかにありましたっけ... 以前誰かがそんなことをおっしゃっていたような...\n<https://github.com/krdlab/haskell-oidc-client/pull/46>",
        "user": "U4LGTMTMK",
        "type": "message"
    },
    {
        "ts": "1603848189.084000",
        "text": "最低限、major を3つですが、GHC 8 はすべてサポートする方が親切でしょうね。",
        "user": "U56MBRKR9",
        "type": "message"
    },
    {
        "ts": "1603848434.084300",
        "text": "ああー、kazuさんでしたか。その「majorを3つ」というのはどこかに書いてましたっけ...？",
        "user": "U4LGTMTMK",
        "type": "message"
    },
    {
        "ts": "1603848710.084500",
        "text": "正式じゃないけど、こことか？ <https://www.snoyman.com/blog/2018/07/stop-supporting-older-ghcs>",
        "user": "U56MBRKR9",
        "type": "message"
    },
    {
        "ts": "1603848805.084900",
        "text": "ありがとうございます！まぁ、習慣的なものでしょうし、今回は軽微なものですからきっとマージしてくれるでしょうけども、何かしら引用したくなったときのための覚えておきます。 :memo:",
        "user": "U4LGTMTMK",
        "type": "message"
    },
    {
        "ts": "1603848865.085100",
        "text": "どこかに正式な文章があった気がするけど、今は探し出せませんでした。",
        "user": "U56MBRKR9",
        "type": "message"
    },
    {
        "ts": "1603848956.085400",
        "text": "ただし、それは一年に一回GHCのメジャーバージョンが出てたころの文章で、その後正式な合意があるかは分かりません。まぁ、3年分ぐらいサポートすればいいでしょう。",
        "user": "U56MBRKR9",
        "type": "message"
    },
    {
        "ts": "1603858586.085800",
        "text": "自分は“debian stableに入ってるghcバージョン以降“を1つの基準にしてます．",
        "user": "U5G2BCVBN",
        "type": "message"
    },
    {
        "ts": "1603887957.086200",
        "text": "以下のURLが元の`3-Release-Policy`の定義ページだったと思いますが、TracからGitLabへのWiki移行でprime系を移行できていないようです。\n<https://prime.haskell.org/wiki/Libraries/3-Release-Policy>",
        "user": "U55V441FS",
        "type": "message"
    },
    {
        "ts": "1603954864.087000",
        "text": "なるほど!ありがとうございます!\n型族とかで頭が混乱していて存在型の制約がパターンマッチして使えるようになることとかを忘れてました:scream_cat:\n\n今度は `Bot` のリストとかも `Bot` のインスタンスにしたいなと思って以下のようにインスタンス宣言を追加したら、またどうしていいかわからないエラーが出ちゃいました:sob::x::one::zero::zero::zero:\n\n```instance (Bot (b (env :: *)), Dep (b env) env, Functor t, Traversable t) =&gt; Bot (t (b env)) where\n  type Dep (t (b env)) a = a ~ env\n  name _ = \"Bot Pool\"\n  reply bs msg = join . L.find isJust &lt;$&gt; traverse (`reply` msg) bs```\n```Conflicting family instance declarations:\n      Dep (AnyBot env) a = a ~ env -- Defined at src/Bot.hs:49:8\n      Dep (t (b env)) a = a ~ env -- Defined at src/Bot.hs:54:```\n考えてみてもいい解決策が思いつかないです༼;´༎ຶ ༎ຶ༽\nどうかお助けを༼;´༎ຶ ༎ຶ༽",
        "user": "U8G16FA59",
        "type": "message"
    },
    {
        "ts": "1603962796.087200",
        "text": "前の例をコピーするのはあまり筋がよくないですね。どのような型がインスタンスになるかもう一度考えてみましょう",
        "user": "U4KUNQF9N",
        "type": "message"
    },
    {
        "ts": "1603965512.092500",
        "text": "もしかして `AnyBot` を `Bot` のインスタンスにするのをやめて、`AnyBot` を `Functor` と `Traversable` にしちゃうのがいいんでしょうか…？\nとすると`name` メソッドなどを`\"Bot Pool\"` じゃない名前にしたい場合どうしたらいいでしょうか？\n:boom:༼;´༎ຶ ༎ຶ༽:boom::oil_drum:三 :oil_drum:三",
        "user": "U8G16FA59",
        "type": "message"
    },
    {
        "ts": "1603966194.093100",
        "text": "「`Bot` のリストとかも `Bot` のインスタンスにしたい」とのことなので、具体的にどんな型をインスタンスにしたいか列挙して、それらがどう実装できるかを試してみるのが良いと思います",
        "user": "U4KUNQF9N",
        "type": "message"
    },
    {
        "ts": "1603967302.096000",
        "text": "`instance Bot b =&gt; Bot [b]`\nとか\n`instance Bot b =&gt; Bot (Vector b)`\nみたいな感じでしょうか？\nインスタンス宣言ってあまり一般的に書かない方がいいんでしょうか？",
        "user": "U8G16FA59",
        "type": "message"
    },
    {
        "ts": "1603968102.096300",
        "text": "`instance Bot b =&gt; Bot [b]` まさにその通りです。`instance Applicative f =&gt; MyClass f`のような宣言はあらゆる型に対してインスタンスを定義することになるので、多くの場合はアンチパターンです",
        "user": "U4KUNQF9N",
        "type": "message"
    },
    {
        "ts": "1603971137.101500",
        "text": "なるほど〜\nでもどうしてあらゆる型に対するインスタンスを定義することがアンチパターンに近づきがちになっちゃうんでしょうか？\nできるだけ一般的な形で書いた方がより便利そうな気が:hatched_chick:",
        "user": "U8G16FA59",
        "type": "message"
    },
    {
        "ts": "1603973607.101800",
        "text": "全ての型に対して同じ定義で済むなら、型クラスである必要がないためです。たとえば `class Summable a where sum :: a -&gt; a` に対して `instance (Foldable f, Num a) =&gt; Summable (f a) where sum = foldl' (+) 0` という一般的な定義をしても、それは最初から型クラスを使わずに `sum = foldl' (+) 0` と定義するのと変わらないのです",
        "user": "U4KUNQF9N",
        "type": "message"
    },
    {
        "ts": "1603975221.105100",
        "text": "わぁ！\n言われてみれば確かに！\n頭良すぎですか？:muscle::skin-tone-2:\nもしかしてこういうのって有名な話でどこかに書いてあったりするんでしょうか！？",
        "user": "U8G16FA59",
        "type": "message"
    },
    {
        "ts": "1603982884.105500",
        "text": "ありがちな誤解ではあるものの、どこかに書いてあるかというとちょっと心当たりがないです。Haskellでやるべきではないことの一覧みたいなのがあるといいですね",
        "user": "U4KUNQF9N",
        "type": "message"
    },
    {
        "ts": "1604021462.107700",
        "text": "なるほどーいっぱい勉強になりました！\nありがとです！",
        "user": "U8G16FA59",
        "type": "message"
    },
    {
        "ts": "1604024185.108200",
        "text": "<@U01ECB0PNTA> has joined the channel",
        "user": "U01ECB0PNTA",
        "type": "message"
    },
    {
        "ts": "1604152718.108500",
        "text": "haskellのpreludeはデフォルト以外ではどれを使うのが良いのでしょうか？\n<https://haskell.e-bigmoon.com/posts/2018/05-23-extended-prelude.html>",
        "user": "UQERMQX8W",
        "type": "message"
    },
    {
        "ts": "1604168083.108800",
        "text": "<@U01DB6D212B> has joined the channel",
        "user": "U01DB6D212B",
        "type": "message"
    }
]