[
    {
        "type": "message",
        "user": "U05A7BL0PST",
        "ts": "1685679030.509849",
        "text": "<@U05A7BL0PST> has joined the channel"
    },
    {
        "type": "message",
        "user": "U05BK34ESF2",
        "ts": "1685851209.924389",
        "text": "<@U05BK34ESF2> has joined the channel"
    },
    {
        "type": "message",
        "user": "U56MBRKR9",
        "ts": "1686190934.052419",
        "text": "フォーマッタとして hindent を使っている人はいませんか？\nCPPを使っていると、ことごとくフォーマットできずにエラーになるんですが、そういうものですか？"
    },
    {
        "type": "message",
        "user": "U05BNMSPM3Q",
        "ts": "1686335331.764689",
        "text": "<@U05BNMSPM3Q> has joined the channel"
    },
    {
        "type": "message",
        "user": "U05BYT6J7RR",
        "ts": "1686494168.258189",
        "text": "<@U05BYT6J7RR> has joined the channel"
    },
    {
        "type": "message",
        "user": "U56MBRKR9",
        "ts": "1686720298.292579",
        "text": "Hackage の upload 機能が死んでいるようなのですが、どこに連絡すればいいですか？\nHackageには書かれてないように思いました。"
    },
    {
        "type": "message",
        "user": "U05CXHYMHKP",
        "ts": "1686989448.559229",
        "text": "<@U05CXHYMHKP> has joined the channel"
    },
    {
        "type": "message",
        "user": "U74KTAG0N",
        "ts": "1687240914.968079",
        "text": "<https://haskell.jp/blog/posts/2020/strict-gotchas.html>\nstrictは!をつけてくれるのですが、!のseqではなくdeepseqに置き換えたい場合はどうすればいいでしょうか。"
    },
    {
        "type": "message",
        "user": "U05CV9FATHV",
        "ts": "1687245602.208709",
        "text": "<@U05CV9FATHV> has joined the channel"
    },
    {
        "type": "message",
        "user": "U56MBRKR9",
        "ts": "1687321140.257329",
        "text": "Haskellのコードが書かれた大きなファイルを分割したいです。\nそのため関数の依存グラフが欲しいのですが、SourceGraphはもうメンテされてないようです。\nHaskellの関数の依存グラフを可視化するツールとかサービスは、他にありませんか？"
    },
    {
        "type": "message",
        "user": "U05A7BL0PST",
        "ts": "1687643826.871559",
        "text": "haskellの事をAIに質問していたら、sha256な文字列に出会いました。\n<https://hamesspam.sakura.ne.jp/hes2023/230625.html|ask AI>  この鬼のように長いsha256な文字表現を短縮したいです。イメージは\nsed 's/hexDigit x 64/SHA256/g'\nこれをparsecで実現するには、どうしたら良いのでしょうか？"
    },
    {
        "type": "message",
        "user": "U05F7RSDZPC",
        "ts": "1688347266.638029",
        "text": "<@U05F7RSDZPC> has joined the channel"
    },
    {
        "type": "message",
        "user": "U05F4J31TK8",
        "ts": "1688395741.276539",
        "text": "<@U05F4J31TK8> has joined the channel"
    },
    {
        "type": "message",
        "user": "U05A7BL0PST",
        "ts": "1688415525.784589",
        "text": "参照されていないモジュールを指摘してくれるツールってありますでしょうか？\ngolangでは、コンパイラーに厳しい指導をされたような。"
    },
    {
        "type": "message",
        "user": "U05FP4KC755",
        "ts": "1688790288.643299",
        "text": "<@U05FP4KC755> has joined the channel"
    },
    {
        "type": "message",
        "user": "U4KU9ABL0",
        "ts": "1689048948.519879",
        "text": "base パッケージの versioning policy をさがしているのですが、見つけられないでいます．どなたかご存知でしょうか？"
    },
    {
        "type": "message",
        "user": "U05H6Q749GU",
        "ts": "1689352495.167359",
        "text": "<@U05H6Q749GU> has joined the channel"
    },
    {
        "type": "message",
        "user": "U05H6JX0PGB",
        "ts": "1689404805.114849",
        "text": "<@U05H6JX0PGB> has joined the channel"
    },
    {
        "type": "message",
        "user": "U015L5JEP8D",
        "ts": "1690112065.483659",
        "text": "`callCC`の型はなぜ`forall r m a. ((forall b. a -&gt; ContT r m b) -&gt; ContT r m a) -&gt; ContT r m a`ではなく`forall r m a b. ((a -&gt; ContT r m b) -&gt; ContT r m a) -&gt; ContT r m a`なのでしょうか\n実際`callCC' f = callCC (\\exit -&gt; f $ (\\ a -&gt; absurd &lt;$&gt; exit a))`とすれば前者の型にでき、前者の型のほうが脱出用の継続（`callCC (\\exit -&gt; ...)`のexit）の返り値の型が制限されず便利であるように思えます"
    },
    {
        "type": "message",
        "user": "U03H9PH8FRP",
        "ts": "1691583960.006909",
        "text": "`vector-13.0.0` における `newtype` に対する `Unbox` 実装の質問です。\n(1) <https://hackage.haskell.org/package/vector-0.13.0.0/docs/Data-Vector-Unboxed.html#t:UnboxViaPrim|UnboxViaPrim> を使う方法と (2)『`GeneralizedNewtypeDeriving`』を使う方法 [^1]  は、どちらを好むべきですか。 `U.Vector` を使うだけなら、大きな差は無いと思って良いでしょうか。\n[^1]: (<https://hackage.haskell.org/package/vector-0.13.0.0/docs/Data-Vector-Unboxed.html|Unbox モジュール> 冒頭 2 番目のコードブロックの例)"
    },
    {
        "type": "message",
        "user": "U05LSDBQHQF",
        "ts": "1691658512.849699",
        "text": "<@U05LSDBQHQF> has joined the channel"
    },
    {
        "type": "message",
        "user": "U05N5L3N27J",
        "ts": "1691773078.229469",
        "text": "<@U05N5L3N27J> has joined the channel"
    },
    {
        "type": "message",
        "user": "U4KNU6N48",
        "ts": "1691991330.531279",
        "text": "`RecordWildCards` 有効にすると、\nインポート元で定義済みフィールド名とかさなる名前の\n\n\"shadows the existing binding\"\n\nの警告が出なくなるみたいなんですが、\nそういうものでしょうか?\n\n`RecordWildCards` を有効にすると暗黙に有効にされる\n`DisambiguateRecordFields` の効果なのかと思ったけどそういうわけでもないみたいです.\n\n```module M where\n\ndata R = R { x :: String }```\n```{-# LANGUAGE RecordWildCards #-}\n\nimport M\n\ninc :: Int -&gt; Int\ninc x = x + 1\n\ngetX :: R -&gt; String\ngetX m = x m```"
    },
    {
        "type": "message",
        "user": "U05MZJJ1C5C",
        "ts": "1692241313.592449",
        "text": "<@U05MZJJ1C5C> has joined the channel"
    }
]