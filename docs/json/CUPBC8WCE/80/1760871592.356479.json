[
    {
        "ts": "1760871592.356479",
        "text": "書籍: 関数型プログラミング実践入門を読みつつ、手を動かせました。\n特にフィボナッチ数列で遊んでHaskellすげぇぇ!となりました。\n一応Qiitaにもまとめておいたので、よりエレガントな実装とかあれば教えてください!\n\n<https://qiita.com/sigma_devsecops/items/24e05b6248b717aa4067>",
        "type": "message",
        "user": "U09ME60J23W"
    },
    {
        "ts": "1760888881.374949",
        "text": "いろいろあります\n```-- | Fibonacci numbers\nfib :: Num a =&gt; [a]\nfib = 0 : 1 : zipWith (+) fib (tail fib)\n\n-- or\nfib@(_:tl) = 0 : 1 : zipWith (+) fib tl\n\n-- | fix - alert slow\nimport Data.Function (fix)\nfib = fix (\\f -&gt; \\n -&gt; if n &lt; 2 then n else f (n-1) + f (n-2))\n\nfib :: (Applicative f, Num a, Eq a) =&gt; a -&gt; f a\nfib 0 = pure 0\nfib 1 = pure 1\nfib n = (+) &lt;$&gt; fib (n-1) &lt;*&gt; fib (n-2)\n\n-- | Fast Fib\nfib :: Integer -&gt; Integer\nfib = fst . rec (0,1)\n  where\n  rec pq@(p,q) n\n    | n==0      = (0,1)\n    | odd n     = tpq pq $ rec pq (n-1)\n    | otherwise = rec (p^2+q^2,2*p*q+q^2) (n `div` 2)\n  tpq (p,q) (a,b) = (p*a+q*b,q*a+(p+q)* b)\n\n-- or\nfib 0 = (0,1)\nfib n = if even n then (c,d) else (d,c+d)\n  where\n  (a,b) = fib (div n 2)\n  c = a*(b*2-a)\n  d = a*a+b*b\n\n-- | Matrix Fib by SemiGroup \nimport qualified Data.Semigroup as Semigroup\n\ndata Matrix2x2 = \n  Matrix {x00 :: Integer, x01 :: Integer, x10 :: Integer, x11 :: Integer}\n\ninstance Monoid Matrix2x2 where\n  mempty = Matrix {x00 = 1, x01 = 0, x10 = 0, x11 = 1}\n\ninstance Semigroup Matrix2x2 where\n  Matrix l00 l01 l10 l11 &lt;&gt; Matrix r00 r01 r10 r11 = Matrix {\n    x00 = l00*r00 + l01*r10, x01 = l00*r01 + l01*r11,\n    x10 = l10*r00 + l11*r10, x11 = l10*r01 + l11*r11}\n\nfib :: Integer -&gt; Integer\nfib n = x01 (Semigroup.mtimesDefault n matrix)\n  where\n  matrix = Matrix {x00 = 0, x01 = 1, x10 = 1, x11 = 1}\n\n-- | memoize by list\nimport Data.Function (fix)\nfib1 :: Int -&gt; Integer\nfib1 = fix (memoize . fib)\n\nmemoize :: (Num t, Enum t) =&gt; (t -&gt; a) -&gt; Int -&gt; a\nmemoize f = (map f [0..] !!)\n\nfib :: (Num t, Eq t, Num a) =&gt; (t -&gt; a) -&gt; t -&gt; a\nfib f 0 = 1\nfib f 1 = 1\nfib f n = f (n-1) + f (n-2)\n\n-- | memoize by array\nfib2 n = memo (0,n) fib n\n  where\n  fib 0 = 1\n  fib 1 = 1\n  fib n = fib (n-1) + fib (n-2)\n\nmemo bnds gen = (dp!)\n  where\n  dp = listArray bnds . fmap gen $ range bnds\n\n-- | memoize by listArray\nimport Data.Array\nmemo = listArray bnds $ f &lt;$&gt; range bnds\nf 0 = 1\nf 1 = 1\nf i = memo!(i-1) + memo!(i-2)\n\n-- | memo by array in the definition\n{-# LANGUAGE LambdaCase #-}\nimport Data.Array\n\ntabulate :: Ix i =&gt; (i,i) -&gt; (i -&gt; a) -&gt; Array i a\ntabulate bnds f = listArray bnds (map f $ range bnds)\n\nmemo :: Ix i =&gt; (i,i) -&gt; (i -&gt; a) -&gt; (i -&gt; a)\nmemo bnds = (!) . tabulate bnds\n\nfib = memo (0,1000) $ \\case\n  0 -&gt; 0\n  1 -&gt; 1\n  n -&gt; fib (n-1) + fib (n-2)\n\n-- | locally defined fix (warning: slow)\nimport Data.Function\nfibs = fix (scanl (+) 0 . (1:))\n\n-- | representable functor as memoization and a natural isomorphism\n-- Stream a ≃ Natural -&gt; a  -- non-std lib\nimport Data.Natural\nimport Data.Functor.Rep\nclass Functor f =&gt; Representable f where\n  type Key f :: Type\n  tabulate   :: (Key f -&gt; a) -&gt; f a\n  index      :: f a          -&gt; (Key f -&gt; a)\n\nmemoize :: forall f a. Representable f =&gt; ((Key f -&gt; a) -&gt; (Key f -&gt; a)) -&gt; (Key f -&gt; a)\nmemoize g = fix (index @f . tabulate . g)\n\nfibs :: Num a =&gt; Natural -&gt; a\nfibs = memoize @((-&gt;) Natural) fib\n\n-- | representable functor as memoization and and a natural isomorphism\n-- Tree a ≃ Natural -&gt; a\ndata Tree a = Node a (Tree a) (Tree a)\n  deriving Functor\n\nfibs :: Num a =&gt; Natural -&gt; a\nfibs = memoize @Tree fib\n\ninstance Representable Tree where\n  type Key Tree = Natural\n  tabulate f = fmap f nats where\n    nats = Node 0 (fmap ((+1) . (2*)) nats) (fmap ((+2) . (2*)) nats)\n  index (Node a _ _) 0 = a\n  index (Node _ l r) n = if odd n\n    then index l (div n 2)\n    else index r (div n 2 - 1)\n\n-- | fibs by mfix\nimport Control.Monad.State.Strict\nfibs = fst . flip runState [] . mfix \n  $ \\a -&gt; scanl (+) 0 . (1:) &lt;$&gt; (put a &gt;&gt; return a)\n\n-- | MonadMemo  -- non-std lib\nimport Control.Monad.Memo\n\nfib :: MonadMemo Int Integer m =&gt; Int -&gt; m Integer\nfib 0 = return 1\nfib 1 = return 1\nfib n = (+) &lt;$&gt; memo fib (n-1) &lt;*&gt; memo fib (n-2)\n\nevalFib :: Integer -&gt; Integer\nevalFib = startEvalMemo . fib\n\nfib :: (Monad m) =&gt; (Int -&gt; m Integer) -&gt; (Int -&gt; m Integer)\nfib _ 0 = return 0\nfib _ 1 = return 1\nfib f n = (+) &lt;$&gt; f (n-1) &lt;*&gt; f (n-2)\n\nmemoize :: (MonadState (IntMap v) m) =&gt; (Int -&gt; m v) -&gt; Int -&gt; m v\nmemoize f x = do\n  v &lt;- gets (lookup x)\n  case v of\n    Just y -&gt; return y\n    _      -&gt; do\n      y &lt;- f x\n      modify $ insert x y\n      return y\n\nmemoFib :: Int -&gt; Integer\nmemoFib n = evalState (fix (memoize . fib) n) empty\n\n-- MemoCombinators\nimport qualified Data.MemoCombinators as Memo\n\nfib = Memo.integral fib'\n  where\n  fib' 0 = 0\n  fib' 1 = 1\n  fib' x = fib (x-1) + fib (x-2)```",
        "type": "message",
        "user": "U584T7GAH"
    }
]