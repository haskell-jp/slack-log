[
    {
        "ts": "1616430017.009100",
        "text": "<@U01S215169G> has joined the channel",
        "user": "U01S215169G",
        "type": "message"
    },
    {
        "ts": "1616510275.009900",
        "text": "もしかしてこれは自分が作りたいなぁと思っていたものではないか :open_mouth:\n```anythingToString :: forall a. a -&gt; String```\n<https://hackage.haskell.org/package/recover-rtti-0.3.0.0/docs/Debug-RecoverRTTI.html>",
        "user": "U4LGTMTMK",
        "type": "message"
    },
    {
        "ts": "1616510930.011600",
        "text": "convertible パッケージの `Data.Convertible.Convertible` クラス、別パッケージに分離してほしいな\ndata-default-class パッケージのように\nconvertible の依存する old-time が build-type: configure で Windows において手間がかかるので",
        "user": "U4L0B71L1",
        "type": "message"
    },
    {
        "ts": "1616568538.012100",
        "text": "<@U01RTQG4GBH> has joined the channel",
        "user": "U01RTQG4GBH",
        "type": "message"
    },
    {
        "ts": "1616663990.013900",
        "text": "<https://github.com/haskell-jp/blog/issues/206|https://github.com/haskell-jp/blog/issues/206> 一人では経験が足りなくて作れない記事を、せっかくなので haskell-jp のブログに投げました。",
        "user": "U5LEE6C1J",
        "type": "message"
    },
    {
        "ts": "1616714605.018400",
        "text": "まだちゃんと読んでないのですが今週のHaskell Weekly, `ReaderT` より `ImplicitParams` 使えよって記事と `ImplicitParams` 使うと危ないって記事が両方載ってるっぽくて興味深いですね :smirk:\n<https://haskellweekly.news/issue/256.html>",
        "user": "U4LGTMTMK",
        "type": "message"
    },
    {
        "ts": "1616739694.019600",
        "text": "読めました。こちらがその「 `ImplicitParams` 使うと危ないぞ」という記事 <https://chrisdone.com/posts/whats-wrong-with-implicitparams/>\nどうも問題は、単に\n```?param```\nと書いたときに `ReaderT` でいうところの `param &lt;- ask` をさしているのかそれともよそで `ask` した結果の `param` を参照しているのか、型推論した結果からしか分からないところにあるみたいですね。",
        "user": "U4LGTMTMK",
        "type": "message"
    },
    {
        "ts": "1617033943.020400",
        "text": "<@U01SMHCTZN1> has joined the channel",
        "user": "U01SMHCTZN1",
        "type": "message"
    },
    {
        "ts": "1617034812.020600",
        "text": "<@U01S9U2ENS3> has joined the channel",
        "user": "U01S9U2ENS3",
        "type": "message"
    },
    {
        "ts": "1617034906.020900",
        "text": "<http://hackage.haskell.org|hackage.haskell.org> 落ちてる <https://twitter.com/bgamari/status/1376569577249865731>",
        "user": "U4L0B71L1",
        "type": "message"
    },
    {
        "ts": "1617034915.021200",
        "text": "<https://twitter.com/bgamari/status/1376570157691195399>",
        "user": "U4L0B71L1",
        "type": "message"
    },
    {
        "ts": "1617110038.022100",
        "text": "GHC 9.2のブランチが切られました。 alpha版のリリースも近いとのことです。\nGHC 9.2 has branched\n<https://mail.haskell.org/pipermail/ghc-devs/2021-March/019756.html>\nなお、9.0.2 と 8.10.5 のマイナーリリース版もそれぞれ別途準備中です。",
        "user": "U55V441FS",
        "type": "message"
    },
    {
        "ts": "1617262797.022800",
        "text": "<@U01T1F8PCTV> has joined the channel",
        "user": "U01T1F8PCTV",
        "type": "message"
    },
    {
        "ts": "1617263491.023400",
        "text": "（間違えて <#C4LFB6DE0|general> に投稿してしまったのでこちらの投稿し直します。すみませんでした :man-bowing: ）\nGADTsの構文ってまだ「subject to change」って扱いだったんですね。知らなかった！\n<https://github.com/ghc-proposals/ghc-proposals/pull/402>",
        "user": "U4LGTMTMK",
        "type": "message"
    },
    {
        "ts": "1617318060.024300",
        "text": "GHC 9.2.1-alpha1 now available :tada:\n<http://haskell.1045720.n5.nabble.com/ANNOUNCE-GHC-9-2-1-alpha1-now-available-td5900422.html>",
        "user": "U4LGTMTMK",
        "type": "message"
    },
    {
        "ts": "1617326736.024600",
        "text": "かなり、いい感じだね。",
        "user": "U56MBRKR9",
        "type": "message"
    },
    {
        "ts": "1617327295.025100",
        "text": "GHC2021とレコード周りの修正がめっちゃありがたいですねー。プロファイリングやデバッグ周りもよさげな新機能が :eyes:",
        "user": "U4LGTMTMK",
        "type": "message"
    },
    {
        "ts": "1617520312.026300",
        "text": "<@U01TLQGSE3B> has joined the channel",
        "user": "U01TLQGSE3B",
        "type": "message"
    },
    {
        "ts": "1617544774.028200",
        "text": "`listDirectory` 関数が返すリストの順番に依存したコードを書くと、ある日突然何の脈絡もなく順番が変わってしまってバグり出す、という恐怖体験が続きました... :fearful:\n<https://haskell-jp.slack.com/archives/CBY49962V/p1617544631003000>",
        "user": "U4LGTMTMK",
        "type": "message"
    },
    {
        "ts": "1617789188.028500",
        "text": "なんか過ごそう（まだ読んでないですすみません:bow:）\n<https://z.haskell.world/|https://z.haskell.world/>",
        "user": "U4LGTMTMK",
        "type": "message"
    },
    {
        "ts": "1617945954.028900",
        "text": "<@U01UG7SDAPJ> has joined the channel",
        "user": "U01UG7SDAPJ",
        "type": "message"
    },
    {
        "ts": "1617972510.033000",
        "text": "Pythonを操作インターフェイスにしている、おそらくJavaで書かれたライブラリをHaskellで操作しようと思っています。\nprotocol bufferファイルを公開しているので、それを使えばHaskellに型をマッピング出来て、しかも通信部分も型安全に出来るのではと思いました。\nとりあえず検索してみた所、 <https://hackage.haskell.org/package/protocol-buffers> と <https://github.com/google/proto-lens> がよく使われてそうだと分かりました。\nProtocol Bufferを扱うのは実は初めてなので、どのように使うのが王道なのかよく分かっていません。\n「こっちのライブラリの方が良いよ」とか「このライブラリが便利だよ」などの助言があれば教えていただけると嬉しいです。",
        "user": "U57CUMWQ6",
        "type": "message"
    },
    {
        "ts": "1618114065.035200",
        "text": "cabal-install のあるバージョンから Windows で実行ファイルをインストールしたときのフォルダー変わったのかな\n旧：$Env:AppData\\Roaming\\local\\bin\n新：$Env:AppData\\Roaming\\cabal\\bin",
        "user": "U4L0B71L1",
        "type": "message"
    },
    {
        "ts": "1618213390.035500",
        "text": "<@U01TZ1XM7MG> has joined the channel",
        "user": "U01TZ1XM7MG",
        "type": "message"
    },
    {
        "ts": "1618242059.035800",
        "text": "<@U01TU7EMWT0> has joined the channel",
        "user": "U01TU7EMWT0",
        "type": "message"
    },
    {
        "ts": "1618282578.036000",
        "text": "<@U01UT3LUW80> has joined the channel",
        "user": "U01UT3LUW80",
        "type": "message"
    },
    {
        "ts": "1618283774.037300",
        "text": "こちらの質問 <https://teratail.com/questions/332942?rss> に回答してたら `let ... in` って面倒くさいなぁという気持ちになり、これまでの鬱憤もあってこんな乱暴なことをいってしまった :cold_sweat: んですが、 <https://twitter.com/igrep/status/1381803450321661953>\n皆さんどんな場面で `let ... in` を使いますか？",
        "user": "U4LGTMTMK",
        "type": "message"
    },
    {
        "ts": "1618284017.037900",
        "text": "個人的には関数は where で、簡単な定数は let で定義しますね",
        "user": "UK0MXUCAV",
        "type": "message"
    },
    {
        "ts": "1618284121.039500",
        "text": "let は上から下に読めば定義がわかるので、本体が大きくなりすぎない場合は let に纏める傾向がありますね。あと、where だと節ごとに共通する変数しか使えないので、局所的な条件に依存するような定義は let を使うことがおおいですね",
        "user": "UK0MXUCAV",
        "type": "message"
    },
    {
        "ts": "1618284170.040500",
        "text": "case の中の個別の変数は let in を使うかな。",
        "user": "U56MBRKR9",
        "type": "message"
    },
    {
        "ts": "1618284205.041400",
        "text": "それもこれも `do` の `let` で実は実現できるけど、やっぱり違和感ありますかね... :disappointed:",
        "user": "U4LGTMTMK",
        "type": "message"
    },
    {
        "ts": "1618284250.042400",
        "text": "do を Monad や Applicative 以外の用途に使うのは可読性を損うのであんまり好きじゃないですね",
        "user": "UK0MXUCAV",
        "type": "message"
    },
    {
        "ts": "1618284314.044000",
        "text": "第一引数に部分適用しておくと早くなる関数があった場合、where とか使うと、どこまでちゃんと評価されるか分からない場合があって、その場合は let in で書きます。",
        "user": "U56MBRKR9",
        "type": "message"
    },
    {
        "ts": "1618284341.044400",
        "text": "```aes128gcmEncrypt :: Key -&gt; (Nonce -&gt; PlainText -&gt; AddDat -&gt; [CipherText])\naes128gcmEncrypt (Key key) =\n    let aes = throwCryptoError (cipherInit key) :: AES128\n    in \\(Nonce nonce) plaintext (AddDat ad) -&gt;\n      let aead = throwCryptoError $ aeadInit AEAD_GCM aes nonce\n          (AuthTag tag0, ciphertext) = aeadSimpleEncrypt aead ad plaintext 16\n          tag = Byte.convert tag0\n      in [ciphertext,tag]```\n",
        "user": "U56MBRKR9",
        "type": "message"
    },
    {
        "ts": "1618284394.045400",
        "text": "以前、この関数を where で書いてたんだけど、プロファイルを取ったら意図通りに動いていなくて、let in で書き直しました。",
        "user": "U56MBRKR9",
        "type": "message"
    },
    {
        "ts": "1618284558.046900",
        "text": "あと、厳密な話をするのならば、doの中の let  statement は構文糖衣であって、最終的には let expression に脱糖されるので「do の letでいいじゃん」はいささか循環論法ではないかなと思います（cf. <https://www.haskell.org/onlinereport/haskell2010/haskellch3.html#x8-470003.14>",
        "user": "UK0MXUCAV",
        "type": "message"
    },
    {
        "ts": "1618284981.050600",
        "text": "ところでkazuさんの :point_up: のサンプルを見ていて気づいたんですけど、わたしこれまで、 `let` と `in` の行頭をそろえちゃいけないと思っていたんですが（本件の元となった質問 <https://teratail.com/questions/332942?rss> でも質問者が間違えてそろえてしまってハマっています）、そろえていい場合もあるんですね... :cold_sweat: （むしろそろえるのが普通なのか）\n`do` の中で `let .. in` を使うのが鬼門なのか...",
        "user": "U4LGTMTMK",
        "type": "message"
    },
    {
        "ts": "1618285000.050800",
        "text": "仕様上 case alternative にも where は書けるんですが、あんまり知られておらず読みづらいので、僕も case の中の個別定義は let を使いますね",
        "user": "UK0MXUCAV",
        "type": "message"
    },
    {
        "ts": "1618285067.052600",
        "text": "case の中の where は、どうやって書くのか、未だに分からないです。。。",
        "user": "U56MBRKR9",
        "type": "message"
    },
    {
        "ts": "1618285114.053300",
        "text": "オフサイドルールが直観に反する局面なのでぼくもわからないですね……",
        "user": "UK0MXUCAV",
        "type": "message"
    },
    {
        "ts": "1618285132.053700",
        "text": "あと do 式の中という話に限定するのなら基本的に let ... in は使わないで let statement だけ使います。一般的な文脈で do let を使うべきという話ではなく、do 式の中では let 文を使うべきという話ならその通りだと思います",
        "user": "UK0MXUCAV",
        "type": "message"
    },
    {
        "ts": "1618285215.054500",
        "text": "pure な関数だと let と in は連続行だとみなされれば、どのように書いてもいいのでは？",
        "user": "U56MBRKR9",
        "type": "message"
    },
    {
        "ts": "1618285302.056100",
        "text": "fourmolu とかだと\n\n```let foo = bar\n in ...```\nみたいに式／定義のはじまる位置が揃うようにフォーマットされますしね。do のようにオフサイドルールが重要になってくる場面以外はどう書いてもよい（何なら\n\n```let foo = bar in\nfoo + 1```\nみたいに書いてもいいですし）",
        "user": "UK0MXUCAV",
        "type": "message"
    },
    {
        "ts": "1618365052.057300",
        "text": "`try` が非同期例外を捕捉しなくて悩んでいたんだけど、非同期例外が連続して2回飛んでた。。。",
        "user": "U56MBRKR9",
        "type": "message"
    },
    {
        "ts": "1618365126.058400",
        "text": "QUICサーバのソケットがリークするので、IO manager のバグを疑っていたんだけど、ソケットはちゃんと閉じられており、直後に同じアドレス/ポートのソケットができていた。。。",
        "user": "U56MBRKR9",
        "type": "message"
    },
    {
        "ts": "1618365135.058600",
        "text": "最近、こんなのばっかり。",
        "user": "U56MBRKR9",
        "type": "message"
    }
]