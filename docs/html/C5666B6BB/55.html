<!DOCTYPE html><html><head><meta charset="utf-8"><title>haskell-jp / questions #55</title><link rel="stylesheet" href="../../messages.css" type="text/css" media="screen"></head><body><h1>haskell-jp / questions #55</h1><div class="pager"><a href="../../html/C5666B6BB/54.html" class="pager__previous">Previous</a><a href="../../" class="pager__top">Top</a><a href="../../html/C5666B6BB/56.html" class="pager__next">Next</a></div><div class="message_list"><div class="message" id="message-1553867435.003800"><div class="message__timestamp">2019-03-29<br/>22:50:35 +0900</div><div class="message__header">nisi3genki</div><div class="message__body">@nisi3genki has joined the channel</div></div><div class="message" id="message-1553905204.004000"><div class="message__timestamp">2019-03-30<br/>09:20:04 +0900</div><div class="message__header">ah</div><div class="message__body">返信遅くなりすみません<br/>Haskellのプロセスの起動までは大した時間がかからないのですが、そのプロセスの中でDynamoDBやS3にアクセスすると、長大な時間がかかるのです。<br/>node.jsでDynamoDBにアクセスしてそれをHaskellに渡す、というのは確かに１つの方法ではありますが、できればHaskellでなるべく多くの仕事をしたいと思っています。</div></div><div class="message" id="message-1553958638.005000"><div class="message__timestamp">2019-03-31<br/>00:10:38 +0900</div><div class="message__header">charlie.51749</div><div class="message__body">@charlie.51749 has joined the channel</div></div><div class="message" id="message-1553971125.005300"><div class="message__timestamp">2019-03-31<br/>03:38:45 +0900</div><div class="message__header">coricozizi_slack</div><div class="message__body">@coricozizi_slack has joined the channel</div></div><div class="message" id="message-1554235326.006000"><div class="message__timestamp">2019-04-03<br/>05:02:06 +0900</div><div class="message__header">sciencefiction314</div><div class="message__body">@sciencefiction314 has joined the channel</div></div><div class="message" id="message-1554250658.006300"><div class="message__timestamp">2019-04-03<br/>09:17:38 +0900</div><div class="message__header">shunsuke.masuda</div><div class="message__body">皆さんありがとうございました。今回は、as_cabal さんの方法を使うことにしました。既に組み上げたものにちょっと足すだけで、やりたかったことが実現できました。</div></div><div class="message" id="message-1554255522.006500"><div class="message__timestamp">2019-04-03<br/>10:38:42 +0900</div><div class="message__header">junji.hashimoto</div><div class="message__body">私もnode.jsからはeventのデータだけしかやりとりせずに<br/>DynamoDBやS3とは直接やりとりしていますが、<br/>そもそもそのプログラムはAWS Lambdaでなければアクセスは速いのですか？</div></div><div class="message" id="message-1554300039.007000"><div class="message__timestamp">2019-04-03<br/>23:00:39 +0900</div><div class="message__header">ah</div><div class="message__body">ローカル環境で動かすと1秒もかからないですね。</div></div><div class="message" id="message-1554342719.007300"><div class="message__timestamp">2019-04-04<br/>10:51:59 +0900</div><div class="message__header">cyb.ai.815</div><div class="message__body">@cyb.ai.815 has joined the channel</div></div><div class="message" id="message-1554343638.007600"><div class="message__timestamp">2019-04-04<br/>11:07:18 +0900</div><div class="message__header">fujiwara.atsushi</div><div class="message__body">@fujiwara.atsushi has joined the channel</div></div><div class="message" id="message-1554347164.007900"><div class="message__timestamp">2019-04-04<br/>12:06:04 +0900</div><div class="message__header">louvre2489</div><div class="message__body">@louvre2489 has joined the channel</div></div><div class="message" id="message-1554388753.008300"><div class="message__timestamp">2019-04-04<br/>23:39:13 +0900</div><div class="message__header">tyukasanlsbs</div><div class="message__body">@tyukasanlsbs has joined the channel</div></div><div class="message" id="message-1554423176.009800"><div class="message__timestamp">2019-04-05<br/>09:12:56 +0900</div><div class="message__header">igrep</div><div class="message__body">ざっくりした質問で恐縮なんですが、cabal new-buildってどういう仕組みでcabal sandboxや古いcabal buildの問題点を解決しているんでしょうか。参考になるリンクでも良いので教えてください！ hask(_ _)eller</div></div><div class="message" id="message-1554425012.009900"><div class="message__timestamp">2019-04-05<br/>09:43:32 +0900</div><div class="message__header">cohei</div><div class="message__body">Nix-style というだけあって、 Nix ぽいです。もし Nix を知っていれば、類推でなんとなくつかめるかもしれません。端的にいえば、 sandbox に加えて、ライブラリのビルドキャッシュがホームディレクトリ単位になったものと理解しています。<br/>古い cabal build は同一ライブラリの複数バージョンを持てませんでしたが、 new-build は sandbox 相当の機能を持っているのでこれを解消しています。<br/>sandbox はプロジェクト毎に分離されていたので、プロジェクト間でライブラリのビルドが重複してしまいます。 new-build ではホームディレクトリ単位でキャッシュされているので、同じライブラリの同じバージョンのビルドは全体で一回ですみます。<br/><br/>というのが自分の理解ですが、本格的に調べたわけではないので違うところがあったらごめんなさい。<br/>参考になるドキュメントはとりあえず公式の <a href='https://cabal.readthedocs.io/en/latest/nix-local-build-overview.html'>https://cabal.readthedocs.io/en/latest/nix-local-build-overview.html</a> を挙げておきます……</div></div><div class="message" id="message-1554426237.014900"><div class="message__timestamp">2019-04-05<br/>10:03:57 +0900</div><div class="message__header">maoe</div><div class="message__body">ビルドの成果物に影響を及ぼす入力、例えばソースコードの内容、各種GHCフラグ、依存パッケージのバージョンなどから一意に決まるハッシュ値を計算して、ハッシュ値ごとに成果物をstoreにキャッシュして、同じハッシュ値を使うビルドにはキャッシュの内容を再利用するとりかいしてます</div></div><div class="message" id="message-1554427355.015200"><div class="message__timestamp">2019-04-05<br/>10:22:35 +0900</div><div class="message__header">kazu</div><div class="message__body">Hutton本2でDefunctionalizationなるテクニックが使われています。<br/>どうも、関数をデータ構成子で置き換えることのようです。<br/><a href='https://en.wikipedia.org/wiki/Defunctionalization'>https://en.wikipedia.org/wiki/Defunctionalization</a><br/>この説明中の first-order と higher-order は、どういう意味でしょうか？<br/>あと、Defunctionalizationの訳語があれば、教えてください。<br/>「関数の除去」ぐらいでいいかなとは思っています。</div></div><div class="message" id="message-1554429174.015700"><div class="message__timestamp">2019-04-05<br/>10:52:54 +0900</div><div class="message__header">igrep</div><div class="message__body">大体わかりました！ドキュメントも読んでみます！<br/>ありがとうございます！</div></div><div class="message" id="message-1554431398.016800"><div class="message__timestamp">2019-04-05<br/>11:29:58 +0900</div><div class="message__header">fumieval</div><div class="message__body">一般的な語法通り、高階関数とそうでない関数のことだと思います。化学用語などに倣ってあえて訳すとすれば「脱関数」でしょう</div></div><div class="message" id="message-1554431423.017200"><div class="message__timestamp">2019-04-05<br/>11:30:23 +0900</div><div class="message__header">misaki</div><div class="message__body">Higher-Order Programming Languagesの所であれば「高階関数を扱う」というくらいに考えていました．<br/>first-orderはhigher-orderの対義語くらいの意味なんだと思います．<br/><blockquote>The M-language of McCarthy (1960) is first order, as there is no provision to pass a function as argument or return a function as result5.</blockquote><a href='https://www.cs.kent.ac.uk/people/staff/dat/tfp12/tfp12.pdf'>https://www.cs.kent.ac.uk/people/staff/dat/tfp12/tfp12.pdf</a></div></div><div class="message" id="message-1554431626.017500"><div class="message__timestamp">2019-04-05<br/>11:33:46 +0900</div><div class="message__header">kazu</div><div class="message__body">Hutton2 では、高階関数を置き換える感じじゃないんです。関数を構成子に置き換えるだけ。</div></div><div class="message" id="message-1554431646.017700"><div class="message__timestamp">2019-04-05<br/>11:34:06 +0900</div><div class="message__header">kazu</div><div class="message__body">Hutton2では、first-orderを訳さない方向で検討します。</div></div><div class="message" id="message-1554432072.017900"><div class="message__timestamp">2019-04-05<br/>11:41:12 +0900</div><div class="message__header">cutsea110</div><div class="message__body"><a href='https://github.com/cutsea110/aop/blob/master/src/Defunctionalization.hs'>https://github.com/cutsea110/aop/blob/master/src/Defunctionalization.hs</a></div></div><div class="message" id="message-1554432140.018200"><div class="message__timestamp">2019-04-05<br/>11:42:20 +0900</div><div class="message__header">cutsea110</div><div class="message__body">wikipediaのexampleのやっていることは分かったけどLamを差し込む意義が良く分からないな...</div></div><div class="message" id="message-1554432267.018400"><div class="message__timestamp">2019-04-05<br/>11:44:27 +0900</div><div class="message__header">cutsea110</div><div class="message__body">このexampleを見る限りTreeとLamは完全に同型なのでだから何?みたいな.</div></div><div class="message" id="message-1554432937.018900"><div class="message__timestamp">2019-04-05<br/>11:55:37 +0900</div><div class="message__header">cutsea110</div><div class="message__body">そうか関数と構成子の違いってパターンマッチできるとかcase splitできる点にあることを考えると,Lamがexampleの例のままだと非力すぎるってことなのかな.</div></div><div class="message" id="message-1554432964.019100"><div class="message__timestamp">2019-04-05<br/>11:56:04 +0900</div><div class="message__header">cutsea110</div><div class="message__body">Lamの構成子を豊かにしてやれば差が見えてくる?</div></div><div class="message" id="message-1554434082.019300"><div class="message__timestamp">2019-04-05<br/>12:14:42 +0900</div><div class="message__header">as_capabl</div><div class="message__body">C言語に直して言うと「関数ポインタを引数に取る関数(高階関数)があって、それに指定される関数ポインタがすべて分かっているとき、関数ポインタをenum、その呼び出しをswitchに置き換える」という最適化なのだと理解しました</div></div><div class="message" id="message-1554434217.019500"><div class="message__timestamp">2019-04-05<br/>12:16:57 +0900</div><div class="message__header">as_capabl</div><div class="message__body">で、enumをもっと複雑な代数データ型に拡張できるよというのがDefunctionalizationの要点で、それがLamなのか</div></div><div class="message" id="message-1554434370.019700"><div class="message__timestamp">2019-04-05<br/>12:19:30 +0900</div><div class="message__header">as_capabl</div><div class="message__body">Defunctionalizationは"functional"を除去するという意味じゃないかと思います。functional(汎関数)はHigher-order functionの別名の一つです。 <a href='https://en.wikipedia.org/wiki/Higher-order_function'>https://en.wikipedia.org/wiki/Higher-order_function</a></div></div><div class="message" id="message-1554435304.020100"><div class="message__timestamp">2019-04-05<br/>12:35:04 +0900</div><div class="message__header">kazu</div><div class="message__body">@cutsea110 Hutton2 では、導出したコンパイラ＆仮想マシンから、継続（関数）を取り除いて、仮想マシンのコマンドに変えています。ので、かなり意味があります。</div></div><div class="message" id="message-1554435528.020400"><div class="message__timestamp">2019-04-05<br/>12:38:48 +0900</div><div class="message__header">igrep</div><div class="message__body"><a href='https://blog.poisson.chat/posts/2018-08-06-one-type-family.html'>https://blog.poisson.chat/posts/2018-08-06-one-type-family.html</a> の普通の関数版のお話ってことですかね。</div></div><div class="message" id="message-1554435599.020700"><div class="message__timestamp">2019-04-05<br/>12:39:59 +0900</div><div class="message__header">kazu</div><div class="message__body">具体的には、<br/><br/><pre>
addC :: Cont -&gt; Cont
</pre><br/><br/>を<br/><br/><pre>
data Code = HALT | PUSH Int Code | ADD Code
                 deriving Show
</pre><br/><br/>の <code>ADD</code> で置き換えます。<br/><br/><pre>
type Cont = Stack -&gt; Stack
</pre><br/><br/>なので、 <code>addC</code> は高階関数ですね。<br/><br/>脱高階関数と訳そうかな。。。</div></div><div class="message" id="message-1554436694.021700"><div class="message__timestamp">2019-04-05<br/>12:58:14 +0900</div><div class="message__header">cutsea110</div><div class="message__body">関数のままだと適用されて計算が進んじゃうけどデータ構成子を被せればWHNFで一旦ストップするからコンパイラが手を出せる、最適化などが出来るってところかな.狙いとしては.</div></div><div class="message" id="message-1554437145.022000"><div class="message__timestamp">2019-04-05<br/>13:05:45 +0900</div><div class="message__header">cutsea110</div><div class="message__body">SICPの積極制御評価器ぽいネタだ.おもしろそう.</div></div><div class="message" id="message-1554438422.022700"><div class="message__timestamp">2019-04-05<br/>13:27:02 +0900</div><div class="message__header">kazu</div><div class="message__body">数式の eval 関数が、コンパイラcompと仮想マシンexecに分離され、その間が <code>Code</code> で取り持たれます。</div></div><div class="message" id="message-1554439108.026300"><div class="message__timestamp">2019-04-05<br/>13:38:28 +0900</div><div class="message__header">autotaker</div><div class="message__body">プログラム解析の文脈ですと一階のプログラム(Cなど)の解析手法(抽象解釈など)で関数オブジェクトを扱いたいときに使われているとおもいます。いわゆるクロージャ変換のことを指すこともある気がします。</div></div><div class="message" id="message-1554440406.026600"><div class="message__timestamp">2019-04-05<br/>14:00:06 +0900</div><div class="message__header">cutsea110</div><div class="message__body"><a href='https://typesandkinds.wordpress.com/2013/04/01/defunctionalization-for-the-win/'>https://typesandkinds.wordpress.com/2013/04/01/defunctionalization-for-the-win/</a><br/>これなんかはそれに近い話をしてるのかなぁ</div></div><div class="message" id="message-1554442360.027100"><div class="message__timestamp">2019-04-05<br/>14:32:40 +0900</div><div class="message__header">mizunashi-mana</div><div class="message__body">shiatsumat さんは脱関数化と訳してるっぽいですね．脱高階関数化の方が適切だとは思います<br/><a href='https://github.com/shiatsumat/fp-papers/wiki/%E8%84%B1%E9%96%A2%E6%95%B0%E5%8C%96%E3%82%92%E5%AE%9F%E7%94%A8%E3%81%99%E3%82%8B'>https://github.com/shiatsumat/fp-papers/wiki/%E8%84%B1%E9%96%A2%E6%95%B0%E5%8C%96%E3%82%92%E5%AE%9F%E7%94%A8%E3%81%99%E3%82%8B</a></div></div><div class="message" id="message-1554472687.030900"><div class="message__timestamp">2019-04-05<br/>22:58:07 +0900</div><div class="message__header">cutsea110</div><div class="message__body">そうかwalk_defがcompでapplyがexecと.<br/>今exampleを冷静にみたら確かに脱高階関数してる…のか?</div></div><div class="message" id="message-1554707786.031200"><div class="message__timestamp">2019-04-08<br/>16:16:26 +0900</div><div class="message__header">1to100pen</div><div class="message__body">単に「コンパイラ Defunctionalization」でググって見つけた情報ですが、以下の論文では「非関数化」と訳しているみたいです。<br/>ちなみに「非関数化」の説明は、<br/>「非関数化とは他から独立している関数を一階のオブジェクトに置き換える変換で，関数を返す部分をそのオブジェクトを返すように変更し，そのオブジェクトを処理するための apply 関数を別に用意する，というものである．」<br/>とあります。<br/><a href='http://pllab.is.ocha.ac.jp/~asai/jpapers/ppl/kitani10.pdf'>http://pllab.is.ocha.ac.jp/~asai/jpapers/ppl/kitani10.pdf</a></div></div><div class="message" id="message-1554730660.035000"><div class="message__timestamp">2019-04-08<br/>22:37:40 +0900</div><div class="message__header">yharuhi39</div><div class="message__body">初歩的な質問で申し訳ないのですが<br/>なぜ(baseライブラリの) Functor はDataに属してるのでしょうか？ 関連する Monad, Applicative, BiFunctor は Controlに属しているのに</div></div><div class="message" id="message-1554731408.035100"><div class="message__timestamp">2019-04-08<br/>22:50:08 +0900</div><div class="message__header">fumieval</div><div class="message__body">Applicativeは逐次実行、Monadは分岐という制御能力がありますが、Functorにはないからではないでしょうか？もっとも、ControlとDataの区別はかなり曖昧ではあると思います</div></div><div class="message" id="message-1554790447.035900"><div class="message__timestamp">2019-04-09<br/>15:14:07 +0900</div><div class="message__header">koyama</div><div class="message__body">あれ、 BiFunctor って Control にも Data にもあるようですが、  Control の方ってたぶん古いような感じがするんですがどうなんでしょうか</div></div><div class="message" id="message-1554790554.036100"><div class="message__timestamp">2019-04-09<br/>15:15:54 +0900</div><div class="message__header">koyama</div><div class="message__body">ついでに元の話について思うところを書くと、 Functor は Traversable の親でもあるので、さすがに Control.Traversable は違和感があるのでそこまではひっくるめて Data っていうニュアンスなんじゃないかなあ、という気がします</div></div><div class="message" id="message-1554793066.040300"><div class="message__timestamp">2019-04-09<br/>15:57:46 +0900</div><div class="message__header">hamana55</div><div class="message__body">@hamana55 has joined the channel</div></div><div class="message" id="message-1554793399.043600"><div class="message__timestamp">2019-04-09<br/>16:03:19 +0900</div><div class="message__header">shunsuke.masuda</div><div class="message__body">こんにちは。いつもお世話になります。<br/>ファイルの書き出しを正格に（？）実行する方法はありますか？<br/><br/>do 構文の中で、<br/><code>writeFile</code> ( <a href='http://hackage.haskell.org/package/bytestring-0.10.8.2/docs/Data-ByteString.html#g:28'>http://hackage.haskell.org/package/bytestring-0.10.8.2/docs/Data-ByteString.html#g:28</a> )に filepathとコンテンツを渡したあと、このfilepathのファイルを別のところに送信するプログラムを書いているのですが、 <code>writeFile</code>呼び出し直後にはファイルが存在しないことがあります。<br/><br/><code>writeFile</code>の同期処理についてグーグルで検索すると、<br/><code>readFile</code>の内容を`seq`で評価して`writeFile`に渡す、という例は多数見つかるのですが、 <code>writeFile</code>で出力される予定のファイルをすぐに使う例が見当たりませんでした。</div></div><div class="message" id="message-1554793894.043800"><div class="message__timestamp">2019-04-09<br/>16:11:34 +0900</div><div class="message__header">igrep</div><div class="message__body"><code>writeFile</code> が遅延するとしたら、少なくともlazy IOによるものではないとおもいます。<br/>書き込む系はlazy IOではないはずです。<br/>バッファリングとか、ほかの問題が起きていないでしょうか？</div></div><div class="message" id="message-1554796117.044100"><div class="message__timestamp">2019-04-09<br/>16:48:37 +0900</div><div class="message__header">fumieval</div><div class="message__body">writeFileは閉じるときにバッファを流すはずなのでファイルシステムの問題ではないでしょうか？</div></div><div class="message" id="message-1554796824.044400"><div class="message__timestamp">2019-04-09<br/>17:00:24 +0900</div><div class="message__header">shunsuke.masuda</div><div class="message__body">ありがとうございます。調べてみます。</div></div><div class="message" id="message-1554797318.044700"><div class="message__timestamp">2019-04-09<br/>17:08:38 +0900</div><div class="message__header">icadraic9</div><div class="message__body">@icadraic9 has joined the channel</div></div></div><div class="pager"><a href="../../html/C5666B6BB/54.html" class="pager__previous">Previous</a><a href="../../" class="pager__top">Top</a><a href="../../html/C5666B6BB/56.html" class="pager__next">Next</a></div></body></html>