[
    {
        "text": "cabal.project.local に相当するような stack.yaml のやつってありますか？",
        "type": "message",
        "ts": "1661954651.345509",
        "user": "U4L0B71L1"
    },
    {
        "text": "いくつかのデータ型があらかじめ定義されており、それらはTLV(type length value)で統一的に符号化されるとします。\nこれに対する符号器/復号器の基本ライブラリを作りますが、データ型は将来追加されるかもしれないので、サードパーティライブラリで拡張可能としたいです。\n\nまず、符号化のために以下のようなクラスを定義します。\n\n```class Typeable a =&gt; T a where\n  typeT  :: Int\n  encode :: T -&gt; ByteString\n  decode :: ByteString -&gt; T\n  fromTLV :: TLV -&gt; Maybe a  -- TLVは後述\n  fromTLV (TLV x) = cast x\n  toTLS :: a -&gt; TLV\n  toTLS = TLV```\n既存のデータを表す型を A と B とすると、\n\n```data A = A ...\ndata B = B ...\n\ninstance A where\n  typeT = 0\n  encode = ...\n  decode = ...\n\ninstance B where\n  typeT = 1\n  encode = ...\n  decode = ...```\nこれらの型を同じように扱えるように、 `ExistentialQuantification` を用いて、以下の型を定義します。\n\n```data TLV = forall a. T a =&gt; TLV a```\n符号器で encode を使うのは、 `a` が与えられるので簡単です。\n\n```encodeTLV :: TLV -&gt; ByteString\nencodeTLV (TLV x) = encode x```\n問題は復号器です。TLVのTとLの部分は `ByteString` に符号化された整数なので、それをパースして V の部分の `ByteString` を切り出した後に、適切な `decode` を呼ぶだしたいのですが、どうすれば呼べるでしょうか？\n\nぱっと思いつくのは、 `Int -&gt; ByteString` の辞書を用意して、それを引くことです。拡張可能にするのは、この辞書を公開し、利用時に要素を追加可能にする必要がありそうです。\n\n基本的に reflaction に関係する問題だと思います。サードバーティが `data C` を定義したら、自動的にその `decode` も呼ばれるような魔法はあるのでしょうか？",
        "type": "message",
        "ts": "1662340285.680249",
        "user": "U56MBRKR9"
    },
    {
        "text": "Haskellそのものとは関係ない質問になるので恐縮ですがお聞かせ下さい\n\nプログラミング初心者やHaskellの周辺に全く触れたことない人向けに一時間程度Haskellについて話す機会を得たのですが、皆さんならどういった内容を話すと良いと思われますか？",
        "type": "message",
        "ts": "1662712288.672419",
        "user": "U02LD7MAQ00"
    },
    {
        "text": "ライブラリを書いており、テスト用にライブラリ内で定義した型の <https://hackage.haskell.org/package/QuickCheck-2.14.2/docs/Test-QuickCheck-Arbitrary.html#t:Arbitrary|QuickCheckの >`Arbitrary`<https://hackage.haskell.org/package/QuickCheck-2.14.2/docs/Test-QuickCheck-Arbitrary.html#t:Arbitrary| インスタンス>を作成しようと考えています。 `Arbitrary` インスタンスをどこに書くのが良いのかで悩んでいます。\nこのライブラリを他のプロジェクトから使った時にも `Arbitrary` インスタンスを使えるようにしたいので、テストコード側ではなくライブラリ側に書きたいと考えています。\nしかし、インスタンスを書く為に必要な <https://hackage.haskell.org/package/quickcheck-instances|quickcheck-instances>ライブラリがそれ自身を他のライブラリの依存パッケージとしないことを推奨しているため、「ライブラリ側に書く」のを躊躇しています。\n別のライブラリとして記述するという方法もあると思いますが、それだと後々整合性を持たせるのを忘れそうなのであまり使いたくないなぁと思っています。\n\nこの場合どこに書くのが適切なのでしょうか",
        "type": "message",
        "ts": "1662787201.859309",
        "user": "ULTBB86UC"
    },
    {
        "text": "<@U041V2FD49H> has joined the channel",
        "type": "message",
        "ts": "1662796961.406049",
        "user": "U041V2FD49H"
    },
    {
        "text": "<@U0427D94J5V> has joined the channel",
        "type": "message",
        "ts": "1663285388.992699",
        "user": "U0427D94J5V"
    },
    {
        "text": "<@U042R04R22H> has joined the channel",
        "type": "message",
        "ts": "1663391272.236539",
        "user": "U042R04R22H"
    },
    {
        "text": "はじめて質問させていただきます。\nHaskell学習中の者で、理解が進まない箇所があるのでお力添えいただきたく思います:man-bowing:\n（続く...）",
        "type": "message",
        "ts": "1663570888.297569",
        "user": "U02B9UAPCQ4"
    },
    {
        "text": "<@U043E4G2CRZ> has joined the channel",
        "type": "message",
        "ts": "1663811846.559439",
        "user": "U043E4G2CRZ"
    },
    {
        "text": "現在作ろうとしているツールの一環として、「一定の文字列候補の中から、入力された文字列に一致する文字列をフィルタリングする」機能を作ろうとしています。\n(最終的に作りたいものはrofiやdmenuと似たようなものです、というか具体的にはrofiクローンのようなツールを作ろうとしています)\n\nこのツールでは「文字列の一致」の判定方法をFuzzyやGlob、regex等複数から選べるようにしたいため、ツール全体のステートを維持する型の中に判定用の関数(matcherと呼ぶことにします)を含めたいです。\n\n実際に今考えていたのは以下のような型です:\n\n```data AppModel = AppModel { _typing :: Text\n           , _candidates :: Zipper Candidate\n           , _configFile :: FilePath\n           , _matcher :: (T.Text -&gt; T.Text -&gt; Bool) -- ^ ここのこと\n           } deriving (Eq)```\nしかし、 `AppModel` はUIライブラリ(<https://github.com/fjvallarino/monomer|monomer>)の都合で `Eq` インスタンスを持つ必要があるのですが、 `Eq (a -&gt; a)` のインスタンスが存在しない故に定義が出来なくなってしまっています。\n\n実装の仕方を自分なりに複数考えてみたのですが、どれも微妙でどれを選ぶべきなのか、またより良い方法は無いのかで悩んでいます。\n何かしら定石みたいなものがあれば教えていただければ幸いです :pray:\n(自分で考えたものはスレッドに書き込みます)",
        "type": "message",
        "ts": "1663934840.110889",
        "user": "ULTBB86UC"
    },
    {
        "text": "<@U043KGWLGVC> has joined the channel",
        "type": "message",
        "ts": "1664032314.512979",
        "user": "U043KGWLGVC"
    },
    {
        "text": "<@U044F90MY68> has joined the channel",
        "type": "message",
        "ts": "1664422829.245959",
        "user": "U044F90MY68"
    },
    {
        "text": "<@U045PMGH4RG> has joined the channel",
        "type": "message",
        "ts": "1665197476.012299",
        "user": "U045PMGH4RG"
    },
    {
        "text": "<@U045TDSSH8C> has joined the channel",
        "type": "message",
        "ts": "1665272454.231939",
        "user": "U045TDSSH8C"
    },
    {
        "text": "<@U045SA60C90> has joined the channel",
        "type": "message",
        "ts": "1665356484.779969",
        "user": "U045SA60C90"
    },
    {
        "text": "<@U047GLV1KA5> has joined the channel",
        "type": "message",
        "ts": "1666147001.222979",
        "user": "U047GLV1KA5"
    }
]