<!DOCTYPE html><html><head><meta charset="utf-8"><title>haskell-jp / questions #21</title><link rel="stylesheet" href="../../main.css" type="text/css" media="screen"></head><body><div class="ui container"><h1>haskell-jp / questions #21</h1><div class="pager ui pagination menu"><a href="../../html/C5666B6BB/20.html" class="pager__previous item">Previous</a><a href="../../" class="pager__top item">Top</a><a href="../../html/C5666B6BB/22.html" class="pager__next item">Next</a></div><div class="message_list ui feed"><div class="message event" id="message-1525921948.000207"><div class="content"><div class="summary"><div class="message__header user">igrep</div><div class="message__timestamp date">2018-05-10&nbsp;12:12:28 +0900</div></div><div class="message__body description">はい、なので実際のコードでは <code>Word64</code> にしています。<br/>実際のところは正確にわからないので本当は <code>Integer</code> のほうがいいのかもしれませんが。</div></div></div><div class="message event" id="message-1525922227.000062"><div class="content"><div class="summary"><div class="message__header user">maoe</div><div class="message__timestamp date">2018-05-10&nbsp;12:17:07 +0900</div></div><div class="message__body description">ありがとうございます。katipは何かのライブラリで使われているのをみたことがあります。</div></div></div><div class="message event" id="message-1525924006.000224"><div class="content"><div class="summary"><div class="message__header user">1to100pen</div><div class="message__timestamp date">2018-05-10&nbsp;12:46:46 +0900</div></div><div class="message__body description">わかりやすさの観点は別にして、Theorems for free の方は型の情報だけから fusion が導かれるのが興味深こうございました。</div></div></div><div class="message event" id="message-1525924331.000023"><div class="content"><div class="summary"><div class="message__header user">1to100pen</div><div class="message__timestamp date">2018-05-10&nbsp;12:52:11 +0900</div></div><div class="message__body description">圏論的には fold はF代数の catamorphism なのでそのユニーク性から融合法則を導く方法も多分あると思います。ググったところでは cata-fusion と呼ぶみたいです。</div></div></div><div class="message event" id="message-1525936270.000048"><div class="content"><div class="summary"><div class="message__header user">hiroto.shioi</div><div class="message__timestamp date">2018-05-10&nbsp;16:11:10 +0900</div></div><div class="message__body description">皆さんPreludeは何を使っていますか。できれば使用感なども知りたいです。。！<br/><a href='https://github.com/sdiehl/protolude'>https://github.com/sdiehl/protolude</a><br/><a href='https://github.com/commercialhaskell/rio'>https://github.com/commercialhaskell/rio</a><br/><a href='https://github.com/serokell/universum'>https://github.com/serokell/universum</a><br/>今日 <code>universum</code> を使ってみたんですけど、第一印象は「かゆいところに手が届かない」Preludeでした。</div></div></div><div class="message event" id="message-1525936601.000142"><div class="content"><div class="summary"><div class="message__header user">igrep</div><div class="message__timestamp date">2018-05-10&nbsp;16:16:41 +0900</div></div><div class="message__body description">@cdepillabout ずいぶん前にどこかで聞いた気がするんですが、デニスさんはたしか <a href='https://hackage.haskell.org/package/classy-prelude'>https://hackage.haskell.org/package/classy-prelude</a> でしたっけ？</div></div></div><div class="message event" id="message-1525937334.000401"><div class="content"><div class="summary"><div class="message__header user">matsubara0507</div><div class="message__timestamp date">2018-05-10&nbsp;16:28:54 +0900</div></div><div class="message__body description">さいきんは rio であそんでます<br/>lens 系演算子がもっと欲しいなぁって思う</div></div></div><div class="message event" id="message-1525937862.000174"><div class="content"><div class="summary"><div class="message__header user">hiroto.shioi</div><div class="message__timestamp date">2018-05-10&nbsp;16:37:42 +0900</div></div><div class="message__body description">rioはちょっと気になってるので勉強用で作ってるリポで遊んでみようかなと思ってます。<br/>Universumすごく気まぐれなんですよね。。前のバージョンでは`containers`使えなかったのに今日触ったのは入ってたし、次のバージョンでは`text-format`が丸々削除されるらしくて、DevOpsが泣いてました。</div></div></div><div class="message event" id="message-1525938825.000322"><div class="content"><div class="summary"><div class="message__header user">hiroto.shioi</div><div class="message__timestamp date">2018-05-10&nbsp;16:53:45 +0900</div></div><div class="message__body description">ごめんなさいやっぱり`containers`使えませんでした。<br/>僕がなにか勘違いしてるんですかね。。<https://hackage.haskell.org/package/universum-1.2.0/docs/Universum-Container-Reexport.html><br/><code>type SomeMap = Map String int </code><br/>これは`Map`を明示的にインポートしなくても定義できるのに、`Map`に関する関数は一切使えないんですよね。あと<br/><code>import Data.Map.Strict</code>ができないんです。</div></div></div><div class="message event" id="message-1525954536.000350"><div class="content"><div class="summary"><div class="message__header user">cdepillabout</div><div class="message__timestamp date">2018-05-10&nbsp;21:15:36 +0900</div></div><div class="message__body description">そうですね、classy-preludeを結構使っています。いろいろ便利な機能を提供していて、mono-traversableの関数をexportしているので使いやすいという印象です。</div></div></div><div class="message event" id="message-1525966783.000746"><div class="content"><div class="summary"><div class="message__header user">sugano</div><div class="message__timestamp date">2018-05-11&nbsp;00:39:43 +0900</div></div><div class="message__body description">@sugano has joined the channel</div></div></div><div class="message event" id="message-1526008760.000063"><div class="content"><div class="summary"><div class="message__header user">ncaq</div><div class="message__timestamp date">2018-05-11&nbsp;12:19:20 +0900</div></div><div class="message__body description">Yesod開発者なのでclassy-preludeをよく使ってますがstackもrio行ったし移行するのかなあ</div></div></div><div class="message event" id="message-1526029737.000188"><div class="content"><div class="summary"><div class="message__header user">mizunashi-mana</div><div class="message__timestamp date">2018-05-11&nbsp;18:08:57 +0900</div></div><div class="message__body description">classy-prelude，最近もsafe-exceptions -&gt; UnliftIO.Exceptionの移行があったり，かなりAPI破壊してくるのが辛いですね</div></div></div><div class="message event" id="message-1526030366.000478"><div class="content"><div class="summary"><div class="message__header user">fumieval</div><div class="message__timestamp date">2018-05-11&nbsp;18:19:26 +0900</div></div><div class="message__body description">classy-preludeは、以前よりはマシになったとはいえ、リエクスポートも過剰で正直出来が悪いと思います</div></div></div><div class="message event" id="message-1526031211.000072"><div class="content"><div class="summary"><div class="message__header user">mizunashi-mana</div><div class="message__timestamp date">2018-05-11&nbsp;18:33:31 +0900</div></div><div class="message__body description">個人的には，プロジェクトでかなり使用頻度の高い関数群や要請(保守性が高い方がいい/関数が所属してるモジュールの検索性は悪くてもいいので，Utilityが欲しい/dependencyが少ない方がいい)がかなり異なるので，プロジェクトごとにclassy-preludeなりbase-preludeなりをベースにPreludeモジュール作るのが好みですね</div></div></div><div class="message event" id="message-1526176535.000051"><div class="content"><div class="summary"><div class="message__header user">as_capabl</div><div class="message__timestamp date">2018-05-13&nbsp;10:55:35 +0900</div></div><div class="message__body description">基本は普通のPreludeなんですが、idと(.)はControl.Categoryの奴が使いたくて毎回hidingしてますね……自分に合う奴を探した方がいいのでしょうか</div></div></div><div class="message event" id="message-1526193310.000027"><div class="content"><div class="summary"><div class="message__header user">karoyakani</div><div class="message__timestamp date">2018-05-13&nbsp;15:35:10 +0900</div></div><div class="message__body description">なるほど　後者は歯が立たないと思ったのは拙速でした　腰を据えて読み返してみれば　記法が異なるだけで <code>3.2 Fold</code> は確かに Parametricity と代数の可換性から自然に fusion が導かれているのが分かりました　重ねてご教示有難うございました</div></div></div><div class="message event" id="message-1526200938.000058"><div class="content"><div class="summary"><div class="message__header user">n.tatsuki.214</div><div class="message__timestamp date">2018-05-13&nbsp;17:42:18 +0900</div></div><div class="message__body description">@n.tatsuki.214 has joined the channel</div></div></div><div class="message event" id="message-1526277321.000233"><div class="content"><div class="summary"><div class="message__header user">hiroto.shioi</div><div class="message__timestamp date">2018-05-14&nbsp;14:55:21 +0900</div></div><div class="message__body description">カスタムPreludeは潜在的にバグとなりうる関数、型クラスと取り除いてるので安全なコードが書けるというのが１つの利点だと思います。(UniversumではShowの型クラスインスタンスを定義できない（導出のみ）し、NonEmptyのリストのみhead,tail等ができる）RIOに関してはいえばReaderTパターン（変換子の中でも鉄板パターン）をベースにいれています。<br/>ただ地雷Preludeもあるので注意しないといけません。。！</div></div></div><div class="message event" id="message-1526433975.000231"><div class="content"><div class="summary"><div class="message__header user">igrep</div><div class="message__timestamp date">2018-05-16&nbsp;10:26:15 +0900</div></div><div class="message__body description">昨日の <a href='https://haskell-jp.slack.com/archives/C4M4TT8JJ/p1526345560000259'>https://haskell-jp.slack.com/archives/C4M4TT8JJ/p1526345560000259</a> で、fumiさんから助言を受けて、「型レベルリストから要素を取り除く型族Remove :: k -&gt; [k] -&gt; [k]」を書いているところなんです。<br/>値レベルの関数を割と愚直に翻訳してこんな :point_down: ところまで書きました（よそのライブラリーで実装済みじゃないのか、という気もしますが）。<br/><pre>
type family ConsUnless (b :: Bool) (x :: k) (xs :: [k]) :: [k] where
  ConsUnless False x xs = (x ': xs)
  ConsUnless True _ xs = xs

type family Reject (p :: (k -&gt; Bool)) (xs :: [k]) :: [k] where
  Reject p '[] = '[]
  Reject p (x ': xs) = ConsUnless (p x) x (Reject p xs)

type family Same (x :: k) (y :: k) :: Bool where
  Same x x = 'True
  Same x y = 'False

type family Without (x :: k) (xs :: [k]) :: [k] where
  Without x xs = Reject (Same x) xs
</pre><br/>で、コンパイルするとなぜか<br/><pre>
    • The type family ‘Same’ should have 2 arguments, but has been given 1
    • In the equations for closed type family ‘Without’
      In the type family declaration for ‘Without’
</pre><br/>というエラーが出ます。 <code>Same</code> が2つ引数をとるのはいいとして、 <code>Reject</code> の第一引数が引数を1つとる型族をとるよう宣言しているので、 <code>Same x</code> とすればいいんじゃないかと思えるのですが、なんでエラーになってしまうのでしょうか？</div></div></div><div class="message event" id="message-1526434199.000320"><div class="content"><div class="summary"><div class="message__header user">igrep</div><div class="message__timestamp date">2018-05-16&nbsp;10:29:59 +0900</div></div><div class="message__body description">補足: 名前が紛らわしくて申し訳ないんですが、 fumiさんのおっしゃる  <code>Remove</code> に相当するのは <code>Without</code> と呼んでいます。</div></div></div><div class="message event" id="message-1526434824.000034"><div class="content"><div class="summary"><div class="message__header user">matsubara0507</div><div class="message__timestamp date">2018-05-16&nbsp;10:40:24 +0900</div></div><div class="message__body description">型族ってカリー化みたいなのできたっけ？</div></div></div><div class="message event" id="message-1526435256.000091"><div class="content"><div class="summary"><div class="message__header user">matsubara0507</div><div class="message__timestamp date">2018-05-16&nbsp;10:47:36 +0900</div></div><div class="message__body description">っぽいことが書いてある？<br/><a href='http://www.kotha.net/ghcguide_ja/latest/type-families.html#type-family-declarations'>http://www.kotha.net/ghcguide_ja/latest/type-families.html#type-family-declarations</a></div></div></div><div class="message event" id="message-1526440483.000050"><div class="content"><div class="summary"><div class="message__header user">wado</div><div class="message__timestamp date">2018-05-16&nbsp;12:14:43 +0900</div></div><div class="message__body description">僕はあんまり詳しく無いですが、確かこの論文に色々書いてあったような<br/>Promoting Functions to Type Families in Haskell<br/><a href='https://repository.brynmawr.edu/cgi/viewcontent.cgi?referer=&amp;httpsredir=1&amp;article=1000&amp;context=compsci_pubs'>https://repository.brynmawr.edu/cgi/viewcontent.cgi?referer=&amp;httpsredir=1&amp;article=1000&amp;context=compsci_pubs</a></div></div></div><div class="message event" id="message-1526449957.000060"><div class="content"><div class="summary"><div class="message__header user">fumieval</div><div class="message__timestamp date">2018-05-16&nbsp;14:52:37 +0900</div></div><div class="message__body description">型族は常に引数を飽和させる必要があります。エレガントさは損なわれますが、Withoutは直接定義することになると思います</div></div></div><div class="message event" id="message-1526577909.000217"><div class="content"><div class="summary"><div class="message__header user">kaznak.at.work</div><div class="message__timestamp date">2018-05-18&nbsp;02:25:09 +0900</div></div><div class="message__body description">@kaznak.at.work has joined the channel</div></div></div><div class="message event" id="message-1526606658.000243"><div class="content"><div class="summary"><div class="message__header user">igrep</div><div class="message__timestamp date">2018-05-18&nbsp;10:24:18 +0900</div></div><div class="message__body description">毎度ありがとうございます。<br/>「レコードから指定したキーの要素を取り除いたレコードを返す関数」作りの続きです。<br/>:point_down: のような、closedな型族と型クラスを組み合わせて、レコードが空の場合とそうでない場合とで実装をわけられるようにしました。<br/>が、残念ながら今度は実装で思わぬコンパイルエラーになってしまいます（エラーメッセージは後ほどコメントに張ります）<br/>おそらくもう一歩なところだと思うので、助言をいただきたく！<br/><pre>
type family Result (x :: k) (xs :: [k]) :: [k] where
  Result x '[] = '[]
  Result x (x ': xs) = Result x xs
  Result x (y ': ys) = y ': Result x ys

class Without (x :: k) (xs :: [k]) where
  without :: Membership xs x -&gt; (h :* xs) -&gt; (h :* Result x xs)

instance Without x '[] where
  without _ _ = nil

instance Without x (x ': xs) where
  without key rec =
    let (_, ys) = huncons $ toHList rec
    in without key (fromHList ys)

instance Without x (y ': ys) where
  without key rec =
    let (y, ys) = huncons $ toHList rec
    in y &lt;: without key (fromHList ys)

huncons :: HList h (x ': xs) -&gt; (h x, HList h xs)
huncons (HCons hx hxs) = (hx, hxs)
</pre></div></div></div><div class="message event" id="message-1526606686.000117"><div class="content"><div class="summary"><div class="message__header user">igrep</div><div class="message__timestamp date">2018-05-18&nbsp;10:24:46 +0900</div></div><div class="message__body description">エラーメッセージです :point_down: <br/><pre>
app\Main.hs:41:21: error:
    ? Couldn't match type ‘xs’ with ‘x : xs’
      ‘xs’ is a rigid type variable bound by
        the instance declaration at app\Main.hs:38:10-28
      Expected type: h :* (x : xs)
        Actual type: h :* xs
    ? In the second argument of ‘without’, namely ‘(fromHList ys)’
      In the expression: without key (fromHList ys)
      In the expression:
        let (_, ys) = huncons $ toHList rec in without key (fromHList ys)
    ? Relevant bindings include
        ys :: HList h xs (bound at app\Main.hs:40:13)
        rec :: h :* (x : xs) (bound at app\Main.hs:39:15)
        key :: Membership (x : xs) x (bound at app\Main.hs:39:11)
        without :: Membership (x : xs) x
                   -&gt; (h :* (x : xs)) -&gt; h :* Result x (x : xs)
          (bound at app\Main.hs:39:3)
   |
41 |     in without key (fromHList ys)
   |                     ^^^^^^^^^^^^

app\Main.hs:46:26: error:
    ? Couldn't match type ‘ys’ with ‘y : ys’
      ‘ys’ is a rigid type variable bound by
        the instance declaration at app\Main.hs:43:10-28
      Expected type: h :* (y : ys)
        Actual type: h :* ys
    ? In the second argument of ‘without’, namely ‘(fromHList ys)’
      In the second argument of ‘(&lt;:)’, namely
        ‘without key (fromHList ys)’
      In the expression: y &lt;: without key (fromHList ys)
    ? Relevant bindings include
        y :: h y (bound at app\Main.hs:45:10)
        ys :: HList h ys (bound at app\Main.hs:45:13)
        rec :: h :* (y : ys) (bound at app\Main.hs:44:15)
        key :: Membership (y : ys) x (bound at app\Main.hs:44:11)
        without :: Membership (y : ys) x
                   -&gt; (h :* (y : ys)) -&gt; h :* Result x (y : ys)
          (bound at app\Main.hs:44:3)
   |
46 |     in y &lt;: without key (fromHList ys)
</pre></div></div></div><div class="message event" id="message-1526607469.000052"><div class="content"><div class="summary"><div class="message__header user">kaznak.at.work</div><div class="message__timestamp date">2018-05-18&nbsp;10:37:49 +0900</div></div><div class="message__body description">質問があります。<br/><br/>練習のために、 stack resolver lts-11.9 の環境で数独に関するライブラリを作っています。<br/>いま、一つのセルの状態を表現するために Maybe を使おうと思ってます。<br/>例えば、あるセルに 1 が入っていれば Maybe 1 、空ならば Nothing という具合です。<br/><br/>ただ、そのままでは show した時に Maybe や Nothing が表示されてしまうので、<br/>この表示を変えたいと思っています。<br/>例えば、 Maybe 1 ならば 1 、 Nothing ならば _ が出力されるという具合にです。<br/>出来れば read も同じように出来ると嬉しいです。<br/><br/>Maybe 関連のライブラリ関数を使いたいので、さしあたって show と read の振る舞いだけ変えたいのです。<br/>こういった、ほとんど同じなんだけど、ほんの少し振る舞いが異なる型を表現したいときはどうしたら良いのでしょうか。<br/><br/>よろしくお願いします。</div></div></div><div class="message event" id="message-1526607546.000279"><div class="content"><div class="summary"><div class="message__header user">igrep</div><div class="message__timestamp date">2018-05-18&nbsp;10:39:06 +0900</div></div><div class="message__body description"><pre>
newtype Cell = Cell (Maybe Int)
</pre><br/>ですねぱっと思いつくのは。<br/><br/><code>newtype</code> とすることで、 <code>Cell</code> はまさにおっしゃるような、 「 <code>Maybe Int</code> と ほとんど同じなんだけど、ほんの少し振る舞いが異なる型」として定義できます。</div></div></div><div class="message event" id="message-1526607966.000024"><div class="content"><div class="summary"><div class="message__header user">igrep</div><div class="message__timestamp date">2018-05-18&nbsp;10:46:06 +0900</div></div><div class="message__body description">ただ、個人的には <code>Show</code> はあくまでもデバッグ用の文字列に変換するものとして使ったほうがよいのではないかと考えています。<br/>なので、 <code>newtype</code> でセル専用の型を用意するにせよしないにせよ、<br/><code>Show</code> や <code>Read</code> のインスタンスを無理に書き換えずに、文字列からパースして作成したり文字列に変換する用の関数は独立して作った方がいいんじゃないかと思います。</div></div></div><div class="message event" id="message-1526608361.000125"><div class="content"><div class="summary"><div class="message__header user">mizunashi-mana</div><div class="message__timestamp date">2018-05-18&nbsp;10:52:41 +0900</div></div><div class="message__body description">あんまりよくわかってないですが，<br/><pre>
instance Without x ys =&gt; Without x (y:ys) where
</pre><br/>が正しいのではないでしょうか？(Overlappingしそうですが)</div></div></div><div class="message event" id="message-1526609227.000251"><div class="content"><div class="summary"><div class="message__header user">fumieval</div><div class="message__timestamp date">2018-05-18&nbsp;11:07:07 +0900</div></div><div class="message__body description">prettyprinter <a href='https://hackage.haskell.org/package/prettyprinter'>https://hackage.haskell.org/package/prettyprinter</a> は、名前の通りShowよりも小奇麗に表示するのに適しています。整列表示などもできるのでお試しあれ</div></div></div><div class="message event" id="message-1526611655.000184"><div class="content"><div class="summary"><div class="message__header user">igrep</div><div class="message__timestamp date">2018-05-18&nbsp;11:47:35 +0900</div></div><div class="message__body description">@igrep pinned a message to this channel.</div></div></div><div class="message event" id="message-1526612591.000094"><div class="content"><div class="summary"><div class="message__header user">mizunashi-mana</div><div class="message__timestamp date">2018-05-18&nbsp;12:03:11 +0900</div></div><div class="message__body description">文脈を把握してきたんですけど，うーん僕はあまり型レベルプログラミングには詳しくないんですが，hFilterは結構実装難しいんじゃないんですかね？上のエラーは，`Without x xs =&gt;` の制約がないため，xsに対してxのwithoutメソッドを呼べないエラーですが，おそらく呼べるようにしてみても<br/><pre>
type family Result (x :: k) (xs :: [k]) :: [k] where
  Result x '[] = '[]
  Result x (x ': xs) = Result x xs
  Result x (y ': ys) = y ': Result x ys
</pre><br/>のResult x (y ’: ys)の部分がかなり怪しくって，こいつをpolymorphicなままで呼び出すのはかなり技巧が必要だと思いますね</div></div></div><div class="message event" id="message-1526613189.000065"><div class="content"><div class="summary"><div class="message__header user">mizunashi-mana</div><div class="message__timestamp date">2018-05-18&nbsp;12:13:09 +0900</div></div><div class="message__body description">まあ少なくとも，上の例ほど単純には書けないんじゃないかな？と思います(なんらかの，type equalityをラップする処理が必要なんじゃないかなと思います)</div></div></div><div class="message event" id="message-1526619855.000021"><div class="content"><div class="summary"><div class="message__header user">kaznak.at.work</div><div class="message__timestamp date">2018-05-18&nbsp;14:04:15 +0900</div></div><div class="message__body description">ありがとうございます。newtype 使うといい感じに書けました。<br/><br/><blockquote>ただ、個人的には ｀Show｀ はあくまでもデバッグ用の文字列に変換するものとして使ったほうがよいのではないかと考えています。</blockquote><br/>これはなぜなんですかね? なんとなく Show や Read は標準のリーダ/ライタなのかなと思っていたのですが。<br/><br/>prettyprinter ありがとうございます。見てみます。</div></div></div><div class="message event" id="message-1526621056.000251"><div class="content"><div class="summary"><div class="message__header user">mizunashi-mana</div><div class="message__timestamp date">2018-05-18&nbsp;14:24:16 +0900</div></div><div class="message__body description">なんか，知識が錆びついてたみたいですね．昔は一苦労必要だった気がするんですが， <a href='https://hackage.haskell.org/package/base-4.10.1.0/docs/Data-Type-Equality.html#t:-61--61-'>https://hackage.haskell.org/package/base-4.10.1.0/docs/Data-Type-Equality.html#t:-61--61-</a> を使えば結構簡単にいけましたね．FunctionalDependenciesを使うといけると思います(HListがその方式っぽいですね)</div></div></div><div class="message event" id="message-1526621270.000191"><div class="content"><div class="summary"><div class="message__header user">mizunashi-mana</div><div class="message__timestamp date">2018-05-18&nbsp;14:27:50 +0900</div></div><div class="message__body description">いちよ，書いたやつを置いときます(ただHListを参考にやって見た方が，分かりやすいかもしれません．あと，extensibleよく知らないんですがMembershipが内部で持ってる位置をfilter後に移してやる必要があったりするんじゃないんですかね？)<br/><a href='https://gist.github.com/mizunashi-mana/df1d54e87a9901b9f225f1ed658bdff6'>https://gist.github.com/mizunashi-mana/df1d54e87a9901b9f225f1ed658bdff6</a></div></div></div><div class="message event" id="message-1526622308.000106"><div class="content"><div class="summary"><div class="message__header user">mizunashi-mana</div><div class="message__timestamp date">2018-05-18&nbsp;14:45:08 +0900</div></div><div class="message__body description">コードがちょっとミスってたんで，微修正しました</div></div></div><div class="message event" id="message-1526622632.000050"><div class="content"><div class="summary"><div class="message__header user">igrep</div><div class="message__timestamp date">2018-05-18&nbsp;14:50:32 +0900</div></div><div class="message__body description">絶対にそうした方がいいというつもりではないですが、<br/>例えば <code>String</code> の <code>show</code> 関数は、受け取った文字列をそのまま返すのではなく、<br/>ダブルクォートで囲ったり、エスケープシーケンスがわかりやすくなるように変換したりして返すようになっています。<br/>これと同じように、大概の <code>Show</code> のインスタンスは、<br/>変換後の文字列から、何の型の値を変換したかがわかりやすいように作られています。<br/><code>traceShowId</code> など <code>Show</code> のインスタンスをデバッグ用に使う関数に渡して表示させた際、（特に何カ所も出力させた場合に）どの型の値を出力したのか区別できるようにした方が、視認性が上がるためでしょう。<br/>なので、自前で定義するにしても、何の型の値から変換された文字列かがわかりやすいように作った方がよいかと思います。</div></div></div><div class="message event" id="message-1526627317.000013"><div class="content"><div class="summary"><div class="message__header user">kaznak.at.work</div><div class="message__timestamp date">2018-05-18&nbsp;16:08:37 +0900</div></div><div class="message__body description">なるほど。 Show と Read はあくまで ghci 用だと考えたほうが良いってことですね。確かにそんな気がしてきました。ありがとうございます。</div></div></div><div class="message event" id="message-1526961523.000255"><div class="content"><div class="summary"><div class="message__header user">ncaq</div><div class="message__timestamp date">2018-05-22&nbsp;12:58:43 +0900</div></div><div class="message__body description">Readを自前実装しようとするとその型のリストをRead対応させるのがめっちゃ面倒という問題もあります</div></div></div><div class="message event" id="message-1526965523.000272"><div class="content"><div class="summary"><div class="message__header user">igrep</div><div class="message__timestamp date">2018-05-22&nbsp;14:05:23 +0900</div></div><div class="message__body description">そうなんですよねぇ。<br/>ただ、（おそらく）今回のように1アプリケーションでしか使わないデータ型であれば、あえて <code>Read</code> のインスタンスにする必要はないだろうな、と思って触れてませんでした。</div></div></div><div class="message event" id="message-1527990588.000004"><div class="content"><div class="summary"><div class="message__header user">hexirp</div><div class="message__timestamp date">2018-06-03&nbsp;10:49:48 +0900</div></div><div class="message__body description">ライフゲームを作りたいんですが、そのためのGUIライブラリでいいものはありますか？</div></div></div><div class="message event" id="message-1527990811.000086"><div class="content"><div class="summary"><div class="message__header user">lotz</div><div class="message__timestamp date">2018-06-03&nbsp;10:53:31 +0900</div></div><div class="message__body description">僕はglossをよく使ってます！<br/><https://hackage.haskell.org/package/gloss><br/>ライフゲームならこの simulate って関数を使えば楽に実装できるんじゃないかなと思います~!<br/><https://hackage.haskell.org/package/gloss-1.12.0.0/docs/Graphics-Gloss.html#v:simulate></div></div></div><div class="message event" id="message-1527991129.000018"><div class="content"><div class="summary"><div class="message__header user">hexirp</div><div class="message__timestamp date">2018-06-03&nbsp;10:58:49 +0900</div></div><div class="message__body description">早い返信ありがとうございます！想定している機能は停止/再開ボタンとクリックによるセルの反転が含まれているので すが、それもまた play で実現できそうですね！</div></div></div><div class="message event" id="message-1527991162.000072"><div class="content"><div class="summary"><div class="message__header user">lotz</div><div class="message__timestamp date">2018-06-03&nbsp;10:59:22 +0900</div></div><div class="message__body description">はい、playで実現できると思います :raised_hands:</div></div></div><div class="message event" id="message-1528066580.000111"><div class="content"><div class="summary"><div class="message__header user">hexirp</div><div class="message__timestamp date">2018-06-04&nbsp;07:56:20 +0900</div></div><div class="message__body description">glossを依存関係に加えた後にビルドしようとしたら、freeglutをインストールしていなかったために推移依存関係によるGLUTのビルド時に何かが壊れたようで、precompiled packageが全部読み込めなくなったみたいです。</div></div></div><div class="message event" id="message-1528066600.000063"><div class="content"><div class="summary"><div class="message__header user">hexirp</div><div class="message__timestamp date">2018-06-04&nbsp;07:56:40 +0900</div></div><div class="message__body description">glossを依存関係に加えたプロジェクトをstack buildでビルドした後に実行しようとしたらuser error (unknown GLUT entry glutInit)が出たため調べたらglutのインストールがいるよと出たため、一旦やめて他のプロジェクトをstack buildでビルドしようとしたら</div></div></div></div><div class="pager ui pagination menu"><a href="../../html/C5666B6BB/20.html" class="pager__previous item">Previous</a><a href="../../" class="pager__top item">Top</a><a href="../../html/C5666B6BB/22.html" class="pager__next item">Next</a></div></div></body></html>