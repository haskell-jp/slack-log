<!DOCTYPE html><html><head><meta charset="utf-8"><title>haskell-jp / questions #87</title><link rel="stylesheet" href="../../main.css" type="text/css" media="screen"></head><body><div class="ui container"><h1>haskell-jp / questions #87</h1><div class="pager ui pagination menu"><a href="../../html/C5666B6BB/86.html" class="pager__previous item">Previous</a><a href="../../" class="pager__top item">Top</a></div><div class="message_list ui feed"><div class="message event" id="message-1592620487.062600"><div class="content"><div class="summary"><div class="message__header user">cj.bc-sd</div><div class="message__timestamp date"><a class="date" href="#message-1592620487.062600">2020-06-20&nbsp;11:34:47 +0900</a></div></div><div class="message__body description">返信遅くなりましたがうまく行きました！！！<br/>ありがとうございます！！<br/>Lensはoverやsetやviewと使うものだという固定概念がありました…今度からもっと型を注意してみるようにしてみます<br/><br/><pre>Prelude Control.Lens&gt; _2 (\a -&gt; print ("PRINTED: " ++ show a) &gt;&gt; return (Just "a")) (("hoge",6), 1.20)
"PRINTED: 1.2"
(("hoge",6),Just "a")
Prelude Control.Lens&gt; (_1 . _2) (\a -&gt; print ("PRINTED: " ++ show a) &gt;&gt; return (Just "a")) (("hoge",6), 1.20)
"PRINTED: 6"
(("hoge",Just "a"),1.2)</pre><br/>そうなんですねwすごい偶然</div></div></div><div class="message event" id="message-1592726883.064100"><div class="content"><div class="summary"><div class="message__header user">dex10619</div><div class="message__timestamp date"><a class="date" href="#message-1592726883.064100">2020-06-21&nbsp;17:08:03 +0900</a></div></div><div class="message__body description">初歩的な質問ですが、お尋ねさせてください。<br/>仮定として、Main.hsに以下のような相対パス指定のファイル読み込みのコードが書かれているとします。<br/><br/><pre>readFile "../hoge.txt" --1つ上の階層のパスからファイルを読み込み</pre><br/>この時、current working directoryに依存せずに、「Main.hsファイルを起点とした相対パス指定」でファイルを読み込みたいです。<br/>（「stack exec XXX-exe」でプロセスを起動すると、current working directory起点とした相対パス指定になるため、場合によりうまく動かないです。）<br/><br/>上記のやりたいことを実現するための、お決まりのパターンとかってありますか？<br/>getCurrentDirectoryだと、簡単には行かなそうです。</div></div></div><div class="message event" id="message-1592729423.064300"><div class="content"><div class="summary"><div class="message__header user">matonix</div><div class="message__timestamp date"><a class="date" href="#message-1592729423.064300">2020-06-21&nbsp;17:50:23 +0900</a></div></div><div class="message__body description">私が同じような問題に当たっときは「コンパイル時に相対パス指定したファイルを埋め込む」という方法を取りました。<br/>以下のパッケージがそのような手段を提供しています。<br/><a href='https://hackage.haskell.org/package/file-embed-0.0.12.0'>https://hackage.haskell.org/package/file-embed-0.0.12.0</a><br/>他の方法をご存じの方がいらっしゃいましたらよろしくお願いします（私も気になってます…）</div></div></div><div class="message event" id="message-1592730211.064700"><div class="content"><div class="summary"><div class="message__header user">dex10619</div><div class="message__timestamp date"><a class="date" href="#message-1592730211.064700">2020-06-21&nbsp;18:03:31 +0900</a></div></div><div class="message__body description">@matonix<br/>回答ありがとうございます。上記の方法はなかなかテクニカルですね。。<br/>意外と手軽にできる方法はなかったりするのですかね:cry:</div></div></div><div class="message event" id="message-1592730946.064900"><div class="content"><div class="summary"><div class="message__header user">igrep</div><div class="message__timestamp date"><a class="date" href="#message-1592730946.064900">2020-06-21&nbsp;18:15:46 +0900</a></div></div><div class="message__body description">コンパイル時のことって基本的に忘れられてしまうので難しいですね。<br/>イマイチ目的が想像できませんが、プロジェクトルートからの相対パスか、 <a href='https://www.haskell.org/cabal/users-guide/developing-packages.html?highlight=paths_#accessing-data-files-from-package-code'>https://www.haskell.org/cabal/users-guide/developing-packages.html?highlight=paths_#accessing-data-files-from-package-code</a> などに書かれている <code>Paths_pkgname</code> を使った方が賢明かと思います。<br/>それでもコンパイルされる <code>Main.hs</code> の場所が欲しい、ということであれば、Template Haskellの <code>location</code> が使えるかな、と思ったけどこれはフルパスはとれないっぽいな<br/><a href='http://hackage.haskell.org/package/template-haskell-2.16.0.0/docs/Language-Haskell-TH-Syntax.html#v:location'>http://hackage.haskell.org/package/template-haskell-2.16.0.0/docs/Language-Haskell-TH-Syntax.html#v:location</a></div></div></div><div class="message event" id="message-1592732425.067800"><div class="content"><div class="summary"><div class="message__header user">kakkun61</div><div class="message__timestamp date"><a class="date" href="#message-1592732425.067800">2020-06-21&nbsp;18:40:25 +0900</a></div></div><div class="message__body description">自分も <code>Paths_pkgname</code> が正攻法に思います</div></div></div><div class="message event" id="message-1592732460.068500"><div class="content"><div class="summary"><div class="message__header user">maoe</div><div class="message__timestamp date"><a class="date" href="#message-1592732460.068500">2020-06-21&nbsp;18:41:00 +0900</a></div></div><div class="message__body description">コンパイル時に指定したパスが実行時にも存在することが保証されている前提ならCPPを有効にして <code>__FILE__</code> マクロを使う手もあります。</div></div></div><div class="message event" id="message-1592733614.068800"><div class="content"><div class="summary"><div class="message__header user">dex10619</div><div class="message__timestamp date"><a class="date" href="#message-1592733614.068800">2020-06-21&nbsp;19:00:14 +0900</a></div></div><div class="message__body description">@igrep @kakkun61 @maoe<br/>なるほど、ありがとうございます！<br/>確かに<br/><br/><blockquote>コンパイル時のことって基本的に忘れられてしまうので難しいですね。</blockquote>これが真理な気がしてきました。。</div></div></div><div class="message event" id="message-1592734058.069000"><div class="content"><div class="summary"><div class="message__header user">dex10619</div><div class="message__timestamp date"><a class="date" href="#message-1592734058.069000">2020-06-21&nbsp;19:07:38 +0900</a></div></div><div class="message__body description">基本的にstackを利用してprojectを作成する際は、実行体である.exeファイルはstackのサンドボックス内に作られるので、プロセスの起動もサンドボックス内の特定のディレクトリで行う、という形をとるのが素直な気がしてきました:bow:</div></div></div><div class="message event" id="message-1593074145.069800"><div class="content"><div class="summary"><div class="message__header user">ym0429_ma4ma</div><div class="message__timestamp date"><a class="date" href="#message-1593074145.069800">2020-06-25&nbsp;17:35:45 +0900</a></div></div><div class="message__body description">@ym0429_ma4ma has joined the channel</div></div></div><div class="message event" id="message-1593243213.070100"><div class="content"><div class="summary"><div class="message__header user">znmxodq1</div><div class="message__timestamp date"><a class="date" href="#message-1593243213.070100">2020-06-27&nbsp;16:33:33 +0900</a></div></div><div class="message__body description">@znmxodq1 has joined the channel</div></div></div><div class="message event" id="message-1593512177.070500"><div class="content"><div class="summary"><div class="message__header user">falgon53</div><div class="message__timestamp date"><a class="date" href="#message-1593512177.070500">2020-06-30&nbsp;19:16:17 +0900</a></div></div><div class="message__body description">@falgon53 has joined the channel</div></div></div><div class="message event" id="message-1593575176.070800"><div class="content"><div class="summary"><div class="message__header user">sdghrwihl456</div><div class="message__timestamp date"><a class="date" href="#message-1593575176.070800">2020-07-01&nbsp;12:46:16 +0900</a></div></div><div class="message__body description">@sdghrwihl456 has joined the channel</div></div></div><div class="message event" id="message-1593672664.071100"><div class="content"><div class="summary"><div class="message__header user">U016D5S559B</div><div class="message__timestamp date"><a class="date" href="#message-1593672664.071100">2020-07-02&nbsp;15:51:04 +0900</a></div></div><div class="message__body description">@U016D5S559B has joined the channel</div></div></div><div class="message event" id="message-1593710468.075000"><div class="content"><div class="summary"><div class="message__header user">dex10619</div><div class="message__timestamp date"><a class="date" href="#message-1593710468.075000">2020-07-03&nbsp;02:21:08 +0900</a></div></div><div class="message__body description">「プログラミングHaskell 第2版」１３章の「モナドパーサー」を読んでいますが、<br/>以下の式がどう簡約されていき、最終的に[("1", "a")]と評価されているのか分からず、苦戦中。。<br/><br/>これ、どのような順序で式が評価されていってるのでしょう。。<br/><pre>&gt;parse (some digit) "1a"
[("1","a")]</pre><br/>以下の簡約の仕方だと、永遠に評価が終わらない。<br/><br/><pre>-- many x = some x &lt;|&gt; pure []
-- some x = pure (:) &lt;*&gt; x &lt;*&gt; many x

parse (some digit) "1a"
parse (pure (:) &lt;*&gt; digit &lt;*&gt; many digit) "1a"
parse (pure (:) &lt;*&gt; digit &lt;*&gt; (some digit &lt;|&gt; pure [])) "1a"
parse (pure (:) &lt;*&gt; digit &lt;*&gt; ((pure (:) &lt;*&gt; digit &lt;*&gt; many digit) &lt;|&gt; pure [])) "1a"
…（以下略）</pre><br/><br/>ちなみに、以下のコードを叩いてみたら、次の結果となったので、末尾の相互再帰(many/some)の部分は遅延評価されているように思えますが、具体的にどう簡約されていくのかが分からないです。。<br/><br/><pre>&gt;parse (some digit) (repeat 'a')
[] --これは直ちに結果（empty)を返す</pre><br/><pre>&gt;parse (some digit) (repeat '1')
*** Exception: stack overflow --スタックオーバーフローが発生</pre><br/><br/>＜補足＞<br/>上記の元となる実装は以下です。<br/><br/><pre>newtype Parser a = Parser (String -&gt; [(a, String)])                                                                                                                                                                                           

parse :: Parser a -&gt; String -&gt; [(a, String)]
parse (Parser p) inp = p inp 

instance Alternative Parser where
  empty  = Parser (\inp -&gt; []) 
  p &lt;|&gt; q = Parser (\inp -&gt; case parse p inp of
                              [] -&gt; parse q inp 
                              [(a, out)] -&gt; [(a, out)])
  many x = some x &lt;|&gt; pure []
  some x = pure (:) &lt;*&gt; x &lt;*&gt; many x


instance Functor Parser where
  fmap f p = Parser (\inp -&gt; case parse p inp of
                               [] -&gt; []
                               [(a, out)] -&gt; [(f a, out)])

instance Applicative Parser where
  pure v = Parser (\inp -&gt; [(v, inp)])
  pf &lt;*&gt; pa = Parser (\inp -&gt; case parse pf inp of
                                [] -&gt; []
                                [(f, out)] -&gt; parse (fmap f pa) out)

instance Monad Parser where
  return = pure
  p &gt;&gt;= f = Parser (\inp -&gt; case parse p inp of
                         [] -&gt; []
                         [(v, out)] -&gt; parse (f v) out)

item :: Parser Char
item = Parser (\inp -&gt; case inp of
                          [] -&gt; []
                          (x:xs) -&gt; [(x, xs)])

sat :: (Char -&gt; Bool) -&gt; Parser Char
sat p = do
  x &lt;- item
  if p x then return x else empty

digit :: Parser Char
digit = sat isDigit</pre><br/></div></div></div></div><div class="pager ui pagination menu"><a href="../../html/C5666B6BB/86.html" class="pager__previous item">Previous</a><a href="../../" class="pager__top item">Top</a></div></div></body></html>