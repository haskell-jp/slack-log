<!DOCTYPE html><html><head><meta charset="utf-8"><title>haskell-jp / questions #19</title><link rel="stylesheet" href="/messages.css" type="text/css" media="screen"></head><body><h1>haskell-jp / questions #19</h1><div class="pager"><a href="/html/C5666B6BB/18.html" class="pager__previous">Previous</a><a href="/" class="pager__top">Top</a><a href="/html/C5666B6BB/20.html" class="pager__next">Next</a></div><div class="message_list"><div class="message" id="message-1524378882.000009"><div class="message__timestamp">2018-04-22<br/>15:34:42 +0900</div><div class="message__header">fujiyan18</div><div class="message__body">ありがとうございます。<br/>私の質問が言葉足らずでしたが、<br/>パーサーを使う程でもない、10数行程度の入門レベルのコンソールアプリのサンプルを作る際に、<br/>毎回(pack . show)と(read . unpack)で行数がやや膨らむので悩んだところでした。<br/><br/>特に定番的なものがなければ、入門レベルならむしろその方が、追加のライブラリも不要ですし、<br/>対称的で見栄えも良い、という感じでも問題は無いでしょうか？</div></div><div class="message" id="message-1524381354.000050"><div class="message__timestamp">2018-04-22<br/>16:15:54 +0900</div><div class="message__header">igrep</div><div class="message__body">いいと思います。<br/>個人的には、入門程度のアプリケーションであれば、そもそもTextを使うまでもないかと思います（Textの勉強をしている場合は別ですが。。。）</div></div><div class="message" id="message-1524382426.000067"><div class="message__timestamp">2018-04-22<br/>16:33:46 +0900</div><div class="message__header">fujiyan18</div><div class="message__body">textはデファクトみたいなもので、<br/>早いうちから慣れておいた方が後々楽かなぁという思いでした。<br/><br/>自分のやり方があっているのかが不安でしたが、<br/>Haskellベテランの方のご意見をお伺い出来て安心しました。<br/>ありがとうございました！</div></div><div class="message" id="message-1524406964.000035"><div class="message__timestamp">2018-04-22<br/>23:22:44 +0900</div><div class="message__header">fumieval</div><div class="message__body">BuilderとLazy版Textを通るのでかなり遠回りですが、<http://hackage.haskell.org/package/text-1.2.3.0/docs/Data-Text-Lazy-Builder-Int.html> というモジュールもあります</div></div><div class="message" id="message-1524407811.000107"><div class="message__timestamp">2018-04-22<br/>23:36:51 +0900</div><div class="message__header">fujiyan18</div><div class="message__body">ご紹介ありがとうございます！<br/><br/>実は、これにも疑問があったのですが、Lazy版しか提供されていないのは<br/>何か理由があるのでしょうか？<br/>ストリームから読み込む際に、変換可能なバイト列が揃うまで評価を待ちたいから、<br/>みたいな事情でしょうか？<br/><br/>更に質問で恐縮ですが、よろしくお願いします。</div></div><div class="message" id="message-1524408870.000115"><div class="message__timestamp">2018-04-22<br/>23:54:30 +0900</div><div class="message__header">fumieval</div><div class="message__body">私もなぜ正格なBuilderを提供しないのか、実はよくわかっていません。標準のBuilderは特別効率がよいとは言えないです…</div></div><div class="message" id="message-1524410845.000047"><div class="message__timestamp">2018-04-23<br/>00:27:25 +0900</div><div class="message__header">fujiyan18</div><div class="message__body">正格版があったほうがパフォーマンス的に有難い気もするのですが、<br/>パフォーマンス気にするならそもそもBuilder以外の方法を使いましょう、<br/>みたいな方針なのですかね…<br/><br/>ご回答ありがとうございました</div></div><div class="message" id="message-1524436360.000067"><div class="message__timestamp">2018-04-23<br/>07:32:40 +0900</div><div class="message__header">igrep</div><div class="message__body">多分大きな文字列を組み立てる前提だから、正格に結合するとメモリー消費量がすごく大きくなってしまうという想定でやってるんじゃないっすかね。</div></div><div class="message" id="message-1524440609.000131"><div class="message__timestamp">2018-04-23<br/>08:43:29 +0900</div><div class="message__header">fujiyan18</div><div class="message__body">扱う文字列の大きさが、(Lazyな)Builderを使うかの判断基準にはなりそうですね<br/>ありがとうございます！</div></div><div class="message" id="message-1524448493.000059"><div class="message__timestamp">2018-04-23<br/>10:54:53 +0900</div><div class="message__header">nakaji-dayo</div><div class="message__body">HDBC-mysqlで、ブロックが発生するクエリを実行した際に、他のスレッドが停止してしまい困っています。<br/>対処方法などご存知の方いたら教えて下さい。<br/>（HDBCというより、ffiで一般的な話な気もしますが、調べてもわからず、、）<br/><pre>
module Main where

import Control.Monad
import Database.HDBC
import Database.HDBC.MySQL
import Control.Concurrent

main = do
  forkIO $ do  -- quickQuery'でブロックが発生した時点で処理がとまる
    forM_ [0..10] $ \i -&gt; do
      print i
      threadDelay $ 1000*1000
  conn &lt;- connectMySQL defaultMySQLConnectInfo {  } 
  withTransaction conn $ \c -&gt; do
    quickQuery' c "select * from hoge where id = 1 for update" [] -- 別途ロックしてから実行
  threadDelay $ 10000*1000
</pre><br/><br/><pre>
ghc-options:         -threaded -rtsopts -with-rtsopts=-N -eventlog
</pre></div></div><div class="message" id="message-1524450277.000049"><div class="message__timestamp">2018-04-23<br/>11:24:37 +0900</div><div class="message__header">maoe</div><div class="message__body">ブロックする可能性のある関数をunsafe ffiで呼び出しているのが原因だと思います。ライブラリ側でsafe ffiに直すか別のパッケージを使う以外方法はないと思います。</div></div><div class="message" id="message-1524450800.000048"><div class="message__timestamp">2018-04-23<br/>11:33:20 +0900</div><div class="message__header">maoe</div><div class="message__body">mysqlパッケージの話ですが、基本的に同じなのでここを読むとわかりやすいかと思います。 <br/><a href='https://ro-che.info/articles/2015-04-17-safe-concurrent-mysql-haskell'>https://ro-che.info/articles/2015-04-17-safe-concurrent-mysql-haskell</a></div></div><div class="message" id="message-1524451585.000043"><div class="message__timestamp">2018-04-23<br/>11:46:25 +0900</div><div class="message__header">maoe</div><div class="message__body">ベンチを取ってないので断言はできませんが、入力が短ければtoLazyTextによって作られるlazy textもsingletonになってtoStrictもコピーしないのでそれほど非効率にならないのではないかと思いました。</div></div><div class="message" id="message-1524480539.000339"><div class="message__timestamp">2018-04-23<br/>19:48:59 +0900</div><div class="message__header">fujiyan18</div><div class="message__body">リプライありがとうございます。<br/>Builderがちょっとしたアプリでも使えそうな感じですが、<br/>一般的にもBuilferは良く使われるものなのでしょうか？<br/>Lazyに変換するのをサボりたくなって、簡単な文字列変換なら、つい敬遠してshowとappendで済ませてしまいます…</div></div><div class="message" id="message-1524486296.000224"><div class="message__timestamp">2018-04-23<br/>21:24:56 +0900</div><div class="message__header">maoe</div><div class="message__body">ケースバイケースじゃないかと思います。時間、空間効率に問題がなければimportも少なくて済むpack.showが楽でしょうし、効率も気になるならBuilderが良いのではないかと思います。Stringは非常に富豪的なデータ構造なので、それが問題になるかを考えれば自ずと決まるのではないかと。</div></div><div class="message" id="message-1524486809.000009"><div class="message__timestamp">2018-04-23<br/>21:33:29 +0900</div><div class="message__header">fujiyan18</div><div class="message__body">皆様のお話でBuilderという選択肢が得られて勉強になりました。<br/>いろいろなご意見ありがとうございました！</div></div><div class="message" id="message-1524487406.000335"><div class="message__timestamp">2018-04-23<br/>21:43:26 +0900</div><div class="message__header">maoe</div><div class="message__body">HLearnはたしかsubhaskと併せて野心的なプロジェクトだったんですが、作者が自分の考える最高のコードを書くには、まだGHCが機能不足だという結論にいたって開発が止まったという話だった気がします。</div></div><div class="message" id="message-1524487459.000212"><div class="message__timestamp">2018-04-23<br/>21:44:19 +0900</div><div class="message__header">maoe</div><div class="message__body">結局今はPythonを使ってるとredditかどこかで見かけた気がします</div></div><div class="message" id="message-1524487641.000463"><div class="message__timestamp">2018-04-23<br/>21:47:21 +0900</div><div class="message__header">maoe</div><div class="message__body"><a href='http://www.datahaskell.org/docs//community/current-environment.html#machine-learning'>http://www.datahaskell.org/docs//community/current-environment.html#machine-learning</a> dataHaskellというコミュニティがライブラリの情報をまとめています</div></div><div class="message" id="message-1524549790.000338"><div class="message__timestamp">2018-04-24<br/>15:03:10 +0900</div><div class="message__header">brackss1</div><div class="message__body">ありがとうございます</div></div><div class="message" id="message-1524635726.000256"><div class="message__timestamp">2018-04-25<br/>14:55:26 +0900</div><div class="message__header">cosmiafu</div><div class="message__body">@cosmiafu has joined the channel</div></div><div class="message" id="message-1524635816.000134"><div class="message__timestamp">2018-04-25<br/>14:56:56 +0900</div><div class="message__header">cosmiafu</div><div class="message__body">Algebraのことなら、個人的にArtinの本をお勧め<br/><a href='https://www.amazon.co.jp/Algebra-Classic-Classics-Advanced-Mathematics/dp/0134689607'>https://www.amazon.co.jp/Algebra-Classic-Classics-Advanced-Mathematics/dp/0134689607</a></div></div><div class="message" id="message-1524638935.000310"><div class="message__timestamp">2018-04-25<br/>15:48:55 +0900</div><div class="message__header">brackss1</div><div class="message__body">高いですねw</div></div><div class="message" id="message-1524665291.000248"><div class="message__timestamp">2018-04-25<br/>23:08:11 +0900</div><div class="message__header">nakaji-dayo</div><div class="message__body">@maoe ありがとうございます！<br/>原因と対応方法まで理解できました。</div></div><div class="message" id="message-1524704315.000063"><div class="message__timestamp">2018-04-26<br/>09:58:35 +0900</div><div class="message__header">ttsurutani</div><div class="message__body">大変抽象的な聞き方で申し訳ないのですが。ソースコードを入力にコード規約のような複数のチェックを実施して、その結果を全て返すというような処理を書くとき、haskellの場合どのような書き方をするのが王道なのでしょう。</div></div><div class="message" id="message-1524704328.000069"><div class="message__timestamp">2018-04-26<br/>09:58:48 +0900</div><div class="message__header">igrep</div><div class="message__body">まだ詳しく調べ切れてないのですが、heterogeneous listの実装ってなにがおすすめですか？</div></div><div class="message" id="message-1524704616.000198"><div class="message__timestamp">2018-04-26<br/>10:03:36 +0900</div><div class="message__header">igrep</div><div class="message__body">いまいち何が懸念なのかわかりませんが、<br/>その要件だけ聞いてざっくり設計するなら:point_down: な型の関数を書きますかね。。。<br/><pre>
type SourceCode = Text

data AST = {- ソースコードのASTを表す型 -}

data AnalysisResult = {- ... 解析結果を表す型 -}

parse :: FilePath -&gt; SourceCode -&gt; AST

analyze :: AST -&gt; [AnalysisResult]
</pre></div></div><div class="message" id="message-1524706881.000122"><div class="message__timestamp">2018-04-26<br/>10:41:21 +0900</div><div class="message__header">ttsurutani</div><div class="message__body">すみません。具体的な懸念があるということではなく純粋にどういう形になるのが一般的なのかと思いまして。<br/><br/>いただいた例ではテキストを抽象構文木に変換したのちに解析して最終的に解析結果のリストを返すということですね。いまひとつ具体的なイメージがわかないのはanalyze関数の部分です。チェックの内容にもよると思うのですが、複数のチェックを実施する場合、チェックの都度ASTを頭から舐めなおすことになるのかなと。<br/><br/>単純化するためにチェックの内容を特定のインストラクションが含まれているとして、”A"がある・”B"がある・”C"があるの３つのチェックをする場合、ASTに"A"が含まれるか→結果を結果リストに追加→ASTに”B"が・・・→結果リストを戻すというような実装になるのか、それともASTを頭から葉まで一回舐めていくうちに結果を貯めていくような方法とするのか、それらを混在させるのか。<br/>毎回舐めなおすのはどんなチェックにも対応できそうですが効率が悪いですし、一方舐めるのを一回で済ませようとしても必ずバックトラックが必要なタイプのチェックもあるように思いますし。<br/>単にOK・NGを返す、もしくは最初にエラーとなった内容を返すだけなら個々のチェックを実施するパーサを連結すればできそうだなというイメージはあるのですが、全てを返す方法がイメージできていません。<br/>「単一の入力に対して複数のチェックを実施して、その結果を全て返却する」というような処理は私の仕事では頻出のパターンでして、比較的一般的な処理だと思いましたので、良く知られたオーソドックスな方法があるのかも？と思った次第です。全体的に分かりにくくて申し訳ありません。</div></div><div class="message" id="message-1524709134.000250"><div class="message__timestamp">2018-04-26<br/>11:18:54 +0900</div><div class="message__header">igrep</div><div class="message__body">もちろん一般論としてなるべくバックトラックが少ない方が効率的なのは間違いないでしょうし、その辺はやってみないとなんとも。。。という感じです。幸いhlintをはじめその手のHaskell製ツールはたくさんOSSで存在するので、読んでみるといいかもしれません。</div></div><div class="message" id="message-1524709428.000213"><div class="message__timestamp">2018-04-26<br/>11:23:48 +0900</div><div class="message__header">igrep</div><div class="message__body">ぱっと思いつくのは、Haskellのソースコードで言えば、「module単位で行うチェック」、「関数単位で行うチェック」、「型宣言に対して行うチェック」、「式に対して行うチェック」みたいにあらかじめ分類しておいた上で、各単位の頭から都度処理する、みたいなやり方ですかねぇ。<br/><br/>式単位だと当然入れ子になる式が出てくるでしょうから、お話はまだ複雑になりますけども。</div></div><div class="message" id="message-1524780637.000404"><div class="message__timestamp">2018-04-27<br/>07:10:37 +0900</div><div class="message__header">hs.ioling.hs</div><div class="message__body">コマンドライン引数のオプションの解析、自分で書いたことはありますが「車輪の再発明やめよう」ということでライブラリを使おうと思い調べてみたところ、かなり候補が出てきたのですが、オススメとか避けるべきとかってありますかね<br/><a href='https://wiki.haskell.org/Command_line_option_parsers'>https://wiki.haskell.org/Command_line_option_parsers</a></div></div><div class="message" id="message-1524781311.000159"><div class="message__timestamp">2018-04-27<br/>07:21:51 +0900</div><div class="message__header">igrep</div><div class="message__body">ほかとの比較はしたことないですが、optparse-applicativeはよく使われているイメージです。</div></div><div class="message" id="message-1524791060.000198"><div class="message__timestamp">2018-04-27<br/>10:04:20 +0900</div><div class="message__header">msakai</div><div class="message__body">自分も最近は optparse-applicative をよく使ってます。 ただ、これが理想かというとう～ん……</div></div><div class="message" id="message-1524794841.000017"><div class="message__timestamp">2018-04-27<br/>11:07:21 +0900</div><div class="message__header">fumieval</div><div class="message__body">extensible以外のものをお探しでしょうか？</div></div><div class="message" id="message-1524794959.000159"><div class="message__timestamp">2018-04-27<br/>11:09:19 +0900</div><div class="message__header">msakai</div><div class="message__body"><a href='http://hackage.haskell.org/package/HList'>http://hackage.haskell.org/package/HList</a> ?</div></div><div class="message" id="message-1524796946.000217"><div class="message__timestamp">2018-04-27<br/>11:42:26 +0900</div><div class="message__header">igrep</div><div class="message__body">そうですね、extensibleも（もちろんいにしえのHListも）含めて見てみます。</div></div><div class="message" id="message-1524797413.000182"><div class="message__timestamp">2018-04-27<br/>11:50:13 +0900</div><div class="message__header">igrep</div><div class="message__body">この際なのでついでにfumiさんに伺いたいのですが、OverloadedLabelsをextensibleに応用した、<br/><a href='https://hackage.haskell.org/package/extensible-0.4.8/docs/Data-Extensible-Label.html'>https://hackage.haskell.org/package/extensible-0.4.8/docs/Data-Extensible-Label.html</a><br/>を使った場合、どんな使用方法になるのでしょうか？</div></div><div class="message" id="message-1524797600.000180"><div class="message__timestamp">2018-04-27<br/>11:53:20 +0900</div><div class="message__header">igrep</div><div class="message__body">もしかして、<br/><a href='https://www.schoolofhaskell.com/user/fumieval/extensible/extensible-records'>https://www.schoolofhaskell.com/user/fumieval/extensible/extensible-records</a><br/>の<br/><pre>
mkField "name collective cry"
</pre><br/>の箇所がなくなって<br/><pre>dove :: Animal
dove = #name @= "dove"
  &lt;: #collective @= "dule"
  &lt;: #cry @= Just "coo"
  &lt;: Nil
</pre><br/>みたいに書けるイメージですかね。</div></div><div class="message" id="message-1524797633.000054"><div class="message__timestamp">2018-04-27<br/>11:53:53 +0900</div><div class="message__header">fumieval</div><div class="message__body">はい、従来はTemplate Haskellで生成したものをラベル記法にそのまま置き換えることができます</div></div><div class="message" id="message-1524804784.000089"><div class="message__timestamp">2018-04-27<br/>13:53:04 +0900</div><div class="message__header">lesguillemets</div><div class="message__body">リストにないですが tanakh さんの optparse-declarative はそこそこ楽できた覚えがあります</div></div><div class="message" id="message-1524806263.000227"><div class="message__timestamp">2018-04-27<br/>14:17:43 +0900</div><div class="message__header">igrep</div><div class="message__body">選択肢を増やすようで申し訳ないですが、optparse-applicativeに対抗されて作られたalternativeです。<br/>上記のwikiにも載っていません。<br/><a href='https://github.com/lspitzner/butcher'>https://github.com/lspitzner/butcher</a></div></div><div class="message" id="message-1524876327.000156"><div class="message__timestamp">2018-04-28<br/>09:45:27 +0900</div><div class="message__header">nobsun</div><div class="message__body">stack new でテンプレートを指定しなかったときデフォルトで使われるファイルを new-template 以外のカスタムテンプレートを使うように簡便に指定できないものでしょうか．</div></div><div class="message" id="message-1524892676.000118"><div class="message__timestamp">2018-04-28<br/>14:17:56 +0900</div><div class="message__header">mizunashi-mana</div><div class="message__body">globalのconfig.yamlでdefault-templateを指定すればできるはずです<br/><a href='https://docs.haskellstack.org/en/latest/yaml_configuration/#default-template'>https://docs.haskellstack.org/en/latest/yaml_configuration/#default-template</a></div></div><div class="message" id="message-1525006040.000091"><div class="message__timestamp">2018-04-29<br/>21:47:20 +0900</div><div class="message__header">nobsun</div><div class="message__body">できました．ありがとうございます:pray:</div></div><div class="message" id="message-1525184336.000503"><div class="message__timestamp">2018-05-01<br/>23:18:56 +0900</div><div class="message__header">ncaq</div><div class="message__body">package.yaml or cabalで,stack testを実行した時に特定のプリプロセッサフラグを有効にする方法は無いでしょうか?<br/>DEVELOPMENTフラグを有効化してテスト時のみYesod.Auth.Dummyを読み込ませたいのですが…<br/>一々stack test --flag application:devとタイプするしか無いのでしょうか<br/>サンプルを見るとtest以下にcpp-options: -DDEVELOPMENTと書けば良いように見えたのですが,どうもそうではないっぽい</div></div><div class="message" id="message-1525192222.000354"><div class="message__timestamp">2018-05-02<br/>01:30:22 +0900</div><div class="message__header">as_capabl</div><div class="message__body">-Dオプションはパッケージ単位でしか効かなかった気がします(未確認)</div></div><div class="message" id="message-1525192346.000566"><div class="message__timestamp">2018-05-02<br/>01:32:26 +0900</div><div class="message__header">as_capabl</div><div class="message__body"><a href='https://github.com/haskell/cabal/issues/2821'>https://github.com/haskell/cabal/issues/2821</a> これが使えれば、テストスイートからだけフラグを有効にする、という事が可能かと思われますが、採用されるか分からない感じですね</div></div><div class="message" id="message-1525224759.000259"><div class="message__timestamp">2018-05-02<br/>10:32:39 +0900</div><div class="message__header">kayhide</div><div class="message__body">なるほど、 cabal の flag はソースコード中でそのようにして参照できるのですね。<br/>やってみます！</div></div><div class="message" id="message-1525326102.000154"><div class="message__timestamp">2018-05-03<br/>14:41:42 +0900</div><div class="message__header">ncaq</div><div class="message__body">ああなるほどそれが議論されているということは普通では無理ということでしょうね<br/>外部パッケージのためだけかと思ってました</div></div><div class="message" id="message-1525388436.000427"><div class="message__timestamp">2018-05-04<br/>08:00:36 +0900</div><div class="message__header">maoe</div><div class="message__body">yesod界隈では{fast,monad}-loggerが使われていますが、一般的にロガーを自分で選択するときは何を使っていますか？</div></div></div><div class="pager"><a href="/html/C5666B6BB/18.html" class="pager__previous">Previous</a><a href="/" class="pager__top">Top</a><a href="/html/C5666B6BB/20.html" class="pager__next">Next</a></div></body></html>