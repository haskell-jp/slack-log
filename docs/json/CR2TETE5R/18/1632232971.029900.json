[
    {
        "ts": "1632232971.029900",
        "text": "<@UGM9F7XQS> <@UL1HFJATE> もしくは他の方でも構いません\n「Haskellで戦う競技プログラミング」でプリミティブ型についての説明をされている部分があったのですがいまいちピンとこなかったので質問させてください。\n以下第4章 P.33より抜粋\n&gt;  ここでの「プリミティブ型」という言い方は便宜的なものです。GHC 的にはプリミティブ型と言った\n&gt; ら GHC.Prim で定義されている unboxed 型のことでしょうが、ここでは「GHC の unboxed 型を\n&gt; ラップした型」程度の意味です。\n「GHC的にはプリミティブ型といったらGHC.Primで定義されているunboxed型」と「GHC の unboxed 型をラップした型」これらの文が理解できませんでした。\nGHC.Primが何のモジュールなのかもHackage見ただけではイマイチ理解できないレベルです。ざっくりとでも構いません、以上の文を噛み砕いていただけると助かります",
        "user": "U024U0DCJ3T",
        "type": "message"
    },
    {
        "ts": "1632234325.041600",
        "text": "GHC の基本ライブラリって `ghc-prim` の上に `base` が乗っかってる、みたいな構造をしてて、 `ghc-prim` には「GHC内部で定義された、実際には Haskell で実装が書かれてない型や関数」があり、 `base` でそれらを簡単に呼び出すためのラッパーが定義されています。\n\n```-- in ghc-prim\ndata Int#\n-- コード上では Void 型(発散値(エラーとか無限ループとか)以外を持たない型)と同等に定義されるが、GHCがGHC内部の定義に読み替える```\n```-- in base\ndata Int = I# Int#```\nみたいなことになっています。`GHC.Prim` は `ghc-prim` のモジュールですね。この `Int#` をプリミティブ型と呼ぶのが良いのだろうが、この場合 `Int` をそう呼んでいる、と言うことです。「unboxed」という言葉を除けばこれで説明し切れてるんではないだろうか。",
        "user": "UL1HFJATE",
        "type": "message"
    },
    {
        "ts": "1632234535.045200",
        "text": "unboxedを説明する前に `#` について注意しておくと、 `#` は演算子を表す記号ではなく、 `Int#` で一個の名前です。\n\n```{-# LANGUAGE MagicHash #-}```\nで、英数字名の識別子の後ろに `#` をくっつけても識別子とみなされるようになります。",
        "user": "UL1HFJATE",
        "type": "message"
    },
    {
        "ts": "1632234813.047700",
        "text": "unboxed は、ちゃんと説明しようとすると「ヒープ」、「スタック」、「ポインタ」、「サンク」くらいの用語を使うのですが、聞いたことあります？",
        "user": "UL1HFJATE",
        "type": "message"
    },
    {
        "ts": "1632235097.047900",
        "text": "そこらへんの用語は問題なく使用していただいて大丈夫です",
        "user": "U024U0DCJ3T",
        "type": "message"
    },
    {
        "ts": "1632235394.052900",
        "text": "boxedは大まかにいって「いつ何時でも実体がヒープにあることが強制されており、その値は必ず実体へのポインタとして表現される」型のことです。このboxedは型がliftedである（発散値を値として持つ≒値の実体がサンクでありうる）ための必要条件ですね、多分",
        "user": "UL1HFJATE",
        "type": "message"
    },
    {
        "ts": "1632235674.057400",
        "text": "unboxedはこの否定をとって得られます。典型的には（多分全てかな?）値が格納されているところにそのまま実体があります。だから `Int#` はヒープに居てもスタックに居てもよくて、まんま32bitsか64bitsの符号付き整数を表すビットパターンです。",
        "user": "UL1HFJATE",
        "type": "message"
    },
    {
        "ts": "1632235972.063300",
        "text": "`data Int = I# Int#` がスタックに居るとしてもヒープに居るとしても、`Int` の値が居るところには整数そのものを表すビットパターンはいなくて、ただヒープへのポインタだけがあります。そのポインタはサンクを指しているかもしれないし、2wordの構造体を指しているかもしれないです。後者の場合、`I#` を表すタグであるワードと、整数そのものを表すビットパターン(`Int#`)であるワードからなる構造体です。",
        "user": "UL1HFJATE",
        "type": "message"
    },
    {
        "ts": "1632236086.065400",
        "text": "一方で、`Int#` は、スタックに居ようとヒープに居ようと、1word分のビットパターンがそこにあります。",
        "user": "UL1HFJATE",
        "type": "message"
    },
    {
        "ts": "1632236663.066400",
        "text": "「値」という用語に混乱が見られるので、どうか真似しないでください",
        "user": "UL1HFJATE",
        "type": "message"
    },
    {
        "ts": "1632267971.077700",
        "text": "む、難しいですね……\nなんとか理解したいと思います\nご丁寧にありがとうございました",
        "user": "U024U0DCJ3T",
        "type": "message"
    },
    {
        "ts": "1632274916.078000",
        "text": "無関係な話題も多いですが <https://haskell.jp/blog/posts/2017/13-about-kind-system-part2.html> の「型の分類」の節が参考になるかと思います。",
        "user": "U4LGTMTMK",
        "type": "message"
    },
    {
        "ts": "1632277969.078300",
        "text": "<@U4LGTMTMK> ありがとうございます！読んでみます！",
        "user": "U024U0DCJ3T",
        "type": "message"
    },
    {
        "ts": "1634559910.132800",
        "text": "今更ですが、boxed typeとはC--に直した時に `void *` になる型のことで、そのうちlifted typeとはその `void *` がthunkを指しうる型のこと、とか説明したらいい気がしてきました",
        "user": "UL1HFJATE",
        "type": "message"
    }
]