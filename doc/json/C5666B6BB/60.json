[
    {
        "ts": "1558658628.093400",
        "text": "こんにちは。型クラスについて質問です。\nInt64をラップしたMyNumberという型をつくりました。\nこの型について、以下のような操作を定義したいのですが、どうもうまくいきません。そもそもこのようなことが可能なのか、可能であればどうしたらよいのか、ぜひ教えてください。\n\nやりたいこと：\n- 許可：MyNumber 同士の 足し算、引き算\n- 許可：MyNumber の整数倍\n- 許可：MyNumber 同士の大小比較\n- 不許可： MyNumber と整数の足し算、引き算\n- 不許可：MyNumberと 整数の大小比較\n- 不許可：MyNumber同士の掛け算。\n\n不許可については、コンパイル時にエラーとなるのが理想です。\n\nこんな感じで書き進めてみたものの、なにか根本的に違うような気がしています。\n作戦として、MyNumberをNumやOrdのインスタンスにして、不許可の操作を実装しない、もしくは何らかの方法でコンパイルエラーにする、ということを考えました。\n\n```haskell\nmodule Main where\n\nimport qualified <http://GHC.Int|GHC.Int> as GI (Int64)\n\nnewtype MyNumber = MyNumber { getNumber::GI.Int64} deriving(Eq, Show)\ninstance Num MyNumber where\n    (+) (MyNumber x) (MyNumber y) = MyNumber $ x + y\n    -- (*) _ _ = undefined -- not sure how to achieve \"MyNumber 150 * 2\"\n    -- fromInteger x = undefined -- to avoid comparison against Num\n\ninstance Ord MyNumber where\n    (&lt;=) (MyNumber x) (MyNumber y) = x &lt;= y\n\nmain :: IO ()\nmain = do\n    putStrLn $ (++) \"Allow MyNumber + MyNumber : \" $ show $ MyNumber 100 + MyNumber 200 == MyNumber 300\n    putStrLn $ (++) \"Allow MyNumber &gt; MyNumber : \" $ show $ MyNumber 330 &gt; MyNumber 100 -- not detected by compiler\n    putStrLn $ (++) \"Allow MyNumber * Integer :\" $ show $ (MyNumber 150) * 2  -- show can I do this?\n    putStrLn $ (++) \"Don't allow MyNumber &gt; Integger : \" $ show $ (MyNumber 330) &gt; 100 -- not detected by compiler\n    putStrLn $ (++) \"Don't allow MyNumber * MyNumber : \" $ show $ (MyNumber 330) * (MyNumber 100) -- not detected by compiler?\n```",
        "user": "U7GSVRQ6S",
        "type": "message"
    },
    {
        "ts": "1558659783.093500",
        "text": "```\n1. 許可：MyNumber 同士の 足し算、引き算\n2. 許可：MyNumber の整数倍\n3. 許可：MyNumber 同士の大小比較\n4. 不許可： MyNumber と整数の足し算、引き算\n5. 不許可：MyNumberと 整数の大小比較\n6. 不許可：MyNumber同士の掛け算。\n```\n便宜上ナンバリング。\n`Num a` 型クラスは型 `a` 同士の足し算 `(+)` と掛け算 `(*)` を両方定義する必要があるので、その方針( `Num` のインスタンスにする)で 1 と 6 を実現することはできないです。",
        "user": "U56L7EVNY",
        "type": "message"
    },
    {
        "ts": "1558659954.093700",
        "text": "まぁ方法としては\n(1) 足し算だけの型クラス `Add a` なんかを独自で定義する\n(2) 足し算を `Monoid a` 型クラスかなんかで定義する(演算子が `(&lt;&gt;)` に変わってしまうが)\n\nがあるかなぁ。。。",
        "user": "U56L7EVNY",
        "type": "message"
    },
    {
        "ts": "1558664779.094100",
        "text": "演算子の見かけにこだわりたいのであれば、カスタムPreludeを作って(+)や(-)を上書きすればいいでしょうね。\n（やり過ぎ感は否めませんが…）\n<https://haskell.e-bigmoon.com/posts/2018/05-23-extended-prelude.html>",
        "user": "U4LGTMTMK",
        "type": "message"
    },
    {
        "ts": "1558666437.094500",
        "text": "<http://hackage.haskell.org/package/vector-space> 演算子は変わりますがvector-space を使ってみてはどうでしょうか？まさに加算とスカラー倍のためのインターフェイスです",
        "user": "U4KUNQF9N",
        "type": "message"
    },
    {
        "ts": "1558693882.000400",
        "text": "Numに全部ぶちこんだのはHaskellの初期設計過ち四天王に入りそうで入らなさそう",
        "user": "U57CUMWQ6",
        "type": "message"
    },
    {
        "ts": "1558758303.000700",
        "text": "Numeric Prelude ってどうなんですか？",
        "user": "U6JPU2DD2",
        "type": "message"
    },
    {
        "ts": "1558963421.001100",
        "text": "<@UJPKD2R2P> has joined the channel",
        "user": "UJPKD2R2P",
        "type": "message"
    },
    {
        "ts": "1559009020.001400",
        "text": "<@UJQ0WEJG2> has joined the channel",
        "user": "UJQ0WEJG2",
        "type": "message"
    },
    {
        "ts": "1559011117.003200",
        "text": "Haskellで｢送られてきたメールアドレスの少なくともドメインがメールサーバとして成立しているかどうか(DNSでMXもしくはAもしくはAAAAを持つか)｣どうか調べる必要があって,汎用性があるからOSSにしようかと思ってるのですが既出なら教えてください\n後DNS周りで楽に取れるやつが欲しい…パフォーマンス気にしなければ <http://hackage.haskell.org/package/resolv-0.1.1.2/docs/Network-DNS.html> で良いんですが…いや別に気にしなくても良いのか",
        "user": "U57CUMWQ6",
        "type": "message"
    },
    {
        "ts": "1559011160.003300",
        "text": "いやパフォーマンスの問題ではなく使い勝手の問題ですねこれは",
        "user": "U57CUMWQ6",
        "type": "message"
    },
    {
        "ts": "1559017840.006300",
        "text": "&gt; which is why we recommend using `try` rather than `catch` for ordinary exception recovery.\n&gt; <https://www.stackage.org/haddock/lts-13.23/base-4.12.0.0/Control-Exception.html#g:3>\nとあるので `try` の方を使うかという気持ちなんですが、複数の型の例外を捕捉したいとき何かイディオムあるんですかね？\nつまり `catch` ならこう ↓ なるケース（ `catches` を使ってもいい）\n```\nprint $ (head []) `div` (0 :: Int)\n  `catch` (\\e -&gt; putStrLn $ \"arith \" &lt;&gt; displayException (e :: ArithException))\n  `catch` (\\e -&gt; putStrLn $ \"some \" &lt;&gt; displayException (e :: SomeException))\n```\n`try` でベタで書くとこうなる\n```\ndo\n  v &lt;- try $ do\n    v &lt;- try $ print $ (head []) `div` (0 :: Int)\n    case v of\n      Right _ -&gt; pure ()\n      Left e -&gt; putStrLn $ \"arith \" &lt;&gt; displayException (e :: ArithException)\n  case v of\n    Right _ -&gt; pure ()\n    Left e -&gt; putStrLn $ \"some \" &lt;&gt; displayException (e :: SomeException)\n```\n<https://wandbox.org/permlink/FSlRioZ1EPWcWXjf>",
        "user": "U4L0B71L1",
        "type": "message"
    },
    {
        "ts": "1559018427.006500",
        "text": "dns: DNS library in Haskell - <http://hackage.haskell.org/package/dns> もありますが、使い勝手は似たようなものっぽいですね",
        "user": "U7155GPR9",
        "type": "message"
    },
    {
        "ts": "1559019191.006800",
        "text": "口頭での議論のとおりですが、簡潔に書くなら諦めて `catches` するしかなさそうな気がします。\n\n&gt; which is why we recommend using `try` rather than `catch` for ordinary exception recovery.\n\nの部分ですが、例外処理が十分に軽い処理（非同期例外がmaskされてもすぐに終わる）であれば問題ないでしょうし。",
        "user": "U4LGTMTMK",
        "type": "message"
    },
    {
        "ts": "1559021399.007000",
        "text": "1つのアプリーケーション内なら、直和型を宣言して適宜ラップするとか",
        "user": "U56L7EVNY",
        "type": "message"
    },
    {
        "ts": "1559024673.007300",
        "text": "実際に `try` 関数が `catch` を使ってやっているように、直和型でラップするだけ、というのが正解なんでしょうね\n参考: <https://hackage.haskell.org/package/base-4.12.0.0/docs/src/Control.Exception.Base.html#try>",
        "user": "U4LGTMTMK",
        "type": "message"
    },
    {
        "ts": "1559024850.007500",
        "text": "こんなのはどうでしょう？\n<https://gist.github.com/mizunashi-mana/c2d6b87206e9c1f43046f84b135fd445>\n\nやってることは大体 `catches` と同じです",
        "user": "U57D08Z9U",
        "type": "message"
    },
    {
        "ts": "1559026004.007900",
        "text": "なるほでぃうす",
        "user": "U4L0B71L1",
        "type": "message"
    },
    {
        "ts": "1559118620.008400",
        "text": "<@UJRDL35U3> has joined the channel",
        "user": "UJRDL35U3",
        "type": "message"
    },
    {
        "ts": "1559198752.000200",
        "text": "みなさんありがとうございました。vector-spaceは良さげですね！直接は大小比較をサポートしていない（ベクトルだから当たり前ですが）ので、その部分を手当してあげる必要はありそうです。",
        "user": "U7GSVRQ6S",
        "type": "message"
    },
    {
        "ts": "1559268175.002400",
        "text": "Haskellでデータをファイルに書き出し，読み込みできるようなライブラリはなにがあるでしょうか．\n思い付くのだとAesonを使うしかないのかなと考えています．\nより効率がいいものがあるような気がするのですが，見付けられませんでした．",
        "user": "UH195J82Y",
        "type": "message"
    },
    {
        "ts": "1559270297.002900",
        "text": "シリアライズライブラリという認識でよろしいでしょうか．\nこちらの方で有志の方々がシリアライズのパフォーマンス比較をなさっておられるので参考になると思います．\n<https://scrapbox.io/haskell-shoen/シリアライズ>",
        "user": "U59GW4U4T",
        "type": "message"
    },
    {
        "ts": "1559272495.003300",
        "text": "ありがとうございます!\nたすかりました!",
        "user": "UH195J82Y",
        "type": "message"
    },
    {
        "ts": "1559374102.008300",
        "text": "自分で簡単なパーサーを作ろうと思っています。失敗した時の位置情報を出すくらいの機能はつけたいのですが、その実装について述べられているページや基本的なアイディアなとご存知でしたら教えていただければ幸いです（Parsecあたりのソースコードを読め、と言われればそうなんですが……）",
        "user": "U7155GPR9",
        "type": "message"
    },
    {
        "ts": "1559377409.008400",
        "text": "読んでたらなんとなくわかってきたかも……もうちょい自分で頑張ってみます",
        "user": "U7155GPR9",
        "type": "message"
    },
    {
        "ts": "1559385536.008700",
        "text": "「パーサー」ではなく「パーサーコンビネーターライブラリー」ですよね？\nparsecもmegaparsecも読んでませんが、ちょっと思い浮かぶ感じだと、Stateとして現在の位置情報を表すカウンターを持っておいて、1文字進めるごとに +1 する感じですかね。",
        "user": "U4LGTMTMK",
        "type": "message"
    },
    {
        "ts": "1559391832.009000",
        "text": "Text.Parser.Pos に SourcePos というのがあって、 `getPosition :: Monad m =&gt; ParsecT s u m SourcePos` でいつでも取得できます。 igrep さんがいうようなメンテナンスは、 `setPosition :: Monad m =&gt; SourcePos -&gt; ParsecT s u m ()` でやることができるのですが、 Text.Parser.Char に含まれてるようなコンビネータはもともと一文字単位でいい感じに setPosition してるのだと思うので、自分で書く必要はほとんどないのでは、と思います",
        "user": "UF8SE896V",
        "type": "message"
    },
    {
        "ts": "1559391962.009200",
        "text": "あとは、 AST に SourcePos の情報を混ぜ込んで扱うのが吉だと思います。 <https://qiita.com/Mizunashi_Mana/items/115855bf2af9b9970198> 個々の例だと AST に a の穴をあけておいてそこに SourcePos をいれていますね",
        "user": "UF8SE896V",
        "type": "message"
    },
    {
        "ts": "1559392081.009500",
        "text": "ちなみにガチの AST の例として LLVM の C++ フロントエンドである Clang の AST をみてると、 AST に対応するソースコード位置の情報を「その AST に対応する部分の先頭位置・終了位置・代表的な位置（エラーメッセージにつけるのにもっともよさげな位置）」と三種類ぐらい持っていた気がします。そこまでやらないとあの親切なエラーメッセージは出せないんだなあ、っていう感じでした",
        "user": "UF8SE896V",
        "type": "message"
    },
    {
        "ts": "1559392257.009700",
        "text": "あ、ひょっとしてパーサコンビネータライブラリを作る、っていうもう一個メタな話をしていらっしゃるんでしたら、釈迦に説法でしたか…^^;;",
        "user": "UF8SE896V",
        "type": "message"
    },
    {
        "ts": "1559392364.009900",
        "text": "もし、パーサコンビネータに頼らずにパーサを書くとなると、結局「1文字パースするたびにアップデートする基礎の層」を作ってそれをメンテナンスできる State をもっておいて、適宜 get しておくようにしつつ、結局は AST に混ぜ込むようにするという話になって、それは AST を設計する際に考えましょうっていう話になると思います。",
        "user": "UF8SE896V",
        "type": "message"
    },
    {
        "ts": "1559406646.011000",
        "text": "<@UK8LM56K0> has joined the channel",
        "user": "UK8LM56K0",
        "type": "message"
    }
]