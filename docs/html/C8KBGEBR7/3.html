<!DOCTYPE html><html><head><meta charset="utf-8"><title>haskell-jp / C8KBGEBR7 #3</title><link rel="stylesheet" href="/messages.css" type="text/css" media="screen"></head><body><h1>haskell-jp / C8KBGEBR7 #3</h1><div class="pager"><a href="/html/C8KBGEBR7/2.html" class="pager__previous">Previous</a><a href="/" class="pager__top">Top</a><a href="/html/C8KBGEBR7/4.html" class="pager__next">Next</a></div><div class="message_list"><div class="message" id="message-1519046529.000403"><div class="message__timestamp">2018-02-19<br/>22:22:09 +0900</div><div class="message__header">mizunashi-mana</div><div class="message__body">VoQnさんので言うと， <a href='https://github.com/VoQn/cacco/blob/master/src/Cacco/Ann.hs#L21'>https://github.com/VoQn/cacco/blob/master/src/Cacco/Ann.hs#L21</a> がまさにCofreeですね．(Indexed Fixはまだ導入してなさそう？)</div></div><div class="message" id="message-1519091019.000057"><div class="message__timestamp">2018-02-20<br/>10:43:39 +0900</div><div class="message__header">voqn.tyrant</div><div class="message__body">Ix＊ はまだ組み入れてないですね。ラムダ式や関数宣言とかの、AST内部の小分類が必要になってきたら組み込んでく予定です</div></div><div class="message" id="message-1519100550.000080"><div class="message__timestamp">2018-02-20<br/>13:22:30 +0900</div><div class="message__header">takohati0821</div><div class="message__body">@takohati0821 has joined the channel</div></div><div class="message" id="message-1519124416.000220"><div class="message__timestamp">2018-02-20<br/>20:00:16 +0900</div><div class="message__header">fumieval</div><div class="message__body">あれは閉じた型族などがなかった時代の苦肉の策なので、今では型レベルリストと型族を活用すれば簡単に実現できます。 extensibleも型族を使っています <a href='http://hackage.haskell.org/package/extensible-0.4.7.1/docs/Data-Extensible-Sum.html'>http://hackage.haskell.org/package/extensible-0.4.7.1/docs/Data-Extensible-Sum.html</a></div></div><div class="message" id="message-1519125117.000205"><div class="message__timestamp">2018-02-20<br/>20:11:57 +0900</div><div class="message__header">mizunashi-mana</div><div class="message__body">型レベルリストってopen unionとかと同じように，sumするやつをリストに突っ込んでおいて，injectする時型レベルのmemberをするやつですか？あんまりよく知らないんですけど，それってかなりコンパイル時間がかかったり，型エラーがえぐくなったりしないですか？</div></div><div class="message" id="message-1519125461.000111"><div class="message__timestamp">2018-02-20<br/>20:17:41 +0900</div><div class="message__header">fumieval</div><div class="message__body">実装が悪いとそうなりますが、extensibleは速いという評判を頂いています。ただ要素数が200くらいになってくるとコンパイルが遅くなる感じがあります。</div></div><div class="message" id="message-1519126577.000089"><div class="message__timestamp">2018-02-20<br/>20:36:17 +0900</div><div class="message__header">mizunashi-mana</div><div class="message__body">なるほど，実装見てみます．ありがとうございます．</div></div><div class="message" id="message-1519615487.000016"><div class="message__timestamp">2018-02-26<br/>12:24:47 +0900</div><div class="message__header">voqn.tyrant</div><div class="message__body"><a href='https://github.com/VoQn/cacco/blob/master/src/Cacco/Syntax/Parser/AST.hs'>https://github.com/VoQn/cacco/blob/master/src/Cacco/Syntax/Parser/AST.hs</a><br/>IxFIx を導入したASTのパーサが一応できました（IxCofree をインジェクションするのはまだ出来ていないので、純粋な構文木をパースするようになっています）</div></div><div class="message" id="message-1519705552.000149"><div class="message__timestamp">2018-02-27<br/>13:25:52 +0900</div><div class="message__header">voqn.tyrant</div><div class="message__body">できた</div></div><div class="message" id="message-1519705715.000104"><div class="message__timestamp">2018-02-27<br/>13:28:35 +0900</div><div class="message__header">voqn.tyrant</div><div class="message__body">haskellの好きなところ、書き終わった後に「ぜってぇこれもっといいやり方がある」ってモチベ上がるところですね</div></div><div class="message" id="message-1519709576.000102"><div class="message__timestamp">2018-02-27<br/>14:32:56 +0900</div><div class="message__header">mizunashi-mana</div><div class="message__body">これって，気になったとこ言っていい系なんでしょうか？</div></div><div class="message" id="message-1519709918.000079"><div class="message__timestamp">2018-02-27<br/>14:38:38 +0900</div><div class="message__header">voqn.tyrant</div><div class="message__body">まぁ、 <a href='#C8KBGEBR7'>code-review</a> に貼ったぐらいなので何かアドバイスなり意見が欲しいので大丈夫です</div></div><div class="message" id="message-1519711018.000186"><div class="message__timestamp">2018-02-27<br/>14:56:58 +0900</div><div class="message__header">mizunashi-mana</div><div class="message__body">ここが(おそらくnat transのtype sigを適用できるようにするためだと思うんですが)f i aの順になっていないために，ixを固定した時に既存のFunctorのAPIを使えないのは残念だなと思いました<br/><a href='https://github.com/VoQn/cacco/blob/master/src/Data/IxFix.hs#L76'>https://github.com/VoQn/cacco/blob/master/src/Data/IxFix.hs#L76</a></div></div><div class="message" id="message-1519711320.000014"><div class="message__timestamp">2018-02-27<br/>15:02:00 +0900</div><div class="message__header">mizunashi-mana</div><div class="message__body">後，個人的には <code>UndecidableInstances</code> は避けてる人なので，ちょっと余計なインスタンス宣言が増えますが， <code>deriving (Show (f (Fix f)) =&gt; ...</code> の部分は <code>deriving (Show1 f) =&gt; ...</code> で書く派なので，そこの部分も気になりました</div></div><div class="message" id="message-1519711555.000048"><div class="message__timestamp">2018-02-27<br/>15:05:55 +0900</div><div class="message__header">voqn.tyrant</div><div class="message__body">そうなんですよ。普通のfmapが上手に利用できないというか、評価器を作るところで通常のdoなども利用できないので作りを見直して克服したいところなんです</div></div><div class="message" id="message-1519711619.000238"><div class="message__timestamp">2018-02-27<br/>15:06:59 +0900</div><div class="message__header">voqn.tyrant</div><div class="message__body">あ、いや、たしかに逆にするだけで何とかなる？</div></div><div class="message" id="message-1519711702.000232"><div class="message__timestamp">2018-02-27<br/>15:08:22 +0900</div><div class="message__header">voqn.tyrant</div><div class="message__body">"indexed" なんだから、型の表記的にも i f  と続かせる方が正しいような気もしますね</div></div><div class="message" id="message-1519711708.000041"><div class="message__timestamp">2018-02-27<br/>15:08:28 +0900</div><div class="message__header">mizunashi-mana</div><div class="message__body">多分逆にして， deriving Functor すればいい気がしますね</div></div><div class="message" id="message-1519713828.000099"><div class="message__timestamp">2018-02-27<br/>15:43:48 +0900</div><div class="message__header">mizunashi-mana</div><div class="message__body">後，結構不要なところに <code>UndecidableInstances</code> が入ってる印象があるので，もし拡張のプラグマをコピペしてる感じだったらむしろ，cabalのdefault-extensionsを使って，モジュール別に必要な拡張だけモジュールごとに指定するのがいいかもしれません(<https://www.haskell.org/cabal/users-guide/developing-packages.html#pkg-field-default-extensions>)</div></div><div class="message" id="message-1519715013.000232"><div class="message__timestamp">2018-02-27<br/>16:03:33 +0900</div><div class="message__header">mizunashi-mana</div><div class="message__body">これも好みの問題かもですが，<br/>* <https://github.com/VoQn/cacco/blob/master/src/Cacco/Syntax/AST.hs#L43> -&gt; `Data.Proxy.Proxy`<br/>* <https://github.com/VoQn/cacco/blob/master/src/Data/IxFix.hs#L31> -&gt; `Data.Functor.Const`<br/>* <https://github.com/VoQn/cacco/blob/master/src/Data/IxFix.hs#L35> -&gt; `Data.Functor.Identity`<br/>* <https://github.com/VoQn/cacco/blob/master/src/Cacco/Syntax/Expr.hs#L52> -&gt; `DeriveTraversable` で代用可能<br/>みたいなのを思いました</div></div><div class="message" id="message-1519715168.000214"><div class="message__timestamp">2018-02-27<br/>16:06:08 +0900</div><div class="message__header">mizunashi-mana</div><div class="message__body">それから，一部メッセージを良くunwordsして作ってる印象があったので，<br/>* <https://hackage.haskell.org/package/ansi-wl-pprint-0.6.8.1/docs/Text-PrettyPrint-ANSI-Leijen.html#t:Doc><br/>* <https://hackage.haskell.org/package/pretty-1.1.3.6/docs/Text-PrettyPrint.html#t:Doc><br/>みたいなのと相性が良さそうな気がしました．</div></div><div class="message" id="message-1519717172.000094"><div class="message__timestamp">2018-02-27<br/>16:39:32 +0900</div><div class="message__header">mizunashi-mana</div><div class="message__body">それから，<https://github.com/VoQn/cacco/blob/master/src/Cacco/Syntax/Parser/AST.hs#L131> の部分は， <code>GADTs</code> と <code>ScopedTypeVariables</code> 拡張を加えて，<br/><pre>
astFix :: forall t (i :: AstIx). IxFunctor t =&gt; AstIxProxy i -&gt; AstIxFixParser t i
astFix proxy d e p t = case proxy of
    DeclProxy -&gt; d'
    ExprProxy -&gt; e'
    PattProxy -&gt; p'
    TypeProxy -&gt; t'
  where
    astFix' :: (forall f. AstIxParser t f j) -&gt; Parser (IxFix t j)
    astFix' f = In &lt;$&gt; f d' e' p' t'

    d' = astFix' d
    e' = astFix' e
    p' = astFix' p
    t' = astFix' t
{-# INLINEABLE astFix #-}

located :: forall f (i :: AstIx). AstIxParser AstF f i -&gt; AstIxParser (IxAnnF Location AstF) f i
located f d e p t = IxAnnF &lt;$&gt; withLocation (f d e p t)
{-# INLINE located #-}

astParser :: AstIxProxy i -&gt; Parser (IxAnn Location AstF i)
astParser proxy = astFix proxy
  (located declAstF) (located exprAstF) (located pattAstF) (located typeAstF)

declAst :: Parser (IxAnn Location AstF AstDecl)
declAst = astParser DeclProxy
{-# INLINEABLE declAst #-}

exprAst :: Parser (IxAnn Location AstF AstExpr)
exprAst = astParser ExprProxy
{-# INLINEABLE exprAst #-}

pattAst :: Parser (IxAnn Location AstF AstPatt)
pattAst = astParser PattProxy
{-# INLINEABLE pattAst #-}

typeAst :: Parser (IxAnn Location AstF AstType)
typeAst = astParser TypeProxy
{-# INLINEABLE typeAst #-}
</pre><br/>の感じで書くと，ボイラープレートが増えなくて良いかな？と思いました</div></div><div class="message" id="message-1519718434.000107"><div class="message__timestamp">2018-02-27<br/>17:00:34 +0900</div><div class="message__header">voqn.tyrant</div><div class="message__body">Show1使ったことありませんでした… せっかくtransformers使ってんのに…</div></div><div class="message" id="message-1519719407.000167"><div class="message__timestamp">2018-02-27<br/>17:16:47 +0900</div><div class="message__header">voqn.tyrant</div><div class="message__body">あ、今はbaseに入ったのか…</div></div><div class="message" id="message-1519719786.000150"><div class="message__timestamp">2018-02-27<br/>17:23:06 +0900</div><div class="message__header">mizunashi-mana</div><div class="message__body">はい，baseにあるので気兼ねなく使えますね．GHC 8からいつのまにか，MonadIOとかも入ってました<br/><a href='https://hackage.haskell.org/package/base-4.9.1.0/docs/Control-Monad-IO-Class.html'>https://hackage.haskell.org/package/base-4.9.1.0/docs/Control-Monad-IO-Class.html</a></div></div><div class="message" id="message-1519720511.000094"><div class="message__timestamp">2018-02-27<br/>17:35:11 +0900</div><div class="message__header">voqn.tyrant</div><div class="message__body">書いてる途中でコンパイル一時的に通す為に入れたGHC拡張が残ったままになってたりするのか</div></div><div class="message" id="message-1519720633.000270"><div class="message__timestamp">2018-02-27<br/>17:37:13 +0900</div><div class="message__header">voqn.tyrant</div><div class="message__body">UndecidableInstances は意識的に入れたつもり無くて、StandaloneDerivingが使いたかっただけ、というパターンとかあります</div></div><div class="message" id="message-1519723541.000188"><div class="message__timestamp">2018-02-27<br/>18:25:41 +0900</div><div class="message__header">voqn.tyrant</div><div class="message__body">せっかくProxyを作ったんだからそれを利用すればよかったんだなぁ</div></div><div class="message" id="message-1520006371.000517"><div class="message__timestamp">2018-03-03<br/>00:59:31 +0900</div><div class="message__header">falsandtru</div><div class="message__body">@falsandtru has left the channel</div></div><div class="message" id="message-1520501034.000437"><div class="message__timestamp">2018-03-08<br/>18:23:54 +0900</div><div class="message__header">satopen1729</div><div class="message__body">@satopen1729 has joined the channel</div></div><div class="message" id="message-1520918707.000050"><div class="message__timestamp">2018-03-13<br/>14:25:07 +0900</div><div class="message__header">voqn.tyrant</div><div class="message__body">やっとcompdataとData Types a la carte まで学習が進みました。 <a href='http://hackage.haskell.org/package/compdata'>http://hackage.haskell.org/package/compdata</a></div></div><div class="message" id="message-1520922053.000184"><div class="message__timestamp">2018-03-13<br/>15:20:53 +0900</div><div class="message__header">kakkun61</div><div class="message__body">compdata ほう こんなものが</div></div><div class="message" id="message-1520922759.000127"><div class="message__timestamp">2018-03-13<br/>15:32:39 +0900</div><div class="message__header">voqn.tyrant</div><div class="message__body"><a href='http://www.timphilipwilliams.com/posts/2013-01-16-fixing-gadts.html'>http://www.timphilipwilliams.com/posts/2013-01-16-fixing-gadts.html</a><br/>ここで解説されている「任意のデータ型をFunctorからもう一段階高階の抽象化をして、『Int型しか受け付けない（あるいは評価結果がそうなる）構文』とかをできるようにする」手法が別のワークショップでそのまま実装されていたっていうオチ</div></div><div class="message" id="message-1520933688.000201"><div class="message__timestamp">2018-03-13<br/>18:34:48 +0900</div><div class="message__header">kakkun61</div><div class="message__body">ちょうど今 Data Types a la carte ベースでテンプレートエンジン作ってるから気になる<br/>後で見よう</div></div><div class="message" id="message-1520941309.000196"><div class="message__timestamp">2018-03-13<br/>20:41:49 +0900</div><div class="message__header">ywataywatay</div><div class="message__body">@ywataywatay has joined the channel</div></div><div class="message" id="message-1521174705.000115"><div class="message__timestamp">2018-03-16<br/>13:31:45 +0900</div><div class="message__header">voqn.tyrant</div><div class="message__body">@mizunashi-mana さんに指摘された Cofree annotation 、本当に <code>IndexedCofree f a i</code> っていう型を作って出来るか試してみたら出来ました</div></div><div class="message" id="message-1521174727.000086"><div class="message__timestamp">2018-03-16<br/>13:32:07 +0900</div><div class="message__header">voqn.tyrant</div><div class="message__body">これだけでもこのチャンネル入って本当に良かった。ありがとうございます</div></div><div class="message" id="message-1521177090.000106"><div class="message__timestamp">2018-03-16<br/>14:11:30 +0900</div><div class="message__header">mizunashi-mana</div><div class="message__body">@mizunashi-mana has left the channel</div></div><div class="message" id="message-1521177102.000089"><div class="message__timestamp">2018-03-16<br/>14:11:42 +0900</div><div class="message__header">mizunashi-mana</div><div class="message__body">@mizunashi-mana has joined the channel</div></div><div class="message" id="message-1521935264.000018"><div class="message__timestamp">2018-03-25<br/>08:47:44 +0900</div><div class="message__header">shunsuke.masuda</div><div class="message__body">@shunsuke.masuda has joined the channel</div></div><div class="message" id="message-1522397929.000042"><div class="message__timestamp">2018-03-30<br/>17:18:49 +0900</div><div class="message__header">andes</div><div class="message__body">@andes has joined the channel</div></div><div class="message" id="message-1522427498.000258"><div class="message__timestamp">2018-03-31<br/>01:31:38 +0900</div><div class="message__header">shohei.takaichi</div><div class="message__body">@shohei.takaichi has joined the channel</div></div><div class="message" id="message-1522803896.000278"><div class="message__timestamp">2018-04-04<br/>10:04:56 +0900</div><div class="message__header">nrskt</div><div class="message__body">@nrskt has joined the channel</div></div><div class="message" id="message-1523499248.000187"><div class="message__timestamp">2018-04-12<br/>11:14:08 +0900</div><div class="message__header">klonoa</div><div class="message__body">@klonoa has joined the channel</div></div><div class="message" id="message-1524038560.000043"><div class="message__timestamp">2018-04-18<br/>17:02:40 +0900</div><div class="message__header">hiroto.shioi</div><div class="message__body">すごく簡素なプログラムですが、haskellで書きました。<br/>もしかしたらリリースされるかもしれません。（まだプロトタイプです）<br/>プログラムの目的、利用方法に関してはreadmeを読んでください。<br/><a href='https://github.com/input-output-hk/cardano-diagnosis-program'>https://github.com/input-output-hk/cardano-diagnosis-program</a><br/><br/>気になってる点:<br/>1. どのようなテストを行えばいいのかわかりません。（ダミーファイルを作ってそれをパースするとか？）<br/>2. ログを解析する部分(`Classifier.hs`)が総当りに近いです（`isInfixOf` を使って特定の文字をキャッチしています。）本当はregexやパーサーライブラリを使って解析したいのですが、１日かけても全く動きませんでした。これに関してなにか具体例みたいなものがあれば是非紹介して頂きたいです。。<br/>3. <code>LogExtractor</code>（ログファイルの有無を確認し、ある場合には読み込む）に関してOSごとにFilePathを指定する部分が若干不安です（とくにユーザー名に半角英数字以外を使用しているユーザーに対して動作するのか）<br/><br/>その他気づいた点がありましたらお願いします。</div></div><div class="message" id="message-1524040265.000050"><div class="message__timestamp">2018-04-18<br/>17:31:05 +0900</div><div class="message__header">hiroto.shioi</div><div class="message__body">ログファイルのサンプルあったほうがいいですよね。夜にアップロードします。</div></div><div class="message" id="message-1524041258.000279"><div class="message__timestamp">2018-04-18<br/>17:47:38 +0900</div><div class="message__header">mizunashi-mana</div><div class="message__body">ちょっと覗いた程度ですが，1点だけ気になりました．<br/><a href='https://github.com/input-output-hk/cardano-diagnosis-program/blob/master/app/Main.hs#L38'>https://github.com/input-output-hk/cardano-diagnosis-program/blob/master/app/Main.hs#L38</a><br/>の部分ですが，こういう場合throwIOを使われるのが好まれると思います．<br/><a href='https://mail.haskell.org/pipermail/libraries/2012-September/018410.html'>https://mail.haskell.org/pipermail/libraries/2012-September/018410.html</a> のスレッドが参考になると思うのでどうぞ</div></div><div class="message" id="message-1524048568.000121"><div class="message__timestamp">2018-04-18<br/>19:49:28 +0900</div><div class="message__header">hiroto.shioi</div><div class="message__body">ありがとうございます。その点に関しては僕も気になっていたのでさっそく取り組んでみます。</div></div><div class="message" id="message-1524051160.000068"><div class="message__timestamp">2018-04-18<br/>20:32:40 +0900</div><div class="message__header">hiroto.shioi</div><div class="message__body">@hiroto.shioi uploaded a file: <a href='https://haskell-jp.slack.com/files/U7Z4F723Z/FA9TKV40P/pub.zip'>pub.zip</a> and commented: ログファイルのサンプル</div></div><div class="message" id="message-1524068406.000665"><div class="message__timestamp">2018-04-19<br/>01:20:06 +0900</div><div class="message__header">mizunashi-mana</div><div class="message__body">あんまりよく読んでないので心証的な感じで申し訳ないんですが<br/>解析のパフォーマンスについては，どれぐらいの規模なのかよく分からないですが，複数ファイルを1回読み込んでしまうとメモリをかなり食ってGCの回数が増えるとかがあるのではないでしょうか？テストより先にプロファイリング用に余計な処理を省いたベンチマークを作ってみるのがいい気がしました</div></div></div><div class="pager"><a href="/html/C8KBGEBR7/2.html" class="pager__previous">Previous</a><a href="/" class="pager__top">Top</a><a href="/html/C8KBGEBR7/4.html" class="pager__next">Next</a></div></body></html>