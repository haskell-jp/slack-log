<!DOCTYPE html><html><head><meta charset="utf-8"><title>haskell-jp / questions #12</title><link rel="stylesheet" href="/slack-log/messages.css" type="text/css" media="screen"></head><body><h1>haskell-jp / questions #12</h1><div class="pager"><a href="/slack-log/html/C5666B6BB/11.html" class="pager__previous">Previous</a><a href="/slack-log/" class="pager__top">Top</a><a href="/slack-log/html/C5666B6BB/13.html" class="pager__next">Next</a></div><div class="message_list"><div class="message" id="message-1517959897.000229"><div class="message__timestamp">2018-02-07<br/>08:31:37 +0900</div><div class="message__header">msakai</div><div class="message__body">ExplicitForAll の方が ScopedTypeVariables よりも導入が後だった気がする。</div></div><div class="message" id="message-1518090183.000347"><div class="message__timestamp">2018-02-08<br/>20:43:03 +0900</div><div class="message__header">kazu</div><div class="message__body">appveyorで、バイナリを作りたいのですが、できあがったバイナリがどこにあるのか分かりません。どなたか、どう記述すればいいか、ご存知ありませんか？</div></div><div class="message" id="message-1518090186.000016"><div class="message__timestamp">2018-02-08<br/>20:43:06 +0900</div><div class="message__header">kazu</div><div class="message__body"><a href='https://ci.appveyor.com/project/kazu-yamamoto/hs-tls'>https://ci.appveyor.com/project/kazu-yamamoto/hs-tls</a><br/><a href='https://ci.appveyor.com/project/kazu-yamamoto/hs-tls/build/artifacts'>https://ci.appveyor.com/project/kazu-yamamoto/hs-tls/build/artifacts</a><br/><a href='https://github.com/kazu-yamamoto/hs-tls/blob/tls13/appveyor.yml'>https://github.com/kazu-yamamoto/hs-tls/blob/tls13/appveyor.yml</a></div></div><div class="message" id="message-1518146867.000099"><div class="message__timestamp">2018-02-09<br/>12:27:47 +0900</div><div class="message__header">kazu</div><div class="message__body">github からとってきたソースは C:\projects\&lt;packagename&gt; にあって、stack はここで実行される。</div></div><div class="message" id="message-1518146906.000223"><div class="message__timestamp">2018-02-09<br/>12:28:26 +0900</div><div class="message__header">kazu</div><div class="message__body">stack が作業に使うのは、stack_root にしていしたディレクトリ。</div></div><div class="message" id="message-1518146959.000230"><div class="message__timestamp">2018-02-09<br/>12:29:19 +0900</div><div class="message__header">kazu</div><div class="message__body">artifacts は、前者内での相対パスしか使えないので、バイナリが見えない。</div></div><div class="message" id="message-1518147011.000250"><div class="message__timestamp">2018-02-09<br/>12:30:11 +0900</div><div class="message__header">kazu</div><div class="message__body"><code>stack --local-bin-path . install &lt;package_name&gt;</code> すると、作業ディレクトリから後者へバイナリをコピーしてくれる。</div></div><div class="message" id="message-1518147023.000241"><div class="message__timestamp">2018-02-09<br/>12:30:23 +0900</div><div class="message__header">kazu</div><div class="message__body">やった！ &lt;- 今ココ</div></div><div class="message" id="message-1518147260.000045"><div class="message__timestamp">2018-02-09<br/>12:34:20 +0900</div><div class="message__header">kazu</div><div class="message__body">う、スレッドになってなかった。ごめんなさい。</div></div><div class="message" id="message-1518147692.000048"><div class="message__timestamp">2018-02-09<br/>12:41:32 +0900</div><div class="message__header">kazu</div><div class="message__body"><pre>
Copying from C:\projects\hs-tls\.stack-work\install\1e01afab\bin\tls-simpleclient.exe to C:\projects\hs-tls\tls-simpleclient.exe
</pre><br/>きたー！</div></div><div class="message" id="message-1518158706.000018"><div class="message__timestamp">2018-02-09<br/>15:45:06 +0900</div><div class="message__header">igrep</div><div class="message__body">ちょっとHaskellと外れた質問かな、と思いきや、なるほどAppVeyorではなくstackの使用についての質問でしたか。。。すみません、察せなくて。</div></div><div class="message" id="message-1518327591.000032"><div class="message__timestamp">2018-02-11<br/>14:39:51 +0900</div><div class="message__header">ttaakkee</div><div class="message__body">実行時の数値からNat種の型を作る(?)には <code>GHC.TypeLits</code> の <code>someNatVal</code> 関数などを使えばできるとおもうのですが、この時作られる型を自作の型クラスのインスタンスに限定するにはどのようにすればいいのでしょうか?:sob::sob::innocent:</div></div><div class="message" id="message-1518329567.000024"><div class="message__timestamp">2018-02-11<br/>15:12:47 +0900</div><div class="message__header">ttaakkee</div><div class="message__body">補足します:man-bowing::writing_hand:<br/>Z/nZ を表す型として <code>IntResidueClass</code> というデータ型と、有限体を表す型クラスとして <code>FiniteField</code> 型クラスを作りました。<br/>n が素数のときにZ/nZが有限体になることを次のようにしてプログラムにしました:writing_hand::scream_cat:<br/><br/><pre>
class FiniteField k where
  hoge :: k -&gt; String

newtype IntResidueClass (n :: Nat) = MkIntResidueClass Integer deriving (Show)

instance (IsPrime p) =&gt; FiniteField (IntResidueClass p) where
  hoge _ = "hogehoge"
</pre><br/><br/><code>IsPrime</code> は以下のように型族として定義しました。Natの型が素数になってるかどうかコンパイル時に判定させることができました:exploding_head:<br/><br/><pre>
type family (x :: Nat) % (y :: Nat) :: Nat  where
  x % y = Mod' x y (y &lt;=? x)

type family Mod' (x :: Nat) (y :: Nat) (xGeqY :: Bool) :: Nat where
  Mod' x y 'True  = Mod' (x - y) y (y &lt;=? (x - y))
  Mod' x y 'False = x

type IsPrime p = IsPrimeB p ~ 'True
  
type family IsPrimeB (p :: Nat) :: Bool where
  IsPrimeB 0 = 'False
  IsPrimeB 1 = 'False
  IsPrimeB 2 = 'True
  IsPrimeB p = IsPrimeB' p 3 (p % 2 == 0) (Not (3 ^ 2 &lt;=? p))

type family IsPrimeB' (p :: Nat) (i :: Nat) (hasFactor :: Bool) (searchEnd :: Bool) where
  IsPrimeB' _ _ 'True _ = 'False
  IsPrimeB' _ _ _ 'True = 'True
  IsPrimeB' p i _ _     = IsPrimeB' p (i + 2) (p % i == 0) (Not ((i + 2) ^ 2 &lt;=? p))
</pre><br/><br/>さらに、実行時のユーザの入力によって n を決めて <code>IntResidueClass n</code> 型の値を作り出すことは、以下のようにしてできました:oden:<br/><br/><pre>
main :: IO ()
main = do
  s &lt;- getLine
  let i = read s :: Integer
  let sn = fromJust $ someNatVal i
  case sn of
    SomeNat p -&gt; do
      let irc = mkIntResidueClassFromProxy p 0
      print irc 
</pre><br/><br/>このとき、 <code>print $ hoge irc</code> とするなどの、`FiniteField`クラスのメソッドを使うことができません:sob:<br/> <code>FiniteField</code> クラスのインスタンスである <code>IntResidueClass</code> を実行時に作るにはどうすれば良いのでしょうか:sob::man-bowing:</div></div><div class="message" id="message-1518332550.000008"><div class="message__timestamp">2018-02-11<br/>16:02:30 +0900</div><div class="message__header">mashedhotate</div><div class="message__body">@mashedhotate has joined the channel</div></div><div class="message" id="message-1518334587.000034"><div class="message__timestamp">2018-02-11<br/>16:36:27 +0900</div><div class="message__header">mashedhotate</div><div class="message__body">KnownNat n からIntegerはいつでも変換できますが、どうしても値レベルの素数判定は使いたくないということですか？仮に型レベルの素数判定を使ったとしても、この場合結局実行時に評価することになって、性能はむしろ悪くなりそうですが</div></div><div class="message" id="message-1518335266.000018"><div class="message__timestamp">2018-02-11<br/>16:47:46 +0900</div><div class="message__header">mizunashi-mana</div><div class="message__body">どういう状況なのかは分かりませんが，基本的なアイデアとしては， <code>SomeNat</code> と同じようにまず <code>FiniteField</code> の制約を持つ存在型で包んであげて， <code>FiniteField</code> のリフレクションでインスタンスを導出してあげれば良いです．ただ，Haskellはこの辺があまり柔軟にはできていないので，リフレクションに多少工夫が必要です．</div></div><div class="message" id="message-1518335452.000051"><div class="message__timestamp">2018-02-11<br/>16:50:52 +0900</div><div class="message__header">mashedhotate</div><div class="message__body">そうですね。あとはGADTで型レベルのパターンマッチをするのもあると思います。GHCの型だけで数学を表現するのは大変で、たくさんの人が挫折してますね・・</div></div><div class="message" id="message-1518336071.000046"><div class="message__timestamp">2018-02-11<br/>17:01:11 +0900</div><div class="message__header">mizunashi-mana</div><div class="message__body">どの道どのリフレクションを使うにしろ，何らかのユーザー保証は入ってくる(素数判定の結果がIsPrimeを満たすことを，GHCではなくユーザーが保証する． <strike>型族の実装からの実行時動作を導出することは個人的には無理だと思っていますが，できるかもしれません</strike> できそうかもです．アイデアだけ次のコメントに書いておきました．)と思いますが，リフレクションの方法としては<br/>1. <code>IsPrime</code> が1つのメソッドしか持たないなら <a href='https://www.schoolofhaskell.com/user/thoughtpolice/using-reflection'>https://www.schoolofhaskell.com/user/thoughtpolice/using-reflection</a> という方法があります．<br/>2. もう一つは， <code>Typeable</code> (<https://www.stackage.org/haddock/lts-10.5/base-4.10.1.0/Type-Reflection.html#t:Typeable>) を利用して <code>someNat</code> で持ち上げた <code>Nat</code> の型情報を持ってくる方法があります<br/>他にもいろいろありますが，代表的なのはこの辺ですかね？</div></div><div class="message" id="message-1518339576.000019"><div class="message__timestamp">2018-02-11<br/>17:59:36 +0900</div><div class="message__header">mizunashi-mana</div><div class="message__body">あまり頭のいいことをしようと考えなければ，結構簡単にいけそうですね．とりあえず思いついた方法を書いてみました．参考にどうぞ<br/><a href='https://gist.github.com/mizunashi-mana/30bccdd729e1a069580ac17e9d0853f2'>https://gist.github.com/mizunashi-mana/30bccdd729e1a069580ac17e9d0853f2</a><br/>後，型族からの実装の抽出は，IsPrimeBが構造的帰納法などで停止することを証明して，KnownNat n =&gt; IsPrimeB n <strike> ’True \/ IsPrimeB n </strike> ’False であることを証明すれば，後はその証明を使って型レベルの’True/’Falseを値レベルのTrue/Falseに落としてTrueかどうか判定することでできそうな気がしました．まあ，ちょっとめんどそうなので，そっちの方は試してないです</div></div><div class="message" id="message-1518345282.000085"><div class="message__timestamp">2018-02-11<br/>19:34:42 +0900</div><div class="message__header">notogawa</div><div class="message__body">singletonsとconstraintsを使いましょう．<br/><a href='https://gist.github.com/notogawa/83324a70e35049cd1ddccc005ea1a278'>https://gist.github.com/notogawa/83324a70e35049cd1ddccc005ea1a278</a></div></div><div class="message" id="message-1518345900.000038"><div class="message__timestamp">2018-02-11<br/>19:45:00 +0900</div><div class="message__header">notogawa</div><div class="message__body">今回は書き下してますが， <code><http://Data.Singletons.TH|Data.Singletons.TH></code> とか使うともっとラクに書けるんじゃないかなと思います．</div></div><div class="message" id="message-1518367636.000053"><div class="message__timestamp">2018-02-12<br/>01:47:16 +0900</div><div class="message__header">ttaakkee</div><div class="message__body">おお:heart_eyes:どうもありがとうございます:pray:<br/>プログラムまで書いて頂いてものすごく参考になりそうです:man-bowing:<br/>まだ全部理解できていないのですが、わからないことがあったらまた質問するかもしれないです:sweat_drops:</div></div><div class="message" id="message-1518500384.000177"><div class="message__timestamp">2018-02-13<br/>14:39:44 +0900</div><div class="message__header">ttsurutani</div><div class="message__body">haskellの数値演算では型合わせが必須で、少しまともに書き始めると色々躓きまして、あちこち調べて整理しています。その中で過去の９８のクラス階層図<https://www.haskell.org/onlinereport/basic.htmlと、ここにある>　<https://en.wikibooks.org/wiki/Haskell/Classes_and_types#Standard_classes> おそらく最新と思われるものの間で違いがあります。具体的にはNumについていたEqやshowの型制約が外れているようなのですが、これは何故なのでしょう？</div></div><div class="message" id="message-1518501074.000102"><div class="message__timestamp">2018-02-13<br/>14:51:14 +0900</div><div class="message__header">cohei</div><div class="message__body">結構前に、 Num クラスに Eq, Show 制約は不要だからなくなったと記憶しています。 xuwei さんのブログ記事がありました: <a href='http://xuwei-k.hatenablog.com/entry/20120123/1327325922'>http://xuwei-k.hatenablog.com/entry/20120123/1327325922</a></div></div><div class="message" id="message-1518501190.000143"><div class="message__timestamp">2018-02-13<br/>14:53:10 +0900</div><div class="message__header">igrep</div><div class="message__body"><a href='http://downloads.haskell.org/~ghc/latest/docs/html/users_guide/bugs.html#numbers-basic-types-and-built-in-classes'>http://downloads.haskell.org/~ghc/latest/docs/html/users_guide/bugs.html#numbers-basic-types-and-built-in-classes</a> にも同じ話がありましたが、 <strike>やっぱり詳しい背景までは載ってませんね</strike> すみません、 :point_up: の記事でも軽く触れてますね。<br/>推測ですが、単純に <code>Eq</code> であることと <code>Show</code> であることとは <code>Num</code> に本質的でないと判断したんではないでしょうか。</div></div><div class="message" id="message-1518502923.000016"><div class="message__timestamp">2018-02-13<br/>15:22:03 +0900</div><div class="message__header">ttsurutani</div><div class="message__body">ありがとうございます。公式に外されたものなのですね。図の中で制約が外れた後も「All except～」とあるので、暗黙的に制約される何がしかの仕組みがあるのかと勘繰っていました。提案の中に書かれているように”意味がない”ということなのですね</div></div><div class="message" id="message-1518578885.000146"><div class="message__timestamp">2018-02-14<br/>12:28:05 +0900</div><div class="message__header">ttsurutani</div><div class="message__body">引き続き、数値演算時の型変換の質問です。</div></div><div class="message" id="message-1518578911.000041"><div class="message__timestamp">2018-02-14<br/>12:28:31 +0900</div><div class="message__header">ttsurutani</div><div class="message__body">@ttsurutani uploaded a file: <a href='https://haskell-jp.slack.com/files/U55UN00G0/F98PFFPMG/image.png'>RWHに、このような図があります（レイアウト等一部アレンジしています）　</a></div></div><div class="message" id="message-1518578945.000043"><div class="message__timestamp">2018-02-14<br/>12:29:05 +0900</div><div class="message__header">ttsurutani</div><div class="message__body">これを見ながら色々考えていたのですが、`realToFrac`の使いどころが分からなくなりました。</div></div><div class="message" id="message-1518579128.000135"><div class="message__timestamp">2018-02-14<br/>12:32:08 +0900</div><div class="message__header">ttsurutani</div><div class="message__body">整数型からの変換は`fromIntegral`一択。`Rational`へ・からの変換はそれぞれ専用関数があり、`Fractional`からの整数型への変換は何らかの切り捨て関数となると、`realToFrac`は`Fractional`間の変換時の使用に見えます。</div></div><div class="message" id="message-1518579194.000124"><div class="message__timestamp">2018-02-14<br/>12:33:14 +0900</div><div class="message__header">ttsurutani</div><div class="message__body">ただ、<https://wiki.haskell.org/Converting_numbers>　では、浮動小数点型の変換に`realToFrac`を使うのは問題があるので、専用関数を使え、とあります。（上表にはRWHの記述にくわえて、相互変換関数を追記してあります）</div></div><div class="message" id="message-1518579301.000020"><div class="message__timestamp">2018-02-14<br/>12:35:01 +0900</div><div class="message__header">ttsurutani</div><div class="message__body">となると、`realToFrac`の使いどころがわからなくなりました。ネット等にあるサンプルは比較的単純で`realToFrac`を使わずとも他の関数で書いても同じ結果になりました。もしかしてcomplexあたりとの演算？？分かれば単純なことな気がしていますが、思いつかなかったのでご教授いただけると嬉しいです</div></div><div class="message" id="message-1518580106.000082"><div class="message__timestamp">2018-02-14<br/>12:48:26 +0900</div><div class="message__header">igrep</div><div class="message__body"><a href='https://www.stackage.org/haddock/lts-10.5/base-4.10.1.0/Prelude.html#t:Fractional'>https://www.stackage.org/haddock/lts-10.5/base-4.10.1.0/Prelude.html#t:Fractional</a> を見る限り、<br/>お察しの通りComplexはRealじゃないかつFractionalである場合があるみたいですね。<br/>ただ、実際のところ<br/><pre>
realToFrac = fromRational . toRational
</pre><br/>で定義される程度の、ユースケースの割にはシンプルな関数です（個人の感想です）。<br/>歴史の闇の中でいろいろ仕様変更しているうちに要らないものができちゃった、なんてことは普通にあり得ますが。。。 :cold_sweat:</div></div><div class="message" id="message-1518580242.000126"><div class="message__timestamp">2018-02-14<br/>12:50:42 +0900</div><div class="message__header">ttsurutani</div><div class="message__body">早々のお返事ありがとうございます。RWHには実際にはrealToFracではなく、fromRational.toRationalで書かれていますね。</div></div><div class="message" id="message-1518580311.000206"><div class="message__timestamp">2018-02-14<br/>12:51:51 +0900</div><div class="message__header">ttsurutani</div><div class="message__body">いわゆる入門系の書籍やネットの記事等も比較的古めの情報が多いため、今ソースコードをみたときに事情が異なっているものが多いなあというのは昨日の例も含め、すごく感じています</div></div><div class="message" id="message-1518580402.000100"><div class="message__timestamp">2018-02-14<br/>12:53:22 +0900</div><div class="message__header">igrep</div><div class="message__body">:thinking_face: <code>realToFrac</code> を deprecate にした方がいいか議論した方がいいのだろうか。。。</div></div><div class="message" id="message-1518580451.000125"><div class="message__timestamp">2018-02-14<br/>12:54:11 +0900</div><div class="message__header">kakkun61</div><div class="message__body">今 RWH 読むならこちらも参考にどうぞ <a href='http://d.hatena.ne.jp/kazu-yamamoto/20140206/1391666962'>http://d.hatena.ne.jp/kazu-yamamoto/20140206/1391666962</a></div></div><div class="message" id="message-1518583762.000165"><div class="message__timestamp">2018-02-14<br/>13:49:22 +0900</div><div class="message__header">as_capabl</div><div class="message__body">質問です。<br/>以下のコードはDataKinds+PolyKindsではコンパイルが通らず、TypeInTypeを有効にすると通ります。<br/><br/><pre>
{-# LANGUAGE TypeFamilies, DataKinds, PolyKinds #-}

import GHC.TypeLits

type S = Symbol

type family T :: Symbol -- OK
type family T2 :: Maybe Symbol -- OK
type family T3 :: Maybe S -- Error!
</pre><br/><br/>エラー内容<br/><br/><pre>
kind.hs:8:25: error:
    ? Type constructor ‘S’ cannot be used here
        (Perhaps you intended to use TypeInType)
    ? In the first argument of ‘Maybe’, namely ‘S’
      In the kind ‘Maybe S’
</pre><br/><br/>TypeInTypeの意味は「*のカインドを*とし、型と同様に扱えるようにする」との事ですが、上記のコードが通る事がそれとどのように関係しているのか理解できていません。<br/>DataKinds+PolyKindsで上記のコードが通らないのはどのような制約によるもので、なぜTypeInTypeを指定するとそれが外れるのでしょうか。</div></div><div class="message" id="message-1518585483.000201"><div class="message__timestamp">2018-02-14<br/>14:18:03 +0900</div><div class="message__header">matsubara0507</div><div class="message__body">(ぜんぜん詳しく無いですけど)<br/>そもそも type alias の型では kind に昇格できないのではないですか？<br/><pre>
type family T4 :: S -- Error!
</pre></div></div><div class="message" id="message-1518585685.000140"><div class="message__timestamp">2018-02-14<br/>14:21:25 +0900</div><div class="message__header">matsubara0507</div><div class="message__body">最後の方に <code>TypeInType</code> について書いてありますね<br/><a href='https://haskell.jp/blog/posts/2017/13-about-kind-system-part2.html'>https://haskell.jp/blog/posts/2017/13-about-kind-system-part2.html</a></div></div><div class="message" id="message-1518586501.000069"><div class="message__timestamp">2018-02-14<br/>14:35:01 +0900</div><div class="message__header">mizunashi-mana</div><div class="message__body">僕も全然詳しくないですが，それは一重にDataKindsの型システムではtype aliasのpromotionが許可されていないけど，TypeInTypeの型システムでは許可されているからだと思いますね．GHCの現状のTypeInTypeの実装がどういう風になっているかはあまり知らないのですが，「*のカインドを*とする」のはinfiniteなtype hierarchyを許可することのように聞こえます</div></div><div class="message" id="message-1518587237.000214"><div class="message__timestamp">2018-02-14<br/>14:47:17 +0900</div><div class="message__header">mizunashi-mana</div><div class="message__body">TypeInTypeの原論文のIntroductionがいちよ解になってる気がします．<br/><a href='http://www.seas.upenn.edu/~sweirich/papers/fckinds.pdf'>http://www.seas.upenn.edu/~sweirich/papers/fckinds.pdf</a><br/>型の同値判定を種の同値判定に昇格するのが難しいと言ってますね．おそらくですが，この辺の兼ね合いでtype aliasを含めた型の同値判定を，既存の型システムで種レベルに昇格するのが難しかったのではないでしょうか？</div></div><div class="message" id="message-1518587449.000089"><div class="message__timestamp">2018-02-14<br/>14:50:49 +0900</div><div class="message__header">ttsurutani</div><div class="message__body">数値の型について、もうひとつ。<br/><br/>皆さんは`Fracitonal‘ってどんな日本語をあてられますか？（日本語になんかしないよ、という意見は置いておいて）。<br/>直訳は「分数」で手元にある虎本でも思い切り「分数」と訳されていますが、クラス間の関係から考えると「非整数」あたりが一番正確なのかな、と思っています。<br/>「分数」だとサブクラスに√やpiや複素数があることと整合しない気がしまして・・<br/><br/>この流れでいうと`RealFrac`は非整数のうち実数のもの、`RealFloat`は浮動小数点の実数（`Floating`は複素数も含む）という理解で正しいでしょうか？</div></div><div class="message" id="message-1518587804.000117"><div class="message__timestamp">2018-02-14<br/>14:56:44 +0900</div><div class="message__header">matsubara0507</div><div class="message__body">pi = pi / 1 <br/>だし、分数でもいいのでは？<br/>pi や √ があるとおかしいのは有理数じゃない？</div></div><div class="message" id="message-1518587975.000027"><div class="message__timestamp">2018-02-14<br/>14:59:35 +0900</div><div class="message__header">mizunashi-mana</div><div class="message__body">Oh…<br/><blockquote>Languages such as Coq and Agda avoid the <b>:</b> axiom because it introduces inconsistency, but that is not an issue here. The FC type language is already inconsistent in the sense that all kinds are inhabited.</blockquote>なんですね，知りませんでした… 本当に文面通り*のカインドを*にするんですね…</div></div><div class="message" id="message-1518588106.000009"><div class="message__timestamp">2018-02-14<br/>15:01:46 +0900</div><div class="message__header">ttsurutani</div><div class="message__body">無理数とは分数で表現できない数値（分子分母ともに整数である分数＝有理数、以外の値）で、代表は２の平方根や円周率だと教わりました。分数で表現できないのが無理数なのに分数クラスっていうのはと思ったのですが、なるほどpi/1という捉え方も確かにありますね・・</div></div><div class="message" id="message-1518588248.000013"><div class="message__timestamp">2018-02-14<br/>15:04:08 +0900</div><div class="message__header">matsubara0507</div><div class="message__body">無理数は 有理数 (分母と分子が整数の分数)で表現できない数だと思うよ<br/>ぼくも専門ではないけど、分数はもっと一般化された概念なんじゃない？</div></div><div class="message" id="message-1518588604.000108"><div class="message__timestamp">2018-02-14<br/>15:10:04 +0900</div><div class="message__header">ttsurutani</div><div class="message__body">上の記述、おかしいですね。分子分母ともに整数である分数＝有理数で、それ以外が無理数。なので、よく「無理数は分数で表現できない数」といった説明がされています（ちょっと書き方直しました）</div></div><div class="message" id="message-1518588857.000113"><div class="message__timestamp">2018-02-14<br/>15:14:17 +0900</div><div class="message__header">ttsurutani</div><div class="message__body">さらに`Rational`が`Ratio Integer`で（分母分子整数による分数）あることを考えると、やっぱり分数という日本語には個人的には違和感がありました</div></div><div class="message" id="message-1518589631.000178"><div class="message__timestamp">2018-02-14<br/>15:27:11 +0900</div><div class="message__header">kazu</div><div class="message__body">数学の話ですが、rational を有理数と訳したのは、誤りとだったと言われています。</div></div></div><div class="pager"><a href="/slack-log/html/C5666B6BB/11.html" class="pager__previous">Previous</a><a href="/slack-log/" class="pager__top">Top</a><a href="/slack-log/html/C5666B6BB/13.html" class="pager__next">Next</a></div></body></html>