[
    {
        "ts": "1540520498.000200",
        "text": "<@UDP2YN4P7> has joined the channel",
        "user": "UDP2YN4P7",
        "type": "message"
    },
    {
        "ts": "1540737524.001800",
        "text": "hfmtがTemplateHaskellのトップレベルな関数呼び出しに対応してなさそうで泣いてる\n```\nfoo bar ''Baz\n```",
        "user": "U5LV76EJH",
        "type": "message"
    },
    {
        "ts": "1540738682.002300",
        "text": "対応してた:two_hearts:",
        "user": "U5LV76EJH",
        "type": "message"
    },
    {
        "ts": "1540779064.003100",
        "text": "ちまたで話題の <http://pixe.la|pixe.la> のクライアントを土曜日から書き始めた",
        "user": "U4L0B71L1",
        "type": "message"
    },
    {
        "ts": "1540779660.003600",
        "text": "Pixela使って何か作るんですか？",
        "user": "U4KPPQW7K",
        "type": "message"
    },
    {
        "ts": "1540780101.005100",
        "text": "`$` の感覚でいると `infixl 4 &lt;$&gt;` で引っかかってしまう……",
        "user": "U7155GPR9",
        "type": "message"
    },
    {
        "ts": "1540785450.005600",
        "text": "とりあえずデジカメの写真がいっぱいあるのでそれから日付情報取ってこれば撮影枚数で草生やせるなーと考えてます",
        "user": "U4L0B71L1",
        "type": "message"
    },
    {
        "ts": "1540785476.005800",
        "text": "なるほどそういう使いみちもあるんですね :memo:",
        "user": "U4KPPQW7K",
        "type": "message"
    },
    {
        "ts": "1540821378.008200",
        "text": "hfmt……っていうか多分その内部のstylish-haskell？\nパースエラー起こすと変なフォーマットがかかったコードを落としていく気がするので、なかなかつらくなってきた。\n設定の問題？",
        "user": "U5LV76EJH",
        "type": "message"
    },
    {
        "ts": "1540880676.008500",
        "text": "GHCがPhabricatorからGitLabに移行するかもしれない話\n<https://mail.haskell.org/pipermail/ghc-devs/2018-October/016425.html>",
        "user": "U4LGTMTMK",
        "type": "message"
    },
    {
        "ts": "1540881060.008900",
        "text": "<https://ghc.haskell.org/trac/ghc/wiki/WhyNotPhabricator>\n\n私もPhabricatorが嫌いなので実現したら嬉しい",
        "user": "U4KUNQF9N",
        "type": "message"
    },
    {
        "ts": "1540901892.009400",
        "text": "<https://qiita.com/advent-calendar/2018/haskell>",
        "user": "U5LV76EJH",
        "type": "message"
    },
    {
        "ts": "1540901941.010300",
        "text": "登録 :done: \n\nHaskell-jp Blog への寄稿も大歓迎です！（寄稿方法はこちら）\n……って書いちゃってもいいですかね :eyes:",
        "user": "U5LV76EJH",
        "type": "message"
    },
    {
        "ts": "1540901958.010600",
        "text": "もうできたんだw",
        "user": "U56L7EVNY",
        "type": "message"
    },
    {
        "ts": "1540902012.010900",
        "text": "もちろんOKだ！\n<https://github.com/haskell-jp/blog/blob/master/README.md> のご案内も忘れずに！",
        "user": "U4LGTMTMK",
        "type": "message"
    },
    {
        "ts": "1540904015.011800",
        "text": "もしかしてstackage-ltsのお知らせ機能停止してます？？",
        "user": "U561MADLH",
        "type": "message"
    },
    {
        "ts": "1540904132.013000",
        "text": "ほんとだ2日前に 12.16 出てるね\n<https://www.stackage.org>",
        "user": "U56L7EVNY",
        "type": "message"
    },
    {
        "ts": "1540904246.014500",
        "text": "情報源がRSSだから、先方にお願いしないといけないかな？",
        "user": "U4LGTMTMK",
        "type": "message"
    },
    {
        "ts": "1540904256.014800",
        "text": "これってどうやってるんでしたっけ？\n誰かのプログラムだっけ？",
        "user": "U56L7EVNY",
        "type": "message"
    },
    {
        "ts": "1540904317.015300",
        "text": "いや、 <#C5UPKRGRE|questions-feed> とかと同じように、SlackのRSS配信機能を使っています。",
        "user": "U4LGTMTMK",
        "type": "message"
    },
    {
        "ts": "1540904329.015500",
        "text": "なるほど",
        "user": "U56L7EVNY",
        "type": "message"
    },
    {
        "ts": "1540904472.016300",
        "text": "なのでどこかで聞いてみないとな。。。止まっていると言うより、1日に連続して出たことによってなんかバグったんだろうか。。。",
        "user": "U4LGTMTMK",
        "type": "message"
    },
    {
        "ts": "1540904859.017500",
        "text": "元のfeedが入ったXMLファイルがこれらしい <https://www.stackage.org/feed/lts>\nページ内検索した限り普通に12.16もヒットしますね。。。\nどちらかというとSlack側の問題なんじゃないかという気がしてきました。",
        "user": "U4LGTMTMK",
        "type": "message"
    },
    {
        "ts": "1540907264.019300",
        "text": "<https://twitter.com/slackhq/status/506655984979546113> で言ってるように、５分間隔でRSSの更新を確認して、さらに、RSSのフィードとしての要件として、各レコードは正しい日付を持っていることとなっていますので、同じ日付の更新だとRSSの更新とは見られないのかもしれませんね。",
        "user": "U9XHWQX7Z",
        "type": "message"
    },
    {
        "ts": "1540966291.022100",
        "text": "<http://fumieval.hatenablog.com/entry/2018/10/31/150056> 最近の議論を受け、取り急ぎ「束縛」という言葉の使い方についての記事を執筆しました。なるべく正確を期したつもりですが、もし不適当な記述があればご教示ください",
        "user": "U4KUNQF9N",
        "type": "message"
    },
    {
        "ts": "1540968000.022700",
        "text": "ちなみに、 `x = 42` のように Haskell で `=` を使った場合は何て読むのが正しいのでしょう？定義とかですかね？",
        "user": "U56L7EVNY",
        "type": "message"
    },
    {
        "ts": "1540968205.023000",
        "text": "(関数|変数)定義が一番無難だと思います。",
        "user": "U4KUNQF9N",
        "type": "message"
    },
    {
        "ts": "1540968235.023300",
        "text": "なるほど :+1: ",
        "user": "U56L7EVNY",
        "type": "message"
    },
    {
        "ts": "1540999831.023700",
        "text": "読ませていただきました．うまく理解できないところがありましたのでコメントします．\n\n&gt;これは**あくまで変数とそれを導入する抽象の関係**であり、**変数と実体の関係ではない**ことだ。\n\n「自由な」とか「束縛された」が修飾するのは構文上の**位置**なので，λ変数とそれを導入する抽象の関係を「束縛」といえることは確かだと思います．しかし，λ変数は後続の構文中での出現によって，どの位置がどの抽象で束縛されているか示すため方法の1つにすぎません．どの位置がどの抽象で束縛されているか示せれば，変数が存在しなくてもよいわけです．そうだとすると**変数と実体の関係ではない**というためにはさらに説明が必要な気がします．\n\n&gt;Haskellは、x = 42のような定義を与えることによって、変数で値を参照できる。だからといって「Haskellでは変数を値にバインドする」と言い切ってしまうことには大きな問題がある。理由は簡単で、変数に対して値以外もバインドできるからだ。例えばy = x + 1という宣言を考えてみよう。この宣言はyをバインドするが、その対象はx + 1という計算であり、式を評価した結果の値ではない。\n\n&gt;定義がインライン化(その名前が使われている場所に展開)されず、メモリ上に領域を確保すべきものと処理系が判断した場合、初めて値に関する議論が始まる――これが「代入」である。代入は、オブジェクトをヒープ(実行時に確保されるメモリ領域)上の場所にセットする。ここで言うオブジェクトは大きく分けて2種類ある。\n\n私には，式``42``と式``6 * 7``とでは，一方は値で一方は計算であるという区別をする理由がよく判らないです．どちらの式も，「よんじゅうに」という同じ値を表わ(denote)すと考えたとき，どのような不都合がありますでしょうか？\n一般にはHaskellで書かれたプログラムの意味は，数学的な関数モデルで考えるのが判りやすいと思われています．関数モデルは**構文**と**意味**で二元的に構成されている体系だとすると，**式**と**値**がその2つに相当すると考えてよいでしょう．そこに3つめの**計算**という元素を入れて，さらにメモリ，関数モデルではないモデルで説明する理由が示されていると判りやすいのかもしれません．\n\n&gt;この混乱は言語仕様ですらやらかしてしまっている。Haskell 2010 Language Reportの3.17.2 Informal Semantics of Pattern Matchingを見ると、\"Binding does not imply evaluation\"と注記しているにもかかわらず、本来オブジェクトに対するものであるパターンマッチを値に対するものと宣言してしまい、変数を値に束縛するという旨の表現を二箇所で使ってしまっている。学習者は言語仕様を読むだけでなく、case undefined + undefined of _ -&gt; 42のような式を手元で評価し、実際の意味論を把握することを推奨する。\n\n私としては「パターンマッチは値に対するものではなく，オブジェクトに対するものである」ことがうまく理解できません．「パターンマッチは値に対するもの」では，どのような不都合があるのでしょうか？\nまた``case undefined + undefined of _ -&gt; 42``はなにを説明する例なのでしょうか．\n\n&gt;以下のような主張はすべて**誤り**である．\n\n定義が明示されていないので，すこし判りにく気がします．「定義によるんじゃないの」というひねくれものが出そう(相手にしなければいいだけかもしれないですが）．\n\nbindがどのような意味で使われているかに注意を払うべき，という主張は，肝に銘じます．",
        "user": "U4KU9ABL0",
        "type": "message"
    },
    {
        "ts": "1541030535.024300",
        "text": "<https://twitter.com/fumieval/status/1057784533649547264>",
        "user": "U4KUNQF9N",
        "type": "message"
    },
    {
        "ts": "1541031011.024600",
        "text": "&gt; **変数と実体の関係ではない**というためにはさらに説明が必要な気がします．\n\nこの部分はよく理解できませんでした。変数が存在しなくても良いというのは例えばde-Bruijn indexのようなものを指しているのでしょうか？また、どのような説明が必要だとお考えですか？\n\n&gt; さらにメモリ，関数モデルではないモデルで説明する理由が示されていると判りやすいのかもしれません．\n\n「関数モデル」(私は使わない言葉ですが)は崩していません。「式」と「値」ではなく、「式」と「オブジェクト」がより正確であると主張しています。\n\n&gt; 「パターンマッチは値に対するもの」\n\n今まで述べたことに沿って考えると、もし値に対するものとした場合、サンクのような値でないオブジェクトに対してパターンマッチできないことになります。すると、`case undefined + undefined of _ -&gt; 42`の結果はundefinedになってしまいます(実際の処理系は42を返します)。\n\n&gt; 定義が明示されていないので\n\n主張が正しくなってしまうような定義でないことは本文で示唆したつもりでしたが、どのあたりが不十分とお考えでしょうか？",
        "user": "U4KUNQF9N",
        "type": "message"
    },
    {
        "ts": "1541031744.024800",
        "text": "これは嬉しいやら悲しいやらですね。　それだけHaskellが浸透してきている証拠（なんて堅苦しいものじゃないですけど）でもあるだろうし、 ゴキブリを不浄の比喩ともとらえられるし。。。",
        "user": "U9XHWQX7Z",
        "type": "message"
    },
    {
        "ts": "1541035780.025200",
        "text": "JasperのいるFugueはHaskellを使っている会社なので、自虐的なジョークなのでしょう :bug:",
        "user": "U4KUNQF9N",
        "type": "message"
    },
    {
        "ts": "1541038260.025500",
        "text": "<@UDSK4J525> has joined the channel",
        "user": "UDSK4J525",
        "type": "message"
    },
    {
        "ts": "1541041951.025700",
        "text": "型理論や圏論について、なんかちょっと難しい議論が始まると、とたんに「みんなHaskellを知ってる前提で書くけど……」モードに突入するあるある",
        "user": "U570660KX",
        "type": "message"
    },
    {
        "ts": "1541047357.026200",
        "text": "はい，変数がないというのは de Bruijin インデックスを想定しました．\n&gt;...さらに説明が必要な気がします．\nしかし，ここまでの部分は自分でもなにを言いたかったのかわかりません．撤回させてください．すみません．\n\n&gt;「式」と「オブジェクト」がより正確であると主張しています。\n\nここが要点だと思っていますが，動機というか「こころ」が良く理解できません．\n\nサンクに対するパターンマッチするとは，どういう状況でしょう？サンクの値は⊥とみなせばよく，変数パターンはすべての値にマッチするので case undefined + undefined of _ -&gt; 42 は42です．\n\n&gt;定義が明示されてないので，\n\nこれも完全に私の惚けでした．すみません．撤回させてください．誤った主張をしている側が誤った定義を使っているので，そもそも主張に意味がないことに気づいていませんでした．",
        "user": "U4KU9ABL0",
        "type": "message"
    },
    {
        "ts": "1541049404.026400",
        "text": "雑なコメントで申し訳けありません．",
        "user": "U4KU9ABL0",
        "type": "message"
    },
    {
        "ts": "1541050326.026700",
        "text": "<@UDUM99NUW> has joined the channel",
        "user": "UDUM99NUW",
        "type": "message"
    },
    {
        "ts": "1541054033.027300",
        "text": "<@UDUBKLQMD> has joined the channel",
        "user": "UDUBKLQMD",
        "type": "message"
    },
    {
        "ts": "1541057345.027500",
        "text": "蛇足かもしれませんがde-Bruijn indexはあくまで文字列の代わりに自然数を変数の表現に用いる仕組みで、変数が存在しないわけではありません(変数の存在しないコンビネータ論理の場合、当然束縛も存在しません)。\n&gt; ここが要点だと思っていますが，動機というか「こころ」が良く理解できません．\nそれが実際に使われているモデルだから、というのは十分な動機になると思います。\n&gt; サンクに対するパターンマッチするとは，どういう状況でしょう？サンクの値は⊥とみなせばよく，変数パターンはすべての値にマッチするので case undefined + undefined of _ -&gt; 42 は42です．\nサンクの値をボトムとみなしていいというのはまったく聞いたことがありません。代わりに`case 1+2+3+4+...100000 of`とかを考えてもらってもいいです。パターンマッチの話はコーナーケースといえばコーナーケースですが、Informalと前置きしているにせよ一貫性のない説明だったため、それを本文で指摘しました。",
        "user": "U4KUNQF9N",
        "type": "message"
    },
    {
        "ts": "1541060251.027700",
        "text": "変数とは何か？も難しいですね．私は変数と構文上位置を指示する名前とを同一視して話していました．de Bruijnインデックスはその位置を束縛する抽象の位置を指示する指標ですから，変数とは別の機能なので，変数とは言わないかな．と思うしだいです．もちろん，どちらも，抽象とそれが束縛する位置を特定するために使うので目的は同じですね．\n\n&gt;それが実際に使われているモデルだから、というのは十分な動機になると思います。\n\nHaskellのモデルで使われているのなら十分な動機だと思います．興味としては，単純な式と値のモデルではなく，そのモデルが採用されたモチベーションは何か，ということです．",
        "user": "U4KU9ABL0",
        "type": "message"
    },
    {
        "ts": "1541066891.027900",
        "text": "&gt; その位置を束縛する抽象の位置を指示する指標ですから，変数とは別の機能\nこれは同意しかねます…私ならそれこそが束縛変数の定義だと言います。\n\n&gt; そのモデルが採用されたモチベーションは何か\n これはまさに遅延評価の動機、つまり「使わない計算は評価しない」「評価した結果である値を共有する」(<https://wiki.haskell.org/Lazy_evaluation>)であると言えると思います",
        "user": "U4KUNQF9N",
        "type": "message"
    },
    {
        "ts": "1541067268.028200",
        "text": "評価しようとしまいと，1+2 が表示(denote)する値は「さん」と考えています．これは評価戦略にかかわらずです．",
        "user": "U4KU9ABL0",
        "type": "message"
    },
    {
        "ts": "1541067677.028400",
        "text": "&gt;それこそが束縛変数の定義だと言います。\nはい，それは同意です．私の方が変数と変数名，あるいは変数と変数の出現を混同しています．",
        "user": "U4KU9ABL0",
        "type": "message"
    },
    {
        "ts": "1541071049.029300",
        "text": "&gt;サンクの値をボトムとみなしていいというのはまったく聞いたことがありません。\n⊥値の導入の動機は，「Well-formedな式は例外なく値を表示(denote)する」と単純に考えるために特定の型の特定の値として定義されない⊥値があれば都合がよい，というものです．inf :: Integer; inf = inf + 1とあれば，infの表示(denote)する値は確定できない値⊥です．評価機計算中は表示(denote)する値は確定できないので，そのことを⊥とみなしても不都合はないように思います．",
        "user": "U4KU9ABL0",
        "type": "message"
    },
    {
        "ts": "1541078133.029600",
        "text": "とりあえず API は網羅した\n<https://github.com/kakkun61/pixela-client-haskell>",
        "user": "U4L0B71L1",
        "type": "message"
    },
    {
        "ts": "1541078198.030000",
        "text": "user name と token は基本的に変わらないから毎回渡すのバカらしいのどうしようかな",
        "user": "U4L0B71L1",
        "type": "message"
    },
    {
        "ts": "1541078930.030200",
        "text": "あんまり議論を追えてないのですが，値自体の定義を <https://www.haskell.org/onlinereport/haskell2010/haskellch1.html#dx6-12001> の\n&gt; An expression evaluates to a value and has a static type.\nに則って考えた場合，Haskellでは let x = 1 * 2 はxに(1 * 2を計算した)値を束縛しているのではなく，言うとしたら(call by name的には)1 * 2という式自体への束縛，または(call by need的には)1 * 2という計算自体への束縛というのが正しいと思います(なので記事の値への束縛というのが誤った使用法というのはHaskellでは誤りというのに同意です)．なお，Haskellではcaseも(Formal Semanticsに則れば)まず対象の式を変数に束縛する変換がなされるので同じ議論を適用できると思います(これもつまり記事と同意見です): <https://www.haskell.org/onlinereport/haskell2010/haskellch3.html#x8-610003.17.3>\n\nまた，一般的なdenotational semanticsは明るくないので分かりませんが，Haskellでは <https://www.haskell.org/onlinereport/haskell2010/haskellch3.html#x8-230003.1> に述べられているように⊥とは，計算するとエラーになるまたは計算が止まらないような式に対する表示値のことであり，(一般的な)サンクに対する表示値ではありません．これは当然(仕様上明示されていませんが)Haskellのdenotational semanticsに合わせた定義だと思われるので， <@U4KU9ABL0> の用法はHaskellにおいてはあまり一般的ではないと思います．\n\nそれからここからは個人的な意見ですが，(取り急ぎと言うことなので続編があるのかもしれませんが)正しい言い方に対する言及がないのが色々疑問を招いているのではないかと感じました．",
        "user": "U57D08Z9U",
        "type": "message"
    },
    {
        "ts": "1541080399.030600",
        "text": "Redditを立てましたので，ご活用ください\n<https://www.reddit.com/r/haskell_jp/comments/9t9is7/%E5%90%8D%E5%89%8D%E3%81%AE%E6%9D%9F%E7%B8%9B%E3%81%A8%E3%81%84%E3%81%86%E5%90%8D%E3%81%AE%E6%9D%9F%E7%B8%9B/>",
        "user": "U57D08Z9U",
        "type": "message"
    },
    {
        "ts": "1541112898.031600",
        "text": "<https://airtable.com/shr8G4RBPD9T6tnDf>",
        "user": "U4LGTMTMK",
        "type": "message"
    }
]