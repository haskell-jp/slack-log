[
    {
        "type": "message",
        "user": "UK0MXUCAV",
        "ts": "1702562421.026439",
        "text": "先々月の Linear Haskell に関する拙稿が余りにも長く趣旨がわかりづらかったので、題材を絞って「どれくらい Haskell が Rust に近づくのか」という点があるていど伝わるといいな……と思いながら補遺を書きました。9年ぶりの Haskell Advent Calendar 参加記事ですが、御笑覧ください。\n\n<https://zenn.dev/konn/articles/2023-12-14-pure-parallel-fft-in-linear-haskell>"
    },
    {
        "type": "message",
        "user": "UF8SE896V",
        "ts": "1702616999.427329",
        "text": "誤字を見つけました\n&gt; 2. 分割倒置法なので、二分割した再帰のフェーズはそれぞれ並列にできる\n分割統治法ですよね"
    },
    {
        "type": "message",
        "user": "UK0MXUCAV",
        "ts": "1702617055.686639",
        "text": "うおーありがとうございます！"
    },
    {
        "type": "message",
        "user": "UF8SE896V",
        "ts": "1702617091.038709",
        "text": "あ、ここもですね\n&gt; (2)(3)が分割倒置法の心臓部ですね。\n"
    },
    {
        "type": "message",
        "user": "UF8SE896V",
        "ts": "1702617206.746819",
        "text": "in-place FFT のアルゴリズムが並列化できるという件は古傷が痛みますｗ（修論で自動並列化の判定を扱おうとして結構苦しんだ…）"
    },
    {
        "type": "message",
        "user": "UK0MXUCAV",
        "ts": "1702617556.127999",
        "text": "このあたりは実用しようと思うと直列実行のスレッショルドとかスケジューリングをちゃんと考える必要があって大変そうですねえ……今回のケースだとGHCのスケジューラに任せっきりでなんとかなってしまいましたが"
    },
    {
        "type": "message",
        "user": "UF8SE896V",
        "ts": "1702617978.010669",
        "text": "私の修論は、たんなるFortran3重ループで書かれたものをベクトル化できるかどうかをコンパイラが判定するというものでした^^;"
    },
    {
        "type": "message",
        "user": "UF8SE896V",
        "ts": "1702618179.577219",
        "text": "ベクトル化なので基本的にどんなに細かくても直列実行よりは速くなるという前提の話でしたね…"
    },
    {
        "type": "message",
        "user": "UF8SE896V",
        "ts": "1702618239.449409",
        "text": "まあ、もう〇十年前の話です^^;"
    }
]