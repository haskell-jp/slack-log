<!DOCTYPE html><html><head><meta charset="utf-8"><title>haskell-jp / random #31</title><link rel="stylesheet" href="/slack-log/messages.css" type="text/css" media="screen"></head><body><h1>haskell-jp / random #31</h1><div class="pager"><a href="/slack-log/html/C4M4TT8JJ/30.html" class="pager__previous">Previous</a><a href="/slack-log/" class="pager__top">Top</a><a href="/slack-log/html/C4M4TT8JJ/32.html" class="pager__next">Next</a></div><div class="message_list"><div class="message" id="message-1543399881.174900"><div class="message__timestamp">2018-11-28<br/>19:11:21 +0900</div><div class="message__header">hexirp</div><div class="message__body">知らないパッケージを検索した時に見つかる Hackage の URL が、いつも https ではなく http になっているのちょっと不思議 (検索サイトは関係ない模様)</div></div><div class="message" id="message-1543476611.176100"><div class="message__timestamp">2018-11-29<br/>16:30:11 +0900</div><div class="message__header">1to100pen</div><div class="message__body">今年の Advenct Calendar は去年に比べたら低調ですね。（去年が多すぎただけか）<br/>「Haskell Advent Calendar 2018」（空席1つ） <a href='https://qiita.com/advent-calendar/2018/haskell'>https://qiita.com/advent-calendar/2018/haskell</a><br/>「Haskell (その2) Advent Calendar 2018」（空席多数） <a href='https://qiita.com/advent-calendar/2018/haskell2'>https://qiita.com/advent-calendar/2018/haskell2</a></div></div><div class="message" id="message-1543476927.177300"><div class="message__timestamp">2018-11-29<br/>16:35:27 +0900</div><div class="message__header">lotz</div><div class="message__body">去年は その5 まであったんですね...ｗ</div></div><div class="message" id="message-1543477006.178500"><div class="message__timestamp">2018-11-29<br/>16:36:46 +0900</div><div class="message__header">igrep</div><div class="message__body">まぁ、多けりゃいいってもんでもないですし、やる気のある範囲でやればよいのではないかと。（私は今回できるかまだ不透明なので登録を先延ばししています :bow:</div></div><div class="message" id="message-1543477575.180600"><div class="message__timestamp">2018-11-29<br/>16:46:15 +0900</div><div class="message__header">fumieval</div><div class="message__body">アドベントカレンダーの数に固執するよりは、一年を通して質の良い記事を発信するほうがコミュニティのためになるとは思います</div></div><div class="message" id="message-1543484915.182500"><div class="message__timestamp">2018-11-29<br/>18:48:35 +0900</div><div class="message__header">matsubara0507</div><div class="message__body">むしろ、なんで去年はあんなに多かったのか</div></div><div class="message" id="message-1543545858.185100"><div class="message__timestamp">2018-11-30<br/>11:44:18 +0900</div><div class="message__header">igrep</div><div class="message__body">Haskellのサポートができる日も近いぜよ<br/><a href='https://www.publickey1.jp/blog/18/aws_lambdarubyaws_reinvent_2018.html'>https://www.publickey1.jp/blog/18/aws_lambdarubyaws_reinvent_2018.html</a></div></div><div class="message" id="message-1543547525.185800"><div class="message__timestamp">2018-11-30<br/>12:12:05 +0900</div><div class="message__header">matsubara0507</div><div class="message__body"><blockquote>このCustom Runtimesに対応したC++とRustの環境をAWSはオープンソースとして公開。さらにPHP、COBOL、Erlangなどのサポートを行うパートナーも発表されました。</blockquote><br/>COBOL すごい</div></div><div class="message" id="message-1543548412.186300"><div class="message__timestamp">2018-11-30<br/>12:26:52 +0900</div><div class="message__header">junji.hashimoto</div><div class="message__body">Haskellがない。</div></div><div class="message" id="message-1543548545.187600"><div class="message__timestamp">2018-11-30<br/>12:29:05 +0900</div><div class="message__header">junji.hashimoto</div><div class="message__body">golangのaws lambdaは<br/><a href='https://golang.org/pkg/net/rpc/'>https://golang.org/pkg/net/rpc/</a><br/>これをつかったTCPのサーバーをたてるだけだから<br/>同じような感じでhaskellも動かせるような気がしています。</div></div><div class="message" id="message-1543548835.189300"><div class="message__timestamp">2018-11-30<br/>12:33:55 +0900</div><div class="message__header">matsubara0507</div><div class="message__body">カスタムランタイムでどんな言語でもできるよ、公式は C++ と Rust の分を作ってOSS化しといたよ<br/>PHP、COBOL、Erlang のもやってくれる人がいるってさ<br/>ぐらいに思ってたので、誰か Haskell やって公開すればいいんですよね</div></div><div class="message" id="message-1543548892.189600"><div class="message__timestamp">2018-11-30<br/>12:34:52 +0900</div><div class="message__header">junji.hashimoto</div><div class="message__body"><a href='https://aws.amazon.com/jp/blogs/opensource/rust-runtime-for-aws-lambda/'>https://aws.amazon.com/jp/blogs/opensource/rust-runtime-for-aws-lambda/</a></div></div><div class="message" id="message-1543548899.189900"><div class="message__timestamp">2018-11-30<br/>12:34:59 +0900</div><div class="message__header">matsubara0507</div><div class="message__body"><a href='https://github.com/awslabs/aws-lambda-rust-runtime'>https://github.com/awslabs/aws-lambda-rust-runtime</a><br/><a href='https://github.com/awslabs/aws-lambda-cpp'>https://github.com/awslabs/aws-lambda-cpp</a></div></div><div class="message" id="message-1543548929.190500"><div class="message__timestamp">2018-11-30<br/>12:35:29 +0900</div><div class="message__header">matsubara0507</div><div class="message__body"><a href='https://docs.aws.amazon.com/ja_jp/lambda/latest/dg/runtimes-custom.html'>https://docs.aws.amazon.com/ja_jp/lambda/latest/dg/runtimes-custom.html</a></div></div><div class="message" id="message-1543549408.191500"><div class="message__timestamp">2018-11-30<br/>12:43:28 +0900</div><div class="message__header">matsubara0507</div><div class="message__body">実行ファイルを zip 化して upload する感じなのかな <blockquote>Custom Runtimes</blockquote></div></div><div class="message" id="message-1543550625.004900"><div class="message__timestamp">2018-11-30<br/>13:03:45 +0900</div><div class="message__header">syocy</div><div class="message__body">AWS Lambda の実行環境は Amazon Linux (CentOS) なので、Amazon Linux 向けにビルドした Haskell バイナリを JavaScript の zip に同梱して node API でキックすれば、今までも実はLambda上で Haskell を動かせないことはなかった。<br/>Custom Runtimeというのが実際何をしてくれるのかは把握していないですが。</div></div><div class="message" id="message-1543555665.005200"><div class="message__timestamp">2018-11-30<br/>14:27:45 +0900</div><div class="message__header">junji.hashimoto</div><div class="message__body">1,  LAMBDAのAPIをたたいてリクエストもらう<br/>2, リクエストに基づいて処理<br/>3, LAMBDAのAPIをたたいて結果を返す<br/>という流れなのですね。<br/>Custom RuntimeというのはLAMBDAのAPI（RESTかなにか）の仕様なんでしょうかね。</div></div><div class="message" id="message-1543568164.005900"><div class="message__timestamp">2018-11-30<br/>17:56:04 +0900</div><div class="message__header">its_out_of_tune</div><div class="message__body">:tune: </div></div><div class="message" id="message-1543568186.006600"><div class="message__timestamp">2018-11-30<br/>17:56:26 +0900</div><div class="message__header">its_out_of_tune</div><div class="message__body">（igrepさんに「ちゃんとHaskellerしてください」と怒られた気がする）</div></div><div class="message" id="message-1543569623.008600"><div class="message__timestamp">2018-11-30<br/>18:20:23 +0900</div><div class="message__header">cosmiafu</div><div class="message__body">Haskell は dlopen みたいな機能あるかなあ？もしあったら汎用的な Runtime を作れるかもしれないなあ</div></div><div class="message" id="message-1543569821.009600"><div class="message__timestamp">2018-11-30<br/>18:23:41 +0900</div><div class="message__header">cosmiafu</div><div class="message__body">plugins というpackageを知ってるけど、でもGHCを必要から、ばかでかくなっちゃう。。。</div></div><div class="message" id="message-1543569895.010600"><div class="message__timestamp">2018-11-30<br/>18:24:55 +0900</div><div class="message__header">igrep</div><div class="message__body">完全にGHCのランタイムから分離させたものは難しいでしょうね。。。 :disappointed:</div></div><div class="message" id="message-1543570329.012700"><div class="message__timestamp">2018-11-30<br/>18:32:09 +0900</div><div class="message__header">cosmiafu</div><div class="message__body">Haskell コード同士で FFI を使うという邪道を考えてみた ww :joy:</div></div><div class="message" id="message-1543570451.014100"><div class="message__timestamp">2018-11-30<br/>18:34:11 +0900</div><div class="message__header">igrep</div><div class="message__body">確かGHCでビルドしたsoファイルをGHCでforeign importするのはできなかったはず（多分、ランタイムの何かが衝突してしまうから）なので、同じ理由でそれも難しそう。。。 :sweat_smile:</div></div><div class="message" id="message-1543570547.014200"><div class="message__timestamp">2018-11-30<br/>18:35:47 +0900</div><div class="message__header">cosmiafu</div><div class="message__body">rts 二人分で喧嘩しちゃうってこと？</div></div><div class="message" id="message-1543570901.014400"><div class="message__timestamp">2018-11-30<br/>18:41:41 +0900</div><div class="message__header">igrep</div><div class="message__body">はい、 <a href='https://downloads.haskell.org/~ghc/8.4.4/docs/html/users_guide/shared_libs.html#shared-libraries-that-export-a-c-api'>https://downloads.haskell.org/~ghc/8.4.4/docs/html/users_guide/shared_libs.html#shared-libraries-that-export-a-c-api</a> のWarningで言っていることはそういう意味のはず。</div></div><div class="message" id="message-1543570968.014600"><div class="message__timestamp">2018-11-30<br/>18:42:48 +0900</div><div class="message__header">cosmiafu</div><div class="message__body">hmmm</div></div><div class="message" id="message-1543571156.014800"><div class="message__timestamp">2018-11-30<br/>18:45:56 +0900</div><div class="message__header">igrep</div><div class="message__body">... あ、と思ったけど、すぐ上のセクションで書いてある、 Shared libraries for Haskell packages の方法ならHaskellで書かれたパッケージをHaskellのプログラムからdynamic linkできるみたいですね。すみません。</div></div><div class="message" id="message-1543571320.015000"><div class="message__timestamp">2018-11-30<br/>18:48:40 +0900</div><div class="message__header">cosmiafu</div><div class="message__body">:thinking_face:明日ちょっといじってみよう。。。</div></div><div class="message" id="message-1543571926.015700"><div class="message__timestamp">2018-11-30<br/>18:58:46 +0900</div><div class="message__header">cosmiafu</div><div class="message__body">でもよく考えたらそうやるメリットが全然ない。。。</div></div><div class="message" id="message-1543582608.016700"><div class="message__timestamp">2018-11-30<br/>21:56:48 +0900</div><div class="message__header">takenobu.hs</div><div class="message__body">WebAssemblyのイメージ図集を描きました。<br/>HaskellもWebAssemblyのバックエンド(Asteriusやdhc)があるので、ここでも共有しておきます:slightly_smiling_face:<br/>（ちょっと忙しくなりそうなので、現バージョンでopenしました。理解ミス箇所等は今後修正します。）<br/>ちなみに、WebAssemblyのreference interpreterは、OCaml製です。<br/><br/><a href='https://takenobu-hs.github.io/downloads/WebAssembly_illustrated.pdf'>https://takenobu-hs.github.io/downloads/WebAssembly_illustrated.pdf</a></div></div><div class="message" id="message-1543583128.018300"><div class="message__timestamp">2018-11-30<br/>22:05:28 +0900</div><div class="message__header">yharuhi39</div><div class="message__body">そういえば、haskell(ghc)は、llvmを吐けるからそれ経由でwasmにできないかなとか思ったけどどうなのかな</div></div><div class="message" id="message-1543587714.018600"><div class="message__timestamp">2018-11-30<br/>23:21:54 +0900</div><div class="message__header">takenobu.hs</div><div class="message__body">asteriusは、GHCから(LLVMを経ずに直接)Binaryen経由でwasmを吐かせているようです。<br/><a href='https://github.com/tweag/asterius'>https://github.com/tweag/asterius</a><br/><br/>ただ、原理的にはLLVMに持ち込めれば、Binaryen経由でwasmは吐けるのかなと思います。<br/>（LLVM自体がwasm用のバックエンドにBinaryenを使ってるようでした。）<br/><br/>ただ、ランタイムの部分をどうするかが、結構みなさんの工夫と腕力の見せ所のようです。<br/>asteriusは、GHCのランタイムの軽量版をwasm（とJavaScript）で自力で書いたようです。<br/>なかなか凄い腕力です！:star2:</div></div><div class="message" id="message-1543587994.020800"><div class="message__timestamp">2018-11-30<br/>23:26:34 +0900</div><div class="message__header">yharuhi39</div><div class="message__body">さすがはtweag 変態さんってことですね^^</div></div><div class="message" id="message-1543593488.022000"><div class="message__timestamp">2018-12-01<br/>00:58:08 +0900</div><div class="message__header">a_kirisaki</div><div class="message__body">[fpco/stack-build](<https://hub.docker.com/r/fpco/stack-build/>) がめちゃ重だったので小さめのDockerイメージ作ってみました：kirisaki/overflow - Docker Hub <a href='https://hub.docker.com/r/kirisaki/overflow/'>https://hub.docker.com/r/kirisaki/overflow/</a></div></div><div class="message" id="message-1543624417.022600"><div class="message__timestamp">2018-12-01<br/>09:33:37 +0900</div><div class="message__header">igrep</div><div class="message__body">なんでoverflowっていうんですか？</div></div><div class="message" id="message-1543624575.023000"><div class="message__timestamp">2018-12-01<br/>09:36:15 +0900</div><div class="message__header">igrep</div><div class="message__body">記憶が曖昧なんですが、wasmって使用できる命令はじめいろいろ制限が厳しいので、単純にGHCが吐いたLLVMを変換できるかは怪しかったかと思います。 :disappointed:</div></div><div class="message" id="message-1543632645.023600"><div class="message__timestamp">2018-12-01<br/>11:50:45 +0900</div><div class="message__header">takenobu.hs</div><div class="message__body">確かに。 例えば、単純なgotoが使えないので、asteriusは tail callをwasmで工夫して実装してるようでした:muscle:</div></div><div class="message" id="message-1543640798.024900"><div class="message__timestamp">2018-12-01<br/>14:06:38 +0900</div><div class="message__header">cosmiafu</div><div class="message__body"></div></div><div class="message" id="message-1543640936.027000"><div class="message__timestamp">2018-12-01<br/>14:08:56 +0900</div><div class="message__header">cosmiafu</div><div class="message__body">昨日話したHaskell同士でFFIで実行したい話し、なんとか出来たみたいけどが、join $ mkFun &lt;$&gt; dlsym dl "library_close" の一行を実行したらなぜか <code>main</code> が実行終わったらSegmentation fault: 11になっちゃう。。。</div></div><div class="message" id="message-1543640967.027400"><div class="message__timestamp">2018-12-01<br/>14:09:27 +0900</div><div class="message__header">cosmiafu</div><div class="message__body">でも流石に実用性が皆無かなあ。。。</div></div><div class="message" id="message-1543641377.027800"><div class="message__timestamp">2018-12-01<br/>14:16:17 +0900</div><div class="message__header">a_kirisaki</div><div class="message__body">stackなので</div></div><div class="message" id="message-1543641685.030300"><div class="message__timestamp">2018-12-01<br/>14:21:25 +0900</div><div class="message__header">cosmiafu</div><div class="message__body">ちなみに、単にlibraryをLoadして何もしないのもSegmentation fault: 11。。。やはりあのGHCの制限みたい。。。逆に、Initializeだけするならエラーなく実行できるのはちょっと不思議。。。</div></div><div class="message" id="message-1543641713.030400"><div class="message__timestamp">2018-12-01<br/>14:21:53 +0900</div><div class="message__header">matsubara0507</div><div class="message__body">なるほどw</div></div><div class="message" id="message-1543642857.030700"><div class="message__timestamp">2018-12-01<br/>14:40:57 +0900</div><div class="message__header">igrep</div><div class="message__body">小さくするためにどんな工夫をしたんでしょ？</div></div><div class="message" id="message-1543643458.031100"><div class="message__timestamp">2018-12-01<br/>14:50:58 +0900</div><div class="message__header">a_kirisaki</div><div class="message__body">イメージにdebian:stretch使いました。あとstack-buildではいろいろ他にも入ってたみたいなので必要最低限に絞ったり</div></div><div class="message" id="message-1543671950.031600"><div class="message__timestamp">2018-12-01<br/>22:45:50 +0900</div><div class="message__header">yukimemi</div><div class="message__body">@yukimemi has joined the channel</div></div><div class="message" id="message-1543704166.032000"><div class="message__timestamp">2018-12-02<br/>07:42:46 +0900</div><div class="message__header">takenobu.hs</div><div class="message__body">GHCのホスティングを、TracからGitLabへ移す先行テストが始まります:haskell:<br/>（GitHubのアカウントがあれば、GitLabへログインして試せます。）<br/><a href='https://mail.haskell.org/pipermail/ghc-devs/2018-December/016613.html'>https://mail.haskell.org/pipermail/ghc-devs/2018-December/016613.html</a></div></div><div class="message" id="message-1543706270.032500"><div class="message__timestamp">2018-12-02<br/>08:17:50 +0900</div><div class="message__header">hexirp</div><div class="message__body">‪Haskell のソースコードの複雑性を、型チェックの際のユニフィケーションの数で測ることを考えたことがあるんだけど、実現できそうですかね‬</div></div><div class="message" id="message-1543706302.033500"><div class="message__timestamp">2018-12-02<br/>08:18:22 +0900</div><div class="message__header">hexirp</div><div class="message__body">意図しているところは (&lt;$&gt;) &lt;$&gt; (&lt;$&gt;) みたいなコードを排除すること</div></div></div><div class="pager"><a href="/slack-log/html/C4M4TT8JJ/30.html" class="pager__previous">Previous</a><a href="/slack-log/" class="pager__top">Top</a><a href="/slack-log/html/C4M4TT8JJ/32.html" class="pager__next">Next</a></div></body></html>