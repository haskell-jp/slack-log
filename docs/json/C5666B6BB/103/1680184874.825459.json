[
    {
        "type": "message",
        "user": "UL1HFJATE",
        "ts": "1680184874.825459",
        "text": "<ttps://haskell-jp.slack.com/archives/CL3AXB1AL/p1680155886899719|https://haskell-jp.slack.com/archives/CL3AXB1AL/p1680155886899719> の関係で `strict-wrapper` のコード (<https://github.com/tomjaguarpaw/strict-wrapper/blob/48a2695995a4c4c9d853b5f45175f6cf1241ebb2/lib/Data/Strict/Wrapper.hs#LL223-L262>) を読んでたんですが，ここの `strict` と `unstrict` 関数が怖いことをしていると思うので，皆様のご意見を伺いたいです．参照先のコードは大体\n\n```data SPair a b = SPair !a !b\n\nstrict :: (a, b) -&gt; SPair a b\nstrict x = case x of\n  (!_, !_) -&gt; unsafeCoerce x\n\nunstrict :: SPair a b -&gt; (a, b)\nunstrict = unsafeCoerce```\nのようなことをしており，これって `SPair a b` と `(a, b)` の runtime representation が完全に一致しているということを主張している気がするんですが，そんな保証ってありましたっけ…？"
    },
    {
        "type": "message",
        "user": "U578W9676",
        "ts": "1680187369.961749",
        "text": "データコンストラクターの `SPair` を export せずに `SPair a b` 型の値は必ず `strict` によって生成されるようにすることで、内部表現が `(a, b)` と同じだという保証を得ているんじゃないでしょうか :thinking_face:\n\nスマートコンストラクターパターンですかね。\n<https://wiki.haskell.org/Smart_constructors>"
    },
    {
        "type": "message",
        "user": "UL1HFJATE",
        "ts": "1680188007.370889",
        "text": "そっちだけのexportなら私も不審には思わなかったんですけど、\n\n```constructStrict (x, y) = SPair x y```\nもexportしているので…"
    }
]