[
    {
        "ts": "1556349500.003300",
        "text": "```\ntype PersonParams (f :: * -&gt; *) (g :: * -&gt; *) =\n  Field Identity :*\n  '[ \"name\" &gt;: f Text\n   , \"age\" &gt;: g Int\n   ]\n```\n↓\n```\ntype PersonRequiredParams (f :: * -&gt; *) =\n  Field f :*\n  '[ \"name\" &gt;: Text\n   ]\n\ntype PersonOptionalParams (g :: * -&gt; *) =\n  Field g :*\n  '[ \"age\" &gt;: Int\n   ]\n```",
        "user": "U4LNDESN8",
        "type": "message"
    },
    {
        "ts": "1556349695.003700",
        "text": "`h *: xs` の `xs` のなかに入っているファンクタをフィルターしながら `h` の方に上げたいのです。",
        "user": "U4LNDESN8",
        "type": "message"
    },
    {
        "ts": "1556350546.004200",
        "text": "なるほど、勘違いしてたw\n例えば `PersonParams -&gt; PersonOptionalParams` であれば Nullable の `wrench` に近いやもしれません。\n<http://hackage.haskell.org/package/extensible-0.5/docs/Data-Extensible-Nullable.html#v:wrench>\n参考になるかも",
        "user": "U56L7EVNY",
        "type": "message"
    },
    {
        "ts": "1556351109.004500",
        "text": "`wrench` は `h` に作用するだけなので、 `xs` が不変でないと使えないのです。。。",
        "user": "U4LNDESN8",
        "type": "message"
    },
    {
        "ts": "1556351171.004700",
        "text": "難しいのは `xs` が変わってしまう点ですね。",
        "user": "U4LNDESN8",
        "type": "message"
    },
    {
        "ts": "1556351391.005000",
        "text": "気分的にはこんな感じのコンストレイントが書けないかな、と。\n`(xs ~ [f x1, g x2, f x3], ys ~ [x1, x3], Include xs (f * ys))`",
        "user": "U4LNDESN8",
        "type": "message"
    },
    {
        "ts": "1556358682.005200",
        "text": "それっぽいのできた\n<https://gist.github.com/matsubara0507/0beb24c885585089caa4b769f6a1b1a9>",
        "user": "U56L7EVNY",
        "type": "message"
    },
    {
        "ts": "1556358886.005400",
        "text": "```\n$ ghci\n&gt;&gt;&gt; :set -XOverloadedLabels\n&gt;&gt;&gt; import Lens.Micro\n&gt;&gt;&gt; a = liftRecord person :: PersonRequiredParams\n&gt;&gt;&gt; a ^. #name\n\"alice\"\n```",
        "user": "U56L7EVNY",
        "type": "message"
    },
    {
        "ts": "1556378758.005700",
        "text": "おお、ありがとうございます。見てみます。",
        "user": "U4LNDESN8",
        "type": "message"
    },
    {
        "ts": "1556430312.005900",
        "text": "今更ながら。開発中の古い資料なんで実際はどうか分かりませんが、こんなのがありました。\n当初はビルド時の入力のハッシュ値をとるというプランだったみたいですが、なんかいろいろ試行錯誤してたみたいですね…\n\n<https://www.haskell.org/wikiupload/5/50/Hiw2012-philipp-schuster.pdf>",
        "user": "U4LGTMTMK",
        "type": "message"
    },
    {
        "ts": "1556506761.013400",
        "text": "`aeson` についてなんですが\n\nFoo型を表すJSONとして\n\n`{ \"a\":100, \"b\":200}`\n\nが与えられる場合\n\n```\ndata Foo = Foo { a :: Int, b :: Int} deriving Generic\ninstance FromJSON Foo\n```\n\nのようにして簡単に実装できるのですが。\nレコード b が省略されているときはb に50が入ってるものだと過程する。\nみたいな場合はbの型をMaybe Int にするしかないのでしょうか？\nもちろん手書きすればいいのはわかるのですが。\nデフォルト値を与えられたりしないでしょうか？",
        "user": "U9XHWQX7Z",
        "type": "message"
    },
    {
        "ts": "1556511638.013500",
        "text": "一つの型では難しいんじゃないっすかね。\n一旦 `Maybe Int` として読んでから変換するとか。",
        "user": "U4LGTMTMK",
        "type": "message"
    },
    {
        "ts": "1556511892.014000",
        "text": ":bulb: あとは `FomJSON` を別途実装した `newtype` で囲うとか\n\n```\nnewtype Default50 = Default50 :: Int\ninstance FromJSON Default50 where\n  parseJSON = withScientific ...\n```",
        "user": "U4LGTMTMK",
        "type": "message"
    },
    {
        "ts": "1556511911.014200",
        "text": "ｆｍｆｍ Maybe Int 経由するのが無難ですかね？:sweat: まぁしょうがないか。 回答どうもです！",
        "user": "U9XHWQX7Z",
        "type": "message"
    },
    {
        "ts": "1556512002.014400",
        "text": "あ。 `newtype` 使う作戦もありなのか。そっちにしよっと :smile:",
        "user": "U9XHWQX7Z",
        "type": "message"
    },
    {
        "ts": "1556513170.014800",
        "text": "Stackoverflowに関係ありそうな質問がありました。FromJSONとデフォルトの値を持つ型クラスを満たすnewtypeでラップするという戦略のようです。\n<https://stackoverflow.com/questions/26683693/aeson-generics-with-default-values>",
        "user": "U59GW4U4T",
        "type": "message"
    },
    {
        "ts": "1556515042.015300",
        "text": "完全にオーバーウェポンって感じだけど extensible の Nullable を駆使すればそれっぽいのを実現できる気がする",
        "user": "U56L7EVNY",
        "type": "message"
    },
    {
        "ts": "1556515875.015600",
        "text": "`Maybe` な `RecordOf` 作って各フィールドごとに `&lt;|&gt;` を適用させるってのをやってましたね。そんで最後に `htraverse` で `Nothing` が1つでもあれば全体として `mzero` になるみたいな",
        "user": "U7155GPR9",
        "type": "message"
    },
    {
        "ts": "1556516038.015900",
        "text": "できた\n<https://gist.github.com/matsubara0507/0d0fe2fa59171547ee438dacb0cf6d9c>",
        "user": "U56L7EVNY",
        "type": "message"
    },
    {
        "ts": "1556516136.016100",
        "text": "```\n$ ghci\n&gt;&gt;&gt; :set -XOverloadedStrings\n&gt;&gt;&gt; import Data.Aeson\n&gt;&gt;&gt; decode \"{ \\\"a\\\": 1, \\\"b\\\": 2 }\" :: Maybe Foo\nJust (a @= 1 &lt;: b @= 2 &lt;: nil)\n&gt;&gt;&gt; decode \"{ \\\"a\\\": 1 }\" :: Maybe Foo\nNothing\n&gt;&gt;&gt; decode \"{ \\\"a\\\": 1 }\" :: Maybe Foo'\nJust (Nullable {getNullable = Just (a @= 1)} &lt;: Nullable {getNullable = Nothing} &lt;: nil)\n&gt;&gt;&gt; fromNullable defaultFoo &lt;$&gt; decode \"{ \\\"a\\\": 1 }\" :: Maybe Foo\nJust (a @= 1 &lt;: b @= 50 &lt;: nil)\n```",
        "user": "U56L7EVNY",
        "type": "message"
    },
    {
        "ts": "1556516206.016600",
        "text": "ただデフォルト値なしはできないけど。。。もう少し工夫すればできる気もするが",
        "user": "U56L7EVNY",
        "type": "message"
    }
]