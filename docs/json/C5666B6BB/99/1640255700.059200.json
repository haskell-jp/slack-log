[
    {
        "ts": "1640255700.059200",
        "text": "Sum Typeに対するLensのフィールドを自動生成する方法について質問です。\n(多分日本語を含むのでバイナリ扱いされている)スニペットに詳細を書いてあるように、\n\n```deriveFieldsForSumType ''HasBase ''ToyExpr```\nのように書いたら、\n\n```instance HasBase ToyExpr Text where\n  base = lens getter setter\n    where getter (ToyExprToyInt x) = view base x\n          getter (ToyExprToyStr x) = view base x\n\n          setter (ToyExprToyInt x) y = toToyExpr $ set base y x\n          setter (ToyExprToyStr x) y = toToyExpr $ set base y x```\nのようなコードが自動生成されると嬉しいなと思っています。\n\n軽く探した所そういうライブラリは見当たらなかったので、\n自分で書こうとも思っていますが、\nTemplate Haskellはそんなに得意では無いので、\n既存のライブラリがあったり、\nそもそも他の方法を使えばボイラープレート書かなくても良いなどという指摘があれば欲しいと思っています。",
        "user": "U57CUMWQ6",
        "type": "message"
    },
    {
        "ts": "1640327804.059300",
        "text": "こちら、概ね自分で書けてきた感じがします。",
        "user": "U57CUMWQ6",
        "type": "message"
    },
    {
        "ts": "1640329293.059500",
        "text": "求めている機能はジェネリクスやTHで実装できるとは思いますが、baseに相当する値が入っていることがあらかじめ保証された型を使うのが定石だと思います。data ExprF a = Lit Literal | App a aのようなFunctorとdata Cofree f a = a :&lt; f (Cofree f a)を使ってASTを定義すれば、Cofree ExprF Textは各ノードに必ずTextが入っていることが保証され、さらに型などのアノテーションに応用することも容易です",
        "user": "U4KUNQF9N",
        "type": "message"
    },
    {
        "ts": "1640330406.059700",
        "text": "前提知識が足りていないからかちゃんと物事を理解しているか自信が全く無いのですが、\nそれは一部のツリーには共通したフィールドがあるけど、\n他のツリーではそうでもないという場合でも応用可能ですか?\n\n業務の問題の無いコード部分許可とって持って来ればよかった気がしますが、\n例えば、\nMyStrを更に分割して、UTF-8, UTF-16, UTF-32のそれぞれの文字列型のSum Typeにします。\nそこでMyStrに対しては文字列に共通する、\n文字列の容量のlengthを共通のlensのアクセサとしてアクセスできるようにします。\nそしてMyExprからは一発でlengthは取れないが、\nMyStrまで分解したらそれ以上のパターンマッチ無しでアクセサでアクセスできるようにしたいという感じです。\nこういった場合でもその定石は使えるものなのでしょうか。",
        "user": "U57CUMWQ6",
        "type": "message"
    },
    {
        "ts": "1640356236.059900",
        "text": "そのlengthのアクセサを使って何らかの値をセットしたとき、どのような挙動をしますか？",
        "user": "U4KUNQF9N",
        "type": "message"
    },
    {
        "ts": "1640356347.060100",
        "text": "単純にパターンマッチしてセットを行ったデータをセットしたのと同じで、値が更新されたデータが帰ってきます",
        "user": "U57CUMWQ6",
        "type": "message"
    },
    {
        "ts": "1640356455.060300",
        "text": "すみません、理解できないです。lengthのアクセサを使って\"hello, world\"に4をセットしたらどうなりますか？",
        "user": "U4KUNQF9N",
        "type": "message"
    },
    {
        "ts": "1640356543.060600",
        "text": "…あー、確かにおかしな話をしてしまいました\n文字列バリアントに無理に共通のデータフィールドを考えて長さぐらいしか思いついてなかったので無茶なことを言っていました",
        "user": "U57CUMWQ6",
        "type": "message"
    },
    {
        "ts": "1640356983.060800",
        "text": "実際、プロダクトコードでは構築時にはそれぞれデータ型を作って、Sum Typeをたくさん含むツリーを構築し終わったあとに、中間レイヤーでサクッと、この例ではbaseだけを出して文字列リストとして見るとか、基本的に読み出し専用で使うことが多いです",
        "user": "U57CUMWQ6",
        "type": "message"
    },
    {
        "ts": "1640357811.061000",
        "text": "コメントが全く理解できなかったのでコードだけ見るとだいたい何をしたいのか想像できました。ToyExprにHasBaseを持たないコンストラクタを追加した場合、Lensは定義できなくなります(Traversalにはできます)。そして、HasBaseのインスタンスがあるかどうかは、THはもちろんそのモジュールをコンパイルしている段階では通常知りえない情報なので、そのTraversalはToyExprに対するパターンマッチによって実装すべきだと思います。`ContainsBase :: Type -&gt; Bool`なる型族を定義すればTraversalの対象になるかどうか決められるため、ジェネリクスによる導出も可能になりますが、ほとんどの場合は割りに合わないでしょう",
        "user": "U4KUNQF9N",
        "type": "message"
    },
    {
        "ts": "1640359706.061300",
        "text": "やっぱり業務とちょっと違う技術的に近い例え話を行うのは困難だったことを感じています…\nToyExprにHasBaseを持たないコンストラクタを追加するのではなく、Sum TypeであるToyExprの下位のToyStrが更にToyStrUtf8とかのSum Typeであるとかの想定で、ToyExprは共通するlengthフィールドを持たないけれどToyStrは共通するlengthフィールドを持つ場合部分的に統一アクセスは出来るかみたいな事を言っていました。",
        "user": "U57CUMWQ6",
        "type": "message"
    }
]