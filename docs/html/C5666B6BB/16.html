<!DOCTYPE html><html><head><meta charset="utf-8"><title>haskell-jp / questions #16</title><link rel="stylesheet" href="/slack-log/messages.css" type="text/css" media="screen"></head><body><h1>haskell-jp / questions #16</h1><div class="pager"><a href="/slack-log/html/C5666B6BB/15.html" class="pager__previous">Previous</a><a href="/slack-log/" class="pager__top">Top</a><a href="/slack-log/html/C5666B6BB/17.html" class="pager__next">Next</a></div><div class="message_list"><div class="message" id="message-1520860256.000049"><div class="message__timestamp">2018-03-12<br/>22:10:56 +0900</div><div class="message__header">tenimusubumizuniyador</div><div class="message__body">@tenimusubumizuniyador has joined the channel</div></div><div class="message" id="message-1520997879.000079"><div class="message__timestamp">2018-03-14<br/>12:24:39 +0900</div><div class="message__header">kayhide</div><div class="message__body"><code>machinecell</code> について質問です。<br/><a href='https://hackage.haskell.org/package/machinecell'>https://hackage.haskell.org/package/machinecell</a><br/><br/>複数のストリームが同時に流れることがあると思うのですが、その場合、複数スレッドで並行（？）処理されるような機能はありますでしょうか？<br/>readme に parallel という文字が見えるのですが、それがどういう意味なのかいまいちつかめず・・・</div></div><div class="message" id="message-1520998870.000153"><div class="message__timestamp">2018-03-14<br/>12:41:10 +0900</div><div class="message__header">as_capabl</div><div class="message__body">どうもです。そこのparallelという単語は、単にArrowの <code>(***)</code> 演算子が平行に射を合成するよ、という意味で使っているもので、並列演算の意味ではないんですね。パッケージの標準機能としては、マルチスレッド的なものは提供していません。</div></div><div class="message" id="message-1520999077.000090"><div class="message__timestamp">2018-03-14<br/>12:44:37 +0900</div><div class="message__header">as_capabl</div><div class="message__body">並行処理対応としては、Pipes.Concurrentのspawnに相当する機能を試験実装していたりします(今作っているアプリのコードにこっそり入っている)。 <a href='https://github.com/as-capabl/armageddon/blob/53004f980f17eea5c6ea38a8c5ea53d2ead264e9/machinecell-extra/src/Control/Arrow/Machine/World.hs#L487'>https://github.com/as-capabl/armageddon/blob/53004f980f17eea5c6ea38a8c5ea53d2ead264e9/machinecell-extra/src/Control/Arrow/Machine/World.hs#L487</a></div></div><div class="message" id="message-1521002869.000002"><div class="message__timestamp">2018-03-14<br/>13:47:49 +0900</div><div class="message__header">kayhide</div><div class="message__body">あ、作者さんだ！<br/>回答ありがとうございます！</div></div><div class="message" id="message-1521002955.000157"><div class="message__timestamp">2018-03-14<br/>13:49:15 +0900</div><div class="message__header">kayhide</div><div class="message__body">マルチスレッド的な事情については了解しました。</div></div><div class="message" id="message-1521002967.000186"><div class="message__timestamp">2018-03-14<br/>13:49:27 +0900</div><div class="message__header">kayhide</div><div class="message__body">試験実装の方、おもしろそうですね！</div></div><div class="message" id="message-1521022633.000006"><div class="message__timestamp">2018-03-14<br/>19:17:13 +0900</div><div class="message__header">ncaq</div><div class="message__body">とりあえずコンパイルが通るコードが無いと何をしたいのかわからない<br/>引数を([Bool], Int) -&gt; xにするぐらいなら[Bool] -&gt; Int -&gt; xにした方が良さそうですが<br/>そもそもこの[Bool]必要なのか疑問</div></div><div class="message" id="message-1521197380.000419"><div class="message__timestamp">2018-03-16<br/>19:49:40 +0900</div><div class="message__header">1to100pen</div><div class="message__body">Slack上の「Haskell入門 関数型プログラミング言語の基礎と実践」読書会で<br/>「transformersパッケージと mtlパッケージの違いはなんだろう」<br/>という疑問が出てました。<br/><a href='https://umekitahs.slack.com/'>https://umekitahs.slack.com/</a></div></div><div class="message" id="message-1521209862.000265"><div class="message__timestamp">2018-03-16<br/>23:17:42 +0900</div><div class="message__header">syocy</div><div class="message__body">transformers と mtl の歴史的なことは <a href='https://wiki.haskell.org/Monad_Transformer_Library'>https://wiki.haskell.org/Monad_Transformer_Library</a> にまとまっているようです。これは私のブログ (<http://syocy.hatenablog.com/entry/haskell-library-2016>) にも書いたことがあり、孫引きしてしまうと、<br/><br/><blockquote> まず初期にmtl(mtl V1)があり、その後に新機能のtype familiesを用いたmtl-tfが開発されたものの mtlと重複した部分が多く互換性もなかった。 そこで拡張なしの素のHaskell98で動くtransformersが開発され、 その上にmonads-fdとmonads-tfを別々に構築することで互換性の問題は解決された。 しかしその頃にはすでにmtlが広く使われていたため、transformersとmonads-fdからmtlを再構築(mtl V2)することになった、 という経緯のようです。</blockquote><br/>実際的な違いは、transformers はより古い Haskell で動く、mtl はより洗練された API を持っている、ということになりそうです。</div></div><div class="message" id="message-1521245351.000002"><div class="message__timestamp">2018-03-17<br/>09:09:11 +0900</div><div class="message__header">brackss1</div><div class="message__body">Extensible Effectが保持するモナド数によらずに定数時間で処理できるのはなぜなんですか?(この記事です <a href='https://konn-san.com/prog/haskell/extensible-effects.html'>https://konn-san.com/prog/haskell/extensible-effects.html</a></div></div><div class="message" id="message-1521274227.000077"><div class="message__timestamp">2018-03-17<br/>17:10:27 +0900</div><div class="message__header">1to100pen</div><div class="message__body">ありがとうございます。「Haskell入門 関数型プログラミング言語の基礎と実践」読書会に伝えてこちらの slack のことも宣伝しておきます。</div></div><div class="message" id="message-1521335256.000057"><div class="message__timestamp">2018-03-18<br/>10:07:36 +0900</div><div class="message__header">kakkun61</div><div class="message__body">2つのライブラリーがあって、 <code>MonadError SomeException m =&gt; m a</code> な文脈の中で <code>MonadThrow m =&gt; m a</code> な関数を使いたくなったんですが、混ぜるハックありますかね？<br/><pre>
foo :: MonadError SomeException m =&gt; m a
foo = do
  -- ここで使いたい
  -- 型はライブラリー A で決まってある

bar :: MonadThrow m =&gt; m a
-- これを使いたい
-- 型はライブラリー B で決まってある
</pre></div></div><div class="message" id="message-1521336466.000060"><div class="message__timestamp">2018-03-18<br/>10:27:46 +0900</div><div class="message__header">mizunashi-mana</div><div class="message__body">まず、MonadErrorとはmtlのでしょうか？</div></div><div class="message" id="message-1521336587.000059"><div class="message__timestamp">2018-03-18<br/>10:29:47 +0900</div><div class="message__header">mizunashi-mana</div><div class="message__body">それから、これの意図はMonadThrowのthrowMをMonadErrorのthrowErrorにするようにしたいということでしょうか？</div></div><div class="message" id="message-1521341144.000061"><div class="message__timestamp">2018-03-18<br/>11:45:44 +0900</div><div class="message__header">kakkun61</div><div class="message__body"><blockquote>MonadErrorとはmtlのでしょうか？</blockquote>そうです<br/>それから <code>MonadThrow</code> は exceptions のです</div></div><div class="message" id="message-1521341190.000068"><div class="message__timestamp">2018-03-18<br/>11:46:30 +0900</div><div class="message__header">kakkun61</div><div class="message__body"><blockquote>これの意図はMonadThrowのthrowMをMonadErrorのthrowErrorにするようにしたいということでしょうか？</blockquote>そうですね。例えば一旦捕えて投げ直すとか。</div></div><div class="message" id="message-1521341881.000032"><div class="message__timestamp">2018-03-18<br/>11:58:01 +0900</div><div class="message__header">mizunashi-mana</div><div class="message__body">MonadErrorはパラメータeが必要な気がするんですが、そこにはSomeExceptionを当てはめる想定ですか？</div></div><div class="message" id="message-1521343389.000054"><div class="message__timestamp">2018-03-18<br/>12:23:09 +0900</div><div class="message__header">kakkun61</div><div class="message__body">おっとそうでした。元の投稿を直しました。</div></div><div class="message" id="message-1521350658.000036"><div class="message__timestamp">2018-03-18<br/>14:24:18 +0900</div><div class="message__header">mizunashi-mana</div><div class="message__body">either throwM pure (bar :: Either SomeException a)<br/><br/>or<br/><br/>newtype MonadThrowWrapper m a = W (m a) deriving (Functor, Applicative, Monad)<br/>instance MonadError SomeException m =&gt; MonadThrow (MonadThrowWrapper m) where<br/>  throwM = W . throwError . toException<br/>monadThrowToError :: forall me a. MonadError SomeException me =&gt; (forall mt. MonadThrow mt =&gt; mt a) -&gt; me a<br/>monadThrowToError x = coerce (x @(MonadThrowWrapper me))<br/><br/>monadThrowToError bar</div></div><div class="message" id="message-1521350831.000003"><div class="message__timestamp">2018-03-18<br/>14:27:11 +0900</div><div class="message__header">mizunashi-mana</div><div class="message__body">とかですかね？</div></div><div class="message" id="message-1521367218.000039"><div class="message__timestamp">2018-03-18<br/>19:00:18 +0900</div><div class="message__header">kakkun61</div><div class="message__body">下の方を参考にうまくいきましたー！ :muscle:</div></div><div class="message" id="message-1521369295.000060"><div class="message__timestamp">2018-03-18<br/>19:34:55 +0900</div><div class="message__header">mizunashi-mana</div><div class="message__body">なんかスマフォから打ってめっちゃ間違ってたのと書きかけだったので，いちよ修正しときました</div></div><div class="message" id="message-1521449331.000049"><div class="message__timestamp">2018-03-19<br/>17:48:51 +0900</div><div class="message__header">as_capabl</div><div class="message__body">論文をちゃんと読んでなくて、実装だけで理解してるので、もしかしたら不正確かもしれませんが…<br/>たとえば、以下のようにMaybeモナドがたくさん重なったものを考えます。<br/><br/><pre>
type M5 = MaybeT (MaybeT (MaybeT (MaybeT Maybe)))
</pre><br/><br/>これのreturnとbind(&gt;&gt;=)を書き下してやると、重ねたモナドの数だけ型構築や型分解のコストが増えている事が分かります。<br/><br/><pre>
returnM5 :: a -&gt; M5 a
returnM5 x= MaybeT $ MaybeT $ MaybeT $ MaybeT $ Just $ Just $ Just $ Just $ Just x

bindM5 :: M5 a -&gt; (a -&gt; M5 b) -&gt; M5 b
bindM5 x = 
  case x of
    Nothing -&gt; MaybeT $ MaybeT $ MaybeT $ MaybeT $ Nothing
    Just x -&gt;
      case x of
        Nothing -&gt; MaybeT $ MaybeT $ MaybeT $ MaybeT $ Just $ Nothing
        Just x -&gt; ...</pre><br/><br/>一方で、EEではOpen Unionという仕組みを使って、以下のようなデータ型をコンパイル時に生成します。<br/><br/><pre>
data M5' a = Just' a | Nothing1 | Nothing2 | Nothing3 | Nothing4 | Nothing5
</pre><br/><br/>これによって、いくら重ねるモナドが増えても型構築や型分解のコストが増えない、という訳です。</div></div><div class="message" id="message-1521449361.000372"><div class="message__timestamp">2018-03-19<br/>17:49:21 +0900</div><div class="message__header">as_capabl</div><div class="message__body">モナド→モナド変換子、ですね</div></div><div class="message" id="message-1521506318.000196"><div class="message__timestamp">2018-03-20<br/>09:38:38 +0900</div><div class="message__header">brackss1</div><div class="message__body">階層になっていないから深く潜るためのコストがいらないってことですか。open-unionはただのunionとなにか違うんですか?</div></div><div class="message" id="message-1521518478.000101"><div class="message__timestamp">2018-03-20<br/>13:01:18 +0900</div><div class="message__header">as_capabl</div><div class="message__body">普通のunionというのは、Haskellの普通の和型、data T = A|B|Cのように、宣言の時点で要素を足し算して作る奴の事で、それに対してEE系パッケージに入っているopen-union(単にUnionとかの名前になっている事が多い)は「全体の型を明示せずに構築したりパターンマッチしたりできる」という特徴があります</div></div><div class="message" id="message-1521520183.000126"><div class="message__timestamp">2018-03-20<br/>13:29:43 +0900</div><div class="message__header">brackss1</div><div class="message__body">使わないところはプレースホルダーでもおいて使えるんですね。詳しい説明ありがとうございます。</div></div><div class="message" id="message-1521528970.000121"><div class="message__timestamp">2018-03-20<br/>15:56:10 +0900</div><div class="message__header">brackss1</div><div class="message__body">集合論･群論の本でわかりやすい本を教えてください。大学数学超初心者です。</div></div><div class="message" id="message-1521529603.000275"><div class="message__timestamp">2018-03-20<br/>16:06:43 +0900</div><div class="message__header">hiratara</div><div class="message__body"><a href='#C7Y71415W'>math</a> という部屋がありますので、そちらで聞くといいと思います。<br/>個人的には、初歩的な分野で書籍数も比較的多いので、書店でパラパラめくって読めそうなものを選んだりamazonのレビュー高い本であればどれでも勉強できるのかなと思いました。</div></div><div class="message" id="message-1521781625.000189"><div class="message__timestamp">2018-03-23<br/>14:07:05 +0900</div><div class="message__header">igrep</div><div class="message__body"><code>stack hoogle</code> コマンドを普通に実行すると、現在開発している（stack.yamlを置いている）プロジェクトのインデックスを生成したいのか、開発中のプロジェクトのビルドを始めます。<br/>これを、依存しているパッケージのドキュメントに対するインデックスの生成に限定することはできるでしょうか？<br/>開発中のプロジェクトは、ビルドが通らない状態になっていることが多いので、開発中のプロジェクトが原因でインデックスを生成できないのはつらいです。</div></div><div class="message" id="message-1521782215.000183"><div class="message__timestamp">2018-03-23<br/>14:16:55 +0900</div><div class="message__header">voqn.tyrant</div><div class="message__body"><code>stack hoogle -- generate base</code> ?</div></div><div class="message" id="message-1521782590.000016"><div class="message__timestamp">2018-03-23<br/>14:23:10 +0900</div><div class="message__header">igrep</div><div class="message__body"><code>stack hoogle -- generate</code> でいけました！<br/>（ :thinking_face: さっき手元の環境で <code>openBinaryFile: invalid argument (Invalid argument)</code> と出たのは何だったんだろう。。。）<br/>いずれにしてもありがとうございます！</div></div><div class="message" id="message-1521872215.000048"><div class="message__timestamp">2018-03-24<br/>15:16:55 +0900</div><div class="message__header">aiya000</div><div class="message__body">例えば<br/><pre>haskell
module Sonoda.Parser
#if ON_GHCI
  ( ParseException (..)
  , parseExpr
  , parseType
  , exprParser
  , typeParser
  ) where
#else
  where
#endif
</pre><br/>のようにして、CLIで`stack ghci --on-ghci`みたいな感じ（感じ）でghciを起動したときにだけ<br/>全てエクスポートしてくれるような方法を探しているのですが、何かないですか？:writing_hand:</div></div><div class="message" id="message-1521885679.000041"><div class="message__timestamp">2018-03-24<br/>19:01:19 +0900</div><div class="message__header">igrep</div><div class="message__body">:load コマンドでそのmoduleを読んだだけではダメなんですかね…<br/><br/>そりゃ敢えてやるとしたら、cabalファイルにflagを書いて、CPPの変数を定義すればできそうな気がしますが…</div></div><div class="message" id="message-1521886841.000082"><div class="message__timestamp">2018-03-24<br/>19:20:41 +0900</div><div class="message__header">mizunashi-mana</div><div class="message__body">ついでに，other-modulesでInternalモジュールにしてそこでは全てexportし，exposed-modulesでreexportするのはダメなんですか？</div></div><div class="message" id="message-1521896204.000095"><div class="message__timestamp">2018-03-24<br/>21:56:44 +0900</div><div class="message__header">aiya000</div><div class="message__body"><blockquote>:load コマンドでそのmoduleを読んだだけではダメなんですかね…</blockquote><br/>おっ、なるほど、:loadってexportされてない関数も読めるんですか！</div></div><div class="message" id="message-1521896383.000007"><div class="message__timestamp">2018-03-24<br/>21:59:43 +0900</div><div class="message__header">aiya000</div><div class="message__body"><blockquote>ついでに，other-modulesでInternalモジュールにしてそこでは全てexportし，exposed-modulesでreexportするのはダメなんですか？</blockquote>うーん、考えてみます。<br/><br/>お二人ともありがとうございます！</div></div><div class="message" id="message-1521901368.000032"><div class="message__timestamp">2018-03-24<br/>23:22:48 +0900</div><div class="message__header">shunsuke.masuda</div><div class="message__body">こんにちは。 HaskellでMessagePackのライブラリはどれを使えばよいかご存知の方、教えていただけますか？<br/><br/>data-msgpackというライブラリが該当するかと思い調べているのですが、 timestampの読み込みで、このコードだと、 2バイト目以降を読んでいるように思うのですが、 msgpackの仕様をみると、2バイト目は“Type”なので、読むなら3バイト目以降じゃないといけない気がしてます。ちゃんとテストすればいいのですが、そもそもこのライブラリでよいのかどうか自信がなく、深入りするまえにおたずねしています。<br/><br/><a href='https://github.com/TokTok/hs-msgpack/blob/ecfa24d5e237639597797b8e826b37e92efe4fe3/src/Data/MessagePack/Get.hs#L146'>https://github.com/TokTok/hs-msgpack/blob/ecfa24d5e237639597797b8e826b37e92efe4fe3/src/Data/MessagePack/Get.hs#L146</a><br/><br/><a href='https://github.com/msgpack/msgpack/blob/master/spec.md#ext-format-family'>https://github.com/msgpack/msgpack/blob/master/spec.md#ext-format-family</a></div></div><div class="message" id="message-1521973072.000035"><div class="message__timestamp">2018-03-25<br/>19:17:52 +0900</div><div class="message__header">matsubara0507</div><div class="message__body">意外と種類ありますね<br/><a href='https://hackage.haskell.org/packages/search?terms=messagepack'>https://hackage.haskell.org/packages/search?terms=messagepack</a></div></div><div class="message" id="message-1521977301.000033"><div class="message__timestamp">2018-03-25<br/>20:28:21 +0900</div><div class="message__header">igrep</div><div class="message__body">ほかに同じように使っている人がいればいいんですが、ちょっといなければ深入りするしかなさそうですね。。。 :disappointed:</div></div><div class="message" id="message-1522029223.000192"><div class="message__timestamp">2018-03-26<br/>10:53:43 +0900</div><div class="message__header">nakaji-dayo</div><div class="message__body">windowsでHDBC-mysql使っている方いますか？<br/>こちらの記事やhdbc-mysqlのissueを見ると使うの結構大変そうだなと思ったのですが、どちらもある程度古い記述のため、もしかしたら周辺環境とかで状況変わってないかなと。<br/><a href='http://tsubaki.hatenablog.com/entry/20121020/1350734844'>http://tsubaki.hatenablog.com/entry/20121020/1350734844</a></div></div><div class="message" id="message-1522029492.000165"><div class="message__timestamp">2018-03-26<br/>10:58:12 +0900</div><div class="message__header">kakkun61</div><div class="message__body">半年ほど前だったか試してみましたが libmysqlclient をリンカー（？）にうまく探してもらえなくて1日格闘して、諦めて VM にしました</div></div><div class="message" id="message-1522029981.000176"><div class="message__timestamp">2018-03-26<br/>11:06:21 +0900</div><div class="message__header">nakaji-dayo</div><div class="message__body">@kakkun61 ありがとうございます！<br/>なるほど、、かなり苦戦する点ありそうですね。<br/>格闘する前に感触知れて助かりました。<br/>（まさにwinで動くように頑張るか、vmにするか検討してる状況でした）</div></div><div class="message" id="message-1522035227.000187"><div class="message__timestamp">2018-03-26<br/>12:33:47 +0900</div><div class="message__header">h_hosokawa</div><div class="message__body">@h_hosokawa has left the channel</div></div><div class="message" id="message-1522054664.000183"><div class="message__timestamp">2018-03-26<br/>17:57:44 +0900</div><div class="message__header">kayhide</div><div class="message__body">ソースを非公開のままで Haskell 製のライブラリを提供する方法を探してます。<br/>ソース非公開のパッケージを作る方法（＝ pre built なバイナリ + ヘッダのようなもの）ってありますでしょうか？</div></div><div class="message" id="message-1522054972.000096"><div class="message__timestamp">2018-03-26<br/>18:02:52 +0900</div><div class="message__header">igrep</div><div class="message__body">DLLや.soファイルとして公開するなら GHCの -shared オプションが使えそうですけども、そういう話ではないんですよね。。。</div></div><div class="message" id="message-1522055061.000092"><div class="message__timestamp">2018-03-26<br/>18:04:21 +0900</div><div class="message__header">kayhide</div><div class="message__body">その場合、その .so で提供される関数を Haskell からコールするには、なにかしら FFI をかまさないといけないですよね。</div></div><div class="message" id="message-1522055084.000227"><div class="message__timestamp">2018-03-26<br/>18:04:44 +0900</div><div class="message__header">igrep</div><div class="message__body">そっすね。</div></div><div class="message" id="message-1522055101.000544"><div class="message__timestamp">2018-03-26<br/>18:05:01 +0900</div><div class="message__header">igrep</div><div class="message__body">参考にするとしたら <a href='http://www.kotha.net/ghcguide_ja/7.0.4/separate-compilation.html'>http://www.kotha.net/ghcguide_ja/7.0.4/separate-compilation.html</a> らへんの話ですかね。<br/><blockquote>ソースファイルをコンパイルするとき、GHCはふつう二つのファイルを出力する。オブジェクトファイルとインタフェースファイルである。</blockquote><br/><blockquote>オブジェクトファイルは通常.oで終わり、そのモジュールのコンパイル済みコードを含む。</blockquote><br/><blockquote>インタフェースファイルはふつう.hiで終わり、そのモジュールに依存するモジュールをコンパイルするときに必要な情報を含む。エクスポートされた関数の型や、データ型の定義といったものがこれに含まれる。バイナリ形式なので、読もうとしないように。代わりに—-show-ifaceオプションを使うことができる。</blockquote></div></div></div><div class="pager"><a href="/slack-log/html/C5666B6BB/15.html" class="pager__previous">Previous</a><a href="/slack-log/" class="pager__top">Top</a><a href="/slack-log/html/C5666B6BB/17.html" class="pager__next">Next</a></div></body></html>