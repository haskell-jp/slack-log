[
    {
        "ts": "1638431774.056900",
        "text": "Calculate Polytypically! にある crush 演算子を Haskell で定義したい人です．本当は依存型のような仕組みを使って n-ary functor を扱いたかったのですが，よくわからなかったため，とりあえず論文にある例を動かすためには Bifunctor まで扱えればいいかなということで，<https://haskell-jp.slack.com/archives/CR2TETE5R/p1637818267043300?thread_ts=1637817370.043200&amp;cid=CR2TETE5R|このへん> を参考にしつつ書いてみました．たぶん動いてはいるんですが，これ以前に書いた Haskell のコードが Hutton 本 2 の演習問題くらいしかないので，Haskell らしい良い書き方というものがわからず，いまいち自信がもてません．ぱっと見で改善点があれば教えてほしいです．コードはスレッドにぶら下げておきます．",
        "user": "U02NV1XHYBT",
        "type": "message"
    },
    {
        "ts": "1638431793.057100",
        "text": "```{-# LANGUAGE TypeOperators #-}\n{-# LANGUAGE TypeSynonymInstances #-}\n\nimport Data.Functor.Constant\nimport Data.Functor.Identity\nimport Data.Functor.Sum\nimport Data.Functor.Product\nimport Data.Bifunctor\n\ntype Algebra f a = f a -&gt; a\n\nnewtype WrappedBifunctor f a b = Wrap { unwrap :: f a b }\ninstance Bifunctor f =&gt; Functor (WrappedBifunctor f a) where\n  fmap f (Wrap a) = Wrap (second f a)\n\nnewtype Mu f = Mu { unMu :: f (Mu f) }\nnewtype Tau f a = Tau { unTau :: Mu (WrappedBifunctor f a) }\n\ncata :: Functor f =&gt; Algebra f a -&gt; Mu f -&gt; a\ncata phi = phi . fmap (cata phi) . unMu\n\ntype K = Constant\ntype I = Identity\ntype (:+:) = Sum\ntype (:*:) = Product\n\ninstance Bifunctor f =&gt; Functor (Tau f) where\n  fmap g = Tau . (cata (Mu . Wrap . first g . unwrap)) . unTau\n\nnewtype Biconstant a b c = Biconstant { getBiConstant :: a }\ninstance Bifunctor (Biconstant a) where\n  bimap _ _ (Biconstant x) = Biconstant x\n\nnewtype ProjectionL f a b = ProjectionL { runProjectionLeft :: f a }\ninstance Functor f =&gt; Bifunctor (ProjectionL f) where\n  bimap g _ (ProjectionL x) = ProjectionL (fmap g x)\n\nnewtype ProjectionR f a b = ProjectionR { runProjectionRight :: f b }\ninstance Functor f =&gt; Bifunctor (ProjectionR f) where\n  bimap _ h (ProjectionR x) = ProjectionR (fmap h x)\n\ndata Bisum f g a b = BiinL (f a b) | BiinR (g a b)\ninstance (Bifunctor f, Bifunctor g) =&gt; Bifunctor (Bisum f g) where\n  bimap f g (BiinL x) = BiinL (bimap f g x)\n  bimap f g (BiinR y) = BiinR (bimap f g y)\n\ndata Biproduct f g a b = Bipair (f a b) (g a b)\ninstance (Bifunctor f, Bifunctor g) =&gt; Bifunctor (Biproduct f g) where\n  bimap f g (Bipair x y) = Bipair (bimap f g x) (bimap f g y)\n\ntype KK = Biconstant\ntype L = ProjectionL\ntype R = ProjectionR\ntype (:++:) = Bisum\ntype (:**:) = Biproduct\n\nclass Functor f =&gt; CrushableFunctor f where\n  crush :: (a -&gt; a -&gt; a) -&gt; a -&gt; f a -&gt; a\n\nclass Bifunctor f =&gt; CrushableBifunctor f where\n  bicrush :: (a -&gt; a -&gt; a) -&gt; a -&gt; f a a -&gt; a\n\n-- CrushableFunctor :=\n--   | Const *\n--   | Identity\n--   | Sum CrushableFunctor CrushableFunctor\n--   | Prod CrushableFunctor CrushableFunctor\n--   | Tau CrushableBiFunctor\n\ninstance CrushableFunctor (K a) where\n  crush _ nu (Constant x) = nu\n\ninstance CrushableFunctor I where\n  crush _ _ (Identity x) = x\n\ninstance (CrushableFunctor f, CrushableFunctor g) =&gt; CrushableFunctor (f :+: g) where\n  crush op nu (InL x) = crush op nu x\n  crush op nu (InR x) = crush op nu x\n\ninstance (CrushableFunctor f, CrushableFunctor g) =&gt; CrushableFunctor (f :*: g) where\n  crush op nu (Pair x y) = op (crush op nu x) (crush op nu y)\n\ninstance CrushableBifunctor f =&gt; CrushableFunctor (Tau f) where\n  crush op nu = cata (bicrush op nu . unwrap) . unTau\n\n-- CrushableBiFunctor :=\n--   | Const *\n--   | ProjL CrushableFunctor\n--   | ProjR CrushableFunctor\n--   | Sum CrushableBiFunctor CrushableBiFunctor\n--   | Prod CrushableBiFunctor CrushableBiFunctor\n\ninstance CrushableBifunctor (KK a) where\n  bicrush _ nu (Biconstant x) = nu\n\ninstance CrushableFunctor f =&gt; CrushableBifunctor (L f) where\n  bicrush op nu (ProjectionL x) = crush op nu x\n\ninstance CrushableFunctor f =&gt; CrushableBifunctor (R f) where\n  bicrush op nu (ProjectionR x) = crush op nu x\n\ninstance (CrushableBifunctor f, CrushableBifunctor g) =&gt; CrushableBifunctor (f :++: g) where\n  bicrush op nu (BiinL x) = bicrush op nu x\n  bicrush op nu (BiinR x) = bicrush op nu x\n\ninstance (CrushableBifunctor f, CrushableBifunctor g) =&gt; CrushableBifunctor (f :**: g) where\n  bicrush op nu (Bipair x y) = op (bicrush op nu x) (bicrush op nu y)\n\n-- MaybeF = 1 + id\ntype MaybeF = (K ()) :+: I\n\nnone :: MaybeF a\nnone = InL (Constant ())\n\nsome :: a -&gt; MaybeF a\nsome x = InR (Identity x)\n\n-- ListF a = μ (1 + (a * id))\ntype ListF = Tau ((KK ()) :++: ((L I) :**: (R I)))\n\nnil :: ListF a\nnil = Tau (Mu (Wrap (BiinL (Biconstant ()))))\n\ncons :: a -&gt; ListF a -&gt; ListF a\ncons x xs = Tau (Mu (Wrap (BiinR (Bipair (ProjectionL (Identity x)) (ProjectionR (Identity (unTau xs)))))))\n\n-- BinTreeF a = μ (a + (id * id))\ntype BinTreeF = Tau ((L I) :++: ((R I) :**: (R I)))\n\ntip :: a -&gt; BinTreeF a\ntip x = Tau (Mu (Wrap (BiinL (ProjectionL (Identity x)))))\n\njoin :: BinTreeF a -&gt; BinTreeF a -&gt; BinTreeF a\njoin x y = Tau (Mu (Wrap (BiinR (Bipair (ProjectionR (Identity (unTau x))) (ProjectionR (Identity (unTau y)))))))\n\n-- RoseTreeF a = μ (a * ListF) = μ (a * (\\b -&gt; μ (1 + (b * id))))\ntype RoseTreeF = Tau ((L I) :**: (R ListF))\n\nfork :: a -&gt; ListF (RoseTreeF a) -&gt; RoseTreeF a\nfork x xs = Tau (Mu (Wrap (Bipair (ProjectionL (Identity x)) (ProjectionR (fmap unTau xs)))))\n\nsum_ :: CrushableFunctor f =&gt; f Int -&gt; Int\nsum_ = crush (+) 0\n\ncrushf :: CrushableFunctor f =&gt; (a -&gt; a -&gt; a) -&gt; a -&gt; (b -&gt; a) -&gt; f b -&gt; a\ncrushf op nu g = crush op nu . fmap g\n\nsize :: CrushableFunctor f =&gt; f a -&gt; Int\nsize = crushf (+) 0 (const 1)\n\nelem_ :: (CrushableFunctor f, Eq a) =&gt; a -&gt; f a -&gt; Bool\nelem_ e = crushf (||) False (== e)\n\nflatten :: CrushableFunctor f =&gt; f a -&gt; [a]\nflatten = crushf (++) [] (\\x -&gt; [x])\n\ncrushM :: CrushableFunctor f =&gt; (a -&gt; a -&gt; a) -&gt; f a -&gt; Maybe a\ncrushM op = crushf opM Nothing Just\n  where\n  opM Nothing Nothing = Nothing\n  opM (Just x) Nothing = Just x\n  opM Nothing (Just y) = Just y\n  opM (Just x) (Just y) = Just (op x y)\n\nfirst_ :: CrushableFunctor f =&gt; f a -&gt; Maybe a\nfirst_ = crushM const\n\ncrushMf :: CrushableFunctor f =&gt; (a -&gt; a -&gt; a) -&gt; (b -&gt; a) -&gt; f b -&gt; Maybe a\ncrushMf op g = crushf opM Nothing (Just . g)\n  where\n  opM Nothing Nothing = Nothing\n  opM (Just x) Nothing = Just x\n  opM Nothing (Just y) = Just y\n  opM (Just x) (Just y) = Just (op x y)\n\ndepth :: CrushableFunctor f =&gt; f a -&gt; Maybe Int\ndepth = crushMf (\\m n -&gt; (max m n) + 1) (const 0)\n\nbinned :: CrushableFunctor f =&gt; f a -&gt; Maybe (BinTreeF a)\nbinned = crushMf join tip```",
        "user": "U02NV1XHYBT",
        "type": "message"
    },
    {
        "ts": "1638431870.057300",
        "text": "個人的にはコンストラクタが大量にあって混乱しまくりで，なんとかならんかなと思うのですが，ある程度は仕方ないのでしょうか．",
        "user": "U02NV1XHYBT",
        "type": "message"
    }
]