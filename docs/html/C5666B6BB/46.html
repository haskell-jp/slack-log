<!DOCTYPE html><html><head><meta charset="utf-8"><title>haskell-jp / questions #46</title><link rel="stylesheet" href="../../main.css" type="text/css" media="screen"></head><body><div class="ui container"><h1>haskell-jp / questions #46</h1><div class="pager ui pagination menu"><a href="../../html/C5666B6BB/45.html" class="pager__previous item">Previous</a><a href="../../" class="pager__top item">Top</a><a href="../../html/C5666B6BB/47.html" class="pager__next item">Next</a></div><div class="message_list ui feed"><div class="message event" id="message-1551410882.000900"><div class="content"><div class="summary"><div class="message__header user">kazu</div><div class="message__timestamp date"><a class="date" href="#message-1551410882.000900">2019-03-01&nbsp;12:28:02 +0900</a></div></div><div class="message__body description">Hutton本2に「newtypeで宣言するデータ型も再帰的にできる」って書いてあるんですが、これは誤りですよね？ 再帰的にできるのは、data だけですよね？</div></div></div><div class="message event" id="message-1551411167.001000"><div class="content"><div class="summary"><div class="message__header user">kazu</div><div class="message__timestamp date"><a class="date" href="#message-1551411167.001000">2019-03-01&nbsp;12:32:47 +0900</a></div></div><div class="message__body description">GHCだと、newtype を再帰的に使えるみたいですが、どう使うんでしょうか？</div></div></div><div class="message event" id="message-1551411302.001200"><div class="content"><div class="summary"><div class="message__header user">koyama</div><div class="message__timestamp date"><a class="date" href="#message-1551411302.001200">2019-03-01&nbsp;12:35:02 +0900</a></div></div><div class="message__body description">こんな感じでしょうか？<br/><code>newtype NewTypeRecursion a = N (Either (NewTypeRecursion a) a)</code></div></div></div><div class="message event" id="message-1551411392.001400"><div class="content"><div class="summary"><div class="message__header user">kakkun61</div><div class="message__timestamp date"><a class="date" href="#message-1551411392.001400">2019-03-01&nbsp;12:36:32 +0900</a></div></div><div class="message__body description">fix コンビネーターが newtype で作れるみたいです <a href='http://ilyaletre.hatenablog.com/entry/2018/03/20/224320'>http://ilyaletre.hatenablog.com/entry/2018/03/20/224320</a></div></div></div><div class="message event" id="message-1551411567.001800"><div class="content"><div class="summary"><div class="message__header user">koyama</div><div class="message__timestamp date"><a class="date" href="#message-1551411567.001800">2019-03-01&nbsp;12:39:27 +0900</a></div></div><div class="message__body description">はるかに良い例を出されてしまった^^;</div></div></div><div class="message event" id="message-1551411593.002000"><div class="content"><div class="summary"><div class="message__header user">koyama</div><div class="message__timestamp date"><a class="date" href="#message-1551411593.002000">2019-03-01&nbsp;12:39:53 +0900</a></div></div><div class="message__body description">要は場合分けがないと再帰が止まらないだろうという話だったんだと思いますが、中身が場合分けを持つ型ならできるじゃんというのが私の発想で、そうでなくとも無限再帰的な型でも意味がある場合があるってことですね…</div></div></div><div class="message event" id="message-1551411670.002200"><div class="content"><div class="summary"><div class="message__header user">koyama</div><div class="message__timestamp date"><a class="date" href="#message-1551411670.002200">2019-03-01&nbsp;12:41:10 +0900</a></div></div><div class="message__body description">不動点オペレータの場合、結局「f」に場合分けがあることを期待している、というべきでしょうか</div></div></div><div class="message event" id="message-1551411703.002400"><div class="content"><div class="summary"><div class="message__header user">kazu</div><div class="message__timestamp date"><a class="date" href="#message-1551411703.002400">2019-03-01&nbsp;12:41:43 +0900</a></div></div><div class="message__body description">勉強になりました。</div></div></div><div class="message event" id="message-1551411727.002600"><div class="content"><div class="summary"><div class="message__header user">kazu</div><div class="message__timestamp date"><a class="date" href="#message-1551411727.002600">2019-03-01&nbsp;12:42:07 +0900</a></div></div><div class="message__body description">しかし、Hutton本2で紹介すべきか疑問ですね。Huttonさんに意図を聞いてみます。</div></div></div><div class="message event" id="message-1551412912.002800"><div class="content"><div class="summary"><div class="message__header user">notogawa</div><div class="message__timestamp date"><a class="date" href="#message-1551412912.002800">2019-03-01&nbsp;13:01:52 +0900</a></div></div><div class="message__body description">EmptyCase拡張が無かった昔は <code>newtype Void = Void Void</code> みたいなのも使いましたよ．</div></div></div><div class="message event" id="message-1551413448.003100"><div class="content"><div class="summary"><div class="message__header user">kazu</div><div class="message__timestamp date"><a class="date" href="#message-1551413448.003100">2019-03-01&nbsp;13:10:48 +0900</a></div></div><div class="message__body description">依存型っぽいことをするためですか？</div></div></div><div class="message event" id="message-1551414188.004900"><div class="content"><div class="summary"><div class="message__header user">koyama</div><div class="message__timestamp date"><a class="date" href="#message-1551414188.004900">2019-03-01&nbsp;13:23:08 +0900</a></div></div><div class="message__body description">パッと思いつくのは phantom type で「型の違いを作るための目印として使うが実際には無視される型引数」に入れるのに使う、ってやつでしょうか（phantom type でぐぐると実例がでてきます）</div></div></div><div class="message event" id="message-1551414222.005300"><div class="content"><div class="summary"><div class="message__header user">kazu</div><div class="message__timestamp date"><a class="date" href="#message-1551414222.005300">2019-03-01&nbsp;13:23:42 +0900</a></div></div><div class="message__body description">なるほど。</div></div></div><div class="message event" id="message-1551414351.005500"><div class="content"><div class="summary"><div class="message__header user">mizunashi-mana</div><div class="message__timestamp date"><a class="date" href="#message-1551414351.005500">2019-03-01&nbsp;13:25:51 +0900</a></div></div><div class="message__body description">一般に， <code>type</code> は型の計算が遅延しませんが， <code>newtype</code> は遅延するのが強みだと思っていました(再帰型の場合は <code>type</code> は無限再帰が起き停止しなくなりますが， <code>newtype</code> は型上は <code>data</code> と同じ扱いなので新しい型が作られるだけですね)</div></div></div><div class="message event" id="message-1551414354.005700"><div class="content"><div class="summary"><div class="message__header user">notogawa</div><div class="message__timestamp date"><a class="date" href="#message-1551414354.005700">2019-03-01&nbsp;13:25:54 +0900</a></div></div><div class="message__body description">↑の <code>Void</code> は「値を構成できない型」を作るためで，“矛盾“に相当します．定理証明をするためですね．</div></div></div><div class="message event" id="message-1551414441.006300"><div class="content"><div class="summary"><div class="message__header user">kazu</div><div class="message__timestamp date"><a class="date" href="#message-1551414441.006300">2019-03-01&nbsp;13:27:21 +0900</a></div></div><div class="message__body description">勉強になります</div></div></div><div class="message event" id="message-1551414524.006500"><div class="content"><div class="summary"><div class="message__header user">notogawa</div><div class="message__timestamp date"><a class="date" href="#message-1551414524.006500">2019-03-01&nbsp;13:28:44 +0900</a></div></div><div class="message__body description">実用的には「定理証明が必要となるような強力で厳密な依存型インターフェースを提供するため．」かな．</div></div></div><div class="message event" id="message-1551415231.006900"><div class="content"><div class="summary"><div class="message__header user">mizunashi-mana</div><div class="message__timestamp date"><a class="date" href="#message-1551415231.006900">2019-03-01&nbsp;13:40:31 +0900</a></div></div><div class="message__body description"><code>newtype</code> で再帰型は割と使う人なのですが， <code>Cofree</code> とかは<br/><br/><pre>
newtype Cofree f a = Cofree (a, f (Cofree f a))
</pre><br/><br/>とも書けますね(やってることは同じなので， <code>data</code> を使うべきというのはそうですが)<br/><br/>Hutton本を読んだことがないので，どういうレベルの本なのか分からないですが， <code>type</code> と <code>newtype</code> ， <code>data</code> の大きな違いは<br/>• <code>type</code> は再帰型が書けないが， <code>newtype</code> / <code>data</code> は書ける (<https://www.haskell.org/onlinereport/haskell2010/haskellch4.html#x10-740004.2.3> でも強調されてますね)<br/>• <code>type</code> はインスタンスにできないが， <code>newtype</code> / <code>data</code> はインスタンスにできる<br/>• <code>newtype</code> はコンストラクタが実行時に無いように振舞う<br/>ということだと思うので，この3つは Haskell を書く上では押さえておいてほしいとは思います(特に強調するべきだとは思いませんが，入門書に書いておいてほしいとは思いますね． すごいH本には確か書いてあった気がします)</div></div></div><div class="message event" id="message-1551415588.007200"><div class="content"><div class="summary"><div class="message__header user">notogawa</div><div class="message__timestamp date"><a class="date" href="#message-1551415588.007200">2019-03-01&nbsp;13:46:28 +0900</a></div></div><div class="message__body description">評価の違い(3点目の付帯ではあるけど)も明示はあってほしい．</div></div></div><div class="message event" id="message-1551415758.007400"><div class="content"><div class="summary"><div class="message__header user">mizunashi-mana</div><div class="message__timestamp date"><a class="date" href="#message-1551415758.007400">2019-03-01&nbsp;13:49:18 +0900</a></div></div><div class="message__body description">(あ，主に3点目は評価の違いをさしてました．パターンマッチの意味論が違う点ですね)</div></div></div><div class="message event" id="message-1551415863.007800"><div class="content"><div class="summary"><div class="message__header user">kazu</div><div class="message__timestamp date"><a class="date" href="#message-1551415863.007800">2019-03-01&nbsp;13:51:03 +0900</a></div></div><div class="message__body description">Hutton本は初心者用です。</div></div></div><div class="message event" id="message-1551415894.008000"><div class="content"><div class="summary"><div class="message__header user">kazu</div><div class="message__timestamp date"><a class="date" href="#message-1551415894.008000">2019-03-01&nbsp;13:51:34 +0900</a></div></div><div class="message__body description"><code>newtype</code> で再帰ができると書いてしまうと、例を出すべきですが、例が初心者のレベルを超えていると思います。</div></div></div><div class="message event" id="message-1551415952.008200"><div class="content"><div class="summary"><div class="message__header user">kazu</div><div class="message__timestamp date"><a class="date" href="#message-1551415952.008200">2019-03-01&nbsp;13:52:32 +0900</a></div></div><div class="message__body description">あと、H本をぱらっと読み返してみましたが、 <code>newtype</code> は再帰できるという説明は見つけられませんでした。</div></div></div><div class="message event" id="message-1551416079.008500"><div class="content"><div class="summary"><div class="message__header user">kazu</div><div class="message__timestamp date"><a class="date" href="#message-1551416079.008500">2019-03-01&nbsp;13:54:39 +0900</a></div></div><div class="message__body description">Hutton本の訳注で、「例としては Fix だが、気にしなくていい」みたいに書くのはありだとは思います。でも「 <code>newtype</code> が再帰できる」とは書かない方がいいと思います。</div></div></div><div class="message event" id="message-1551416673.008700"><div class="content"><div class="summary"><div class="message__header user">mizunashi-mana</div><div class="message__timestamp date"><a class="date" href="#message-1551416673.008700">2019-03-01&nbsp;14:04:33 +0900</a></div></div><div class="message__body description"><blockquote>H本をぱらっと読み返してみましたが、 <code>newtype</code> は再帰できるという説明は見つけられませんでした。</blockquote>すいません，確かに書いてないようですね．これは僕の勘違いでした．<br/><br/>Hutton本2が手元にないのでどういう文脈で出てくるのか分からないですが例として<br/><br/><pre>
newtype Tree = Tree (Int, [Tree])
</pre><br/><br/>みたいなのも出せるので，一概に <code>Fix</code> を出す必要はないんじゃないかと(これは， Hutton本1だと type declaration で書けない例として紹介されていますね)</div></div></div><div class="message event" id="message-1551416875.009100"><div class="content"><div class="summary"><div class="message__header user">mizunashi-mana</div><div class="message__timestamp date"><a class="date" href="#message-1551416875.009100">2019-03-01&nbsp;14:07:55 +0900</a></div></div><div class="message__body description">(Hutton本1で newtype に関する記述を見つけられなかったんですが， Hutton 本2から入ったんですかね？)</div></div></div><div class="message event" id="message-1551417057.009300"><div class="content"><div class="summary"><div class="message__header user">kazu</div><div class="message__timestamp date"><a class="date" href="#message-1551417057.009300">2019-03-01&nbsp;14:10:57 +0900</a></div></div><div class="message__body description">この <code>Tree</code> の例は素敵ですね。訳注にこれを書くのが補完し合っていていいかも。</div></div></div><div class="message event" id="message-1551417088.009500"><div class="content"><div class="summary"><div class="message__header user">kazu</div><div class="message__timestamp date"><a class="date" href="#message-1551417088.009500">2019-03-01&nbsp;14:11:28 +0900</a></div></div><div class="message__body description"><code>newtype</code> は、初版にはなく、第2版から入りました。</div></div></div><div class="message event" id="message-1551417134.009700"><div class="content"><div class="summary"><div class="message__header user">kazu</div><div class="message__timestamp date"><a class="date" href="#message-1551417134.009700">2019-03-01&nbsp;14:12:14 +0900</a></div></div><div class="message__body description">第2版は、大幅に書き換わっていて、訳が大変です。。。</div></div></div><div class="message event" id="message-1551494788.011400"><div class="content"><div class="summary"><div class="message__header user">minorinoki_haskjp</div><div class="message__timestamp date"><a class="date" href="#message-1551494788.011400">2019-03-02&nbsp;11:46:28 +0900</a></div></div><div class="message__body description">@minorinoki_haskjp has joined the channel</div></div></div><div class="message event" id="message-1551520784.011700"><div class="content"><div class="summary"><div class="message__header user">hinoshita1992</div><div class="message__timestamp date"><a class="date" href="#message-1551520784.011700">2019-03-02&nbsp;18:59:44 +0900</a></div></div><div class="message__body description">@hinoshita1992 has joined the channel</div></div></div><div class="message event" id="message-1551573016.013800"><div class="content"><div class="summary"><div class="message__header user">hexirp</div><div class="message__timestamp date"><a class="date" href="#message-1551573016.013800">2019-03-03&nbsp;09:30:16 +0900</a></div></div><div class="message__body description">試しに <code>print $ (unsafeCoerce True :: Int)</code> を実行してみたら <code>2305843009213693952</code> と表示されました。64bit に変換すると <code>0010000000000000000000000000000000000000000000000000000000000000</code> になり、GHCの内部表現と関係していそうなんですけど、どうしてこうなるんですか？</div></div></div><div class="message event" id="message-1551573480.013900"><div class="content"><div class="summary"><div class="message__header user">hexirp</div><div class="message__timestamp date"><a class="date" href="#message-1551573480.013900">2019-03-03&nbsp;09:38:00 +0900</a></div></div><div class="message__body description"><a href='https://takenobu-hs.github.io/downloads/haskell_ghc_illustrated.pdf'>https://takenobu-hs.github.io/downloads/haskell_ghc_illustrated.pdf</a><br/>自己解決しました（多分）。上のスライドでの Pointer Tagging の節によると、最初の 3bit が以下のようになっているそうです。<br/>• 000 - 未評価<br/>• 001 - 評価済みで一番目のコンストラクタ<br/>• 010 - 評価済みで二番目のコンストラクタ<br/>• 011 - ...</div></div></div><div class="message event" id="message-1551573611.014100"><div class="content"><div class="summary"><div class="message__header user">hexirp</div><div class="message__timestamp date"><a class="date" href="#message-1551573611.014100">2019-03-03&nbsp;09:40:11 +0900</a></div></div><div class="message__body description">そして、True は定数なので何も参照せず、後の 61bit が空になる……ということみたいです（これ、7個以上コンストラクタがあったときはどうするんだろう）</div></div></div><div class="message event" id="message-1551591369.014600"><div class="content"><div class="summary"><div class="message__header user">mizunashi-mana</div><div class="message__timestamp date"><a class="date" href="#message-1551591369.014600">2019-03-03&nbsp;14:36:09 +0900</a></div></div><div class="message__body description"><a href='https://ghc.haskell.org/trac/ghc/wiki/Commentary/Rts/HaskellExecution/PointerTagging'>https://ghc.haskell.org/trac/ghc/wiki/Commentary/Rts/HaskellExecution/PointerTagging</a><br/>に書かれている通り、64bitだと8個以上コンストラクタを持つ場合コンストラクタ情報はtaggingされず、evaluatedかどうかで000/001のどちらかになり、コンストラクタ情報はinfo tableを見に行くことになります</div></div></div><div class="message event" id="message-1551594758.014900"><div class="content"><div class="summary"><div class="message__header user">koyama</div><div class="message__timestamp date"><a class="date" href="#message-1551594758.014900">2019-03-03&nbsp;15:32:38 +0900</a></div></div><div class="message__body description">Pointer Tagging はたぶん最下位ビット側だと思うので上位が立ってるのは不思議ですね…そして True は Bool にとっては「二番目」の値のはず（deriving Ord 的に False &lt; True なので）なので、その点でも辻褄があってない気がします</div></div></div><div class="message event" id="message-1551603754.015700"><div class="content"><div class="summary"><div class="message__header user">takenobu.hs</div><div class="message__timestamp date"><a class="date" href="#message-1551603754.015700">2019-03-03&nbsp;18:02:34 +0900</a></div></div><div class="message__body description">面白いですね。<br/>pointer taggingの話題自体については解決済みと思いますが、元々のコードの出力値は妙ですね。<br/><br/>pointer taggingは、「ヒープ上のオブジェクト(closure)」へのポインタの下位3bitに印をつける機能なので、そのポインタの値そのものは通常、ユーザーコードからは見えないです。<br/>（つまり、print関数では、ポインタの値自体は出力していないです。）<br/><br/>そしてprintが出力しているのは、データ構築子`True`のマシン上での表現を、unsafeCoerceを使ってInt型に強引に解釈させたときの値です。 なので、不整合な値が出力されているのだと思います。（例え的には、Float型のバイナリ値を、Int型に解釈させて出力させたような不整合が。）<br/><br/>試しに、マシン上での表現が似ているInt型をWord型へ、強引にunsafeCoerceで解釈変更させたら、以下のように値自体は矛盾しない結果になりました。（CPUやOS依存あると思います。）<br/><br/><pre>
ghci&gt; import Unsafe.Coerce
ghci&gt; print $ (unsafeCoerce (-1::Int) :: Word)
18446744073709551615
</pre><br/><br/>18446744073709551615 は、16進表現では、ffffffffffffffff です。（つまりInt型の-1）<br/><br/>unsafeCoerceは、型をごまかすだけで、実行時の表現自体は変更しないというところですね。<br/>（勘違いあればフォローお願いします。）</div></div></div><div class="message event" id="message-1551604333.015900"><div class="content"><div class="summary"><div class="message__header user">takenobu.hs</div><div class="message__timestamp date"><a class="date" href="#message-1551604333.015900">2019-03-03&nbsp;18:12:13 +0900</a></div></div><div class="message__body description">解決済みと思いますが念の為です。 Haskell 2010 Language Reportでも、newtypeは再帰的使われることを想定しているようです。<br/><br/>"Also, unlike type synonyms, newtype may be used to define recursive types."<br/><br/><a href='https://www.haskell.org/onlinereport/haskell2010/haskellch4.html#x10-740004.2.3'>https://www.haskell.org/onlinereport/haskell2010/haskellch4.html#x10-740004.2.3</a></div></div></div><div class="message event" id="message-1551606182.016100"><div class="content"><div class="summary"><div class="message__header user">mizunashi-mana</div><div class="message__timestamp date"><a class="date" href="#message-1551606182.016100">2019-03-03&nbsp;18:43:02 +0900</a></div></div><div class="message__body description">print は I# を紐解くので、そもそも表示されてるものはオブジェクトの純正の表示では無いはずですね。ついでにうちの環境(mac/GHC 8.6.3)では再現しなかったです</div></div></div><div class="message event" id="message-1551610202.016300"><div class="content"><div class="summary"><div class="message__header user">mizunashi-mana</div><div class="message__timestamp date"><a class="date" href="#message-1551610202.016300">2019-03-03&nbsp;19:50:02 +0900</a></div></div><div class="message__body description">うちの環境で試した結果です:<br/><a href='https://gist.github.com/mizunashi-mana/67df53477ef464232f9e97588e099cf9'>https://gist.github.com/mizunashi-mana/67df53477ef464232f9e97588e099cf9</a><br/><br/><code>print (unsafeCoerce True :: IntOrBool)</code> が SEGV になったのは， <code>5764607523051092410</code> をBool値のヒープを指し示すポインタだと思って飛ぼうとしたせいだと思いますね．Bool値のコンストラクタはフィールドを特に持たないので，フィールドじゃない領域をフィールドだと思って参照した結果，そういう結果が返ってくるんだと思います(主に True だと True_closure + 9 ， False だと False_closure + 8 を I64 表現だと解釈した結果こういう表示になってるようです．毎回実行するごとに結果が変わっていたので，多分空いてるヒープ領域なんだと思います)</div></div></div><div class="message event" id="message-1551612186.016600"><div class="content"><div class="summary"><div class="message__header user">hexirp</div><div class="message__timestamp date"><a class="date" href="#message-1551612186.016600">2019-03-03&nbsp;20:23:06 +0900</a></div></div><div class="message__body description"><a href='https://github.com/Hexirp/haskell-gist/blob/1a233daa267b6647bbfede385ab9be653fd0983e/Unsafe.hs'>https://github.com/Hexirp/haskell-gist/blob/1a233daa267b6647bbfede385ab9be653fd0983e/Unsafe.hs</a><br/>なるほど…そう単純に考えられないみたいですね。こっちの環境は Windows 10 です。上の結果は3か月前のもので、今でも再現しました</div></div></div><div class="message event" id="message-1551612406.016900"><div class="content"><div class="summary"><div class="message__header user">hexirp</div><div class="message__timestamp date"><a class="date" href="#message-1551612406.016900">2019-03-03&nbsp;20:26:46 +0900</a></div></div><div class="message__body description">あっ、こっちの方が重要かも。実行は ghci でやってます</div></div></div><div class="message event" id="message-1551612521.017100"><div class="content"><div class="summary"><div class="message__header user">hexirp</div><div class="message__timestamp date"><a class="date" href="#message-1551612521.017100">2019-03-03&nbsp;20:28:41 +0900</a></div></div><div class="message__body description">……GHCiとGHCって内部表現がだいぶ異なりますよね？ 根本から勘違いしてたかも</div></div></div><div class="message event" id="message-1551616167.017300"><div class="content"><div class="summary"><div class="message__header user">takenobu.hs</div><div class="message__timestamp date"><a class="date" href="#message-1551616167.017300">2019-03-03&nbsp;21:29:27 +0900</a></div></div><div class="message__body description">手元のUbuntu18.04だと、以下の出力になりました。（16進で0xc800_007f_6f23_a2f0です。）<br/><br/><pre>
ghci&gt; main
-4035224716524808016
</pre><br/><br/>runghcで実行すると、実行ごとに結果が違いますね。<br/><br/><pre>
$ runghc Unsafe.hs 
-4035224717148402896

$ runghc Unsafe.hs 
-4035224717726351680
</pre><br/><br/>いずれにしても、実メモリ上のデータ表現値を、unsafeCoerceを使って違う型として強引に解釈させるので、メモリの周辺配置状況を含めて、変な値として解釈されてしまいますね。<br/>（例えば、ある構造体で書かれたバイナリ値を、別の構造体のフォーマットに従って読んでしまう場合のように。）</div></div></div><div class="message event" id="message-1551620429.017500"><div class="content"><div class="summary"><div class="message__header user">takenobu.hs</div><div class="message__timestamp date"><a class="date" href="#message-1551620429.017500">2019-03-03&nbsp;22:40:29 +0900</a></div></div><div class="message__body description">ちょっと説明がうまくなかったので補足します。<br/><br/>GHCは、メモリ上において、各オブジェクト(closure)を、次の内部表現で持っています。<br/>（info ptrは、Info table(メタ情報)とEntry code(実アセンブリ命令列)へのポインタです。）<br/><br/><pre>
+--------+--------+--------+
|info ptr|payload1|payload2|..
+--------+--------+--------+
</pre><br/><br/>そして、Bool型のTrueコンストラクタと、Int型の値は、各々、次のフォーマットでメモリ上に置かれます。<br/><br/><pre>
Bool型のTrueコンストラクタの場合
 info ptr
+--------+
| Trueへ | (ここは無し)
+--------+

Int型の数値の場合
 info ptr  payload1
+--------+--------+
| I#へ   | Int値   |
+--------+--------+
</pre><br/><br/>今回、Trueコンストラクタのメモリイメージを、unsafeCoerceを使って、Int型の値として無理やり解釈しようとします。ですが、Int型の「Int値」に相当するpayloadは、Trueコンストラクタにはありません。なので、「（ここは無し）」の部分を、Int値として読みに行って、たまたまそこに書かれている無効な情報をInt値と解釈していることになります。</div></div></div><div class="message event" id="message-1551647023.017900"><div class="content"><div class="summary"><div class="message__header user">mizunashi-mana</div><div class="message__timestamp date"><a class="date" href="#message-1551647023.017900">2019-03-04&nbsp;06:03:43 +0900</a></div></div><div class="message__body description">そういえば True / False は data section に置かれるはずなので、ヒープ領域とは限らないのですね。 True_closure + 9 の場所が Windows だと別の data section の静的データがマッピングされる(ので毎回同じ出力になる)のに対し、 Mac/Linux とかだとゴミ領域になってる(ので初期化されていないゴミデータが出力される)とかかもですね。Mac/Linux 系でも上位ビットは毎回同じなので、元々何かがいたのかもですが</div></div></div><div class="message event" id="message-1551679556.020200"><div class="content"><div class="summary"><div class="message__header user">junji.hashimoto</div><div class="message__timestamp date"><a class="date" href="#message-1551679556.020200">2019-03-04&nbsp;15:05:56 +0900</a></div></div><div class="message__body description">各種ライブラリでhttp-client-opensslでなくてhttp-client-tlsがデフォルトなのは<br/>なにか理由があるのでしょうか。<br/>tlsのほうのパフォーマンスが悪いのでopensslに切り替えているのですが、<br/>そういうのをやめたいですね。</div></div></div><div class="message event" id="message-1551679589.020800"><div class="content"><div class="summary"><div class="message__header user">junji.hashimoto</div><div class="message__timestamp date"><a class="date" href="#message-1551679589.020800">2019-03-04&nbsp;15:06:29 +0900</a></div></div><div class="message__body description">http-client-tlsはcryptonite_gf_mul（cryptoniteのパッケージにあります） というcの関数を呼んでいるのですが、これが特に遅いです。</div></div></div><div class="message event" id="message-1551680505.021300"><div class="content"><div class="summary"><div class="message__header user">igrep</div><div class="message__timestamp date"><a class="date" href="#message-1551680505.021300">2019-03-04&nbsp;15:21:45 +0900</a></div></div><div class="message__body description">正確な理由は存じませんが、ビルドはhttp-client-tlsの方が楽ですね。（特にWindowsだと... :disappointed_relieved:</div></div></div><div class="message event" id="message-1551680746.021600"><div class="content"><div class="summary"><div class="message__header user">junji.hashimoto</div><div class="message__timestamp date"><a class="date" href="#message-1551680746.021600">2019-03-04&nbsp;15:25:46 +0900</a></div></div><div class="message__body description">確かに。</div></div></div></div><div class="pager ui pagination menu"><a href="../../html/C5666B6BB/45.html" class="pager__previous item">Previous</a><a href="../../" class="pager__top item">Top</a><a href="../../html/C5666B6BB/47.html" class="pager__next item">Next</a></div></div></body></html>