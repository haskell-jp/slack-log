<!DOCTYPE html><html><head><meta charset="utf-8"><title>haskell-jp / questions #88</title><link rel="stylesheet" href="../../main.css" type="text/css" media="screen"></head><body><div class="ui container"><h1>haskell-jp / questions #88</h1><div class="pager ui pagination menu"><a href="../../html/C5666B6BB/87.html" class="pager__previous item">Previous</a><a href="../../" class="pager__top item">Top</a></div><div class="message_list ui feed"><div class="message event" id="message-1594111362.101500"><div class="content"><div class="summary"><div class="message__header user">maoe</div><div class="message__timestamp date"><a class="date" href="#message-1594111362.101500">2020-07-07&nbsp;17:42:42 +0900</a></div></div><div class="message__body description">aDestでMDをMの前に持ってきたらどうでしょうか</div></div></div><div class="message event" id="message-1594111566.102300"><div class="content"><div class="summary"><div class="message__header user">maoe</div><div class="message__timestamp date"><a class="date" href="#message-1594111566.102300">2020-07-07&nbsp;17:46:06 +0900</a></div></div><div class="message__body description">ソートしたくないのですね見落としていました。</div></div></div><div class="message event" id="message-1594112462.110600"><div class="content"><div class="summary"><div class="message__header user">maoe</div><div class="message__timestamp date"><a class="date" href="#message-1594112462.110600">2020-07-07&nbsp;18:01:02 +0900</a></div></div><div class="message__body description">あとは[Parser Dest]で定義しておいてまとめてasum . map (&lt;* (char ‘=‘))するとか、あるいはラベルとParser Destの対のリストにしてsortするとかでしょうか。モバイルからなので見にくくてすみません。</div></div></div><div class="message event" id="message-1594113267.110900"><div class="content"><div class="summary"><div class="message__header user">t.mitsuchi3</div><div class="message__timestamp date"><a class="date" href="#message-1594113267.110900">2020-07-07&nbsp;18:14:27 +0900</a></div></div><div class="message__body description">パーズする対象にものすごく見覚えがあります！　「コンピュータシステムの理論と実装」ですね。</div></div></div><div class="message event" id="message-1594115538.111300"><div class="content"><div class="summary"><div class="message__header user">t.mitsuchi3</div><div class="message__timestamp date"><a class="date" href="#message-1594115538.111300">2020-07-07&nbsp;18:52:18 +0900</a></div></div><div class="message__body description">なるほど教科書の誘導に乗らずにつくってらっしゃるんですね。</div></div></div><div class="message event" id="message-1594115977.111500"><div class="content"><div class="summary"><div class="message__header user">t.mitsuchi3</div><div class="message__timestamp date"><a class="date" href="#message-1594115977.111500">2020-07-07&nbsp;18:59:37 +0900</a></div></div><div class="message__body description">ソートするしかなさそうですが、とはいえ実際には教科書120ページの表でAMDから逆順に並べるだけでOKではないでしょうか？</div></div></div><div class="message event" id="message-1594116262.111700"><div class="content"><div class="summary"><div class="message__header user">t.mitsuchi3</div><div class="message__timestamp date"><a class="date" href="#message-1594116262.111700">2020-07-07&nbsp;19:04:22 +0900</a></div></div><div class="message__body description">もしくは、単にA,M,Dからなる3文字以下の文字列としてパーズしてしまって、それを機械語に変換するときになんとかする、とか。</div></div></div><div class="message event" id="message-1594116322.112000"><div class="content"><div class="summary"><div class="message__header user">nobsun</div><div class="message__timestamp date"><a class="date" href="#message-1594116322.112000">2020-07-07&nbsp;19:05:22 +0900</a></div></div><div class="message__body description">Parser a 上の &lt;|&gt; 演算で合成されたパーザは、左オペランドのパーザがパーズに成功すると、右オペランドのパーザによるパーズを行わない（or パーズしても結果を捨てる)ように定義されているのではないでしょうか。だとすると、前者のようなコードにはならないと思います。古い記事ですが、<http://www.ipsj.or.jp/07editj/promenade/4702.pdf><br/>p.178 に少し言及している問題がおこっている思います。</div></div></div><div class="message event" id="message-1594116713.112400"><div class="content"><div class="summary"><div class="message__header user">t.mitsuchi3</div><div class="message__timestamp date"><a class="date" href="#message-1594116713.112400">2020-07-07&nbsp;19:11:53 +0900</a></div></div><div class="message__body description">個人的には「もしくは」と書いた方法でやっちゃいました。なぜならAMD を並び替えた ADM とかもぜんぶ有効にしたほうが、言語として親切だと思ったからです。</div></div></div><div class="message event" id="message-1594118202.112800"><div class="content"><div class="summary"><div class="message__header user">shunkichi.sato</div><div class="message__timestamp date"><a class="date" href="#message-1594118202.112800">2020-07-07&nbsp;19:36:42 +0900</a></div></div><div class="message__body description">@maoe<br/>ありがとうございます <code>asum</code> 試してみます<br/><br/>@t.mitsuchi3<br/>たしかにソートでできてしまうのですが<br/>なんというか <code>&lt;|&gt;</code> でつなげる順序に依存しない方法でいきたいのです<br/>AMDについてはこの並びしか許さない方針でいきます<br/><br/>@nobsun<br/>そうなんです<br/>なので各オペランドが <code>=</code> まで見るようにしないといけない<br/>そうすると冗長な記述になるのでどうしよう...というところです</div></div></div><div class="message event" id="message-1594121429.113700"><div class="content"><div class="summary"><div class="message__header user">shunkichi.sato</div><div class="message__timestamp date"><a class="date" href="#message-1594121429.113700">2020-07-07&nbsp;20:30:29 +0900</a></div></div><div class="message__body description">とりあえず<br/><pre>aDest = 
        M   &lt;$ "M"   &lt;* char '='
    &lt;|&gt; D   &lt;$ "D"   &lt;* char '='
    &lt;|&gt; MD  &lt;$ "MD"  &lt;* char '='</pre><br/>は<br/><pre>aDest = asum . map (&lt;* char '=') $
            [ M   &lt;$ "M"
            , D   &lt;$ "D"
            , MD  &lt;$ "MD"
            ]</pre><br/>と書けました</div></div></div><div class="message event" id="message-1594164690.114500"><div class="content"><div class="summary"><div class="message__header user">shunkichi.sato</div><div class="message__timestamp date"><a class="date" href="#message-1594164690.114500">2020-07-08&nbsp;08:31:30 +0900</a></div></div><div class="message__body description">さらにヘルパー演算子を入れて、だいぶスッキリしました<br/>ありがとうございました</div></div></div><div class="message event" id="message-1594182324.115400"><div class="content"><div class="summary"><div class="message__header user">sesame.parrot</div><div class="message__timestamp date"><a class="date" href="#message-1594182324.115400">2020-07-08&nbsp;13:25:24 +0900</a></div></div><div class="message__body description">@sesame.parrot has joined the channel</div></div></div><div class="message event" id="message-1594261873.131500"><div class="content"><div class="summary"><div class="message__header user">gettaplacetogo</div><div class="message__timestamp date"><a class="date" href="#message-1594261873.131500">2020-07-09&nbsp;11:31:13 +0900</a></div></div><div class="message__body description">import をインライン化したいのですが、何か既存のツールとか、使えそうなライブラリをご存知の方いらっしゃいますか？ 例えば<br/><br/><pre>​-- AtCoderPrelude.hs
​module AtCoderPrelude (readUVecLn, parseInt, otherfct) where
​​import Control.Monad.State.Strict (StateT, runStateT)
​​import qualified Data.ByteString as BS
​import qualified Data.ByteString.Char8 as BSC
​​import qualified Data.Vector.Unboxed as VU
​​import qualified Some.Random.Module as M
​​
​​-- | Given a parser, parse a whole input line and give a vector.
​​readUVecLn
​​  :: (VU.Unbox a)
​​  =&gt; Int                          -- ^ Expected maximum length 
​​  -&gt; StateT BS.ByteString Maybe a -- ^ Parser
​​  -&gt; IO (VU.Vector a)
​​readUVecLn len parser
​​  = VU.unfoldrN len (runStateT parser) &lt;$&gt; BS.getLine
​
​-- | Skip spaces and control chars, and parse an Int.
​parseInt :: StateT BS.ByteString Maybe Int
parse​Int = StateT
​  $ BSC.readInt . BS.dropWhile (&lt; fromIntegral (fromEnum '!'))
​
​otherfct :: A -&gt; Very -&gt; Useful -&gt; Function
​​otherfct = M.usefulFunction "SomeGoodString"
</pre><br/>と<br/><br/><pre>​-- Main.hs
​import AtCoderPrelude
​
​main :: IO ()	
​main = do
​  n &lt;- readLn
​  vec &lt;- readUVecLn n parseInt
​  print vec
</pre><br/>から<br/><br/><pre>​-- Merged.hs
​import qualified Control.Monad.State.Strict (StateT, runStateT) as M3a6f5d
​​import qualified Data.ByteString as M65a7e5
​import qualified Data.ByteString.Char8 as M47ef44
​​import qualified Data.Vector.Unboxed as M3266e4
​​
​​readUVecLn_M2346ed
​​  :: (M3266e4.Unbox a)
​​  =&gt; Int
​​  -&gt; M3a6f5d.StateT M65a7e5.ByteString Maybe a
​​  -&gt; IO (M3266e4.Vector a)
​​readUVecLn_M2346ed len parser
​​  = M3266e4.unfoldrN len (M3a6f5d.runStateT parser) &lt;$&gt; M65a7e5.getLine
​
​parseInt_M2346ed :: M3a6f5d.StateT M65a7e5.ByteString Maybe Int
parse​Int_M2346ed = M3a6f5d.StateT
​  $ M47ef44.readInt . M65a7e5.dropWhile (&lt; fromIntegral (fromEnum '!')
​
​main :: IO ()
​main = do
​  n &lt;- readLn
​  vec &lt;- readUVecLn_M2346ed n parseInt_M2346ed
​  print vec
</pre><br/>に類するもの(16進ハッシュは適当です)を作れると嬉しい、ということなのですが。<br/></div></div></div><div class="message event" id="message-1594263578.131600"><div class="content"><div class="summary"><div class="message__header user">ncaq</div><div class="message__timestamp date"><a class="date" href="#message-1594263578.131600">2020-07-09&nbsp;11:59:38 +0900</a></div></div><div class="message__body description">ハッシュ無くても良くて単に1つのソースコードにまとめたいと言うだけなら<br/>AtCoderPreludeからmodule宣言を無くして,<br/><pre>{-# LANGUAGE CPP #-}

#include "AtCoderPrelude.hs"</pre><br/>として<br/><code>cpphs --noline Main.hs</code><br/>とすれば1つにまとめられそうです.<br/><br/>Main.hsで新しくimport出来無くなったりする問題はありますが…<br/><br/>ハッシュ付けるならTemplate Haskellで頑張るしか私には思いつきませんね</div></div></div><div class="message event" id="message-1594267562.131900"><div class="content"><div class="summary"><div class="message__header user">igrep</div><div class="message__timestamp date"><a class="date" href="#message-1594267562.131900">2020-07-09&nbsp;13:06:02 +0900</a></div></div><div class="message__body description">makeMistakesToLearnHaskellでも :point_down: みたいな感じでその方法を採用しています。そのせいなのかカバレッジがうまくとれなかったりいろいろ難点はありますが、まぁまぁ便利です。<br/><a href='https://github.com/haskell-jp/makeMistakesToLearnHaskell/blob/master/src/imports/external.hs'>https://github.com/haskell-jp/makeMistakesToLearnHaskell/blob/master/src/imports/external.hs</a><br/><br/>早く <a href='https://github.com/ghc-proposals/ghc-proposals/pull/283'>https://github.com/ghc-proposals/ghc-proposals/pull/283</a> か <a href='https://github.com/ghc-proposals/ghc-proposals/pull/295'>https://github.com/ghc-proposals/ghc-proposals/pull/295</a> がacceptされるといいんですが... :disappointed:</div></div></div><div class="message event" id="message-1594371824.132200"><div class="content"><div class="summary"><div class="message__header user">tatsurotamashiro</div><div class="message__timestamp date"><a class="date" href="#message-1594371824.132200">2020-07-10&nbsp;18:03:44 +0900</a></div></div><div class="message__body description">@tatsurotamashiro has joined the channel</div></div></div><div class="message event" id="message-1594459062.132500"><div class="content"><div class="summary"><div class="message__header user">fal19cotton</div><div class="message__timestamp date"><a class="date" href="#message-1594459062.132500">2020-07-11&nbsp;18:17:42 +0900</a></div></div><div class="message__body description">@fal19cotton has joined the channel</div></div></div><div class="message event" id="message-1594465617.140000"><div class="content"><div class="summary"><div class="message__header user">gettaplacetogo</div><div class="message__timestamp date"><a class="date" href="#message-1594465617.140000">2020-07-11&nbsp;20:06:57 +0900</a></div></div><div class="message__body description">んー…なるほど。AtCoderで何百行あるテンプレートコードを使っていて、手元環境で全体のコードが長いとHIEが走るのが遅くなるんですよね。<br/>• 手元環境では、自作ライブラリ部分については先に別ファイルでコンパイルした状態で走ってもらう<br/>• AtCoder自動提出スクリプトを呼んだときに(ライブラリコードのほうはある程度のpreprocessをコンテスト開始前にやっておく前提でもいいから)オートでそれがインライン化される<br/>なんてことがあると嬉しい、というつもりだったのですが…難しそうですかね。</div></div></div><div class="message event" id="message-1594465709.140500"><div class="content"><div class="summary"><div class="message__header user">gettaplacetogo</div><div class="message__timestamp date"><a class="date" href="#message-1594465709.140500">2020-07-11&nbsp;20:08:29 +0900</a></div></div><div class="message__body description">回答ありがとうございます。</div></div></div><div class="message event" id="message-1594467547.142800"><div class="content"><div class="summary"><div class="message__header user">gettaplacetogo</div><div class="message__timestamp date"><a class="date" href="#message-1594467547.142800">2020-07-11&nbsp;20:39:07 +0900</a></div></div><div class="message__body description">使用したいモジュールも複数あるんですよね、これが…</div></div></div><div class="message event" id="message-1594467677.143100"><div class="content"><div class="summary"><div class="message__header user">shiogai1987</div><div class="message__timestamp date"><a class="date" href="#message-1594467677.143100">2020-07-11&nbsp;20:41:17 +0900</a></div></div><div class="message__body description">@shiogai1987 has joined the channel</div></div></div><div class="message event" id="message-1594471467.143400"><div class="content"><div class="summary"><div class="message__header user">igrep</div><div class="message__timestamp date"><a class="date" href="#message-1594471467.143400">2020-07-11&nbsp;21:44:27 +0900</a></div></div><div class="message__body description">うーん、なるほど、コンパイル済みであって欲しいと。となると力業でreexportなり衝突するところはrenameするパッケージを書いておいて（で、 <code>stack.yaml</code> とかにextra-depsとしてリポジトリーやtarballのURLを書いておき）、<br/>提出する手前で該当のパッケージのimportを適当なスクリプトでインライン化する、とかですかね...<br/>と、言う理解であってるかな？ :thinking_face:</div></div></div><div class="message event" id="message-1594476959.143700"><div class="content"><div class="summary"><div class="message__header user">ncaq</div><div class="message__timestamp date"><a class="date" href="#message-1594476959.143700">2020-07-11&nbsp;23:15:59 +0900</a></div></div><div class="message__body description">importの最後に自作ライブラリのimportを書いて<br/>提出前にsedとかでimportを置き換えるのが一番現実的…?</div></div></div><div class="message event" id="message-1594535803.144000"><div class="content"><div class="summary"><div class="message__header user">stmtk13044032</div><div class="message__timestamp date"><a class="date" href="#message-1594535803.144000">2020-07-12&nbsp;15:36:43 +0900</a></div></div><div class="message__body description">@stmtk13044032 has joined the channel</div></div></div><div class="message event" id="message-1594552299.147400"><div class="content"><div class="summary"><div class="message__header user">gettaplacetogo</div><div class="message__timestamp date"><a class="date" href="#message-1594552299.147400">2020-07-12&nbsp;20:11:39 +0900</a></div></div><div class="message__body description">はい、そんな感じになると思います。`AtCoderPrelude` だけじゃなくて <code>Numeric.LinearPrimeSieve</code> みたいなモジュールもあるので、単純に <code>sed</code> だとうまくいかないのが難点ですけどね・・・。</div></div></div><div class="message event" id="message-1594552631.155200"><div class="content"><div class="summary"><div class="message__header user">gettaplacetogo</div><div class="message__timestamp date"><a class="date" href="#message-1594552631.155200">2020-07-12&nbsp;20:17:11 +0900</a></div></div><div class="message__body description">まあ、プラグマ、`import`、宣言群という3グループごと流し込む位置を別々にしておけばいいだけのことなので、手作りすればいいだけのことなのですが、 <code>import ... as</code> に対応するのが面倒、とか、色々面倒だなあ、と思ったんですよね・・・。</div></div></div><div class="message event" id="message-1594991326.162500"><div class="content"><div class="summary"><div class="message__header user">dex10619</div><div class="message__timestamp date"><a class="date" href="#message-1594991326.162500">2020-07-17&nbsp;22:08:46 +0900</a></div></div><div class="message__body description">ある処理の実行時間を測りたい時、Haskellでよく使われるような書き方とかってありますか？<br/><br/>以下のコードはググって書いたコードで、私の実行環境だと、"2000"（プラス数ミリ秒）が出力されますが、この書き方はHaskellで一般的な書き方でしょうか。<br/><br/><pre>millisSinceEpoch :: UTCTime -&gt; Int 
millisSinceEpoch =
    floor . (1e3 *) . nominalDiffTimeToSeconds . utcTimeToPOSIXSeconds

main :: IO ()                                                                                                                                                                                                                                 
main = do
  start &lt;- millisSinceEpoch &lt;$&gt; getCurrentTime
  threadDelay $ 2 * 10 ^ 6 
  end &lt;- millisSinceEpoch &lt;$&gt; getCurrentTime
  print . show $ (end - start)</pre><br/>定番の書き方などがあれば、それに倣った方がよい気がするので、お伺いしたいです。</div></div></div><div class="message event" id="message-1594998464.162600"><div class="content"><div class="summary"><div class="message__header user">maoe</div><div class="message__timestamp date"><a class="date" href="#message-1594998464.162600">2020-07-18&nbsp;00:07:44 +0900</a></div></div><div class="message__body description">実行時間を計る場合はNTPなどの影響を減らすためにもgetCurrentTimeよりmonotonicな時計を使うことをおすすめします。clockパッケージのgetTime MonotonicやGHC依存でよいならGHC.Clock.getMonotonicTimeNSecなどがあります。</div></div></div><div class="message event" id="message-1595036094.163300"><div class="content"><div class="summary"><div class="message__header user">igrep</div><div class="message__timestamp date"><a class="date" href="#message-1595036094.163300">2020-07-18&nbsp;10:34:54 +0900</a></div></div><div class="message__body description">念のため。遅延IOによって思わぬコードが計測するコードの外側で実行される可能性があります。<br/>必要に応じてdeepseqの <code>rnf</code> と <code>evaluate</code> を組み合わせて使いましょう。<br/><a href='http://hackage.haskell.org/package/deepseq-1.4.4.0/docs/Control-DeepSeq.html'>http://hackage.haskell.org/package/deepseq-1.4.4.0/docs/Control-DeepSeq.html</a><br/>今回そこまで求めているかわかりませんが、GHCのプロファイリング機能やベンチマーク用のパッケージ（criterionなど）も調べてみるといいかもしれません。</div></div></div><div class="message event" id="message-1595051150.167500"><div class="content"><div class="summary"><div class="message__header user">dex10619</div><div class="message__timestamp date"><a class="date" href="#message-1595051150.167500">2020-07-18&nbsp;14:45:50 +0900</a></div></div><div class="message__body description"><@U4M9NJ7QE> さん<br/>ありがとうございます！勉強になります！<br/>getCurrenttimeはNTPの影響を受けるんですね。<br/><br/><br/><@U4LGTMTMK> さん<br/>貴重な情報ありがとうございます！<br/>まだリンク先は読みきれてないのですが、後ほど拝見しますm(__)m</div></div></div><div class="message event" id="message-1595074987.174900"><div class="content"><div class="summary"><div class="message__header user">maoe</div><div class="message__timestamp date"><a class="date" href="#message-1595074987.174900">2020-07-18&nbsp;21:23:07 +0900</a></div></div><div class="message__body description">計測対象が綺麗に切り出せるなら igrep さんの言うように <a href='https://hackage.haskell.org/package/criterion'>https://hackage.haskell.org/package/criterion</a> や <a href='https://hackage.haskell.org/package/gauge'>https://hackage.haskell.org/package/gauge</a> を使って計測するのがいいと思います。個人的にはcriterionと <a href='https://hackage.haskell.org/package/criterion-compare'>https://hackage.haskell.org/package/criterion-compare</a> で変更前後の結果を比較するのによく使っています。guauge にも似たような機能があるかも知れません。<br/><br/>実際のワークロードの一部を計測したいならmonotonicな時計を使って自分で差分を計算するのが良いと思います。</div></div></div><div class="message event" id="message-1595086204.176500"><div class="content"><div class="summary"><div class="message__header user">hexirp</div><div class="message__timestamp date"><a class="date" href="#message-1595086204.176500">2020-07-19&nbsp;00:30:04 +0900</a></div></div><div class="message__body description">こんな感じのコードがコンパイルエラーになったんだけど、どうしてなんでしょうか？（ DerivingVia 初心者）<br/><pre>  newtype Difference = Difference { unDifference :: Int }
    deriving stock (Eq, Ord, Bounded)
    deriving newtype (Enum, Show, Read, Num, Real, Integral)
    deriving (Semigroup, Monoid) via Sum Int</pre></div></div></div><div class="message event" id="message-1595086280.177000"><div class="content"><div class="summary"><div class="message__header user">hexirp</div><div class="message__timestamp date"><a class="date" href="#message-1595086280.177000">2020-07-19&nbsp;00:31:20 +0900</a></div></div><div class="message__body description">エラーメッセージはこんな感じです。<br/><pre>src\Numeric\YHSeq\V0201.hs:32:15: error:
    • Couldn't match representation of type 'Int'
                               with that of 'Sum Int'
        arising from the coercion of the method '&lt;&gt;'
          from type 'Sum Int -&gt; Sum Int -&gt; Sum Int'
            to type 'Difference -&gt; Difference -&gt; Difference'
      The data constructor 'base-4.12.0.0:Data.Semigroup.Internal.Sum'
        of newtype 'Sum' is not in scope
    • When deriving the instance for (Semigroup Difference)
   |
32 |     deriving (Semigroup, Monoid) via Sum Int
   |</pre></div></div></div><div class="message event" id="message-1595088755.177200"><div class="content"><div class="summary"><div class="message__header user">cohei</div><div class="message__timestamp date"><a class="date" href="#message-1595088755.177200">2020-07-19&nbsp;01:12:35 +0900</a></div></div><div class="message__body description">データコンストラクターの import で結果が変わりました。<br/><br/><pre>{-# LANGUAGE DerivingVia                #-}
{-# LANGUAGE GeneralizedNewtypeDeriving #-}
module A where

-- import           Data.Monoid (Sum) -- 同様のコンパイルエラー
import           Data.Monoid (Sum (Sum)) -- コンパイルできる

newtype Difference = Difference { unDifference :: Int }
  deriving stock (Eq, Ord, Bounded)
  deriving newtype (Enum, Show, Read, Num, Real, Integral)
  deriving (Semigroup, Monoid) via Sum Int</pre><br/>試してから気付きましたが、よく見るとエラーメッセージに<br/><br/><blockquote>The data constructor ‘base-4.12.0.0:Data.Semigroup.Internal.Sum’<br/>       of newtype ‘Sum’ is not in scope</blockquote>って書いてある通りですね。</div></div></div><div class="message event" id="message-1595089202.177500"><div class="content"><div class="summary"><div class="message__header user">cohei</div><div class="message__timestamp date"><a class="date" href="#message-1595089202.177500">2020-07-19&nbsp;01:20:02 +0900</a></div></div><div class="message__body description">データコンストラクターがないと <code>Sum Int</code> の中身が <code>Int</code> だと知ることができない、って感じだと思われます。</div></div></div><div class="message event" id="message-1595090315.178000"><div class="content"><div class="summary"><div class="message__header user">dex10619</div><div class="message__timestamp date"><a class="date" href="#message-1595090315.178000">2020-07-19&nbsp;01:38:35 +0900</a></div></div><div class="message__body description">@maoe <br/>ありがとうございます！</div></div></div><div class="message event" id="message-1595094389.182800"><div class="content"><div class="summary"><div class="message__header user">kakkun61</div><div class="message__timestamp date"><a class="date" href="#message-1595094389.182800">2020-07-19&nbsp;02:46:29 +0900</a></div></div><div class="message__body description">ここに質問を書こうと GitHub 上のソースコードへのリンクを調べてたらバグが分かった<br/>ありがとうございます</div></div></div></div><div class="pager ui pagination menu"><a href="../../html/C5666B6BB/87.html" class="pager__previous item">Previous</a><a href="../../" class="pager__top item">Top</a></div></div></body></html>