<!DOCTYPE html><html><head><meta charset="utf-8"><title>haskell-jp / questions #54</title><link rel="stylesheet" href="/slack-log/messages.css" type="text/css" media="screen"></head><body><h1>haskell-jp / questions #54</h1><div class="pager"><a href="/slack-log/html/C5666B6BB/53.html" class="pager__previous">Previous</a><a href="/slack-log/" class="pager__top">Top</a><a href="/slack-log/html/C5666B6BB/55.html" class="pager__next">Next</a></div><div class="message_list"><div class="message" id="message-1552802234.296900"><div class="message__timestamp">2019-03-17<br/>14:57:14 +0900</div><div class="message__header">misaki</div><div class="message__body">@misaki has joined the channel</div></div><div class="message" id="message-1552802641.299900"><div class="message__timestamp">2019-03-17<br/>15:04:01 +0900</div><div class="message__header">misaki</div><div class="message__body">Data.Map型の実装はList Tuple a bを低レイヤーで効率化(btreeに)したもののように見えるのですが，<br/>これをfoldableでパターンマッチングするときに(\acc (a, b) -&gt; --process)というような書き方をMapでできないでしょうか．</div></div><div class="message" id="message-1552804021.300300"><div class="message__timestamp">2019-03-17<br/>15:27:01 +0900</div><div class="message__header">ma.efjay</div><div class="message__body">@ma.efjay has joined the channel</div></div><div class="message" id="message-1552814581.300600"><div class="message__timestamp">2019-03-17<br/>18:23:01 +0900</div><div class="message__header">as_capabl</div><div class="message__body">Mapをキーと値のペアについてfoldしたい、という事ならば、Data.Map.toListで一度リスト化してからfoldするか、またはData.Map.foldlWithKeyなどの関数があるのでこれを使うか、でどうでしょう</div></div><div class="message" id="message-1552831769.301100"><div class="message__timestamp">2019-03-17<br/>23:09:29 +0900</div><div class="message__header">misaki</div><div class="message__body">ありがとうございます．<br/>やはりそういった方向になるんですね．<br/>今回は[(a, b)]で実装しました．</div></div><div class="message" id="message-1552892042.301800"><div class="message__timestamp">2019-03-18<br/>15:54:02 +0900</div><div class="message__header">a0</div><div class="message__body">@a0 has joined the channel</div></div><div class="message" id="message-1552968004.302300"><div class="message__timestamp">2019-03-19<br/>13:00:04 +0900</div><div class="message__header">yuukai.tuukai</div><div class="message__body">@yuukai.tuukai has joined the channel</div></div><div class="message" id="message-1552991814.306500"><div class="message__timestamp">2019-03-19<br/>19:36:54 +0900</div><div class="message__header">junji.hashimoto</div><div class="message__body">stackでbackpackをサポートしてほしいのですが<br/>地道にコマンドを追いかけるしかないですかね<br/><a href='https://github.com/commercialhaskell/stack/issues/2540'>https://github.com/commercialhaskell/stack/issues/2540</a><br/>作者も忙しそうなので自分で頑張るしかない気がしております</div></div><div class="message" id="message-1553056998.307300"><div class="message__timestamp">2019-03-20<br/>13:43:18 +0900</div><div class="message__header">khibino</div><div class="message__body">もしかして、 foldrWithKey が相当するものではないでしょうか?</div></div><div class="message" id="message-1553171993.308500"><div class="message__timestamp">2019-03-21<br/>21:39:53 +0900</div><div class="message__header">ue_wo</div><div class="message__body">@ue_wo has joined the channel</div></div><div class="message" id="message-1553226562.309200"><div class="message__timestamp">2019-03-22<br/>12:49:22 +0900</div><div class="message__header">misaki</div><div class="message__body">foldrWithKeyのようです．<br/>ありがとうございます!</div></div><div class="message" id="message-1553307947.309500"><div class="message__timestamp">2019-03-23<br/>11:25:47 +0900</div><div class="message__header">rinseki.contact</div><div class="message__body">@rinseki.contact has joined the channel</div></div><div class="message" id="message-1553487346.310300"><div class="message__timestamp">2019-03-25<br/>13:15:46 +0900</div><div class="message__header">hiroto.shioi</div><div class="message__body">Haskellライブラリ公開に向けてのベストプラクティスみたいな記事とかありますか？<br/>自分でライブラリを開発して、最終的にHackageにて公開、逐次バージョンアップデートする方法を紹介してくれるとありがたいです。</div></div><div class="message" id="message-1553489150.310600"><div class="message__timestamp">2019-03-25<br/>13:45:50 +0900</div><div class="message__header">kakkun61</div><div class="message__body">日本語記事なかったら書くべき事案っぽい気がしますね（書ける人が</div></div><div class="message" id="message-1553493091.311300"><div class="message__timestamp">2019-03-25<br/>14:51:31 +0900</div><div class="message__header">matsubara0507</div><div class="message__body">hackage upload とか検索すると、色々出てくる気がするけど</div></div><div class="message" id="message-1553495362.311600"><div class="message__timestamp">2019-03-25<br/>15:29:22 +0900</div><div class="message__header">hiroto.shioi</div><div class="message__body">出てくるけど、ベストプラクティスというには程遠いと思う。<br/><a href='http://hackage.haskell.org/upload'>http://hackage.haskell.org/upload</a><br/>理想的には読めばHaskell初心者でも実務で利用可能なライブラリを公開できるような記事が望ましいです。</div></div><div class="message" id="message-1553504707.311900"><div class="message__timestamp">2019-03-25<br/>18:05:07 +0900</div><div class="message__header">igrep</div><div class="message__body">パッケージのユーザーから見てよいパッケージが何かを知れば、概ねそのまま作る側のベストプラクティスを教えることになるかと思うのですがいかがでしょうか？<br/>（と、自分の記事を推す）<br/><a href='https://wiki.haskell.jp/Hikers%20Guide%20to%20Haskell#%E3%83%91%E3%83%83%E3%82%B1%E3%83%BC%E3%82%B8%E3%81%A8%E3%81%AE%E4%BB%98%E3%81%8D%E5%90%88%E3%81%84%E6%96%B9'>https://wiki.haskell.jp/Hikers%20Guide%20to%20Haskell#%E3%83%91%E3%83%83%E3%82%B1%E3%83%BC%E3%82%B8%E3%81%A8%E3%81%AE%E4%BB%98%E3%81%8D%E5%90%88%E3%81%84%E6%96%B9</a></div></div><div class="message" id="message-1553505548.312300"><div class="message__timestamp">2019-03-25<br/>18:19:08 +0900</div><div class="message__header">as_capabl</div><div class="message__body">最低限cabal sdistコマンドでワーニングが出なければOKだと思います。ただし必要物を.cabalに書き忘れるのは注意っぽい。hpackを使えば自動でファイルリストを書いてくれるのでベター</div></div><div class="message" id="message-1553505832.312600"><div class="message__timestamp">2019-03-25<br/>18:23:52 +0900</div><div class="message__header">takiy33</div><div class="message__body">@takiy33 has joined the channel</div></div><div class="message" id="message-1553506735.312900"><div class="message__timestamp">2019-03-25<br/>18:38:55 +0900</div><div class="message__header">fumieval</div><div class="message__body"><a href='https://scrapbox.io/haskell-shoen/%E3%83%A9%E3%82%A4%E3%83%96%E3%83%A9%E3%83%AA%E4%BD%9C%E6%88%90%E3%83%81%E3%83%A3%E3%83%BC%E3%83%88'>https://scrapbox.io/haskell-shoen/%E3%83%A9%E3%82%A4%E3%83%96%E3%83%A9%E3%83%AA%E4%BD%9C%E6%88%90%E3%83%81%E3%83%A3%E3%83%BC%E3%83%88</a>　軽くまとめてみました。もっと書くことはありそう</div></div><div class="message" id="message-1553509814.313600"><div class="message__timestamp">2019-03-25<br/>19:30:14 +0900</div><div class="message__header">hiroto.shioi</div><div class="message__body">@fumieval ありがとうございます！</div></div><div class="message" id="message-1553512888.313900"><div class="message__timestamp">2019-03-25<br/>20:21:28 +0900</div><div class="message__header">hygxsh2k</div><div class="message__body">@hygxsh2k has joined the channel</div></div><div class="message" id="message-1553533818.318000"><div class="message__timestamp">2019-03-26<br/>02:10:18 +0900</div><div class="message__header">ah</div><div class="message__body">AWS Lambda上でHaskellを動かす知見をお持ちの方はいらっしゃらないでしょうか・・・<br/><br/>aws-lambda-haskell-runtime（<https://github.com/theam/aws-lambda-haskell-runtime）><br/>や<br/>Serverless Haskell（<https://github.com/seek-oss/serverless-haskell）><br/>を試してみて、単純なサンプルは動作するのですがDynamoDBにアクセスしてみると90秒などという長大な時間がかかってしまい、とても使い物にならないのです。<br/>DynamoDBだけでなくHTTPS通信全般がどうも遅いようで、S3へのアクセスや単なるWebサイトのデータを取ってくるだけでも非常に時間がかかってしまいます。</div></div><div class="message" id="message-1553583486.324600"><div class="message__timestamp">2019-03-26<br/>15:58:06 +0900</div><div class="message__header">junji.hashimoto</div><div class="message__body">https全般はtlsがおそいのでopenssl使ってますが、それ以外は気にならないですね<br/>nodeとかでかいたものよりメモリも使わず快適に動いています<br/></div></div><div class="message" id="message-1553584416.324800"><div class="message__timestamp">2019-03-26<br/>16:13:36 +0900</div><div class="message__header">junji.hashimoto</div><div class="message__body">haskell-runtimeつかってません。<br/>node.jsからデータを渡してつかっています。<br/>runtimeの問題かもですね。</div></div><div class="message" id="message-1553585194.326600"><div class="message__timestamp">2019-03-26<br/>16:26:34 +0900</div><div class="message__header">maoe</div><div class="message__body">Travisなどで複数バージョンのGHCに対してテストすると良いと思います <a href='https://github.com/haskell-CI/haskell-ci'>https://github.com/haskell-CI/haskell-ci</a> が便利です。</div></div><div class="message" id="message-1553585274.328400"><div class="message__timestamp">2019-03-26<br/>16:27:54 +0900</div><div class="message__header">maoe</div><div class="message__body">cabal sdist してビルドしたりcabal checkもしてくれるので簡単なミスも気がつけます</div></div><div class="message" id="message-1553609423.329000"><div class="message__timestamp">2019-03-26<br/>23:10:23 +0900</div><div class="message__header">cgp</div><div class="message__body">@cgp has joined the channel</div></div><div class="message" id="message-1553658157.340400"><div class="message__timestamp">2019-03-27<br/>12:42:37 +0900</div><div class="message__header">shunsuke.masuda</div><div class="message__body">Either モナドの使い方をお尋ねします。<br/><br/>Eitherを返す複数の関数を組み合わせ Eitherを返す関数を作るとき、組み合わせに含まれるどの関数のLeftで処理が中断されたかわかるようにする方法はありますか？<br/><br/>例えば以下のようなコードがあったとき、<br/><pre>
caller x= do
      case someFunc x of
            Left err -&gt; print err
            Right y -&gt; ..

someFunc:: MyType -&gt; Either String OtherType
someFunc mt = do
       first &lt;- SomeEitherFunc mt
       second &lt;- AnotherEitherFunc first
       …
</pre><br/><br/>caller 側でLeftを受け取ったとき、 SomeEitherFuncから来たか、AnotherEitherFuncから来たかを区別したいです。<br/>区別する目的は、デバッグや障害時の原因究明で、どこでLeftが発生したかを把握するためです。SomeEitherFunc の Left や、 AnotherEitherFunc  の Leftは、どのようなメッセージを持つか事前に分かりません。<br/><br/><pre>
     case SomeEitherFunc mt of
          Left err -&gt; Left ( "from SomeEitherFunc:" ++ err)
</pre><br/><br/>としていけば目的達成できますが、書き方として冗長な気がするので、別の方法があれば教えていただきたいです。</div></div><div class="message" id="message-1553659195.340600"><div class="message__timestamp">2019-03-27<br/>12:59:55 +0900</div><div class="message__header">kakkun61</div><div class="message__body">.o( 何らかソースコードを書き換えないとムリかなぁ</div></div><div class="message" id="message-1553661037.340800"><div class="message__timestamp">2019-03-27<br/>13:30:37 +0900</div><div class="message__header">igrep</div><div class="message__body">結論から言うと直接実現するのは無理です。<br/>挙げていただいた :point_down: 相当のことを行う、errorsパッケージの <code>Data.EitherR.fmapL</code> 関数を使って頑張るしかないでしょう。<br/>同じような関数はほかのパッケージにもたくさんあるので、探して依存するなりコピペするなりするとよいかと思います。<br/><br/><pre>
case SomeEitherFunc mt of

         Left err -&gt; Left ( "from SomeEitherFunc:" ++ err)
</pre></div></div><div class="message" id="message-1553661184.341000"><div class="message__timestamp">2019-03-27<br/>13:33:04 +0900</div><div class="message__header">kakkun61</div><div class="message__body"><blockquote>デバッグや障害時の原因究明</blockquote>のためならロガーをしこむのが順当な対応ですかね</div></div><div class="message" id="message-1553661321.341300"><div class="message__timestamp">2019-03-27<br/>13:35:21 +0900</div><div class="message__header">as_capabl</div><div class="message__body">someFuncをいじって良いなら、こんな感じに書きます(例として挙がっているやつを関数化しただけ)<br/><br/><pre>haskell
ePrefix :: String -&gt; Either String r -&gt; Either String r
ePrefix pfx (Left orig) = Left (pfx ++ orig)
ePrefix _ r = r

someFunc:: MyType -&gt; Either String OtherType
someFunc mt = do
       first &lt;-  ePrefix "someEitherFunc"    $ someEitherFunc mt
       second &lt;- ePrefix "anotherEitherFunc" $ anotherEitherFunc first
</pre></div></div><div class="message" id="message-1553662309.341800"><div class="message__timestamp">2019-03-27<br/>13:51:49 +0900</div><div class="message__header">hiroto.shioi</div><div class="message__body">自分ならEither String OtherTypeからEither MyException OtherTypeに変換して、caller側でMyExceptionの値に応じて場合分けするかなー。こんな感じ<br/><br/><pre>
caller x= do
      case someFunc x of
            Left err -&gt; print err
            Right y -&gt; print y

type MyType = Int
type OtherType = String

someFunc:: MyType -&gt; Either MyException OtherType
someFunc mt = do
       first &lt;- someEitherFuncWithException mt
       second &lt;- anotherEitherFuncWithException first
       return second
  where
    someEitherFuncWithException = convert SomeEitherError . someEitherFunc
    anotherEitherFuncWithException first = convert AnotherEitherFuncError (anotherEitherFunc first)
    someEitherFunc _    = Left "wrong"
    anotherEitherFunc _ = Right "Correct!"

data MyException = SomeEitherError | AnotherEitherFuncError
    deriving Show

convert :: MyException -&gt; Either String a -&gt; Either MyException a
convert myException (Left _)      = Left myException
convert _           (Right other) = return other
</pre></div></div><div class="message" id="message-1553671756.342600"><div class="message__timestamp">2019-03-27<br/>16:29:16 +0900</div><div class="message__header">fumieval</div><div class="message__body">今来ました。こんな風にコールスタックを使うのはいかが？<br/><pre>
import GHC.Stack

throw :: HasCallStack =&gt; String -&gt; Either (CallStack, String) a
throw msg = Left (popCallStack callStack, msg)

foo :: HasCallStack =&gt; Either (CallStack, String) ()
foo = throw "err"

bar :: HasCallStack =&gt; Either (CallStack, String) ()
bar = throw "err"

main = case foo &gt;&gt; bar of
  Left (e, msg) -&gt; do
    putStrLn $ prettyCallStack e
    putStrLn msg
  Right a -&gt; print a
</pre></div></div><div class="message" id="message-1553671784.342800"><div class="message__timestamp">2019-03-27<br/>16:29:44 +0900</div><div class="message__header">fumieval</div><div class="message__body">実行するとこんな感じで場所がわかります<br/><pre>
CallStack (from HasCallStack):
  foo, called at stack.hs:12:13 in main:Main
err
</pre></div></div><div class="message" id="message-1553692763.345700"><div class="message__timestamp">2019-03-27<br/>22:19:23 +0900</div><div class="message__header">igrep</div><div class="message__body"><a href='https://github.com/chrisdone/pure-io'>https://github.com/chrisdone/pure-io</a> の代わりになるような、ファイルシステムなどへの読み書きをMonadで簡単にシミュレートするためのパッケージはありませんか？<br/>リポジトリーがすでにarchivedされていることからわかるとおり、もうpure-ioはメンテされていません。</div></div><div class="message" id="message-1553692782.345900"><div class="message__timestamp">2019-03-27<br/>22:19:42 +0900</div><div class="message__header">igrep</div><div class="message__body">参考までに、pure-ioのドキュメントはこちらです。 <a href='http://hackage.haskell.org/package/pure-io-0.2.1/docs/PureIO.html'>http://hackage.haskell.org/package/pure-io-0.2.1/docs/PureIO.html</a></div></div><div class="message" id="message-1553692834.346200"><div class="message__timestamp">2019-03-27<br/>22:20:34 +0900</div><div class="message__header">igrep</div><div class="message__body">まぁ、もちろんユースケースに応じて自前で定義すればいいんですけど...</div></div><div class="message" id="message-1553731536.346600"><div class="message__timestamp">2019-03-28<br/>09:05:36 +0900</div><div class="message__header">igrep</div><div class="message__body">改めて検索してみましたがなさそうなのでこの際自分で作りますね。。。ある程度拡張性も視野に入れつつ、できるだけ単純なものを。</div></div><div class="message" id="message-1553764277.000100"><div class="message__timestamp">2019-03-28<br/>18:11:17 +0900</div><div class="message__header">junji.hashimoto</div><div class="message__body">いまいちユーザーケースがわからないのですが、<br/>どういう用途なのでしょうか。</div></div><div class="message" id="message-1553764368.000300"><div class="message__timestamp">2019-03-28<br/>18:12:48 +0900</div><div class="message__header">junji.hashimoto</div><div class="message__body">閉鎖された環境はdockerで手に入りますし。</div></div><div class="message" id="message-1553770944.000500"><div class="message__timestamp">2019-03-28<br/>20:02:24 +0900</div><div class="message__header">igrep</div><div class="message__body">閉鎖された環境が欲しいんじゃなくて、ファイルシステムっぽく振る舞うtest doubleが欲しいのです。<br/>例えば今やりたいのは<br/><br/><pre>
readHoge :: Monad m =&gt; (FilePath -&gt; m String) -&gt; m String
readHoge readF = do
  hogeContent &lt;- readF "hoge"
  return $ "Hoge: " ++ hogeContent
</pre><br/><br/>みたいに、 <code>readFile</code> っぽくふる舞う関数をパラメーターとして受け取れるようにすることで、 <code>IO</code> に依存した処理をテストしやすくする、ということを私はよくやるのですが、その際にテスト用のファイルシステムの実装が必要となるのです。</div></div><div class="message" id="message-1553771931.000700"><div class="message__timestamp">2019-03-28<br/>20:18:51 +0900</div><div class="message__header">igrep</div><div class="message__body">ちなみに、環境の分離、という意味では <a href='https://www.haskell.org/'>https://www.haskell.org/</a> にある「Try It!」で使用されています。<br/>Dockerよりもお手軽！</div></div><div class="message" id="message-1553775188.001100"><div class="message__timestamp">2019-03-28<br/>21:13:08 +0900</div><div class="message__header">junji.hashimoto</div><div class="message__body">なるほど。</div></div><div class="message" id="message-1553775268.001300"><div class="message__timestamp">2019-03-28<br/>21:14:28 +0900</div><div class="message__header">junji.hashimoto</div><div class="message__body"><a href='https://www.gnu.org/software/libc/manual/html_node/Replacing-malloc.html'>https://www.gnu.org/software/libc/manual/html_node/Replacing-malloc.html</a><br/>LD_PRELOAD<br/>つかうのが簡単ですがそういうのじゃないですよね。</div></div><div class="message" id="message-1553775441.001700"><div class="message__timestamp">2019-03-28<br/>21:17:21 +0900</div><div class="message__header">igrep</div><div class="message__body">そっすね。あくまでHaskellレベルでお手軽にDIしたいので。（まぁ人によってはそっちの方が簡単に感じるかも知れませんが）</div></div><div class="message" id="message-1553778682.002100"><div class="message__timestamp">2019-03-28<br/>22:11:22 +0900</div><div class="message__header">as_capabl</div><div class="message__body">どうせならextensibleとか使ってみてはどうでしょう</div></div><div class="message" id="message-1553836212.003000"><div class="message__timestamp">2019-03-29<br/>14:10:12 +0900</div><div class="message__header">amutake.s</div><div class="message__body">@amutake.s has joined the channel</div></div><div class="message" id="message-1553867397.003300"><div class="message__timestamp">2019-03-29<br/>22:49:57 +0900</div><div class="message__header">igrep</div><div class="message__body">雑に書いてリリースしました。<br/><a href='http://hackage.haskell.org/package/fakefs'>http://hackage.haskell.org/package/fakefs</a><br/>extensibleどころかものすごく古典的な書き方で作ってしまいましたが、拡張性の要件は満たせてるはず。。。<br/><br/>ソースはこちら。別件で急いでいるのでドキュメントは後回しにします。あしからず！ :sweat_drops:<br/><a href='https://gitlab.com/igrep/haskell-fakefs/blob/master/src/Test/FileSystem/Fake.hs'>https://gitlab.com/igrep/haskell-fakefs/blob/master/src/Test/FileSystem/Fake.hs</a></div></div></div><div class="pager"><a href="/slack-log/html/C5666B6BB/53.html" class="pager__previous">Previous</a><a href="/slack-log/" class="pager__top">Top</a><a href="/slack-log/html/C5666B6BB/55.html" class="pager__next">Next</a></div></body></html>