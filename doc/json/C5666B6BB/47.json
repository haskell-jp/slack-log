[
    {
        "ts": "1551681051.021900",
        "text": "デフォルトなのは外部のCライブラリに依存しないでビルドできるからだと思います。\n僕もtls回りが遅くて以前見てみたことがあります。詳細は忘れましたが依存ライブラリ（Haskellコード）を少し弄ったら速度が結構改善しました。全体的にあまり速度を気にして書いているコードではない印象でした。",
        "user": "U4M9NJ7QE",
        "type": "message"
    },
    {
        "ts": "1551681815.022300",
        "text": "tlsを改善するコードをつくっていくしかなさそうですかね。",
        "user": "U74KTAG0N",
        "type": "message"
    },
    {
        "ts": "1551697808.025800",
        "text": "Windows 10 (ghc: 一定, ghci: 一定)\nMac/Linux (ghc: 不定, ghci: 一定)\n\nこういうことで、その値は本来なら範囲外であるデータに由来していることですね。",
        "user": "U5LEE6C1J",
        "type": "message"
    },
    {
        "ts": "1551697898.026000",
        "text": "mizunashi-mana さんのソースコードを実行してみた所、以下のような結果になりました (ghc, ghci どちらでも同じ)\n\n```\n0\nMyI# 0#\nIBI# 0#\n2305843009213693952\nMyI# 0#\nCB\n10\nCB\nCA\nCC\n```",
        "user": "U5LEE6C1J",
        "type": "message"
    },
    {
        "ts": "1551701736.026300",
        "text": "うちのmacだと， GHCi を再度立ち上げながら実行した場合も同様に実行度に値が変わりました．再起動しないままだと常に同じ値ですね．\nしかし， `unsafeCoerce LD :: CompactD` が `CA` にならないのは驚きですね． tagging による分岐が Windows だと違ったりするんですかね？",
        "user": "U57D08Z9U",
        "type": "message"
    },
    {
        "ts": "1551703452.026500",
        "text": "あ，そういえば上のソースコードは，一度ビルドしたものを実行しています． `runghc` / `ghci` だと `unsafeCoerce LD :: CompactD` は `CC` になりました．ビルドする場合は `-O0` でも `CA` になりましたね． `ghci` だと pointer tagging は機能してなかったりするんですかね？ `runghc` / `ghci` の結果は以下のようになりました(と言っても数字の部分は実行度に異なりますが):\n\n```\n4539535848\nMyI# 4539535848#\nIBI# 4539535848#\n-3458764513802808375\nMyI# 4539533688#\nCB\n10\nCB\nCA\nCC\n```",
        "user": "U57D08Z9U",
        "type": "message"
    },
    {
        "ts": "1551706567.026700",
        "text": "せっかくなので、元々のコードの方について、メモリ表現を覗けるようにしてみました。\n以下のgistに貼り付けてあります。\n<https://gist.github.com/takenobu-hs/751aed055481d3594cf439a40790119b>\n\nCoerce2.hsを手元のUbuntuでコンパイルして実行すると、16進数で「0x4000_0000_0000_4645」を出力します。\n\nExecution.txt の方には、ghcコマンドオプションでのstg, cmm, アセンブリのダンプ結果と、最終バイナリの逆アセンブル結果を付けています。\n\n「0x4000_0000_0000_4645」の値は、objdump -D での逆アセンブルの箇所で、Main_boolzuvar1_closure から、+9 byte目からの8byteに一致しています。\n（4a4309 番地から、4a4310番地までの値。）\n\nということで、まさに、True_closure + 9 からの8byteを拾っている挙動ですね。\n\nいずれにしても、GHCi含めて、その時々の後続のメモリを素直に拾っているというとこですね。\nそもそもunsafeの非保証動作の場合ですね:slightly_smiling_face:",
        "user": "U55V441FS",
        "type": "message"
    },
    {
        "ts": "1551739039.027200",
        "text": "+9 （アラインメントしていない場所）からの8バイト、というのがすごく気持ち悪いです… intel だから読めるけどそれ以外のアーキテクチャだったらアラインメントエラーになるのでは、という感が",
        "user": "UF8SE896V",
        "type": "message"
    },
    {
        "ts": "1551739309.027400",
        "text": "TLSライブラリのメンテナの山本です。\n性能は上げたいのですが、個人的にはTLS 1.3とQUICの実装で忙しいので、手が回っていません。\n性能を上げるPRは大歓迎で、最優先でマージしますので、ぜひ送ってください。\nただ、もうすぐQUICのために大改造が入るので、桜の咲く頃まで待っていただけると助かります。",
        "user": "U56MBRKR9",
        "type": "message"
    },
    {
        "ts": "1551739364.027600",
        "text": "とりあえず、hs-tlsのissueに登録していただけると助かります。",
        "user": "U56MBRKR9",
        "type": "message"
    }
]