[
    {
        "ts": "1760848332.180029",
        "text": "山本悠滋です。\n今日は <https://shinjukugyoen.connpass.com/event/371150/> に参加しているので、合間にいつもどおりmakeMistakesToLearnHaskellの続きを進められていたらします。",
        "type": "message",
        "user": "U4LGTMTMK"
    },
    {
        "ts": "1760864420.240629",
        "text": "",
        "type": "message",
        "user": null
    },
    {
        "ts": "1760865294.201419",
        "text": "先週行った、rename 関数 case 式対応の確認をしていました。\n確認したいテストケースを rename 関数に渡す方法の試行錯誤や、渡して処理した結果の正否確認に手間取ってしまいました。\n確認した結果、実装内容が間違っていたことがわかり、修正を行い何とか正しい結果が得られるようになりました。\nEx.6.4 の問題文を見ると、freeVars_case, abstract_case, collectSCs_case の定義を与えてテストするようにとありましたが、\ncollectSCs_e 関数は case 式に最初から対応済みのようで、case 式を含むコア言語プログラムのラムダリフティングも一応できましたので、\nこの問題はひとまず完了とさせていただこうと思います。",
        "type": "message",
        "user": "U04BD6ZFKQ8"
    },
    {
        "ts": "1760865302.002589",
        "text": "Competitive Programming in Haskell: Tree path decomposition, part I: 読了　先々週の課題の２つ目 \"Factor-Full Tree\" の解説のその１　続きが来週にあるとのことで　難度が今まで最高の Difficulty: Hard 7.4 なので　さすがに最終解決までに２回を掛けるらしい　自分の解は「異なる素数を各枝に配する」ものであって WA (testcase 7/36) 判定でした　まさしく解説のとおり木の枝数が長い path がある場合に label が integer overflow になってしまうからで　いろいろ模索しても解けなかった　想定解は来週までお預け　加えて類似問題２問を与えられてしまう　トホホ．．．　出直します",
        "type": "message",
        "user": "U584T7GAH"
    },
    {
        "ts": "1760869742.728419",
        "text": "電車の中などでmakeMistakesToLearnHaskellを進めてました。\n<https://github.com/haskell-jp/makeMistakesToLearnHaskell/commit/50aafbc8965053754841e1e8e657ef4f44c860cc>",
        "type": "message",
        "user": "U4LGTMTMK"
    },
    {
        "ts": "1760871592.356479",
        "text": "書籍: 関数型プログラミング実践入門を読みつつ、手を動かせました。\n特にフィボナッチ数列で遊んでHaskellすげぇぇ!となりました。\n一応Qiitaにもまとめておいたので、よりエレガントな実装とかあれば教えてください!\n\n<https://qiita.com/sigma_devsecops/items/24e05b6248b717aa4067>",
        "type": "message",
        "user": "U09ME60J23W"
    }
]