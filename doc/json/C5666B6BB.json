[
    {
        "ts": "1506918287.000062",
        "text": "少なくともHackageのソースを見る限り <https://hackage.haskell.org/package/bytestring-0.10.8.2/docs/src/Data.ByteString.html#local-6989586621679051445> 、findEOFというローカル関数が \"\\n\" かどうかしか見ていないのが直接的な原因ですね。で、ここで init で末尾の文字を取り除いた場合、改行コードが LF のみの環境では、末尾にある改行コードでない文字が削られてしまうので問題が起きます。",
        "user": "U61BA2X0U",
        "type": "message"
    },
    {
        "ts": "1506921715.000050",
        "text": "<@U61BA2X0U> ありがとうございます　と言っても小生にはバグか仕様か分かりませんし　どう対処すべきなのか不明なのですが　まあ競プロなどにおいては　いっそのこと `Data.Text.IO.getLine` に乗り換えるべきでしょうか？　使った事が無いのですが　充分に速いのでしょうか　試してみます",
        "user": "U584T7GAH",
        "type": "message"
    },
    {
        "ts": "1506924572.000033",
        "text": "<https://github.com/haskell/bytestring/issues/13> Issueが上がっていますが放置されているみたいですね…\\rも取れるように変えられないか聞いてみます",
        "user": "U4KUNQF9N",
        "type": "message"
    },
    {
        "ts": "1506991025.000146",
        "text": "Data.ByteString のinitとlastはO(1)で計算されるみたいなので、とりあえずのworkaroundとして last str が '\\r' に等しかったら init str を、そうでなければ str を返す関数を書いておくのはどうでしょうか",
        "user": "U61BA2X0U",
        "type": "message"
    },
    {
        "ts": "1506994000.000106",
        "text": "とりあえずこんな関数を書いてみました。 <https://gist.github.com/naohaq/b90edfa7308dd8db51314829d005df5e>",
        "user": "U61BA2X0U",
        "type": "message"
    },
    {
        "ts": "1506994937.000100",
        "text": "```\nimport qualified Data.ByteString.Char8 as C\n\nchomp :: C.ByteString -&gt; C.ByteString\nchomp str | C.length str &lt; 1   = str\n          | C.last str == '\\r' = C.init str\n          | otherwise = str\n```",
        "user": "U61BA2X0U",
        "type": "message"
    },
    {
        "ts": "1507003088.000178",
        "text": "CRもLFもCRLFも取り除けるように直してみた。\n```\nchomp :: C.ByteString -&gt; C.ByteString\nchomp str = chompCRLF $ chompCRLF str\n  where chompCRLF s =\n          case C.unsnoc s of\n            Nothing -&gt; s\n            Just (s_c, '\\r') -&gt; s_c\n            Just (s_c, '\\n') -&gt; s_c\n            Just _ -&gt; s\n```",
        "user": "U61BA2X0U",
        "type": "message"
    },
    {
        "ts": "1507010263.000094",
        "text": "log 2 x の整数部分だけが欲しくなることがよくあり、以下のようなコードを使うことが多いです。\n\n```\nlog2Int :: Int -&gt; Int\nlog2Int x = truncate $ logBase 2 $ fromIntegral x\n```\n\n計算が Int で閉じていて、速度が速い関数ってありますか？\nfromIntegral と truncate が気に入らないとも言う。",
        "user": "U56MBRKR9",
        "type": "message"
    },
    {
        "ts": "1507010493.000091",
        "text": "Data.Bits の `countLeadingZeros` 使うのはどうですか？ <https://hackage.haskell.org/package/base-4.10.0.0/docs/Data-Bits.html#v:countLeadingZeros>\n```\nlogBase2 x = finiteBitSize x - 1 - countLeadingZeros x\n```",
        "user": "U61BA2X0U",
        "type": "message"
    },
    {
        "ts": "1507011312.000014",
        "text": "<@U4KUNQF9N> <@U61BA2X0U> Awesome, thank you much!",
        "user": "U584T7GAH",
        "type": "message"
    },
    {
        "ts": "1507011776.000135",
        "text": "おー！ ありがとう！",
        "user": "U56MBRKR9",
        "type": "message"
    },
    {
        "ts": "1507012163.000046",
        "text": "countLeadingZeros の Int 実装は clz# を呼んでますが、これって CPU 命令に翻訳されますか？\nもしかして、自分で strings.h ffsll とかの FFI を定義しなくていい？？？？",
        "user": "U56MBRKR9",
        "type": "message"
    },
    {
        "ts": "1507012263.000108",
        "text": "昔 ffsll が O(1) であること仮定したアルゴリズムを書いたことがあるんです。\n素直に Data.Bits を使えばよかったのか？",
        "user": "U56MBRKR9",
        "type": "message"
    },
    {
        "ts": "1507014084.000038",
        "text": "とりあえずGHCのソースを見た感じだと、GHCのPrimitive Operation <https://ghc.haskell.org/trac/ghc/wiki/Commentary/PrimOps> として実装されているように見えます &lt; clz#",
        "user": "U61BA2X0U",
        "type": "message"
    },
    {
        "ts": "1507017384.000228",
        "text": "__builtin_clz*() is supported by GCC and Clang\nということで、コンパイラに任されるようですね。",
        "user": "U56MBRKR9",
        "type": "message"
    },
    {
        "ts": "1507076790.000155",
        "text": "そういえば、整数値をF_2を係数体とする多項式だと思って剰余を取る関数を書こうとしたときに、WordとかIntだと最上位の0じゃないビットを探すのにcountLeadingZerosが使えるけどIntegerだと使えないのをどうしようかと悩んだんですけど、こういうの普通はどうするんですかね？\n(追記)FiniteBits a とそうでない場合で実装を分けたいんだけど、という疑問です",
        "user": "U61BA2X0U",
        "type": "message"
    },
    {
        "ts": "1507077967.000033",
        "text": "log_2 の整数部分じゃだめですか？",
        "user": "U6S3ARBDL",
        "type": "message"
    },
    {
        "ts": "1507078093.000031",
        "text": "直前のkazuさんの質問を参照されたしー",
        "user": "U61BA2X0U",
        "type": "message"
    },
    {
        "ts": "1507078147.000061",
        "text": "おっと、thread見てなかったです",
        "user": "U6S3ARBDL",
        "type": "message"
    },
    {
        "ts": "1507081193.000181",
        "text": "リストから平衡二分木に変換するHaskell風のアルゴリズムがあれば教えてください。\nただし、ここでいう平衡二分木は、要素の数が2の累乗のとき、完全平衡になる二分木です。\n左の部分木から詰めて行きます。\nO(n)でできると思います。\nスタックを使う命令的なアルゴリズムは知っています。",
        "user": "U56MBRKR9",
        "type": "message"
    },
    {
        "ts": "1507081362.000154",
        "text": "Data.Map.fromListでやっているようなこと、ということでしょうか？",
        "user": "U4LGTMTMK",
        "type": "message"
    },
    {
        "ts": "1507081363.000088",
        "text": "あー、探索木ではありません。\nリストに入っていた順に、底辺に要素が並べばいいです。",
        "user": "U56MBRKR9",
        "type": "message"
    },
    {
        "ts": "1507081494.000083",
        "text": "ぶっちゃけていうと、Merkleハッシュ木をリストから作りたいのです。\n<https://goo.gl/pYMBDr>",
        "user": "U56MBRKR9",
        "type": "message"
    },
    {
        "ts": "1507081912.000223",
        "text": "mapAccumL とか使うのかな？\n考える。",
        "user": "U56MBRKR9",
        "type": "message"
    },
    {
        "ts": "1507083966.000131",
        "text": "すみません、逆にこちらから教えていただきたいのですが、\nハッシュ木というのは、大量（あるいは大容量？）のハッシュ値を一本の木にまとめて空間効率を高める、みたいなイメージであってますか？",
        "user": "U4LGTMTMK",
        "type": "message"
    },
    {
        "ts": "1507084880.000092",
        "text": "結局、型クラスを作って Integer と {Int, Word, Word64, Word32, Word16, Word8} に対するinstantiationを陽に記述しました",
        "user": "U61BA2X0U",
        "type": "message"
    },
    {
        "ts": "1507086655.000192",
        "text": "ハッシュ木の構造は\n- 葉ノードが対象データのハッシュ値\n- 中間ノードが、連結させた子のハッシュ値のハッシュ値\nです。",
        "user": "U56MBRKR9",
        "type": "message"
    },
    {
        "ts": "1507086715.000222",
        "text": "ハッシュ木の性質の全容は掴んでないのですが、2つのデータ間の整合性を高速に検証するために使われるのが一般的だと思います。",
        "user": "U56MBRKR9",
        "type": "message"
    },
    {
        "ts": "1507086899.000041",
        "text": "僕が今取り組んでいるのは、Certificate Transparencyでして、これは世の中にある証明書すべてを書き込み系としては追加しかできないログに記録するという仕組みです。\n読み出すことはできます。\nこのログにハッシュ木が使われています。\nユーザは、ハッシュ木の性質を使って、以下のことを高速に確かめられます。\n- ある証明書がログの中に存在している\n- ログが改ざんされてない",
        "user": "U56MBRKR9",
        "type": "message"
    },
    {
        "ts": "1507087024.000044",
        "text": "Chrome が Symantec が発行する証明書を信用しなくしようとしてますが、これは Symantec が <http://www.google.com|www.google.com> の証明書を間違って発行したことによります。\nそれを見つけた手段が CT です。",
        "user": "U56MBRKR9",
        "type": "message"
    },
    {
        "ts": "1507087090.000166",
        "text": "CT の仕様書である RFC 6962 って、結構酷かったんですが、改訂版は分かりやすくなっているし、具体的なアルゴリズムが載っているので、今実装して理解しようとしています。",
        "user": "U56MBRKR9",
        "type": "message"
    },
    {
        "ts": "1507087098.000063",
        "text": "<https://tools.ietf.org/html/draft-ietf-trans-rfc6962-bis-26>",
        "user": "U56MBRKR9",
        "type": "message"
    },
    {
        "ts": "1507090385.000035",
        "text": "こんな感じか：\n\n```\nimport Data.Bits\nimport Data.List\n\ndata Tree a = Leaf a\n            | Node (Tree a) (Tree a) deriving (Eq, Show)\n\nsingleton :: a -&gt; Tree a\nsingleton = Leaf\n\njoin :: Tree a -&gt; Tree a -&gt; Tree a\njoin = Node\n\nfromList :: [a] -&gt; Tree a\nfromList xs = reduce $ snd $ foldl' add (0,[]) $ map singleton xs\n  where\n    add (i,ts) t = (i+1, merge (mergeCount i) (t:ts))\n    merge 0 ts        = ts\n    merge n (t1:t2:ts) = merge (n - 1) (join t2 t1:ts)\n    merge _ _ = error \"merge\"\n    reduce [t] = t\n    reduce (t1:t2:ts) = reduce (join t2 t1:ts)\n    reduce _ = error \"reduce\"\n\nmergeCount :: Int -&gt; Int\nmergeCount = countTrailingZeros . complement\n```",
        "user": "U56MBRKR9",
        "type": "message"
    },
    {
        "ts": "1507114942.000196",
        "text": "これでどうでしょうか :sunglasses:\n\n```{-# LANGUAGE DeriveFoldable #-}\nimport Data.Foldable\n\ndata Tree a = Leaf a\n            | Node (Tree a) (Tree a) deriving (Eq, Show, Foldable)\n\nfromList :: [a] -&gt; Tree a\nfromList xs = case foldl' (flip $ push 0 . Leaf) [] xs of\n  [] -&gt; error \"empty\"\n  [(_, r)] -&gt; r\n  ts -&gt; error \"incomplete\"\n  where\n    push :: Int -&gt; Tree a -&gt; [(Int, Tree a)] -&gt; [(Int, Tree a)]\n    push m x ys'@((n, y) : ys)\n      | m == n = push (m + 1) (Node y x) ys\n      | otherwise = (m, x) : ys'\n    push m x [] = [(m, x)]\n```",
        "user": "U4KUNQF9N",
        "type": "message"
    },
    {
        "ts": "1507135111.000304",
        "text": "ぱっと思いつくのは、\n```\ndata Tree a = Leaf a | Node (Tree a) (Tree a) deriving (Show)\n\nfromList :: [a] -&gt; Tree a\nfromList [] = error \"No Element\"\nfromList xs = construct (map Leaf xs)\n\nconstruct :: [Tree a] -&gt; Tree a\nconstruct [t] = t\nconstruct ts  = construct (pairing ts)\n\npairing :: [Tree a] -&gt; [Tree a]\npairing (t:u:vs) = Node t u : pairing vs\npairing ts       = ts\n```",
        "user": "U4KU9ABL0",
        "type": "message"
    },
    {
        "ts": "1507135264.000590",
        "text": "<@U7DFU4JCD> has joined the channel",
        "user": "U7DFU4JCD",
        "type": "message"
    },
    {
        "ts": "1507169180.000186",
        "text": "あー、なるほど。\n言われてみると、簡単な話でしたね。&gt; nobsun",
        "user": "U56MBRKR9",
        "type": "message"
    },
    {
        "ts": "1507169199.000053",
        "text": "fumieval くんもありがとう！",
        "user": "U56MBRKR9",
        "type": "message"
    },
    {
        "ts": "1507620228.000173",
        "text": "GHCのmissing-home-modules警告について教えてください。\ncabalファイルにlibraryとexecutableがあって、executableの方がコンパイルされる際にlibraryで列挙しているモジュールを列挙せよと警告が出ます。\nexecutableの依存関係に、そのlibraryを書いてあるので警告が出るべきではないと思うのですが。。。\nモジュールを列挙せずに警告をなくすにはどうすればいいでしょうか？",
        "user": "U56MBRKR9",
        "type": "message"
    },
    {
        "ts": "1507620604.000095",
        "text": "なんだかさっと  <https://ghc.haskell.org/trac/ghc/ticket/13129> を読む限り、仕様通りの挙動じゃないように聞こえますね。。。 :sweat: \nexecutableの方の `other-modules` に libraryのmoduleを列挙せよ、と警告してくるんですか？",
        "user": "U4LGTMTMK",
        "type": "message"
    },
    {
        "ts": "1507637395.000479",
        "text": "なんとなくの推測ですがhs-source-dirsがデフォルトの.になっててexecutableがbuild-dependsに指定したライブラリではなく、ソースファイルを直接見に行ってるとかないですか？ ",
        "user": "U4M9NJ7QE",
        "type": "message"
    },
    {
        "ts": "1507637586.000478",
        "text": "cabal buildでlibとexeで同じモジュールを再コンパイルしていたら多分当たってます",
        "user": "U4M9NJ7QE",
        "type": "message"
    },
    {
        "ts": "1507691302.000013",
        "text": "<@U4M9NJ7QE> ビンゴでした。\ntest のソースはディレクトリを分けないと、自分に依存できない問題と同じでした！\nありがとうございます。",
        "user": "U56MBRKR9",
        "type": "message"
    },
    {
        "ts": "1507762496.000205",
        "text": "質問です、Haskellにおいて余再帰とは末尾再起でない関数のことを指すのでしょうか？あと、この記事(<http://d.hatena.ne.jp/kazu-yamamoto/touch/20121107/1352259739>)で\n&gt; そう、遅延評価だから、余再帰というテクニックが使える。\nと書かれているのですが、遅延評価でないと余再帰は出来ないのでしょうか？",
        "user": "U56G77VM1",
        "type": "message"
    },
    {
        "ts": "1507769601.000092",
        "text": "僕の理解では、入力が再帰構造を持っていて、関数がその構造を辿ると「再帰」と言います。つまり、[a] -&gt; b みたいな関数を再帰と言っています。\n余再帰はその逆で、a -&gt; [b] のように出力が再帰的な構造を持つ場合に使います。\nmapは再帰かつ余再帰です。",
        "user": "U56MBRKR9",
        "type": "message"
    },
    {
        "ts": "1507769697.000041",
        "text": "関数が無限のリストを生成する場合、正格評価だと手に負えませんが、遅延評価なら出力の消費者が制御できますね、ぐらいの意味でした。",
        "user": "U56MBRKR9",
        "type": "message"
    },
    {
        "ts": "1507769861.000064",
        "text": "参考：\n<http://d.hatena.ne.jp/kazu-yamamoto/20091122/1258899591>",
        "user": "U56MBRKR9",
        "type": "message"
    },
    {
        "ts": "1507770028.000233",
        "text": "通常は、ここでいう再帰も余再帰も区別せずに、再帰ということが多いです。",
        "user": "U56MBRKR9",
        "type": "message"
    },
    {
        "ts": "1507772650.000020",
        "text": "ありがとうございます！",
        "user": "U56G77VM1",
        "type": "message"
    },
    {
        "ts": "1507773573.000246",
        "text": "<@U7GCPTF3J> has joined the channel",
        "user": "U7GCPTF3J",
        "type": "message"
    },
    {
        "ts": "1507780337.000064",
        "text": "再帰/余再帰という言葉は「数学的帰納法」と関連が深くて、帰納/余帰納とも呼ばれます。\n数学的帰納法で任意の自然数nについて性質p(n)が成り立つことの証明をすることを思い出してみます。\n(i) Base case: p(0) が成り立つことを示す。\n(ii) Hypothesis: ある自然数kについてp(k)が成り立つとする。\n(iii) Step case: (ii)の仮定の下で、p(k+1)が成り立つことを示す。\n(iv) (i),(ii),(iii) より、任意の自然数nについてp(n)が成り立つと主張して証明終わり。\nなぜこれで全ての自然数についての証明になっているかというと、全ての自然数は、0(ないしは1)から順に1を足していったものになっているからです(ペアノの公理)\n帰納的データ型を扱う関数は、これとそっくりな書き方ができます。",
        "user": "U61BA2X0U",
        "type": "message"
    },
    {
        "ts": "1507780791.000143",
        "text": "例えば、リストを処理する関数fを書くとします。\n```\nf :: [a] -&gt; b\n-- Base case: 0の場合に相当\nf [] = z\n-- Step case: k+1の場合に相当\nf (x:xs) = x ⊕ f xs\n```\nなぜこれで全ての *有限な* リストに対する関数を定義したことになるかといえば、全ての有限なリストは、 [] (nil)に対して : (cons)で一つずつ要素を追加していくことで作られているからです。",
        "user": "U61BA2X0U",
        "type": "message"
    },
    {
        "ts": "1507782022.000061",
        "text": "有限なリストのように、構造が帰納的(0から順に組み立てていくようなやり方)に定義されているデータ型を「帰納的データ型」と呼びます。\nじゃあ無限リストはどうかというと、どこまでいってもbase caseにたどり着きません。そもそも、そういう作られかたをしていないからです。このようなデータに対しては、帰納的に処理を記述することができません。",
        "user": "U61BA2X0U",
        "type": "message"
    },
    {
        "ts": "1507793608.000114",
        "text": "`iterate` とか `unfoldr` が典型的な余再帰のための関数ってことですよね！",
        "user": "U4LGTMTMK",
        "type": "message"
    },
    {
        "ts": "1507793637.000002",
        "text": "Macをお使いの方に聞きたいのですが、 `brew install haskell-stack` したときって今でもGHCやcabalがOSにインストールされている場合はそのGHCでソースからビルドする、という面倒な仕様なのでしょうか？",
        "user": "U4LGTMTMK",
        "type": "message"
    },
    {
        "ts": "1507794092.000108",
        "text": "formulaを見ると、以下のような記述があるのでおそらくそのままになっていると思います。\n```\nsystem \"stack\", \"-j#{jobs}\", \"--local-bin-path=#{bin}\", \"install\"\n```",
        "user": "U57DM8PBK",
        "type": "message"
    },
    {
        "ts": "1507794575.000096",
        "text": "<https://github.com/Homebrew/homebrew-core/blob/master/Formula/haskell-stack.rb> か。みたいですね。。。これはとても簡単なインストール方法とはいえないな。。。やっぱり報告しようか。。。",
        "user": "U4LGTMTMK",
        "type": "message"
    },
    {
        "ts": "1507794639.000112",
        "text": "そうですね...\nあるいは何か問題があってこのような形式になっているかもしれないのですけれども...",
        "user": "U57DM8PBK",
        "type": "message"
    },
    {
        "ts": "1507877265.000118",
        "text": "`newtype Show a =&gt; Foo a = Foo a` みたいなコードってコンパイル通らないと思うのですが（deprecated な `DatatypeContexts` を要求される）， `stack new Foo` して上記のコードのみ書き足して `stack build` すると一言もなくコンパイルが通って挙動も想定通りになります．`stack ghci` はちゃんと通さない．stack か何かのバグ…なんでしょうか？",
        "user": "U5ANNFMNZ",
        "type": "message"
    },
    {
        "ts": "1507877699.000237",
        "text": "追記： i) 問題かどうか（僕の勘違いじゃないか） ii) 既知かどうか iii) なんでやねん あたりで疑問に思っています．",
        "user": "U5ANNFMNZ",
        "type": "message"
    },
    {
        "ts": "1507878382.000150",
        "text": "`DatatypeContexts` は分からないのですが、 `stack build --pedantic` とすると警告が出るかもしれません。",
        "user": "U4M598NHM",
        "type": "message"
    },
    {
        "ts": "1507879077.000090",
        "text": "ありがとうございます． `--pedantic` でも警告はでないようですね．どこで消えてるんだろう…",
        "user": "U5ANNFMNZ",
        "type": "message"
    },
    {
        "ts": "1507882982.000138",
        "text": "実際にstackがどのようなオプションをghcに渡しているかを `stack build --cabal-verbose` で見てみると， `-XHaskell2010` が渡されているのが確認できます．つまり `stack build` 時には `stack new` で生成したcabalファイルに含まれる設定 `default-language: Haskell2010` が有効となり，これは `DatatypeContexts` を包含しているのでエラーが出なくなります．一方 `stack ghci` でも同様に `stack -v ghci` でghcに渡されるオプション(と，一応ghci-scriptとして渡されるファイルの中身)を確認してみると，こちらではdefault-languageが渡されていません．ghciの場合でも `stack ghci --ghci-options=-XHaskell2010` としてあげるとbuild時同様にエラーが出なくなることが確認できます．これがstackの想定通りの挙動なのかはわかりませんが，少なくともbuild側についてはcabalファイルに書かれた設定に対し忠実に動作しているように思えます．",
        "user": "U5G2BCVBN",
        "type": "message"
    },
    {
        "ts": "1507884910.000527",
        "text": "関係してググっていて知ったんですが、 \n<https://ghc.haskell.org/trac/ghc/ticket/8026> によると\n`DatatypeContexts` 相当のことを今やりたくなったら GADTs を有効にして\n```\ndata Foo a where\n  Foo :: Eq a =&gt; a -&gt; Foo a\n```\nと書けばいいんですってね。 :naruhodo:",
        "user": "U4LGTMTMK",
        "type": "message"
    },
    {
        "ts": "1507886367.000149",
        "text": "なるほど！すごくスッキリしました，ありがとうございます． -XHaskell2010 のあたりを全然意識してなかったので教えていただけてよかったです．",
        "user": "U5ANNFMNZ",
        "type": "message"
    },
    {
        "ts": "1507886922.000491",
        "text": "実際のところ、DatatypeContextsはGADTsと違い、パターンマッチしてもコンテキストが使えるわけではない非常にむなしい機能なんですよね…",
        "user": "U4KUNQF9N",
        "type": "message"
    },
    {
        "ts": "1507966229.000001",
        "text": "<@U57A2859S> has joined the channel",
        "user": "U57A2859S",
        "type": "message"
    },
    {
        "ts": "1507966308.000004",
        "text": "<http://d.hatena.ne.jp/sumii/20110830/p1>",
        "user": "U57A2859S",
        "type": "message"
    },
    {
        "ts": "1508030068.000039",
        "text": "ghc-paths-0.1.0.9がGHC-7.0.4と7.2.2でビルド出来ないみたいなんですが、これはパッケージそのものの問題として報告したほうがいいんでしょうか？cabalをよく理解していないがためにパッケージの問題なのか原因を絞り切れないので助けを借りたいです。\n\nTravis CIでのログ(他のGHCバージョンでも失敗していますがそれは無関係です)\n<https://travis-ci.org/Hexirp/doctest-driver-gen/builds/284639068>",
        "user": "U5LEE6C1J",
        "type": "message"
    },
    {
        "ts": "1508044203.000048",
        "text": "要約: ビルド方法が悪いのかパッケージのせいなのか知りたいです。\n\n自分でforkしてビルドした結果\n<https://travis-ci.org/Hexirp/ghc-paths/builds/288111730>",
        "user": "U5LEE6C1J",
        "type": "message"
    },
    {
        "ts": "1508051662.000052",
        "text": "そのビルドには原因とおぼしきエラーメッセージが一切ないので全く分からないのですが、\n<https://travis-ci.org/Hexirp/ghc-paths/jobs/288111731>\nこちらのフォークしてビルドした結果にある\n```\nLinking /tmp/ghc-paths-0.1.0.9-4199/ghc-paths-0.1.0.9/dist/setup/setup ...\nunrecognized option `--disable-benchmarks'\n```\nこれが原因だとすると、 Setup.hs が想定しているCabalのバージョンと、cabal-installのバージョンが離れすぎているんじゃないか、と思えます。",
        "user": "U4LGTMTMK",
        "type": "message"
    },
    {
        "ts": "1508051692.000039",
        "text": "そもそも、なんでそんな古いGHCでコンパイルしようとしているのでしょうか。。。？\n報告してもあまり対応してくれなさそう。。。",
        "user": "U4LGTMTMK",
        "type": "message"
    },
    {
        "ts": "1508054468.000011",
        "text": "cabal ファイルの custom-setup が 1.24 からで、実際に使ってるのが 1.16 だからかな\n<https://www.haskell.org/cabal/users-guide/developing-packages.html?highlight=custom%20setup#custom-setup-scripts>",
        "user": "U4L0B71L1",
        "type": "message"
    },
    {
        "ts": "1508065505.000064",
        "text": "&gt; Warning: ghc-paths.cabal: Ignoring unknown section type: custom-setup\ncustom-setup についてはあくまで警告ですし、関係ないんじゃないっすかね。",
        "user": "U4LGTMTMK",
        "type": "message"
    },
    {
        "ts": "1508148364.000325",
        "text": "答えていただいてありがとうございます。これだけ昔のGHCに対応しようとするとやっぱり色々問題が出てきますね。諦めることにします。\n\n恥ずかしいことに報告しても対応してくれなさそうという視点は持っていませんでした…",
        "user": "U5LEE6C1J",
        "type": "message"
    },
    {
        "ts": "1508389667.000101",
        "text": "haddockで `spliceURL UnhelpfulSpan` というエラーがでてコケるんですがworkaround等ご存じの方いますか？\n\nstack-1.5.1で<https://github.com/myuon/sdlight> のドキュメントを生成しようとしてこのようなエラーになりました。\n<https://github.com/haskell/haddock/pull/558> のPRでfixされているような気がしますがstack upgradeしても変わりませんでした(まだ更新されていない？)\nスレッドにエラーメッセージを貼っておきます",
        "user": "U560KD6DN",
        "type": "message"
    },
    {
        "ts": "1508389739.000150",
        "text": "```\n~$ stack haddock --no-haddock-deps\nsdlight-0.9.0.6: build (lib)\nPreprocessing library sdlight-0.9.0.6...\nsdlight-0.9.0.6: haddock\nRunning Haddock for sdlight-0.9.0.6...\nPreprocessing library sdlight-0.9.0.6...\nWarning: The documentation for the following packages are not installed. No\nlinks will be generated to these packages: fail-4.9.0.0\n\n\n(省略)\n\nWarning: SDLight.Widgets.Internal.Named: could not find link destinations for:\n    ~\nWarning: SDLight.Widgets.Core: could not find link destinations for:\n    WConfigR\nWarning: SDLight.Widgets.Effector: could not find link destinations for:\n    Op'Appear Op'Disappear Op'GetAlpha Op'IsAppeared Op'IsDisappeared Op'Start Op'GetValue\nWarning: SDLight.Widgets.Layer: could not find link destinations for:\n    Op'GetCounter\nWarning: SDLight.Widgets.Balloon: could not find link destinations for:\n    Op'Fly\nWarning: SDLight.Widgets.InputJapanese: could not find link destinations for:\n    Op'GetText\nWarning: SDLight.Widgets.MessageLayer: could not find link destinations for:\n    Op'IsWaiting\nWarning: SDLight.Widgets.ScriptEngine: could not find link destinations for:\n    Op'LoadMiniScript SimpleDSL RefImage\nWarning: SDLight.Widgets.Selector: could not find link destinations for:\n    Op'RenderSelector Op'SetLabels\nWarning: SDLight.Widgets.TabSelector: could not find link destinations for:\n    Op'GetTabName Op'RenderTabSelector Op'GetCurrentSelector Op'SetTabs\nhaddock: internal error: spliceURL UnhelpfulSpan\nCallStack (from HasCallStack):\n  error, called at utils/haddock/haddock-api/src/Haddock/Backends/Xhtml/Utils.hs:79:9 in main:Haddock.Backends.Xhtml.Utils\n\n--  While building package sdlight-0.9.0.6 using:\n      /home/ioijoi/.stack/setup-exe-cache/x86_64-linux/Cabal-simple_mPHDZzAJ_1.24.2.0_ghc-8.0.2 --builddir=.stack-work/dist/x86_64-linux/Cabal-1.24.2.0 haddock --html --html-location=../$pkg-$version/ --haddock-option=--hyperlinked-source\n    Process exited with code: ExitFailure 1\n```",
        "user": "U560KD6DN",
        "type": "message"
    },
    {
        "ts": "1508389816.000120",
        "text": "template haskellで生成した関数をexportしているのが怪しいかもしれません",
        "user": "U560KD6DN",
        "type": "message"
    },
    {
        "ts": "1508399505.000049",
        "text": "headだと直ってるというコメントもありますね <https://github.com/haskell/haddock/issues/565>",
        "user": "U61BA2X0U",
        "type": "message"
    },
    {
        "ts": "1508404671.000116",
        "text": "そのページの中ほどにある <https://github.com/haskell/haddock/issues/565#issuecomment-281133865> で解決したっぽいです。\nstack install haddockで最新のhaddockを入れて、それを `~/.stack/programs/x86_64-linux/ghc-8.0.2/lib/ghc-8.0.2/bin` のものに上書きしたらいけました\nstackが使っているhaddockの更新方法が分からなくて困っていたので助かりました。ありがとうございます :pray: :pray: :pray:",
        "user": "U560KD6DN",
        "type": "message"
    },
    {
        "ts": "1508515263.000717",
        "text": "<@U7MDG53NF> has joined the channel",
        "user": "U7MDG53NF",
        "type": "message"
    },
    {
        "ts": "1508628794.000017",
        "text": "<@U7GSVRQ6S> has joined the channel",
        "user": "U7GSVRQ6S",
        "type": "message"
    },
    {
        "ts": "1508893705.000145",
        "text": "オススメのテンプレートライブラリを教えてください。\nたとえば、${DOMAIN}みたいな文字列を\"<http://example.jp|example.jp>\"とかに置き換えれる機能を欲しています。",
        "user": "U56MBRKR9",
        "type": "message"
    },
    {
        "ts": "1508894420.000055",
        "text": "どの程度高機能なものを求めているかにもよりますが、\n<@U4KPQ676D> さんの <https://github.com/arowM/heterocephalus> はコンパイル時にテンプレートの間違いを検出してくれるのでいい感じですよ！",
        "user": "U4LGTMTMK",
        "type": "message"
    },
    {
        "ts": "1508901092.000030",
        "text": "パッケージをインストールする際に、ビルドには成功しますが、インストール時に\n```\nFailed to load interface for ‘Data.Hashable.Generic’\nno unit id matching ‘hashable-1.2.6.1-14fEJP30YhAG9w115PODz0’ was found\n```\nというエラーが出るんですが何かご存じの方いますか？\nghc-8.2.1とcabal-2.0.0.2を使用しています。\nスレッドに詳細を書いておきます。",
        "user": "U560KD6DN",
        "type": "message"
    },
    {
        "ts": "1508901289.000154",
        "text": "インストールしようとしているのはこのパッケージです\n<https://github.com/myuon/widx/tree/feature/widget-modules>\n\n以下により詳細なログを貼ります",
        "user": "U560KD6DN",
        "type": "message"
    },
    {
        "ts": "1508901331.000237",
        "text": "```\n/home/ioijoi/.stack/programs/x86_64-linux/ghc-8.2.1/bin/ghc returned\nExitFailure 1 with error message:\nFailed to load interface for ‘Data.Hashable.Generic’\nno unit id matching ‘hashable-1.2.6.1-14fEJP30YhAG9w115PODz0’ was found\nCallStack (from HasCallStack):\n  die', called at libraries/Cabal/Cabal/Distribution/Simple/Program/Run.hs:171:7 in Cabal-2.0.0.2:Distribution.Simple.Program.Run\n  getProgramInvocationOutput, called at libraries/Cabal/Cabal/Distribution/Simple/GHC.hs:1522:11 in Cabal-2.0.0.2:Distribution.Simple.GHC\n  libAbiHash, called at libraries/Cabal/Cabal/Distribution/Simple/Register.hs:260:30 in Cabal-2.0.0.2:Distribution.Simple.Register\n  abiHash, called at libraries/Cabal/Cabal/Distribution/Simple/Register.hs:239:21 in Cabal-2.0.0.2:Distribution.Simple.Register\n  generateRegistrationInfo, called at libraries/Cabal/Cabal/Distribution/Simple/Register.hs:135:25 in Cabal-2.0.0.2:Distribution.Simple.Register\n  generateOne, called at libraries/Cabal/Cabal/Distribution/Simple/Register.hs:121:28 in Cabal-2.0.0.2:Distribution.Simple.Register\n  register, called at libraries/Cabal/Cabal/Distribution/Simple.hs:770:10 in Cabal-2.0.0.2:Distribution.Simple\n  defaultRegHook, called at libraries/Cabal/Cabal/Distribution/Simple.hs:584:20 in Cabal-2.0.0.2:Distribution.Simple\n  regHook, called at libraries/Cabal/Cabal/Distribution/Simple/UserHooks.hs:120:5 in Cabal-2.0.0.2:Distribution.Simple.UserHooks\n  cmd_hook, called at libraries/Cabal/Cabal/Distribution/Simple.hs:452:38 in Cabal-2.0.0.2:Distribution.Simple\n  cmd_hook, called at libraries/Cabal/Cabal/Distribution/Simple.hs:469:4 in Cabal-2.0.0.2:Distribution.Simple\n  hookedActionWithArgs, called at libraries/Cabal/Cabal/Distribution/Simple.hs:451:5 in Cabal-2.0.0.2:Distribution.Simple\n  hookedAction, called at libraries/Cabal/Cabal/Distribution/Simple.hs:430:5 in Cabal-2.0.0.2:Distribution.Simple\n  registerAction, called at libraries/Cabal/Cabal/Distribution/Simple.hs:184:50 in Cabal-2.0.0.2:Distribution.Simple\n  defaultMainHelper, called at libraries/Cabal/Cabal/Distribution/Simple.hs:124:19 in Cabal-2.0.0.2:Distribution.Simple\n  defaultMainArgs, called at Main.hs:1210:18 in main:Main\ncabal: '/home/ioijoi/.stack/programs/x86_64-linux/ghc-8.2.1/bin/ghc' exited\nwith an error:\nFailed to load interface for ‘Data.Hashable.Generic’\nno unit id matching ‘hashable-1.2.6.1-14fEJP30YhAG9w115PODz0’ was found\ncabal: Leaving directory '/home/ioijoi/program/widx'\nCallStack (from HasCallStack):\n  die', called at ./Distribution/Client/Install.hs:995:15 in main:Distribution.Client.Install\ncabal: Error: some packages failed to install:\nwidx-0.1.0.0-ENE00C4n2nTCnkzTC7mfaY failed during the final install step. The\nexception was:\nExitFailure 1\n```",
        "user": "U560KD6DN",
        "type": "message"
    },
    {
        "ts": "1508901589.000174",
        "text": "ちなみに、このパッケージ自体はhashableには依存していませんがすでにhashable-1.2.6.1がインストールされています",
        "user": "U560KD6DN",
        "type": "message"
    },
    {
        "ts": "1508905184.000013",
        "text": "試してみたんですけども、僕の環境では  `widx` を依存関係に追加したプロジェクトで普通に使えました。\n\n```\n$ stack --version\nVersion 1.6.0, Git revision 0e756d486a5a4d6fe03e0d448bb8e706c5834ca1 (5293 commits) x86_64 hpack-0.18.1\n\n$ cat stack.yaml\nresolver: lts-9.10\npackages:\n- .\nextra-deps:\n- git: <https://github.com/myuon/widx.git>\n  commit: master\n- colors-0.3.0.2\n\n$ cat package.yaml\nname:                test-widx\nversion:             0.1.0.0\n#synopsis:\n#description:\nhomepage:            <https://github.com/githubuser/test-widx#readme>\nlicense:             BSD3\nauthor:              Author name here\nmaintainer:          <mailto:example@example.com|example@example.com>\ncopyright:           2017 Author name here\ncategory:            Web\nextra-source-files:\n- README.md\n\ndependencies:\n  - base &gt;= 4.7 &amp;&amp; &lt; 5\n  - widx\n\nexecutables:\n  test-widx:\n    source-dirs:      src\n    main:             Main.hs\n```\n\n`.stack-work` を削除して再度実行してみても同じですか？",
        "user": "U5B3EGEFQ",
        "type": "message"
    },
    {
        "ts": "1508905418.000045",
        "text": "ブランチはmasterじゃなくてfeature/widget-modulesなのでは？\n```\nextra-deps:\n- git: <https://github.com/myuon/widx.git>\n  commit: feature/widget-modules\n- colors-0.3.0.2\n```\nかと。",
        "user": "U4LGTMTMK",
        "type": "message"
    },
    {
        "ts": "1508907020.000160",
        "text": "&gt; ブランチはmasterじゃなくてfeature/widget-modulesなのでは？\n確かにそうですね！変更しても問題ありませんでした。",
        "user": "U5B3EGEFQ",
        "type": "message"
    },
    {
        "ts": "1508916944.000381",
        "text": "わかりにくくてすみません、featureブランチの方です",
        "user": "U560KD6DN",
        "type": "message"
    },
    {
        "ts": "1508917061.000229",
        "text": "あと、このパッケージはbackpackを使っているのでghc-8.2, cabal-2以上でないとビルドできません。stackはcabal2系に対応していないので、私はcabal-install-2.0.0.2とghc-8.2をstackで入れてパスなどを通したものを使ってビルドしています。",
        "user": "U560KD6DN",
        "type": "message"
    },
    {
        "ts": "1508929966.000116",
        "text": "こういうSExpr型に被せたCallowSExpr型があって、\n\nPatternSynonymsでCons''パターンを（Cons'パターンのように）\n書きたいんですが、いまいちPatternSynonymsがわかりません…。\n\n（実際に通るコード）\n\n```haskell\n{-# LANGUAGE PatternSynonyms #-}\n\ndata SExpr = Cons SExpr SExpr | AtomInt Int\n\nnewtype CallowSExpr = CallowSExpr { growup :: SExpr }\n\npattern AtomInt' :: Int -&gt; CallowSExpr\npattern AtomInt' x = CallowSExpr (AtomInt x)\n\npattern Cons' :: SExpr -&gt; SExpr -&gt; CallowSExpr\npattern Cons' x y = CallowSExpr (Cons x y)\n\nmain :: IO ()\nmain = do\n  let x = Cons' (AtomInt 1) (AtomInt 2)\n  return ()\n```\n\n（通したい追加コード）\n\n```haskell\npattern Cons'' :: CallowSExpr -&gt; CallowSExpr -&gt; CallowSExpr\n--pattern Cons'' x y &lt;- (growup {- …？ -})\n\ny :: CallowSExpr\ny = Cons'' (AtomInt' 1) (AtomInt' 2)\n```\n\n愚直にパターンを組み立てようとすると、帰納的なのでこんなになってしまいそう。\n\n```haskell\npattern Cons'' (AtomInt' x) (AtomInt' y) = CallowSExpr (Cons x y)\npattern Cons'' (CallowSExpr (Cons (AtomInt x1) (AtomInt x2))) (AtomInt' y) = CallowSExpr (Cons (Cons (AtomInt x) (AtomInt y)) y)\n{-... 以下無限に続くと思う -}\n```\n\nCons''パターンを部分関数的にせずに、書く方法ってないですか？",
        "user": "U5LV76EJH",
        "type": "message"
    },
    {
        "ts": "1508933679.000176",
        "text": "そういえば、cabal sandboxを使ってるんですか？\nそれともnew-buildを使ってるんですか？\nそれとも普通のcabal buildですか？\n「インストール」というのはビルドしてからadd-sourceしてcabal installした場合を指してます？\nなど、再現手順がイマイチ不明瞭なので教えていただきたく。\nもっとも、私からぱっとできるアドバイスは、関連するファイル、 `.cabal-sandbox` とかを一旦削除してやり直せ、ぐらいしか思い浮かばないので、cabalにバグ報告した方がいいんじゃないかと思っています。",
        "user": "U4LGTMTMK",
        "type": "message"
    },
    {
        "ts": "1508935035.000331",
        "text": "この辺関係ありそうな感じもしますけど、どうかな。\n<https://ghc.haskell.org/trac/ghc/ticket/14304>\n<https://github.com/haskell/cabal/issues/4755>",
        "user": "U5B3EGEFQ",
        "type": "message"
    },
    {
        "ts": "1508937899.000051",
        "text": "<@U4LGTMTMK> 再現手順についてはこれでいかがでしょうか(git cloneした直後からのログです)\n<https://gist.github.com/myuon/e49d89b6504cb645cb1d0a53d39e4b77>\n<@U5B3EGEFQ> 私もTH関係かなと思ったんですが、今のコードからTHを取り除いても(makeLenses関係を手書きしても)エラーメッセージは変わりませんでした",
        "user": "U560KD6DN",
        "type": "message"
    },
    {
        "ts": "1508938006.000026",
        "text": "多分なんかのバグを踏んだのだろうという気はするんですが、ghcのバグなのかcabalのバグなのか依存してるパッケージに関連したバグなのかも不明なんですがそんな状態でcabalに報告してもいいんでしょうか？\nとりあえずもう少し調査を進めつつminimalな例を頑張って作ってみようとは思っています",
        "user": "U560KD6DN",
        "type": "message"
    },
    {
        "ts": "1508938279.000504",
        "text": "うーん、確かに。MLで根回しするところからですかね。。。\nとりあえず <https://github.com/haskell/cabal#communicating> に書いてあったのですが、\n <https://mail.haskell.org/mailman/listinfo/cabal-devel> に投げてしまうのはありじゃないかと思います。",
        "user": "U4LGTMTMK",
        "type": "message"
    },
    {
        "ts": "1508938308.000018",
        "text": "ありがとうございます。\nエスケーピングが不要なのと、Text.Printf.printf で事足りることを思い出したので、printfを使いました！",
        "user": "U56MBRKR9",
        "type": "message"
    },
    {
        "ts": "1508938485.000479",
        "text": "再現手順も概ねはっきりしているようですし。まぁ何か間違ったら誰か優しく教えてくれますよ。\n私も購読してみますね。",
        "user": "U4LGTMTMK",
        "type": "message"
    },
    {
        "ts": "1508938825.000291",
        "text": "今たまたまcabalファイルのsignaturesの欄を削ったらエラーが出なくなったので多分backpackのバグですね\nバグであることが確定したっぽいのでそれっぽい例を作ってあとでissueを投げてみようと思います",
        "user": "U560KD6DN",
        "type": "message"
    },
    {
        "ts": "1508951276.000263",
        "text": "hashableをimportすると死ぬことがわかったので報告しておきました :innocent: :innocent: :innocent: \n<https://github.com/haskell/cabal/issues/4847>",
        "user": "U560KD6DN",
        "type": "message"
    },
    {
        "ts": "1509025895.000429",
        "text": "lensのIso' s a、Isoといいつつview (some :: Iso' S A) :: S -&gt; AというSからAの変換しか作れない気がしてきたんですが、A -&gt; Sって作れますか？",
        "user": "U5LV76EJH",
        "type": "message"
    },
    {
        "ts": "1509026843.000363",
        "text": "<@U7RDQ3WBZ> has joined the channel",
        "user": "U7RDQ3WBZ",
        "type": "message"
    },
    {
        "ts": "1509031672.000278",
        "text": "`from :: AnIso s t a b -&gt; Iso b a t s` ですね",
        "user": "U560KD6DN",
        "type": "message"
    },
    {
        "ts": "1509032575.000538",
        "text": "若干邪悪な方法ですがViewPatternsを使うとかですかね\n```\npattern Cons'' :: CallowSExpr -&gt; CallowSExpr -&gt; CallowSExpr\npattern Cons'' x y &lt;- Cons' (CallowSExpr -&gt; x) (CallowSExpr -&gt; y) where\n  Cons'' x y = Cons' (growup x) (growup y)```",
        "user": "U560KD6DN",
        "type": "message"
    }
]
