[
    {
        "type": "message",
        "user": "U05A7BL0PST",
        "ts": "1685679030.509849",
        "text": "<@U05A7BL0PST> has joined the channel"
    },
    {
        "type": "message",
        "user": "U05BK34ESF2",
        "ts": "1685851209.924389",
        "text": "<@U05BK34ESF2> has joined the channel"
    },
    {
        "type": "message",
        "user": "U56MBRKR9",
        "ts": "1686190934.052419",
        "text": "フォーマッタとして hindent を使っている人はいませんか？\nCPPを使っていると、ことごとくフォーマットできずにエラーになるんですが、そういうものですか？"
    },
    {
        "type": "message",
        "user": "U05BNMSPM3Q",
        "ts": "1686335331.764689",
        "text": "<@U05BNMSPM3Q> has joined the channel"
    },
    {
        "type": "message",
        "user": "U05BYT6J7RR",
        "ts": "1686494168.258189",
        "text": "<@U05BYT6J7RR> has joined the channel"
    },
    {
        "type": "message",
        "user": "U56MBRKR9",
        "ts": "1686720298.292579",
        "text": "Hackage の upload 機能が死んでいるようなのですが、どこに連絡すればいいですか？\nHackageには書かれてないように思いました。"
    },
    {
        "type": "message",
        "user": "U05CXHYMHKP",
        "ts": "1686989448.559229",
        "text": "<@U05CXHYMHKP> has joined the channel"
    },
    {
        "type": "message",
        "user": "U74KTAG0N",
        "ts": "1687240914.968079",
        "text": "<https://haskell.jp/blog/posts/2020/strict-gotchas.html>\nstrictは!をつけてくれるのですが、!のseqではなくdeepseqに置き換えたい場合はどうすればいいでしょうか。"
    },
    {
        "type": "message",
        "user": "U05CV9FATHV",
        "ts": "1687245602.208709",
        "text": "<@U05CV9FATHV> has joined the channel"
    },
    {
        "type": "message",
        "user": "U56MBRKR9",
        "ts": "1687321140.257329",
        "text": "Haskellのコードが書かれた大きなファイルを分割したいです。\nそのため関数の依存グラフが欲しいのですが、SourceGraphはもうメンテされてないようです。\nHaskellの関数の依存グラフを可視化するツールとかサービスは、他にありませんか？"
    },
    {
        "type": "message",
        "user": "U05A7BL0PST",
        "ts": "1687643826.871559",
        "text": "haskellの事をAIに質問していたら、sha256な文字列に出会いました。\n<https://hamesspam.sakura.ne.jp/hes2023/230625.html|ask AI>  この鬼のように長いsha256な文字表現を短縮したいです。イメージは\nsed 's/hexDigit x 64/SHA256/g'\nこれをparsecで実現するには、どうしたら良いのでしょうか？"
    },
    {
        "type": "message",
        "user": "U05F7RSDZPC",
        "ts": "1688347266.638029",
        "text": "<@U05F7RSDZPC> has joined the channel"
    },
    {
        "type": "message",
        "user": "U05F4J31TK8",
        "ts": "1688395741.276539",
        "text": "<@U05F4J31TK8> has joined the channel"
    },
    {
        "type": "message",
        "user": "U05A7BL0PST",
        "ts": "1688415525.784589",
        "text": "参照されていないモジュールを指摘してくれるツールってありますでしょうか？\ngolangでは、コンパイラーに厳しい指導をされたような。"
    },
    {
        "type": "message",
        "user": "U05FP4KC755",
        "ts": "1688790288.643299",
        "text": "<@U05FP4KC755> has joined the channel"
    },
    {
        "type": "message",
        "user": "U4KU9ABL0",
        "ts": "1689048948.519879",
        "text": "base パッケージの versioning policy をさがしているのですが、見つけられないでいます．どなたかご存知でしょうか？"
    },
    {
        "type": "message",
        "user": "U05H6Q749GU",
        "ts": "1689352495.167359",
        "text": "<@U05H6Q749GU> has joined the channel"
    },
    {
        "type": "message",
        "user": "U05H6JX0PGB",
        "ts": "1689404805.114849",
        "text": "<@U05H6JX0PGB> has joined the channel"
    },
    {
        "type": "message",
        "user": "U015L5JEP8D",
        "ts": "1690112065.483659",
        "text": "`callCC`の型はなぜ`forall r m a. ((forall b. a -&gt; ContT r m b) -&gt; ContT r m a) -&gt; ContT r m a`ではなく`forall r m a b. ((a -&gt; ContT r m b) -&gt; ContT r m a) -&gt; ContT r m a`なのでしょうか\n実際`callCC' f = callCC (\\exit -&gt; f $ (\\ a -&gt; absurd &lt;$&gt; exit a))`とすれば前者の型にでき、前者の型のほうが脱出用の継続（`callCC (\\exit -&gt; ...)`のexit）の返り値の型が制限されず便利であるように思えます"
    },
    {
        "type": "message",
        "user": "U03H9PH8FRP",
        "ts": "1691583960.006909",
        "text": "`vector-13.0.0` における `newtype` に対する `Unbox` 実装の質問です。\n(1) <https://hackage.haskell.org/package/vector-0.13.0.0/docs/Data-Vector-Unboxed.html#t:UnboxViaPrim|UnboxViaPrim> を使う方法と (2)『`GeneralizedNewtypeDeriving`』を使う方法 [^1]  は、どちらを好むべきですか。 `U.Vector` を使うだけなら、大きな差は無いと思って良いでしょうか。\n[^1]: (<https://hackage.haskell.org/package/vector-0.13.0.0/docs/Data-Vector-Unboxed.html|Unbox モジュール> 冒頭 2 番目のコードブロックの例)"
    },
    {
        "type": "message",
        "user": "U05LSDBQHQF",
        "ts": "1691658512.849699",
        "text": "<@U05LSDBQHQF> has joined the channel"
    },
    {
        "type": "message",
        "user": "U05N5L3N27J",
        "ts": "1691773078.229469",
        "text": "<@U05N5L3N27J> has joined the channel"
    },
    {
        "type": "message",
        "user": "U4KNU6N48",
        "ts": "1691991330.531279",
        "text": "`RecordWildCards` 有効にすると、\nインポート元で定義済みフィールド名とかさなる名前の\n\n\"shadows the existing binding\"\n\nの警告が出なくなるみたいなんですが、\nそういうものでしょうか?\n\n`RecordWildCards` を有効にすると暗黙に有効にされる\n`DisambiguateRecordFields` の効果なのかと思ったけどそういうわけでもないみたいです.\n\n```module M where\n\ndata R = R { x :: String }```\n```{-# LANGUAGE RecordWildCards #-}\n\nimport M\n\ninc :: Int -&gt; Int\ninc x = x + 1\n\ngetX :: R -&gt; String\ngetX m = x m```"
    },
    {
        "type": "message",
        "user": "U05MZJJ1C5C",
        "ts": "1692241313.592449",
        "text": "<@U05MZJJ1C5C> has joined the channel"
    },
    {
        "type": "message",
        "user": "U05P3B4E516",
        "ts": "1692340291.598489",
        "text": "<@U05P3B4E516> has joined the channel"
    },
    {
        "type": "message",
        "user": "U02CE9YGEAU",
        "ts": "1692450923.172359",
        "text": "パターンマッチで分けられた関数定義の一行一行`f p1 p2 ... pn = e`のことを何と呼びますか？\nHaskellのいくつかの文献では`equation`と呼ばれているようですが、`clause`というのも見かけます。\n日本語の文献では対応する用語が見当たらなかったのですが、日本語だと何というのでしょうか？\n\nまた、関数定義をデータ型として表現するときに、\n```data FunDecl = FunDecl String [([Pattern], Expr)]```\nと書くとして、`([Pattern], Expr)`　にはどんな名前をつけますか？\ncase式`case e of {p1 -&gt; e1; p2 -&gt; e2; ... pn -&gt; en}` に含まれる`p1 -&gt; e1`は、HaskellではAlternativeと呼ばれていますが、パターンが複数になると何と呼ばれるのでしょう？"
    },
    {
        "type": "message",
        "user": "U05P3B4E516",
        "ts": "1692784236.307109",
        "text": "Haskellのライブラリをどのくらいの粒度でパッケージ分割したらいいのかの基準が自分の中でまだ整理が付いていないのですが、良い資料をご存知の方、もしくは考えをお持ちの方はいらっしゃいますか？\n\n以前、いわゆる「Internalモジュール」パターンは間違っていて、Internalモジュールが作りたくなったらパッケージ分割の合図だろうといった旨の↓の記事を見まして。\n記事の内容には完全に同意なのですが、すると、究極的にはなるべく細かく分割するのがよいのではないかと思うようになってしまいました。\n分割を止める基準、つまりトレードオフの「分割すべきでない」側の壁がどの辺りにあるのかが分からなくなっています。\n\n<http://nikita-volkov.github.io/internal-convention-is-a-mistake/>"
    },
    {
        "type": "message",
        "user": "U02T0K000AV",
        "ts": "1692853327.298529",
        "text": "Haskell で JSON を受け取って JSON を返す簡単なAPIサーバー（インメモリのキャッシュや openapiやドキュメントの自動生成があるとなおよい）を立てる場合どのようなスタックを使いますか？\n\n参考となるレポジトリなどあれば教えてもらえると助かります."
    },
    {
        "type": "message",
        "user": "U05P3AVUHM4",
        "ts": "1692859057.169869",
        "text": "<@U05P3AVUHM4> has joined the channel"
    },
    {
        "type": "message",
        "user": "U05PGV0U1P0",
        "ts": "1693084934.121649",
        "text": "<@U05PGV0U1P0> has joined the channel"
    },
    {
        "type": "message",
        "user": "U05SUE82DH7",
        "ts": "1694739882.946039",
        "text": "<@U05SUE82DH7> has joined the channel"
    },
    {
        "type": "message",
        "user": "U56MBRKR9",
        "ts": "1695261242.484609",
        "text": "以下、timeout の抜粋です。\n最近の timeout は、TimeManagerを使い「時間切れのどきだけ」スレッドが作られます(forkIOWithUnmask)。\n(gitでlog を読むと高野さんのアイディアらしい。)\nhandleTimeoutで作られるこのスレッドは、どこにもブロックする箇所がないので、すぐに消滅しそうです。\nしかし、cleanupTimeoutでわざわざkillThreadしています。\nこのkillThreadは必要なのでしょうか？\n\n```Haskell\ntimeout :: Int -&gt; IO a -&gt; IO (Maybe a)\ntimeout n f\n    | n &lt;  0    = fmap Just f\n    | n == 0    = return Nothing\n    | otherwise = do\n        -- In the threaded RTS, we use the Timer Manager to delay the\n        -- (fairly expensive) 'forkIO' call until the timeout has expired.\n        --\n        -- An additional thread is required for the actual delivery of\n        -- the Timeout exception because killThread (or another throwTo)\n        -- is the only way to reliably interrupt a throwTo in flight.\n        pid &lt;- myThreadId\n        ex  &lt;- fmap Timeout newUnique\n        tm  &lt;- getSystemTimerManager\n        -- 'lock' synchronizes the timeout handler and the main thread:\n        --  * the main thread can disable the handler by writing to 'lock';\n        --  * the handler communicates the spawned thread's id through 'lock'.\n        -- These two cases are mutually exclusive.\n        lock &lt;- newEmptyMVar\n        let handleTimeout = do\n                v &lt;- isEmptyMVar lock\n                when v $ void $ forkIOWithUnmask $ \\unmask -&gt; unmask $ do\n                    v2 &lt;- tryPutMVar lock =&lt;&lt; myThreadId\n                    when v2 $ throwTo pid ex\n            cleanupTimeout key = uninterruptibleMask_ $ do\n                v &lt;- tryPutMVar lock undefined\n                if v then unregisterTimeout tm key\n                     else takeMVar lock &gt;&gt;= killThread\n        handleJust (\\e -&gt; if e == ex then Just () else Nothing)\n                   (\\_ -&gt; return Nothing)\n                   (bracket (registerTimeout tm n handleTimeout)\n                            cleanupTimeout\n                            (\\_ -&gt; fmap Just f))```"
    },
    {
        "type": "message",
        "user": "U05TM1PA3D1",
        "ts": "1695432046.678049",
        "text": "<@U05TM1PA3D1> has joined the channel"
    },
    {
        "type": "message",
        "user": "U74KTAG0N",
        "ts": "1695954019.278299",
        "text": "<https://github.com/haskell/haskell-language-server/issues/365>\n<https://haskell-language-server.readthedocs.io/en/latest/troubleshooting.html#static-binaries>\ntemplate haskellとhlsって相性が悪いのですね。\nhls使ってないので、ハマらずに済んでいますが、一般的にどうやって解決していますか？\nhlsを直すのは難しいのでパッケージのtemplate haskellのコードを直すのが一般的なのでしょうか？"
    },
    {
        "type": "message",
        "user": "UK0MXUCAV",
        "ts": "1695954716.946699",
        "text": "これはTHというよりも、THとFFIが絡むような場合の話ですね。普通のTHとの組み合わせは大体問題なく動きます。"
    },
    {
        "type": "message",
        "user": "UK0MXUCAV",
        "ts": "1695954836.423639",
        "text": "ふたつ目の公式ドキュメントの話は静的バイナリだとうまく動かないという話で、いまのHLSは各プラットホームごとにDynamic binary で配布されているので問題はほとんどないです"
    },
    {
        "type": "message",
        "user": "UK0MXUCAV",
        "ts": "1695955374.183339",
        "text": "まあ完璧な解決策ではないですねえ……"
    },
    {
        "type": "message",
        "user": "U05UF9EEM0T",
        "ts": "1695964546.520879",
        "text": "<@U05UF9EEM0T> has joined the channel"
    },
    {
        "type": "message",
        "user": "U04LCUXALJ2",
        "ts": "1696137519.721689",
        "text": "`forall`を用いたデータ型について質問です．\n以下の通りに`AnyBar`型を構成した場合に，値を取り出す関数を書きたいです．\n```{-# LANGUAGE ExistentialQuantification #-}\n\nmodule Bar where\n\ndata AnyBar b = forall a. AnyBar a (a -&gt; b)\n\nargBar :: AnyBar b -&gt; b\nargBar (AnyBar x f) = f x\n\nletBar :: AnyBar b -&gt; b\nletBar ab = let AnyBar x f = ab in f x```\n2通りのうち`letBar`だけエラーになりました．\n```src/Bar.hs:11:26: error:\n    • Couldn't match expected type 'p1' with actual type 'a -&gt; b'\n      'p1' is a rigid type variable bound by\n        the inferred types of\n          x :: p\n          f :: p1\n        at src/Bar.hs:11:17-31\n    • In the pattern: AnyBar x f\n      In a pattern binding: AnyBar x f = ab\n      In the expression: let AnyBar x f = ab in f x\n    • Relevant bindings include\n        ab :: AnyBar b (bound at src/Bar.hs:11:8)\n        letBar :: AnyBar b -&gt; b (bound at src/Bar.hs:11:1)\n   |\n11 | letBar ab = let AnyBar x f = ab in f x\n   |                          ^```\n原因が分からないです．見た感じだと両者ともパターンマッチしてるだけで差異が現れるとは思えません．"
    }
]