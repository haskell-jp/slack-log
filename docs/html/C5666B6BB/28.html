<!DOCTYPE html><html><head><meta charset="utf-8"><title>haskell-jp / questions #28</title><link rel="stylesheet" href="../../main.css" type="text/css" media="screen"></head><body><div class="ui container"><h1>haskell-jp / questions #28</h1><div class="pager ui pagination menu"><a href="../../html/C5666B6BB/27.html" class="pager__previous item">Previous</a><a href="../../" class="pager__top item">Top</a><a href="../../html/C5666B6BB/29.html" class="pager__next item">Next</a></div><div class="message_list ui feed"><div class="message event" id="message-1537965036.000100"><div class="content"><div class="summary"><div class="message__header user">kakkun61</div><div class="message__timestamp date"><a class="date" href="#message-1537965036.000100">2018-09-26&nbsp;21:30:36 +0900</a></div></div><div class="message__body description"></div></div></div><div class="message event" id="message-1538017835.000100"><div class="content"><div class="summary"><div class="message__header user">karoyakani</div><div class="message__timestamp date"><a class="date" href="#message-1538017835.000100">2018-09-27&nbsp;12:10:35 +0900</a></div></div><div class="message__body description">:cry:</div></div></div><div class="message event" id="message-1538038244.000100"><div class="content"><div class="summary"><div class="message__header user">as_capabl</div><div class="message__timestamp date"><a class="date" href="#message-1538038244.000100">2018-09-27&nbsp;17:50:44 +0900</a></div></div><div class="message__body description">メモリエラーという事はスペースリークかもしれないので、ソース晒せば誰か直してくれるかも</div></div></div><div class="message event" id="message-1538056356.000100"><div class="content"><div class="summary"><div class="message__header user">kakkun61</div><div class="message__timestamp date"><a class="date" href="#message-1538056356.000100">2018-09-27&nbsp;22:52:36 +0900</a></div></div><div class="message__body description">あ、すでに晒してます <a href='https://haskell-jp.slack.com/files/U4L0B71L1/FD1666PLL/'>https://haskell-jp.slack.com/files/U4L0B71L1/FD1666PLL/</a></div></div></div><div class="message event" id="message-1538117755.000100"><div class="content"><div class="summary"><div class="message__header user">as_capabl</div><div class="message__timestamp date"><a class="date" href="#message-1538117755.000100">2018-09-28&nbsp;15:55:55 +0900</a></div></div><div class="message__body description">こっちはTLEですね…リストとマップを配列とハッシュマップに直せば行けるのか、ロジック直さないと駄目なのか</div></div></div><div class="message event" id="message-1538119225.000100"><div class="content"><div class="summary"><div class="message__header user">kakkun61</div><div class="message__timestamp date"><a class="date" href="#message-1538119225.000100">2018-09-28&nbsp;16:20:25 +0900</a></div></div><div class="message__body description"><blockquote>リストとマップを配列とハッシュマップに直せば行けるのか、ロジック直さないと駄目なのか</blockquote>そう ここが分かってない<br/>競プロガチ勢なら制約とオーダーと制限時間見てこのアルゴリズムで行けるか分かるんでしょうけど</div></div></div><div class="message event" id="message-1538157962.000100"><div class="content"><div class="summary"><div class="message__header user">karoyakani</div><div class="message__timestamp date"><a class="date" href="#message-1538157962.000100">2018-09-29&nbsp;03:06:02 +0900</a></div></div><div class="message__body description">"Testcase 1" で Out of memory になるソースはこちらです　``` {-# LANGUAGE FlexibleInstances, UndecidableInstances, DuplicateRecordFields #-}<br/>module Main where<br/>import Control.Monad<br/>import Data.Array<br/>import Data.List<br/>import System.Environment<br/>import <http://System.IO|System.IO><br/><br/>substringDiff k s1 s2 = bsearch 1 (min n1 n2) f<br/>    where<br/>    n1 = length s1<br/>    n2 = length s2<br/>    ar1 = listArray (1,n1) s1<br/>    ar2 = listArray (1,n2) s2<br/>    ar = array ((0,0),(n1,n2)) $ ((0,0),0):<br/>        [((i,0),0) | i &lt;- [1..n1]] ++ [((0,j),0) | j &lt;- [1..n2]] ++<br/>        [((i,j),ar!(i-1,j-1) + if ar1!i == ar2!j then 0 else 1) | i &lt;- [1..n1], j &lt;- [1..n2]]<br/>    f x = or [ar!(i,j) - ar!(i-x,j-x) &lt;= k | i &lt;- [x..n1], j &lt;- [x..n2], x &lt;= min i j]<br/><br/>bsearch l r p<br/>  | l &gt;= r    = l<br/>  | p m       = bsearch m r p<br/>  | otherwise = bsearch l (m-1) p<br/>  where m = (l+r+1) `div` 2<br/><br/>main :: IO()<br/>main = do<br/>    stdout &lt;- getEnv "OUTPUT_PATH"<br/>    fptr &lt;- openFile stdout WriteMode<br/>    t &lt;- readLn :: IO Int<br/>    forM_ [1..t] $ \t_itr -&gt; do<br/>        kS1S2Temp &lt;- getLine<br/>        let kS1S2 = words kS1S2Temp<br/>        let k = read (kS1S2 !! 0) :: Int<br/>        let s1 = kS1S2 !! 1<br/>        let s2 = kS1S2 !! 2<br/>        let result = substringDiff k s1 s2<br/>        hPutStrLn fptr $ show result<br/>    hFlush fptr<br/>    hClose fptr<br/> ```</div></div></div><div class="message event" id="message-1538195778.000200"><div class="content"><div class="summary"><div class="message__header user">takumaw</div><div class="message__timestamp date"><a class="date" href="#message-1538195778.000200">2018-09-29&nbsp;13:36:18 +0900</a></div></div><div class="message__body description">@takumaw has joined the channel</div></div></div><div class="message event" id="message-1538203286.000100"><div class="content"><div class="summary"><div class="message__header user">ncaq</div><div class="message__timestamp date"><a class="date" href="#message-1538203286.000100">2018-09-29&nbsp;15:41:26 +0900</a></div></div><div class="message__body description">[HERP](<https://herp.co.jp/>)<br/>という会社がHaskellとYesod使っているということを知って興味を持ったので<br/>月曜日に話を聞きに行く予定なのですが<br/>haskell-jpのメンバーにここの社員居たりしますかね</div></div></div><div class="message event" id="message-1538204566.000100"><div class="content"><div class="summary"><div class="message__header user">as_capabl</div><div class="message__timestamp date"><a class="date" href="#message-1538204566.000100">2018-09-29&nbsp;16:02:46 +0900</a></div></div><div class="message__body description">プロファイル取ってみました。arのメモリ使用量削減が課題ですかね。</div></div></div><div class="message event" id="message-1538205074.000100"><div class="content"><div class="summary"><div class="message__header user">as_capabl</div><div class="message__timestamp date"><a class="date" href="#message-1538205074.000100">2018-09-29&nbsp;16:11:14 +0900</a></div></div><div class="message__body description">おもむろにUnboxed Arrayに変えてみたら、arの右辺でarを使う所で無限ループになりました。Mutable Arrayを使うか、kakkun61さんのようにMemoモナドを使う必要がある模様</div></div></div><div class="message event" id="message-1538207873.000100"><div class="content"><div class="summary"><div class="message__header user">as_capabl</div><div class="message__timestamp date"><a class="date" href="#message-1538207873.000100">2018-09-29&nbsp;16:57:53 +0900</a></div></div><div class="message__body description">これで18MBまで減りました。</div></div></div><div class="message event" id="message-1538355253.000100"><div class="content"><div class="summary"><div class="message__header user">igrep</div><div class="message__timestamp date"><a class="date" href="#message-1538355253.000100">2018-10-01&nbsp;09:54:13 +0900</a></div></div><div class="message__body description">もう終わった話題だったら申し訳ないんですが、kakkun61さんのコードもタプルをStrictなタプルに変えるとか、適当なところでBangPatternsを使うだけで大分改善されそうな気がします。<br/>（ちょっと試せてないんですが、忘れないうちに。。。）</div></div></div><div class="message event" id="message-1538368939.000100"><div class="content"><div class="summary"><div class="message__header user">karoyakani</div><div class="message__timestamp date"><a class="date" href="#message-1538368939.000100">2018-10-01&nbsp;13:42:19 +0900</a></div></div><div class="message__body description">よくよく考えなおしたら　最長解の探索の時に　一つのづれ毎に　２次元テーブルの対角方向しか使っていないので　このテーブルは不要でした　下記のコードで AC になりました　as_capabl さんお勧めの Unboxed Array も使いました　皆さんありがとうございました　　``` {-# LANGUAGE FlexibleInstances, UndecidableInstances, DuplicateRecordFields #-}<br/>module Main where<br/>import Control.Monad<br/>import <http://Control.Monad.ST|Control.Monad.ST><br/>import Data.Array.Unboxed<br/>import <http://Data.Array.ST|Data.Array.ST><br/>import Data.List<br/>import System.Environment<br/>import <http://System.IO|System.IO><br/><br/>substringDiff k s1 s2 = maximum $ g &lt;$&gt; [1-n2..n1-1]<br/>    where<br/>    n1 = length s1<br/>    n2 = length s2<br/>    ar1 = listArray (1,n1) s1 :: UArray Int Char<br/>    ar2 = listArray (1,n2) s2 :: UArray Int Char<br/>    mn = min n1 n2<br/>    df = abs (n1-n2)<br/>    g y = bsearch 1 n f<br/>        where<br/>        (i,j) = (max 1 (1+y),max 1 (1-y))<br/>        n   | n1&gt;n2 = if y-df&gt;0 then mn-y+df else mn+min 0 y<br/>            | n1&lt;n2 = if y+df&lt;0 then mn+y-df else mn-max 0 y<br/>            | True  = mn - abs y<br/>        ar :: UArray Int Int<br/>        ar = runSTUArray $ do<br/>            arM &lt;- newArray_ (0,n)<br/>            writeArray arM 0 0<br/>            forM_ [1..n] $ \x -&gt; do<br/>                prev &lt;- readArray arM (x-1)<br/>                writeArray arM x $ prev + if ar1!(i+x-1) == ar2!(j+x-1) then 0 else 1<br/>            return arM<br/>        f x = or [ar!i - ar!(i-x) &lt;= k | i &lt;- [x..n]]<br/><br/>bsearch l r p<br/>  | l &gt;= r    = l<br/>  | p m       = bsearch m r p<br/>  | otherwise = bsearch l (m-1) p<br/>  where m = (l+r+1) `div` 2<br/><br/>main :: IO()<br/>main = do<br/>    stdout &lt;- getEnv "OUTPUT_PATH"<br/>    fptr &lt;- openFile stdout WriteMode<br/>    t &lt;- readLn :: IO Int<br/>    forM_ [1..t] $ \t_itr -&gt; do<br/>        kS1S2Temp &lt;- getLine<br/>        let kS1S2 = words kS1S2Temp<br/>        let k = read (kS1S2 !! 0) :: Int<br/>        let s1 = kS1S2 !! 1<br/>        let s2 = kS1S2 !! 2<br/>        let result = substringDiff k s1 s2<br/>        hPutStrLn fptr $ show result<br/>    hFlush fptr<br/>    hClose fptr<br/> ```</div></div></div><div class="message event" id="message-1538705059.000100"><div class="content"><div class="summary"><div class="message__header user">igrep</div><div class="message__timestamp date"><a class="date" href="#message-1538705059.000100">2018-10-05&nbsp;11:04:19 +0900</a></div></div><div class="message__body description">難しそうな質問ですみません。HIW 2018にあった<br/><a href='https://icfp18.sigplan.org/event/hiw-2018-papers-coercion-quantification'>https://icfp18.sigplan.org/event/hiw-2018-papers-coercion-quantification</a><br/>こちらの発表の内容を理解しようとしているんですが、<br/>出てくる「homogeneous equality」「heterogeneous equality」というキーワードがさっぱりわからず、困っております。<br/>既存の <code>a ~ b</code> ともまた違うっぽいんですが、どう違うんでしょうか？</div></div></div><div class="message event" id="message-1538705462.000100"><div class="content"><div class="summary"><div class="message__header user">notogawa</div><div class="message__timestamp date"><a class="date" href="#message-1538705462.000100">2018-10-05&nbsp;11:11:02 +0900</a></div></div><div class="message__body description"><blockquote>homogeneous equality, which means equality is between types of a same kind</blockquote>だから，同一kindでの関係か異なるkindでの関係かでは？</div></div></div><div class="message event" id="message-1538705622.000100"><div class="content"><div class="summary"><div class="message__header user">igrep</div><div class="message__timestamp date"><a class="date" href="#message-1538705622.000100">2018-10-05&nbsp;11:13:42 +0900</a></div></div><div class="message__body description">「異なるkindだけど等しい」という状態がどんな状態なのかちょっとイメージがわかないです。。。 :sweat:</div></div></div><div class="message event" id="message-1538707054.000100"><div class="content"><div class="summary"><div class="message__header user">notogawa</div><div class="message__timestamp date"><a class="date" href="#message-1538707054.000100">2018-10-05&nbsp;11:37:34 +0900</a></div></div><div class="message__body description">依存型を用いて長さを型やら種レベルに持つコンテナ <code>X</code> があって，さらにそれに交換則を満たすような結合操作が入っているときに，実際に交換して結合した2つのコンテナの値(型)の型(種)は <code>X (a+b)</code> と <code>X (b+a)</code> みたいなものが出てきますが，たとえばこれらのequalityが扱えないことがあるみたいな話ではないですか．</div></div></div><div class="message event" id="message-1538712049.000100"><div class="content"><div class="summary"><div class="message__header user">as_capabl</div><div class="message__timestamp date"><a class="date" href="#message-1538712049.000100">2018-10-05&nbsp;13:00:49 +0900</a></div></div><div class="message__body description"><a href='http://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Type-Equality.html'>http://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Type-Equality.html</a> ここにhomogeniousな <code>:~:</code> とheterogeniousな <code>:~~:</code> がそれぞれ定義されていますね。後者がなぜ必要なのか、私も理解できてないですが一応。</div></div></div><div class="message event" id="message-1538712318.000100"><div class="content"><div class="summary"><div class="message__header user">as_capabl</div><div class="message__timestamp date"><a class="date" href="#message-1538712318.000100">2018-10-05&nbsp;13:05:18 +0900</a></div></div><div class="message__body description">HReflでパターンマッチすれば同じ型(必然的に同じkind)になるけど、マッチ前は異なるkindの型を両辺に書ける、って感じなのか</div></div></div><div class="message event" id="message-1538725364.000100"><div class="content"><div class="summary"><div class="message__header user">igrep</div><div class="message__timestamp date"><a class="date" href="#message-1538725364.000100">2018-10-05&nbsp;16:42:44 +0900</a></div></div><div class="message__body description"><a href='https://icfp18.sigplan.org/event/hiw-2018-papers-coercion-quantification'>https://icfp18.sigplan.org/event/hiw-2018-papers-coercion-quantification</a> に張ってあるスライドの17ページに例がありました（スライドのPDFファイルへの直リンはしにくくなってますね。。。）<br/>ややでっち上げた例のようにも感じられますが、<br/><br/><pre>
data Rep :: forall k. k -&gt; Type where
  RepBool :: Rep Bool
  RepMaybe :: Rep Maybe
</pre><br/><br/>みたいな、任意のkindを内包できる型があった場合に、<br/><code>Rep Bool</code> と <code>Rep Maybe</code> の（型レベルでの）等値性を比較したい場合に kind errorになってしまう、という例です。</div></div></div><div class="message event" id="message-1538729833.000100"><div class="content"><div class="summary"><div class="message__header user">msakai</div><div class="message__timestamp date"><a class="date" href="#message-1538729833.000100">2018-10-05&nbsp;17:57:13 +0900</a></div></div><div class="message__body description">ちなみに、依存型の世界だと heterogenious equality (John Major’s equality) は K を含意するので、通常の homogeneous equality よりも真に強いです。</div></div></div><div class="message event" id="message-1538730454.000100"><div class="content"><div class="summary"><div class="message__header user">hexirp</div><div class="message__timestamp date"><a class="date" href="#message-1538730454.000100">2018-10-05&nbsp;18:07:34 +0900</a></div></div><div class="message__body description">a :~<strike>: b -&gt; a :</strike>: b が axiom K を含意する、の方が正確なような気がします</div></div></div><div class="message event" id="message-1538730833.000100"><div class="content"><div class="summary"><div class="message__header user">hexirp</div><div class="message__timestamp date"><a class="date" href="#message-1538730833.000100">2018-10-05&nbsp;18:13:53 +0900</a></div></div><div class="message__body description">というか <code>a :~: b -&gt; a :~~: b</code> は成り立つのに対して <code>a :~~: b -&gt; a :~: b</code> は成り立たないので heterogenious equality のほうが弱い、といえると私は認識していたんですがこれであってますよね……？</div></div></div><div class="message event" id="message-1538731501.000100"><div class="content"><div class="summary"><div class="message__header user">hexirp</div><div class="message__timestamp date"><a class="date" href="#message-1538731501.000100">2018-10-05&nbsp;18:25:01 +0900</a></div></div><div class="message__body description">ちょっと誤解していたんですが <code>a :~~: b -&gt; a :~: b</code> が成り立たないのは Coq においてで、 Haskell では成り立つみたいです。ｽﾐﾏｾﾝ</div></div></div><div class="message event" id="message-1538794140.000100"><div class="content"><div class="summary"><div class="message__header user">msakai</div><div class="message__timestamp date"><a class="date" href="#message-1538794140.000100">2018-10-06&nbsp;11:49:00 +0900</a></div></div><div class="message__body description">自分の言っているのは体系の強さの意味です。<br/>通常の除去規則(J)を持つ通常の homogeneous な propositional equality と、 John Major’s equality を比べると、後者を持つ体系で前者は自明に定義できて更にKやUIP(Uniqueness of identity proof)等を満たすのに対して、前者しかない体系で後者を定義することは出来ないです(ただしKもしくはUIPもしくは制限のないパターンマッチがあれば定義できる)。<br/><br/>CoqはKやUIPを前提としない体系(Agdaでの <code>--without-K</code> な状態)なので、 John Major’s equality は Axiom を使って定義されているはずです。 John Major’s equality の除去規則(とその計算規則?)を Axiom にすれば <code>a :~~: b -&gt; a :~: b</code> は証明できるはずですが、何らかの事情で別の定義を使っているのかも知れません。</div></div></div><div class="message event" id="message-1538801813.000100"><div class="content"><div class="summary"><div class="message__header user">as_capabl</div><div class="message__timestamp date"><a class="date" href="#message-1538801813.000100">2018-10-06&nbsp;13:56:53 +0900</a></div></div><div class="message__body description">最近ちまちま読んでた論文にも、良く見るとその辺の話めっちゃ出てきてました。 <a href='https://arxiv.org/abs/1610.07978'>https://arxiv.org/abs/1610.07978</a> モチベーションとして3.2節で　<@U4LGTMTMK> さんが挙げたような例が出てきて、論理的裏付けとして5章で @hexirp さんや @msakai さんが挙げてるような話が書いてあるっぽい</div></div></div><div class="message event" id="message-1538801980.000100"><div class="content"><div class="summary"><div class="message__header user">as_capabl</div><div class="message__timestamp date"><a class="date" href="#message-1538801980.000100">2018-10-06&nbsp;13:59:40 +0900</a></div></div><div class="message__body description">というか著者＝発表者だ</div></div></div><div class="message event" id="message-1538806549.000100"><div class="content"><div class="summary"><div class="message__header user">msakai</div><div class="message__timestamp date"><a class="date" href="#message-1538806549.000100">2018-10-06&nbsp;15:15:49 +0900</a></div></div><div class="message__body description">Haskell の話からはかなり脱線してしまいますが、 John Major’s equality の除去規則から 通常の propositional equality の K と UIP を示すのを Agda で書いてみました。 <a href='https://gist.github.com/msakai/b3f3003b1ec900b84c0e5c6e5315c90b'>https://gist.github.com/msakai/b3f3003b1ec900b84c0e5c6e5315c90b</a></div></div></div><div class="message event" id="message-1538814107.000100"><div class="content"><div class="summary"><div class="message__header user">hexirp</div><div class="message__timestamp date"><a class="date" href="#message-1538814107.000100">2018-10-06&nbsp;17:21:47 +0900</a></div></div><div class="message__body description">Haskell では homogeneous equality を表す型クラス a ~ b は heterogeneous equality を表す型クラス a ~~ b を使って class (a ~~ b) =&gt; (a :: k) ~ (b :: k) と定義されていますね。型クラスでは、もしインスタンスがあればそれは一意なので UIP は当然のことといえるかも？a :~: b と a :~~: b の間にはこういう関係はないです。</div></div></div><div class="message event" id="message-1538891257.000200"><div class="content"><div class="summary"><div class="message__header user">yugo.osano</div><div class="message__timestamp date"><a class="date" href="#message-1538891257.000200">2018-10-07&nbsp;14:47:37 +0900</a></div></div><div class="message__body description">@yugo.osano has joined the channel</div></div></div><div class="message event" id="message-1538895705.000100"><div class="content"><div class="summary"><div class="message__header user">tanimocchi</div><div class="message__timestamp date"><a class="date" href="#message-1538895705.000100">2018-10-07&nbsp;16:01:45 +0900</a></div></div><div class="message__body description">仕様と、上手く動かなかったプログラムを添付します。どうしても回数が多いのでOverflowするのと、計算精度が良くないようで結果もおかしな感じとなります。すいませんが、ご教示お願い致します。<br/><br/><pre>{-# LANGUAGE Strict #-}
import System.Environment

qnr :: Double -&gt; Double -&gt; Double -&gt; Double
qnr n r 0 = 0
qnr n r p
  | n &lt; r     = 0
  | n == r    = q
  | otherwise = q + (n-r)*(log(1-p)) + (foldl (+) 0 (map log [n-r+1..n])) - (foldl (+) 0 (map log [2..r]))
  where q = r * (log p)

exp_qnr :: Double -&gt; Double -&gt; Double -&gt; Double
exp_qnr n r p = exp (qnr n r p)

pnr :: Double -&gt; Double -&gt; Double -&gt; Double
pnr n r 0 = 0
pnr n r p
  | n &lt; r     = 0
  | n == r    = exp q
  | otherwise = (pnr (n-1) r p) + (1 - (pnr (n-1) r p))*(exp_qnr n r p)
  where q = r * (log p)

main = do
  args &lt;- getArgs
  (n,r,p) &lt;- case args of
    n':r':p':_ -&gt; (,,) &lt;$&gt; readIO n' &lt;*&gt; readIO r' &lt;*&gt; readIO p'
    _ -&gt; return (6400, 64, 0.8)
  -- putStrLn $ "qnr " ++ show n ++ " " ++ show r ++ " " ++ show p ++ " = " ++ show (exp_qnr n r p)
  putStrLn $ "pnr " ++ show n ++ " " ++ show r ++ " " ++ show p ++ " = " ++ show (pnr n r p)
</pre></div></div></div><div class="message event" id="message-1538895883.000100"><div class="content"><div class="summary"><div class="message__header user">igrep</div><div class="message__timestamp date"><a class="date" href="#message-1538895883.000100">2018-10-07&nbsp;16:04:43 +0900</a></div></div><div class="message__body description">ソースコードの部分はバッククォート3つで囲っていただけると助かります！<br/><pre>
こういう風に
  行頭の
  空白も保存されるので！
</pre><br/><br/>参考: <a href='https://get.slack.help/hc/ja/articles/202288908-%E3%83%A1%E3%83%83%E3%82%BB%E3%83%BC%E3%82%B8%E3%81%AE%E6%9B%B8%E5%BC%8F%E8%A8%AD%E5%AE%9A#u12452u12531u12521u12452u12531u12467u12540u12489'>https://get.slack.help/hc/ja/articles/202288908-%E3%83%A1%E3%83%83%E3%82%BB%E3%83%BC%E3%82%B8%E3%81%AE%E6%9B%B8%E5%BC%8F%E8%A8%AD%E5%AE%9A#u12452u12531u12521u12452u12531u12467u12540u12489</a></div></div></div><div class="message event" id="message-1538896619.000100"><div class="content"><div class="summary"><div class="message__header user">msakai</div><div class="message__timestamp date"><a class="date" href="#message-1538896619.000100">2018-10-07&nbsp;16:16:59 +0900</a></div></div><div class="message__body description">直観主義型理論でも、 propositional equality はデータ構築子が一つしかないにも関わらず、UIPは証明できないので、この場合もインスタンスの一意性があるからといって自明ではないような気はしますが……<br/><br/>ただ、Haskellでは以下の定義は通るようですね。 (Haskellの型レベルプログラミングに詳しくないので適当ですが)<br/><pre>
type family UIP a (x :: a) (e :: x :~: x) :: e :~: Refl where
  UIP a x Refl = Refl
</pre></div></div></div><div class="message event" id="message-1538896818.000100"><div class="content"><div class="summary"><div class="message__header user">msakai</div><div class="message__timestamp date"><a class="date" href="#message-1538896818.000100">2018-10-07&nbsp;16:20:18 +0900</a></div></div><div class="message__body description"><blockquote>依存型を用いて長さを型やら種レベルに持つコンテナ <code>X</code> があって，</blockquote><br/>多次元配列の型付けで必要になる、お仕事っぽい話だ…… (^^;</div></div></div><div class="message event" id="message-1538898458.000100"><div class="content"><div class="summary"><div class="message__header user">naohaq</div><div class="message__timestamp date"><a class="date" href="#message-1538898458.000100">2018-10-07&nbsp;16:47:38 +0900</a></div></div><div class="message__body description">引数の一部を整数にしてみました <a href='https://gist.github.com/naohaq/281aebb3f29378109bb4f866e5068ef8'>https://gist.github.com/naohaq/281aebb3f29378109bb4f866e5068ef8</a></div></div></div><div class="message event" id="message-1538900678.000100"><div class="content"><div class="summary"><div class="message__header user">naohaq</div><div class="message__timestamp date"><a class="date" href="#message-1538900678.000100">2018-10-07&nbsp;17:24:38 +0900</a></div></div><div class="message__body description">漸化式を修正したバージョン <a href='https://gist.github.com/naohaq/281aebb3f29378109bb4f866e5068ef8/2c348a0056fa6977e681f2a31b5ccf5e905c5a89'>https://gist.github.com/naohaq/281aebb3f29378109bb4f866e5068ef8/2c348a0056fa6977e681f2a31b5ccf5e905c5a89</a></div></div></div><div class="message event" id="message-1538909425.000100"><div class="content"><div class="summary"><div class="message__header user">notogawa</div><div class="message__timestamp date"><a class="date" href="#message-1538909425.000100">2018-10-07&nbsp;19:50:25 +0900</a></div></div><div class="message__body description">:innocent:</div></div></div><div class="message event" id="message-1538917124.000100"><div class="content"><div class="summary"><div class="message__header user">hiroto.shioi</div><div class="message__timestamp date"><a class="date" href="#message-1538917124.000100">2018-10-07&nbsp;21:58:44 +0900</a></div></div><div class="message__body description">この式は全然わからないけど、<br/><br/><pre>
(foldl (+) 0 (map log [n-r+1..n]))
</pre><br/><br/>これは次のように書くと計算量は減るんじゃないかな（あと正格foldlも使ってる<br/><br/><pre>
foldl' (\acc num -&gt; log num + acc) 0 [n-r+1..n]
</pre></div></div></div><div class="message event" id="message-1538917258.000100"><div class="content"><div class="summary"><div class="message__header user">hiroto.shioi</div><div class="message__timestamp date"><a class="date" href="#message-1538917258.000100">2018-10-07&nbsp;22:00:58 +0900</a></div></div><div class="message__body description"><a href='http://hackage.haskell.org/package/base-4.12.0.0/docs/Data-List.html#v:foldl-39-'>http://hackage.haskell.org/package/base-4.12.0.0/docs/Data-List.html#v:foldl-39-</a></div></div></div><div class="message event" id="message-1538980131.000200"><div class="content"><div class="summary"><div class="message__header user">algebroid0</div><div class="message__timestamp date"><a class="date" href="#message-1538980131.000200">2018-10-08&nbsp;15:28:51 +0900</a></div></div><div class="message__body description">@algebroid0 has joined the channel</div></div></div><div class="message event" id="message-1539046079.000100"><div class="content"><div class="summary"><div class="message__header user">junji.hashimoto</div><div class="message__timestamp date"><a class="date" href="#message-1539046079.000100">2018-10-09&nbsp;09:47:59 +0900</a></div></div><div class="message__body description">ghcで書いたプログラムを<br/>pythonで動かしたいです<br/>jsへのコンパイラはいろいろありますが<br/>pythonに変換するものはありますか？</div></div></div><div class="message event" id="message-1539047586.000100"><div class="content"><div class="summary"><div class="message__header user">igrep</div><div class="message__timestamp date"><a class="date" href="#message-1539047586.000100">2018-10-09&nbsp;10:13:06 +0900</a></div></div><div class="message__body description">多分ないです。少なくとも私は聞いたことがありません。<br/>そもそもどういう動機でPythonに変換したいんですか？AWS Lambdaで動かすとか？</div></div></div><div class="message event" id="message-1539048784.000100"><div class="content"><div class="summary"><div class="message__header user">notogawa</div><div class="message__timestamp date"><a class="date" href="#message-1539048784.000100">2018-10-09&nbsp;10:33:04 +0900</a></div></div><div class="message__body description">動かしたいだけなら FFI で shared object に変換して，python側で <code>import ctypes</code> から呼び出すのがてっとり早いのではないかと思います．</div></div></div><div class="message event" id="message-1539054228.000100"><div class="content"><div class="summary"><div class="message__header user">junji.hashimoto</div><div class="message__timestamp date"><a class="date" href="#message-1539054228.000100">2018-10-09&nbsp;12:03:48 +0900</a></div></div><div class="message__body description">pythonでグラフを表示したいのですが、<br/>今はpythonからpopenしてhaskellで作ったコマンドを呼び出しています。（呼び出しスピードとか気にしてないです）<br/>インストールが面倒でwheelに実行コマンドを含めようかと思ってました。<br/>用途してはこれで十分なのですが、OS別にバイナリをつくるのがそれはそれで面倒で、どうしたものかと。<br/>大したものではないのでpythonで書き直しも考えております。</div></div></div><div class="message event" id="message-1539143417.000100"><div class="content"><div class="summary"><div class="message__header user">kazu</div><div class="message__timestamp date"><a class="date" href="#message-1539143417.000100">2018-10-10&nbsp;12:50:17 +0900</a></div></div><div class="message__body description"><code>Data.List.delete</code> って、最初にマッチした要素しか消してくれないのですね。マッチする全部の要素を取り除く関数ってありませんか？</div></div></div><div class="message event" id="message-1539143727.000100"><div class="content"><div class="summary"><div class="message__header user">a_kirisaki</div><div class="message__timestamp date"><a class="date" href="#message-1539143727.000100">2018-10-10&nbsp;12:55:27 +0900</a></div></div><div class="message__body description">代わりに <code>Data.List.filter</code> を使うのはどうでしょう</div></div></div><div class="message event" id="message-1539143740.000200"><div class="content"><div class="summary"><div class="message__header user">hiratara</div><div class="message__timestamp date"><a class="date" href="#message-1539143740.000200">2018-10-10&nbsp;12:55:40 +0900</a></div></div><div class="message__body description">それって <code>filter</code> のような気がしますが、汎用的ではない特定の要素を全消しする専用の関数を探しているということです？</div></div></div><div class="message event" id="message-1539143746.000100"><div class="content"><div class="summary"><div class="message__header user">hiratara</div><div class="message__timestamp date"><a class="date" href="#message-1539143746.000100">2018-10-10&nbsp;12:55:46 +0900</a></div></div><div class="message__body description">あ、かぶった・・・</div></div></div><div class="message event" id="message-1539144724.000100"><div class="content"><div class="summary"><div class="message__header user">kazu</div><div class="message__timestamp date"><a class="date" href="#message-1539144724.000100">2018-10-10&nbsp;13:12:04 +0900</a></div></div><div class="message__body description">あー、filter でいいのか。ありがとうございます！</div></div></div></div><div class="pager ui pagination menu"><a href="../../html/C5666B6BB/27.html" class="pager__previous item">Previous</a><a href="../../" class="pager__top item">Top</a><a href="../../html/C5666B6BB/29.html" class="pager__next item">Next</a></div></div></body></html>