[
    {
        "ts": "1632963970.095800",
        "text": "こんにちは、Template Haskellを書いている最中に\nIllegal variable name: Mail\nというエラーが出てきて困っています。\n\nエラーとしては\n```mailscript/app/Main.hs:18:1: error:\n    Illegal variable name: 'Mail'\n    When splicing a TH declaration:\n      main_0 = do {bodyTpl_1 &lt;- eitherParseFile \"./template/body.txt\";\n             titleTpl_2 &lt;- eitherParseFile \"./template/title.txt\";\n             Data.Traversable.mapM (\\property_3 -&gt; GHC.Base.pure (Language.Haskell.TH.Syntax.BindS (Language.Haskell.TH.Syntax.VarP (Language.Haskell.TH.Syntax.mkName GHC.Base.$ (\"input\" GHC.Base.++ property_3))) (Language.Haskell.TH.Syntax.VarE System.IO.getLine))) ps;\n             let {env_4 = fromPairs [(Data.Text.Lazy.unpack GHC.Base.$ Lib.key (Lib.Schema (Data.Text.Lazy.pack \"mail\") [Data.Text.Lazy.pack \"todayWorkSchedule\",\n                                                                                                                         Data.Text.Lazy.pack \"todayOutcome\",\n                                                                                                                         Data.Text.Lazy.pack \"tomorrowWorkSchedule\",\n                                                                                                                         Data.Text.Lazy.pack \"thoughts\"])) Data.Aeson.Types.ToJSON..= (Data.Aeson.Types.ToJSON.toJSON GHC.Base.$ Data.Foldable.foldl (GHC.Base.$) Main.Mail ps)];\n                  body_5 = Data.Either.either GHC.Err.error toStrict GHC.Base.$ (bodyTpl_1 GHC.Base.&gt;&gt;= (`eitherRender` env_4));\n                  title_6 = Data.Either.either GHC.Err.error toStrict GHC.Base.$ (titleTpl_2 GHC.Base.&gt;&gt;= (`eitherRender` env_4))};\n             uprint body_5;\n             uprint title_6}\n   |\n18 | do\n   | ^^...```\n現在、会社の日報のためにメール送信スクリプトを作成しようと考えています。jsonでデータの構造を書いておき、そのインスタンスをEDEでメールの定型文に読み込む方針で す。\n\n対象となるコードはこちらになります。Template Haskell自体まだ概念に馴染めておらず、なかなか苦戦しております…\nなにかおすすめの資料等あれば教えていただけるとありがたいです:writing_hand:\n\n```data Properties = Properties [Text] deriving Show\ninstance FromJSON Properties where\n    parseJSON (Array v) = Properties &lt;$&gt; parseJSON (Array v)\n    parseJSON _ = mzero\n\ndata Schema = Schema\n    { key :: Text\n    , properties :: [Text]\n    } deriving (Lift, Show)\ninstance FromJSON Schema where\n    parseJSON (Object v) =\n        if size v /= 1 then\n            fail \"expected a pair.\"\n        else\n            do hs &lt;- parseJSON (Object v)\n               let ls = toList hs\n               return . (\\(key, Properties properties) -&gt; Schema key properties) $ head ls\n\n\ntoTitle :: Text -&gt; String\ntoTitle =\n    let\n        toTitleString (c:cs) =\n            (toUpper c):cs\n    in\n    toTitleString . unpack\n\n\nschemaToData :: Schema -&gt; Q [Dec]\nschemaToData schema =\n  do\n    name &lt;- ( newName . toTitle $ key schema )\n    pure\n      [ DataD [] name [] Nothing\n        [ RecC\n            ( mkName . toTitle $ key schema )\n            ( Prelude.map\n                (\\property -&gt; ( mkName $ unpack property, Bang Language.Haskell.TH.NoSourceUnpackedness Language.Haskell.TH.NoSourceStrictness, ConT ''Text ))\n                ( properties schema )\n            )\n        ]\n        [ DerivClause Nothing [ConT ''Show, ConT ''Generic]\n        ]\n      , InstanceD Nothing [] (AppT (ConT ''ToJSON) (ConT name)) []\n      , InstanceD Nothing [] (AppT (ConT ''FromJSON) (ConT name)) []\n      ]```",
        "user": "U028P8GL2FJ",
        "type": "message"
    },
    {
        "ts": "1632968955.095900",
        "text": "```(\\property -&gt; ( mkName $ unpack property, Bang ```\nの行で、 `mkName` に渡している `unpack property` の結果の文字列が大文字始まりになっていることが原因と思われます。\nこの `property` は外から入ってきたデータのようなので、これ自体に大文字始まりの文字列が入ってしまっている、もっと根本的な原因は分からないです。",
        "user": "U4LGTMTMK",
        "type": "message"
    },
    {
        "ts": "1632969870.096100",
        "text": "あと、Template Haskellで構文木を組み立てるときは、極力 `[d| |]` や `[e| |]` などのquote構文を使いましょう。これを使うと、直接Haskellのコードを書いて構文木を組み立てることができて、劇的にコード量が減りますし、Template Haskellの仕様変更にも強くなります。例えば拙作ですがtypesafe-precureというパッケージでは、今回のケースのように外部からのデータで型を作成してそのインスタンス定義までしている箇所がたくさんあります。\n具体的には <https://github.com/igrep/typesafe-precure/blob/411e39147b068ffa9e98a73175e244f07c39aa86/src/ACME/PreCure/Types/TH.hs#L139-L205> のあたり。\n\n中に何を `$( )` で埋め込めるかが分かりづらくて、あらゆるケースで使えるわけじゃないのでご注意ください。多分そのあたりでハマると思うのでそのときは改めて教えてください。\n\nさらにもう一つ。上記の方法がうまく使えず、 `DataD` や `RecC` といった値コンストラクターを直接使って構文木を組み立てる場合においても、よりよい方法があります。\n<https://hackage.haskell.org/package/template-haskell-2.17.0.0/docs/Language-Haskell-TH-Lib.html> こちらのモジュールで定義されている、`dataD` などの関数を使いましょう。こちらは直接 `Q` Monadの値を返してくれるので `pure` を使う必要性が減るだけでなく、値コンストラクターではなく関数なので互換性を維持しやすい（Template Haskellの仕様変更に少し強い）というメリットもあります。\nTemplate HaskellはGHCのメジャーバージョンが変わる毎にちまちまと仕様変更を繰り返しているので、これらの方策でなるべく変更に強いコードにしておきましょう。",
        "user": "U4LGTMTMK",
        "type": "message"
    },
    {
        "ts": "1632969952.096400",
        "text": "Template Haskellの `[e| ... |]` などについてもっと詳しく解説してる記事があれば誰補足してほしいです... :pray:",
        "user": "U4LGTMTMK",
        "type": "message"
    },
    {
        "ts": "1632980506.096700",
        "text": "ご返信ありがとうございます！\ndata コンストラクタだから勝手に大文字始まりだと思いこんでいました……Nameあたりまたドキュメント読み直して調べてみます！\n\n実は<@U4LGTMTMK> さんのタイプセーフプリキュアの記事をhaskell-jpで見て、template haskellに興味を持ったんです。\nソースコードを呼んでみたいと思います。ありがとうございます！\n\nstageやlift等コンパイラに怒られてしまって、ちょっとまだ難しいと思いdataD等避けていました。\nこれからは関数で記法を統一していこうと思います。ありがとうございます。:pray:",
        "user": "U028P8GL2FJ",
        "type": "message"
    }
]