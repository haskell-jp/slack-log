[
    {
        "ts": "1567938986.050900",
        "text": "確かに、言われてみればなんの区切りもなく匿名関数が始まっているようで、普通の式とどうやって見分けるんだろうという感じがしますね...",
        "user": "U4LGTMTMK",
        "type": "message"
    },
    {
        "ts": "1567939338.051200",
        "text": "たしかに。\n括弧にくるんでるからって安心してましたけどたしかにexprASTも括弧にくるまれてるから安心できなかった",
        "user": "UMKGDJ2RZ",
        "type": "message"
    },
    {
        "ts": "1567943436.051800",
        "text": "なるほど，不思議な動作ですね… 確かに Strict の時のみ stack overflow になりました… ちょっとそれは想定してませんでしたね…",
        "user": "U57D08Z9U",
        "type": "message"
    },
    {
        "ts": "1567945497.052100",
        "text": "あ，いいのか．過去の自分に追いつけてなかった．\nまず， Strict をつけようがつけまいが，\n```\nfoldl (\\ z x -&gt; x : z) [] [1..n]\n```\nは\n```\nlet k = \\ z x -&gt; x : z in (([] `k` 1) ... `k` n)\n```\nみたいなものを生成することになります．でそれぞれの括弧の中身はサンクのままヒープにのって評価されるのを待つことになります．\n\n`evaluate` でそれが WHNF まで評価されることになりますが，まず一番外側の評価\n```\n(… `k` n) =&gt; n : ...\n```\nが実行されることになります． Strict をつけない場合 `...` は評価されませんが， Strict をつける場合 `...` の部分が評価されることになり，さらにその評価のために `k (…) (n - 1)` の評価が走りという感じで，どんどんスタックに退避された値が積み上がっていきスタックオーバーフローになります．\n\nなお，ちゃんと `foldl'` を使った場合，ヒープに積み上がるはずだったサンクが先に消化されながらループが回るため，どちらの場合もスタックオーバーフローは起きません",
        "user": "U57D08Z9U",
        "type": "message"
    },
    {
        "ts": "1567945696.052800",
        "text": "あ，だから Strict 拡張のみで stack overflow する例なんですね．前のコメントは間違いですね．失礼しました",
        "user": "U57D08Z9U",
        "type": "message"
    },
    {
        "ts": "1567955856.055000",
        "text": "初めて template Haskell を書いたのですがビルド時に 10GB 以上消費されるようになってしまいました…… :cry:\nコードレビューしてほしいです\n<https://github.com/kakkun61/tuple/pull/1>",
        "user": "U4L0B71L1",
        "type": "message"
    },
    {
        "ts": "1567962365.055200",
        "text": "Ty*等構文木のコンストラクタを直で使うとバージョンアップで壊れやすいものができあがるので，可能な限りQuasi-quotationを使って書いておいたほうが幸せになると思います．",
        "user": "U5G2BCVBN",
        "type": "message"
    },
    {
        "ts": "1567963552.055400",
        "text": "なるほど！",
        "user": "U4L0B71L1",
        "type": "message"
    },
    {
        "ts": "1567976577.055600",
        "text": "`Q` モナドは， `runQ` を使えば `IO` の元で走らせることができるようになっているので，それでデバッグできます．大体のデータ型は `Show` が実装されているので，単純に表示してみると良いと思います．\n\n```\n&gt;&gt;&gt; runQ (consType 1) :: IO [Dec]\n[TySynInstD Data.Tuple.List.Data.Cons (TySynEqn [VarT x_2,TupleT 0] (AppT (TupleT 1) (VarT x_2)))]\n```\n\nみたいな感じでそれぞれの関数の `Dec` を表示する `Main` モジュールを書いて，プロファイルを取ってみるといいと思いますね．\n\nついでにですが，無限リストの利用は計画的に行った方が良いと思いますね",
        "user": "U57D08Z9U",
        "type": "message"
    },
    {
        "ts": "1567992697.056300",
        "text": "`runQ` したのをわざわざコピーしてました……",
        "user": "U4L0B71L1",
        "type": "message"
    },
    {
        "ts": "1568007206.056600",
        "text": "できないと思う。少なくとも僕が関わっているプロジェクトではstackでインストールしたパッケージをnixの環境では利用できなかった。\n\n\n&gt; OSSでhydra使うにはどうしたらいいでしょうか。自分でたてるしかないですか？\n自分もよくわからないからきいてみます！",
        "user": "U7Z4F723Z",
        "type": "message"
    },
    {
        "ts": "1568079332.061100",
        "text": "お疲れ様です\ntype levelの関数をpropertyテストするにはどうすればいいでしょうか？\ndoctestでkinds!やtype-specで個別の値はテストできるのですが。\nあとはtemplate haskellつかうとか？",
        "user": "U74KTAG0N",
        "type": "message"
    },
    {
        "ts": "1568081220.062100",
        "text": "<https://hackage.haskell.org/package/should-not-typecheck> をうまく使えば... と思ったけど型レベルで生成する必要があるわけですよね... :gununu:\n\n確かにTemplate Haskellを使って頑張って書くしか思いつかないですね... （新しいパッケージを作るチャンス！",
        "user": "U4LGTMTMK",
        "type": "message"
    }
]