[
    {
        "ts": "1566219854.115200",
        "text": "<@U4LGTMTMK>\nあ！！spacesがspaceになっているのが原因でした..\nありがとうございます\n前々からspacesはやたら出てくるなぁと感じていたので教えていただいたものを使うとだいぶスッキリ書けました",
        "user": "UCM4G8PGW",
        "type": "message"
    },
    {
        "ts": "1566219992.115500",
        "text": "<@U570660KX> これ、やりたかったけど書き方がわからなくて断念したものに近いです！ありがとうございます\n\nちなみにこんな感じになりました\n<https://github.com/mrsekut/plp-hs/commit/7f2a2425244ae40f028d9b1fa3cde321726399dc>",
        "user": "UCM4G8PGW",
        "type": "message"
    },
    {
        "ts": "1566220077.115700",
        "text": "<@U55V441FS>\nchoiceとchainl1は初見でした\n早速試してみます\nありがとうございます！",
        "user": "UCM4G8PGW",
        "type": "message"
    },
    {
        "ts": "1566235611.116600",
        "text": "chainl1ヤバいですね..",
        "user": "UCM4G8PGW",
        "type": "message"
    },
    {
        "ts": "1566252727.117000",
        "text": "おまけにひけらかし: Megaparsecには、chainlを便利にしたmakeExprParserというのがあります\n<https://hackage.haskell.org/package/megaparsec-6.4.0/docs/Text-Megaparsec-Expr.html>",
        "user": "U4LGTMTMK",
        "type": "message"
    },
    {
        "ts": "1566314797.117600",
        "text": "なるほど！！\nParsecを拡張(?)したAuttoparsecやMegaparsecなるものがあるのですね\n初めて知りました\nありがとうございます！\nmakeExprParser、ちょっと調べてみます",
        "user": "UCM4G8PGW",
        "type": "message"
    },
    {
        "ts": "1566320100.118000",
        "text": "Megaparsecについてはそうです。Parsecのイケてないところをいろいろ改善するために作られたライブラリーなので。\nAttoparsecについては、Parsecとちょっと方向性が違っていて、詳しいエラーメッセージを出せない代わりに速度を高めています",
        "user": "U4LGTMTMK",
        "type": "message"
    },
    {
        "ts": "1566320938.118200",
        "text": "なるほど、それぞれ目的が異なるのですね\nなにも知らないですが、処理速度と詳しいエラーが出せないことがトレードオフになるのが少し不思議に感じます",
        "user": "UCM4G8PGW",
        "type": "message"
    },
    {
        "ts": "1566365661.118400",
        "text": "ここでいう「詳しいエラーメッセージ」とはエラーが発生した位置を含んでいる、という意味です。",
        "user": "U4LGTMTMK",
        "type": "message"
    },
    {
        "ts": "1566394109.118700",
        "text": "既知かも知れませんが参考までに、Megaparsecなどの情報です。\n\nBigmoonさんのところの記事（日本語）\n<https://haskell.e-bigmoon.com/posts/2019/07-14-megaparsec-tutorial.html>\n\nSwitch from Parsec to Megaparsec（英語）\n<https://markkarpov.com/megaparsec/switch-from-parsec-to-megaparsec.html>\n\nMizunashiさんの、いろいろなパーサまとめ記事もあり。\n<https://qiita.com/Mizunashi_Mana/items/115855bf2af9b9970198>",
        "user": "U55V441FS",
        "type": "message"
    },
    {
        "ts": "1566408649.119300",
        "text": "うおお、ありがとうございます:man-bowing:",
        "user": "UCM4G8PGW",
        "type": "message"
    },
    {
        "ts": "1566409226.125900",
        "text": "質問ばかりで恐縮ですが、こんどはコード生成に関する雑な質問です。\n\nASTまで得られた状態で、他の言語などへのコード生成の処理を書きたいと思っています。\n関数型言語が構文解析が得意なのは耳にしていましたが、コード生成も得意なのは初めて知りました。\n\n以下のような記事を見つけ、読んでみました。\n<https://keigoi.hatenadiary.org/entry/20111206/haskell_tagless_dsl>\n<http://nebuta.hatenablog.com/entry/2013/08/01/143926>\n一度読んだだけでは正直、わからないところもわからないという感じですが、\nとりあえず以下のような話題を理解するように感じました\n\n- 型クラスの自作\n- モナドの自作\n- モナド変換子の概念の理解と、扱い方\n\nこの記事を参考にして一つずつわからないところを潰していくつもりではありますが、もしこの「コード生成」の部分に関して入門者向けの良い記事や書籍、ライブラリや実装例、検索のための語彙などをご存知でしたら教えていただけると嬉しいです。\n\nターゲットなる言語は特に問うてませんが、実装中なのはアセンブリを吐くコンパイラです。\n現状、コード生成部分はすごい手続き的な書き方になってしまっています..\n<https://github.com/mrsekut/hcc/blob/master/app/Main.hs>\n\nよろしくお願いします。",
        "user": "UCM4G8PGW",
        "type": "message"
    },
    {
        "ts": "1566425500.126500",
        "text": "モナド変換子ならこちらがオススメです\n<http://bicycle1885.hatenablog.com/entry/2012/12/08/165236>",
        "user": "U4L0B71L1",
        "type": "message"
    },
    {
        "ts": "1566425740.126800",
        "text": "モナド変換子を勉強すると、モナド変換子の型別名や newtype ラッパーを作るだけで事足りるので、オリジナルのモナドを作ることはほぼないと思います",
        "user": "U4L0B71L1",
        "type": "message"
    },
    {
        "ts": "1566435662.127000",
        "text": "コード生成、とは少し違うかもしれませんが、いちにぃさんのPDFを読んで生成する話の記事は読みやすくて面白いです~\n<https://itchyny.hatenablog.com/entry/2015/09/16/100000>",
        "user": "U4KPPQW7K",
        "type": "message"
    },
    {
        "ts": "1566452346.127500",
        "text": "ステップバイステップ何回も読んだなー笑",
        "user": "U56L7EVNY",
        "type": "message"
    },
    {
        "ts": "1566488800.128200",
        "text": "<@U4L0B71L1>\nスッテプばいステップ読み進めています\n学びが深くてうずうずしています\nありがとうございます!",
        "user": "UCM4G8PGW",
        "type": "message"
    },
    {
        "ts": "1566492615.128700",
        "text": "<@UMLMHU3HS> has joined the channel",
        "user": "UMLMHU3HS",
        "type": "message"
    },
    {
        "ts": "1566497424.128900",
        "text": "<@U4KPPQW7K>\n\nまだちゃんと読んでいませんが、PDFを生成する記事もヤバそうです！(長い！そしてはてぶ数がすごい！)\nモナド変換子の記事をやり終えたら読んでみたいと思います\nありがとうございます！",
        "user": "UCM4G8PGW",
        "type": "message"
    },
    {
        "ts": "1566531019.129600",
        "text": "<@UMA9RJA3C> has joined the channel",
        "user": "UMA9RJA3C",
        "type": "message"
    },
    {
        "ts": "1566543030.133200",
        "text": "MacOS Sierra で stack lts-12.26 (GHC 8.4.4)だと平気なんだけど、lts-14.2 (GHC 8.6.5) だとリンカで死ぬ :cry:\n```\nLinking .stack-work/dist/x86_64-osx/Cabal-2.4.0.1/build/site/site ...\nUndefined symbols for architecture x86_64:\n  \"_utimensat\", referenced from:       \n      _cazW_info in libHSdirectory-1.3.3.0.a(Posix.o)\nld: symbol(s) not found for architecture x86_64\nclang: error: linker command failed with exit code 1 (use -v to see invocation)\n`gcc' failed in phase `Linker'. (Exit code: 1)\nCompleted 166 action(s).               \n\n--  While building package matsubara0507-ghpages-0.3.1.0 using:\n      $HOME/.stack/setup-exe-cache/x86_64-osx/Cabal-simple_mPHDZzAJ_2.4.0.1_ghc-8.6.5 --builddir=.stack-work/dist/x86_64-osx/Cabal-2.4.0.1 build exe:site --ghc-options \" -fdiagnostics-color=always\"\n    Process exited with code: ExitFailure 1\n```\nutimensat 使えないのに、utimensat 使えるフラグが立っちゃうせいだと思うんだけど、うーん、なぜだろ\nいろんなパターンで試した結果、GHC 8.6.4 からダメっぽい（lts-13.11 は行けて lts-13.19 はダメだった、Cabal も関係なかった）",
        "user": "U56L7EVNY",
        "type": "message"
    },
    {
        "ts": "1566543850.133300",
        "text": "Undefined symbols for architecture x86_64: “_utimensat”, referenced from: _cazW_info in libHSdirectory-1.3.3.0.a(Posix.o)\n<https://stackoverflow.com/questions/56029761/undefined-symbols-for-architecture-x86-64-utimensat-referenced-from-cazw>\n\n似たようなの見つけました。",
        "user": "U5B3EGEFQ",
        "type": "message"
    },
    {
        "ts": "1566544091.133600",
        "text": "そうそう、それみた\nHigh Sierra 以上にすれば平気なんだろうけど",
        "user": "U56L7EVNY",
        "type": "message"
    },
    {
        "ts": "1566623466.133900",
        "text": "<@UMNGDEP4L> has joined the channel",
        "user": "UMNGDEP4L",
        "type": "message"
    },
    {
        "ts": "1566665189.134200",
        "text": "<@UMNNKKV5J> has joined the channel",
        "user": "UMNNKKV5J",
        "type": "message"
    },
    {
        "ts": "1566731735.134500",
        "text": "<@UMRLWNJ5C> has joined the channel",
        "user": "UMRLWNJ5C",
        "type": "message"
    },
    {
        "ts": "1566884214.135000",
        "text": "<@UMDMTSLM9> has joined the channel",
        "user": "UMDMTSLM9",
        "type": "message"
    },
    {
        "ts": "1566915490.135300",
        "text": "<@UMTRA1VHU> has joined the channel",
        "user": "UMTRA1VHU",
        "type": "message"
    },
    {
        "ts": "1566948379.135600",
        "text": "<@UMET4N6Q3> has joined the channel",
        "user": "UMET4N6Q3",
        "type": "message"
    },
    {
        "ts": "1567075207.005000",
        "text": "GHCのRTSについての質問です。 <https://twitter.com/igrep/status/1167019215489863681> に書いたとおりなのですが、\n<https://gitlab.haskell.org/ghc/ghc/wikis/commentary/rts/haskell-execution/pointer-tagging> で解説されている「tagged pointerによる最適化」というのは、 <https://gitlab.haskell.org/ghc/ghc/blob/bd660edeb783a74e5ca3f1f82713b2aeedae19dc/includes/Cmm.h#L279-285> で行われている、\n「タグを取得してみてタグが0じゃなかったらタグの値をそのまま返して、0だったら `%INFO_PTR` というマクロを呼ぶ」処理のこと、という理解で正しいでしょうか？",
        "user": "U4LGTMTMK",
        "type": "message"
    },
    {
        "ts": "1567082253.005200",
        "text": "Pointer Tagging は、ヒープオブジェクトが評価済みか否かを、ポインタの下位ビットを使って表す実装方法になります。\n\nタグが0でなければ「評価済み」であると判断して、そのヒープオブジェクトの評価を省略できます。\nそのヒープオブジェクトが値コンストラクタの場合は、タグのビットが値をそのものを表します。\n例えば、Maybe型の値であれば、タグが1なら「Nothing」で、タグが2なら「Just x」であることがわかります。\n\nなお、タグが0の場合は「未評価」であるとして、そのヒープオブジェクトを評価（ENTER）します。\n\n参考までに、pointer taggingの実装イメージはこんな感じです。\n<https://takenobu-hs.github.io/downloads/haskell_ghc_illustrated.pdf#page=37>",
        "user": "U55V441FS",
        "type": "message"
    },
    {
        "ts": "1567084567.005400",
        "text": "なお、Pointer Tagging を使ったコードは、GHCのランタイムシステムだけでなく、GHCによるコンパイル結果のコード側にも表れます。例えば、 `case x of ... ` の `x` が評価済みかを、pointer tagging で切り分けています。\n\n少しコード例が古いですが、Pointer Tagging については、以下の箇所付近も参考になります。\n<https://gitlab.haskell.org/ghc/ghc/wikis/commentary/compiler/generated-code#example-7-case-expressions>",
        "user": "U55V441FS",
        "type": "message"
    },
    {
        "ts": "1567089206.006300",
        "text": "型の切り出しによる関数の書き換え方ついて質問させてください。\n\n今まで以下のような型だったものを\n```\ndata Expr = Add Expr Expr\n          | Sub Expr Expr\n          | Nat Int\n            deriving (Show, Eq)\n```\n\n以下のように切り出したいと考えています\n```\ndata BinOp = Add | Sub deriving (Show, Eq)\ndata Expr = BinOp Expr Expr\n          | Nat Int\n            deriving (Show, Eq)\n```\n\nそれに伴い、今まで使っていた関数も少し手を加えなければいけないのですが、書き換え方がわかりません。\n```\n-- 従来のもの\n-- add ::= term | term ('+' add | \"-\" add)\nadd :: Parser Expr\nadd = term `chainl1` skipW1 addop\n\naddop :: Parser (Expr -&gt; Expr -&gt; Expr)\naddop = Add &lt;$ char '+' &lt;|&gt; Sub &lt;$ char '-'\n```\n\n欲しいaddopの型は`addop :: Parser (Expr -&gt; Expr -&gt; Expr)`ですが、このままだと`addop :: ParsecT String () Identity BinOp`になってしまいます。\n\n今まで通り以下のように書けば、コンパイルは通りますが、欲しい物と結果が異なります。\n```\naddop :: Parser (Expr -&gt; Expr -&gt; Expr)\naddop = BinOp &lt;$ char '+' &lt;|&gt; BinOp &lt;$ char '-'\n```\n\n欲しい物の例→`Add (Nat 1) (Nat 2)\n得られる物の例→`BinOp (Nat 1) (Nat 2)\n\n怒られている理由はわかりますが、直し方がわからないという状態です。\n\nまた、この問題を解決するために「Haskell 型 切り出し」などでいくつかググってみたのですが、良い成果が得られませんでした。\nもし今回の件のようなものに対して適当な用語などがあれば教えていただけると嬉しいです。\n\nよろしくお願いします。\n\n\n変更前のコードの全体はいかにあります\n<https://github.com/mrsekut/hcc/blob/master/src/Parser.hs>",
        "user": "UCM4G8PGW",
        "type": "message"
    },
    {
        "ts": "1567089924.006800",
        "text": "この型の切り出し方で、記述する関数の数が減ったりするわけではないので、このように切り出す事自体が微妙なのかなとも思い始めました。\n単純にExprの定義が多少見やすくなるかなというのと、こういう切り出し方をしている例をよく見るなというのがモチベーションですが、それがそもそも正しいのかもわかりません",
        "user": "UCM4G8PGW",
        "type": "message"
    },
    {
        "ts": "1567090511.007100",
        "text": "まず、切り出したあとの Expr の定義間違ってない？\n`Expr = B BinOp Expr Expr | Nat Int` じゃないとじゃない？\nただの typo ならいいんだけど",
        "user": "U56L7EVNY",
        "type": "message"
    },
    {
        "ts": "1567091201.007300",
        "text": "typoのつもりではありませんでした\nなるほど！、ただ切り出してエイリアスのように使うものではなく、ネストが一階層深くなるのですね\nそうすることでパターンマッチなどもできるのですね.\n型コンストラクタや値コンストラクタなどに対する理解が甘いのかもしれません。\nご教示頂いたコードなら動かすことができました。\nありがとうございます！",
        "user": "UCM4G8PGW",
        "type": "message"
    },
    {
        "ts": "1567121011.008000",
        "text": "tagで切り分けている、というのは `if (R1 &amp; 3 != 0) goto ccA;` の行のことですよね？",
        "user": "U4LGTMTMK",
        "type": "message"
    },
    {
        "ts": "1567170273.008200",
        "text": "はい、 `if (R1 &amp; 3 != 0) goto ccA;` が１つめの切り分けです。\nここは、 `x` が「評価済みか否か」を切り分けています。\n（未評価の場合のみ、 `x` を評価（xのコードへjump）します。）\n\n続いて、 `if (_ccu::I32 &gt;= 2) goto ccv;` が２つめの切り分けです。\nここは、コンストラクタの値を切り分けています。（caseの各節への分岐に相当します。）\ntagの部分が「1」なら `Nothing` で、「2」なら `Just` を表します。\nここでは、 `&gt;= 2` によって、 `Just` かを切り分けています。\nつまり、pointer の tag の部分をみると、「評価済みか否か」に加えて\n「そのコンストラクタの値が何か」までをも判別できます。\n\nつまり、 `x` の実体にメモリアクセスすることなく、 `x` が評価済みかと、\n`x` の値が何かがわかるのが、pointer taggingの良いところです。",
        "user": "U55V441FS",
        "type": "message"
    },
    {
        "ts": "1567208371.008500",
        "text": "見てみます！ありがとうございます",
        "user": "ULTBB86UC",
        "type": "message"
    },
    {
        "ts": "1567304642.008800",
        "text": "<@UMKGDJ2RZ> has joined the channel",
        "user": "UMKGDJ2RZ",
        "type": "message"
    }
]