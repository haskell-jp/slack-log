[
    {
        "ts": "1573546692.085000",
        "text": "ghcup 的な PowerShell 用なにがしをざっくり作ってみた\n<https://github.com/kakkun61/ghcups>",
        "user": "U4L0B71L1",
        "type": "message"
    },
    {
        "ts": "1573558189.085300",
        "text": "そもそも PowerShell で GHC 使ってる人は何人いるのか",
        "user": "U4L0B71L1",
        "type": "message"
    },
    {
        "ts": "1573573705.086100",
        "text": "cabal が ghc-pkg.ps1 を使ってくれない\n```\nλ  cabal init\ncabal.exe: The program 'ghc-pkg' is required but it could not be found.\n\nC:\\Users\\kazuki\\temp\nλ  Get-Command ghc-pkg\n\nCommandType     Name                                               Version    Source\n-----------     ----                                               -------    ------\nExternalScript  ghc-pkg.ps1                                                   C:\\ProgramData\\ghcups\\ghc-pkg.ps1\n```",
        "user": "U4L0B71L1",
        "type": "message"
    },
    {
        "ts": "1573686531.087000",
        "text": "TExpQとOverloadedStringsをうまく利用して、特定の形式に沿った文字列リテラルかを静的にチェックする\n<https://gist.github.com/chrisdone/809296b769ee36d352ae4f8dbe89a364>",
        "user": "U4LGTMTMK",
        "type": "message"
    },
    {
        "ts": "1573697287.088100",
        "text": "ソースプラグインの出番な気もする\nByteString の文字列リテラルで 8 bit 超えてたらエラーにするの誰か書いてなかったっけ",
        "user": "U4L0B71L1",
        "type": "message"
    },
    {
        "ts": "1573697493.089100",
        "text": "<https://mizunashi-mana.github.io/blog/posts/2019/10/lint-bslit-by-ghc-plugin/#lint-bslit-by-ghc-plugin> ね。\nぱっと見TExpQの方がお手軽な手段だし、これから `IsString` のインスタンスを作る場合はいいんじゃないっすか",
        "user": "U4LGTMTMK",
        "type": "message"
    },
    {
        "ts": "1573740913.089500",
        "text": "いい感じになったので試してみてほしい",
        "user": "U4L0B71L1",
        "type": "message"
    },
    {
        "ts": "1573782542.090100",
        "text": "memory パッケージの Bytes は pinned だった。ByteString と変わらない。。。",
        "user": "U56MBRKR9",
        "type": "message"
    },
    {
        "ts": "1573782587.091000",
        "text": "やはり、syscall とのやりとりは ByteString で、内部的には pinned じゃないShortByteString で持つのが安全かなぁ。",
        "user": "U56MBRKR9",
        "type": "message"
    },
    {
        "ts": "1573785550.092400",
        "text": "ByteString を使いたくないのは fragmentation とかですか？",
        "user": "U4M9NJ7QE",
        "type": "message"
    },
    {
        "ts": "1573785955.092600",
        "text": "意図せずに共有してしまうとリークします。そして、そのうち断片化しますね。",
        "user": "U56MBRKR9",
        "type": "message"
    },
    {
        "ts": "1573786536.097000",
        "text": "なるほど。大きな ByteString の一部を thunk が保持していて GC されないみたいなのもよくあります。retainer profilerがpinned objectを検出できるようになればいいのですが今はそうなってないので、デバッグが少し難しいタイプのリークですね。",
        "user": "U4M9NJ7QE",
        "type": "message"
    },
    {
        "ts": "1573786610.097600",
        "text": "関連チケット: <https://gitlab.haskell.org/ghc/ghc/issues/7275>",
        "user": "U4M9NJ7QE",
        "type": "message"
    },
    {
        "ts": "1573786775.099400",
        "text": "僕は、遅延評価も ByteString も捨てる方向です。",
        "user": "U56MBRKR9",
        "type": "message"
    },
    {
        "ts": "1573788272.101500",
        "text": "遅延評価はともかくByteString はブートライブラリの一つでほとんどのライブラリが前提としてるので捨てるのは難しくないですか？",
        "user": "U4M9NJ7QE",
        "type": "message"
    },
    {
        "ts": "1573788346.101800",
        "text": "FFI には使いますよ！ 内部データとして ByteString は使わないということです。",
        "user": "U56MBRKR9",
        "type": "message"
    },
    {
        "ts": "1573788608.102100",
        "text": "内部ではShortByteStringで持っておいて、APIの境界部分でByteStringにcopyしなおす感じですか？",
        "user": "U4M9NJ7QE",
        "type": "message"
    },
    {
        "ts": "1573788628.102300",
        "text": "そうです！",
        "user": "U56MBRKR9",
        "type": "message"
    }
]