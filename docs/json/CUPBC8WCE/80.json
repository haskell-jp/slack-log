[
    {
        "ts": "1760848332.180029",
        "text": "山本悠滋です。\n今日は <https://shinjukugyoen.connpass.com/event/371150/> に参加しているので、合間にいつもどおりmakeMistakesToLearnHaskellの続きを進められていたらします。",
        "type": "message",
        "user": "U4LGTMTMK"
    },
    {
        "ts": "1760864420.240629",
        "text": "",
        "type": "message",
        "user": null
    },
    {
        "ts": "1760865294.201419",
        "text": "先週行った、rename 関数 case 式対応の確認をしていました。\n確認したいテストケースを rename 関数に渡す方法の試行錯誤や、渡して処理した結果の正否確認に手間取ってしまいました。\n確認した結果、実装内容が間違っていたことがわかり、修正を行い何とか正しい結果が得られるようになりました。\nEx.6.4 の問題文を見ると、freeVars_case, abstract_case, collectSCs_case の定義を与えてテストするようにとありましたが、\ncollectSCs_e 関数は case 式に最初から対応済みのようで、case 式を含むコア言語プログラムのラムダリフティングも一応できましたので、\nこの問題はひとまず完了とさせていただこうと思います。",
        "type": "message",
        "user": "U04BD6ZFKQ8"
    },
    {
        "ts": "1760865302.002589",
        "text": "Competitive Programming in Haskell: Tree path decomposition, part I: 読了　先々週の課題の２つ目 \"Factor-Full Tree\" の解説のその１　続きが来週にあるとのことで　難度が今まで最高の Difficulty: Hard 7.4 なので　さすがに最終解決までに２回を掛けるらしい　自分の解は「異なる素数を各枝に配する」ものであって WA (testcase 7/36) 判定でした　まさしく解説のとおり木の枝数が長い path がある場合に label が integer overflow になってしまうからで　いろいろ模索しても解けなかった　想定解は来週までお預け　加えて類似問題２問を与えられてしまう　トホホ．．．　出直します",
        "type": "message",
        "user": "U584T7GAH"
    },
    {
        "ts": "1760869742.728419",
        "text": "電車の中などでmakeMistakesToLearnHaskellを進めてました。\n<https://github.com/haskell-jp/makeMistakesToLearnHaskell/commit/50aafbc8965053754841e1e8e657ef4f44c860cc>",
        "type": "message",
        "user": "U4LGTMTMK"
    },
    {
        "ts": "1760871592.356479",
        "text": "書籍: 関数型プログラミング実践入門を読みつつ、手を動かせました。\n特にフィボナッチ数列で遊んでHaskellすげぇぇ!となりました。\n一応Qiitaにもまとめておいたので、よりエレガントな実装とかあれば教えてください!\n\n<https://qiita.com/sigma_devsecops/items/24e05b6248b717aa4067>",
        "type": "message",
        "user": "U09ME60J23W"
    },
    {
        "ts": "1761451222.021999",
        "text": "",
        "type": "message",
        "user": null
    },
    {
        "ts": "1761451650.233949",
        "text": "<https://byorgey.github.io/blog/posts/2024/08/08/TreeDecomposition.html|Competitive Programming in Haskell: Tree path decomposition, part II>:  Brent Yorgey 先生の blog をもとに Kattis の問題を解きます",
        "type": "message",
        "user": "U584T7GAH"
    },
    {
        "ts": "1761452605.852289",
        "text": "S.K.です。ちょっと遅くなってしまいましたが、今週もお世話になります。よろしくお願いいたします。\n今週も Implementing Functional Languages: a tutorial の Chapter 6 Lambda Lifting の続きを進めて行こうと思います。",
        "type": "message",
        "user": "U04BD6ZFKQ8"
    },
    {
        "ts": "1761464164.391099",
        "text": "山本悠滋です。昼寝などしていて遅くなってしまいましたが、いつもどおりmakeMistakesToLearnHaskellやHaskell-jp Blogの続きをします。",
        "type": "message",
        "user": "U4LGTMTMK"
    },
    {
        "ts": "1761469205.099199",
        "text": "",
        "type": "message",
        "user": null
    },
    {
        "ts": "1761469348.013969",
        "text": "makeMistakesToLearnHaskellの進捗: <https://github.com/haskell-jp/makeMistakesToLearnHaskell/commit/a9ccbc1eddb3622c0157d8f3a37f884e0b53920f>\n課題15はやっぱ長い...",
        "type": "message",
        "user": "U4LGTMTMK"
    },
    {
        "ts": "1761469376.982839",
        "text": "Haskell-jp Blogの続きも延長戦で少しはします。",
        "type": "message",
        "user": "U4LGTMTMK"
    },
    {
        "ts": "1761470439.686799",
        "text": "Ex.6.5 に対応中です。\nテキストに載っていた例を含む次のテストプログラム\n\nf = \\\\x. x+1;\nmain = f 4\n\nの動作確認結果を元に方針を決めて実装中です。\n時間がかかってしまってますが、自分に可能なペースで進めて行こうと思います。",
        "type": "message",
        "user": "U04BD6ZFKQ8"
    },
    {
        "ts": "1761472741.227309",
        "text": "Competitive Programming in Haskell: tree path decomposition, part II: 読了　先々々週の課題の２つ目 \"Factor-Full Tree\" の最終解説　木を道に分解して (pathDecomposition) その高さ順に　素数の冪を割り当てる　そうすると　それらの積がそれぞれ個別でありながら　最大でも integer overflow を起こさないようにできるとね　ナルドねぇ　これに類似して先週の課題 \"Floating Formations\" だがその困難さに匙を投げていたが　かすかに光明が見えてきた　まず biconnected components を抽出して　残りの森（木のリスト）を道に分解して　それらを高さの順に　助け舟を出せばよいのでは？　それを目指して実装中",
        "type": "message",
        "user": "U584T7GAH"
    },
    {
        "ts": "1761478880.443319",
        "text": "Haskell-jp Blogの進捗:\n- <https://github.com/haskell-jp/blog/commit/3e58bf7d4cd1bb13608110ec8739f3a163e5a663>\n- <https://github.com/haskell-jp/blog/commit/2c2802d6804959b10064ca34567c56ba595bf98a>",
        "type": "message",
        "user": "U4LGTMTMK"
    },
    {
        "ts": "1762056025.870929",
        "text": "",
        "type": "message",
        "user": null
    },
    {
        "ts": "1762056229.274829",
        "text": "<https://byorgey.github.io/blog/posts/2024/11/02/UnionFind.html|Competitive Programming in Haskell: Union-Find>:  Brent Yorgey 先生の blog をもとに Kattis の問題を解きます",
        "type": "message",
        "user": "U584T7GAH"
    },
    {
        "ts": "1762057304.479609",
        "text": "• 昨日のAtCoderの復習\n• <https://judge.u-aizu.ac.jp/onlinejudge/finder.jsp?course=ITP1> をちまちま解く\n• 内包表記弱いので復習、モナドについての理解を深めるため、関数プログラミング実践入門の続きを読む\n",
        "type": "message",
        "user": "U09ME60J23W"
    },
    {
        "ts": "1762058355.287309",
        "text": "S.K.です。ちょっと遅くなってしまいましたが、今週もお世話になります。よろしくお願いいたします。\n今週も Implementing Functional Languages: a tutorial の Chapter 6 Lambda Lifting の続きを進めて行こうと思います。",
        "type": "message",
        "user": "U04BD6ZFKQ8"
    },
    {
        "ts": "1762059130.869309",
        "text": "山本悠滋です。いつもどおりmakeMistakesToLearnHaskellやHaskell-jp Blogの続きをします。",
        "type": "message",
        "user": "U4LGTMTMK"
    },
    {
        "ts": "1762074012.836689",
        "text": "",
        "type": "message",
        "user": null
    },
    {
        "ts": "1762074690.231589",
        "text": "makeMistakesToLearnHaskellの進捗: <https://github.com/haskell-jp/makeMistakesToLearnHaskell/commit/3f66f62dcab40cb6128939a7642e7f2d423477fe>\nHaskell-jp Blogの方はもう少しキリよくなるまで頑張ります。",
        "type": "message",
        "user": "U4LGTMTMK"
    },
    {
        "ts": "1762074718.584409",
        "text": "先週着手した Ex.6.5 (冗長なスーパーコンビネータの排除)を、ひとまず完了しました。\n次いで、Ex.6.6 (冗長なローカル定義の排除)の対応中です。\nテキストに載っていた例を含む次のテストプログラム\nf x = let g = (\\\\y. y+1) in g (g x);\nmain = f 4\nの動作確認結果を元に方針を決めて実装中です。\nこちらも Ex.6.5 と同様に時間がかかってしまってますが、自分に可能なペースで進めて行こうと思います。",
        "type": "message",
        "user": "U04BD6ZFKQ8"
    },
    {
        "ts": "1762074852.280249",
        "text": "Competitive Programming in Haskell: Union-Find: 読了　ナルホド <http://Data.Array.ST|Data.Array.ST> を用いて高速　しかも中間 State を一般的な Semigroup 属性の Data で維持するスグレもの　今まで手持ちのライブラリは Data.Vector ベースの物しか無かったので助かる　今回出された例題 \"Duck Journey\" と \"Inventing Test Data\" に挑戦中\nたった今　米国夏時間が終わった　来週から日本に行きますので　２週間休みます",
        "type": "message",
        "user": "U584T7GAH"
    },
    {
        "ts": "1762075823.245129",
        "text": "Haskell-jp Blogの進捗。Okapiの仕様を日本語にするのがめんどかった。\n<https://github.com/haskell-jp/blog/commit/58a4a7a887a5792f85e2a1a3a19e64c8649e4e09>",
        "type": "message",
        "user": "U4LGTMTMK"
    },
    {
        "ts": "1762085404.852899",
        "text": "遅くなりましたが、報告\n• 昨日のAtCoderの復習完了\n• AIZU3問くらい解いた。\n• 関数プログラミング実践入門のモナド部分を読み進めた。\n• Kattiesのアカウント作成Brent Yogey先生のブログを漁った。難しさeasyかつ解説のあるやつから解いていく。対応表が作れると理想。",
        "type": "message",
        "user": "U09ME60J23W"
    },
    {
        "ts": "1762660822.188259",
        "text": "",
        "type": "message",
        "user": null
    },
    {
        "ts": "1762662047.129639",
        "text": "遅くなりました。\nsigmaと申します。\n<https://x.com/sigma5736394841|https://x.com/sigma5736394841>\n• 昨日のAtCoderの復習\n• 前回教えていただいた、`interact`を使った入出力管理の練習 <https://byorgey.github.io/blog/posts/2025/06/10/comprog-hs-intro.html|https://byorgey.github.io/blog/posts/2025/06/10/comprog-hs-intro.html>\n• Aizuの問題を解く。ITP1全部終わったらkatties に移る予定",
        "type": "message",
        "user": "U09ME60J23W"
    },
    {
        "ts": "1762662391.335109",
        "text": "S.K.です。ちょっと遅くなってしまいましたが、今週もお世話になります。よろしくお願いいたします。\n今週も Implementing Functional Languages: a tutorial の Chapter 6 Lambda Lifting の続きを進めて行こうと思います。",
        "type": "message",
        "user": "U04BD6ZFKQ8"
    },
    {
        "ts": "1762673956.824829",
        "text": "山本悠滋です。例の如く昼寝で遅くなってしまいましたが、makeMistakesToLearnHaskellやHaskell-jp Blogの続きをします。",
        "type": "message",
        "user": "U4LGTMTMK"
    },
    {
        "ts": "1762678804.809429",
        "text": "",
        "type": "message",
        "user": null
    },
    {
        "ts": "1762679834.855379",
        "text": "Haskell-jp BlogについてはPull requestを送ってからビルドが通るよう格闘中です。\n<https://github.com/haskell-jp/blog/pull/223>\nmakeMistakesToLearnHaskellはもう少し進めてから共有します。",
        "type": "message",
        "user": "U4LGTMTMK"
    },
    {
        "ts": "1762680688.260269",
        "text": "先週着手した Ex.6.6 (冗長なローカル定義の排除)を、何とか完了しました。\nこれで「6.4 Mark 2: Improving the simple lambda lifter」はひとまず完了とさせていただき、引き続き「6.5 Mark 3: Johnsson-style lambda lifting」を進めて行こうと思います。",
        "type": "message",
        "user": "U04BD6ZFKQ8"
    },
    {
        "ts": "1762681573.576609",
        "text": "MakeMistakesToLearnHaskellの更新: <https://github.com/haskell-jp/makeMistakesToLearnHaskell/commit/3db8e1e424599ee35a7deba6d87bcef66a5dc850>",
        "type": "message",
        "user": "U4LGTMTMK"
    },
    {
        "ts": "1763265605.142989",
        "text": "",
        "type": "message",
        "user": null
    },
    {
        "ts": "1763269406.755129",
        "text": "S.K.です。遅くなってしまいましたが、今週もお世話になります。よろしくお願いいたします。\n今週も Implementing Functional Languages: a tutorial の Chapter 6 Lambda Lifting の続きを進めて行こうと思います。",
        "type": "message",
        "user": "U04BD6ZFKQ8"
    },
    {
        "ts": "1763269560.788839",
        "text": "JSConf JPに参加しているので合間を縫ってmakeMistakesToLearnHaskellの続きをちょっとだけやります。",
        "type": "message",
        "user": "U4LGTMTMK"
    },
    {
        "ts": "1763280882.525629",
        "text": "開始と終了まとめてですみません。\n本日の進捗は以下です。\n• 昨日のAtCoderの復習 <https://github.com/RyosukeDTomita/atcoder/tree/main/src/2025-11-15>\n• アドベントカレンダーを書きました <https://qiita.com/sigma_devsecops/items/3f388b7553339f1de38c> 残り22記事がんばります。",
        "type": "message",
        "user": "U09ME60J23W"
    },
    {
        "ts": "1763283610.717579",
        "text": "",
        "type": "message",
        "user": null
    },
    {
        "ts": "1763283940.114269",
        "text": "makeMistakesToLearnHaskellの更新 <https://github.com/haskell-jp/makeMistakesToLearnHaskell/commit/9e495a51936234a46a1c799267910de0482d98d6>",
        "type": "message",
        "user": "U4LGTMTMK"
    },
    {
        "ts": "1763285849.939519",
        "text": "「6.5 Mark 3: Johnsson-style lambda lifting」の内容を一通り読んで、Ex.6.7 までのコードを写経し、以下のテストプログラムで処理結果を比較してみました。\n\nf x = letrec g = \\y. cons (x*y) (g y) in g 3\nmain = f 6\n\nMark2 の結果:\n\nf x_0 = letrec\n          g_1 = sc_2 g_1 x_0\n        in g_1 3 ;\nsc_2 g_3 x_4 y_5 = cons (x_4 * y_5) (g_3 y_5) ;\nmain  = f 6\n\nMark3 の結果:\n\nf x_0 = g_1 x_0 3 ;\ng_1 x_0 y_2 = cons (x_0 * y_2) (g_1 x_0 y_2) ;\nmain  = f 6\n\nMark3 の方が、テキスト通りに letrec 式がなくなって、g_1 が直接再帰的になっているようです。\nこの動作結果を参考に、もう一度説明を読み返そうと思います。",
        "type": "message",
        "user": "U04BD6ZFKQ8"
    }
]