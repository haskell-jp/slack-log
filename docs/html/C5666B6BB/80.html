<!DOCTYPE html><html><head><meta charset="utf-8"><title>haskell-jp / questions #80</title><link rel="stylesheet" href="../../main.css" type="text/css" media="screen"></head><body><div class="ui container"><h1>haskell-jp / questions #80</h1><div class="pager ui pagination menu"><a href="../../html/C5666B6BB/79.html" class="pager__previous item">Previous</a><a href="../../" class="pager__top item">Top</a></div><div class="message_list ui feed"><div class="message event" id="message-1582715671.026900"><div class="content"><div class="summary"><div class="message__header user">as_capabl</div><div class="message__timestamp date"><a class="date" href="#message-1582715671.026900">2020-02-26&nbsp;20:14:31 +0900</a></div></div><div class="message__body description">実装を見ると、入力値を全て記憶していますね。これはfumievalさんに上で説明頂いた対角化のようです <a href='https://www.stackage.org/haddock/lts-15.1/machines-0.7/src/Data.Machine.Mealy.html#driveMealy'>https://www.stackage.org/haddock/lts-15.1/machines-0.7/src/Data.Machine.Mealy.html#driveMealy</a></div></div></div><div class="message event" id="message-1582715810.027100"><div class="content"><div class="summary"><div class="message__header user">as_capabl</div><div class="message__timestamp date"><a class="date" href="#message-1582715810.027100">2020-02-26&nbsp;20:16:50 +0900</a></div></div><div class="message__body description">ArrowApplyインスタンスが正しく定義できる場合、`k a b` と <code>a -&gt; k () b</code> が同型になるので、ArrowMonadで一般のMealyを表現できます</div></div></div><div class="message event" id="message-1582721720.028600"><div class="content"><div class="summary"><div class="message__header user">igrep</div><div class="message__timestamp date"><a class="date" href="#message-1582721720.028600">2020-02-26&nbsp;21:55:20 +0900</a></div></div><div class="message__body description">今日同僚と話して気になったんですが、構文とか、表面的な要素を除いて、型レベルプログラミングにできてTemplate Haskellにできないこと、って何がありますかね。あるのは間違いないんですが、なんかうまく言語化できないので、お知恵を拝借したいです。</div></div></div><div class="message event" id="message-1582722789.028700"><div class="content"><div class="summary"><div class="message__header user">fumieval</div><div class="message__timestamp date"><a class="date" href="#message-1582722789.028700">2020-02-26&nbsp;22:13:09 +0900</a></div></div><div class="message__body description">一言で表すなら「型に応じて挙動を変えること」ではないでしょうか。Template Haskellは型検査の前にあるので、構文として見えている型が実際は何であるか、既知のデータから推測しかできない一方、型レベルプログラミングなら型に依存した振る舞いを拡張性のある形で表現できます</div></div></div><div class="message event" id="message-1582762118.029100"><div class="content"><div class="summary"><div class="message__header user">as_capabl</div><div class="message__timestamp date"><a class="date" href="#message-1582762118.029100">2020-02-27&nbsp;09:08:38 +0900</a></div></div><div class="message__body description">同型作れるのかこれ……（だんだん不安になる）</div></div></div><div class="message event" id="message-1582877987.029400"><div class="content"><div class="summary"><div class="message__header user">hiroto.shioi</div><div class="message__timestamp date"><a class="date" href="#message-1582877987.029400">2020-02-28&nbsp;17:19:47 +0900</a></div></div><div class="message__body description">ものすごいニッチな質問なのですが、REPL上でTextをプリントする際、<http://Data.Text.IO|Data.Text.IO>.putStrLnよりもRIOが提供しているlogInfoのほうが出力される速度が圧倒的に速いのはなぜだかわかる人いますか。<br/><a href='https://hackage.haskell.org/package/text-1.2.4.0/docs/Data-Text-IO.html#v:putStrLn'>https://hackage.haskell.org/package/text-1.2.4.0/docs/Data-Text-IO.html#v:putStrLn</a><br/><a href='https://hackage.haskell.org/package/rio-0.1.14.0/docs/RIO.html#v:logInfo'>https://hackage.haskell.org/package/rio-0.1.14.0/docs/RIO.html#v:logInfo</a></div></div></div><div class="message event" id="message-1582879409.035000"><div class="content"><div class="summary"><div class="message__header user">hiroto.shioi</div><div class="message__timestamp date"><a class="date" href="#message-1582879409.035000">2020-02-28&nbsp;17:43:29 +0900</a></div></div><div class="message__body description">簡単な例をRepoにしてみました。<br/><a href='https://github.com/HirotoShioi/speed-test'>https://github.com/HirotoShioi/speed-test</a></div></div></div><div class="message event" id="message-1582879416.035200"><div class="content"><div class="summary"><div class="message__header user">t.takeuchi.a</div><div class="message__timestamp date"><a class="date" href="#message-1582879416.035200">2020-02-28&nbsp;17:43:36 +0900</a></div></div><div class="message__body description">Windows環境でMySQLの接続確認したかったけど、mysql_config not foundの直し方(それらしいSetup.hsかSetup.lhsがみあたらない)がわからないのでPostgresqlで試したら動いたのでよしとするか</div></div></div><div class="message event" id="message-1582881982.039500"><div class="content"><div class="summary"><div class="message__header user">hexirp</div><div class="message__timestamp date"><a class="date" href="#message-1582881982.039500">2020-02-28&nbsp;18:26:22 +0900</a></div></div><div class="message__body description"><a href='https://qiita.com/Lugendre/items/6b4a8c8a9c85fcdcb292'>https://qiita.com/Lugendre/items/6b4a8c8a9c85fcdcb292</a> によると <code>arr (b, c) d === b -&gt; arr c d</code> という同型が ArrowApply ならあるらしいので問題ないと思います。というか、下みたいに作れませんかね？<br/><pre>(&gt;&gt;=) :: ArrowApply arr =&gt; arr a b -&gt; (b -&gt; arr a c) -&gt; arr a c
x &gt;&gt;= f = proc a -&gt;
  b &lt;- x -&lt; a
  f b -&lt;&lt; a</pre></div></div></div><div class="message event" id="message-1582882311.041200"><div class="content"><div class="summary"><div class="message__header user">hexirp</div><div class="message__timestamp date"><a class="date" href="#message-1582882311.041200">2020-02-28&nbsp;18:31:51 +0900</a></div></div><div class="message__body description">そういえば Prelude の putStrLn を使っていたら、出力なしの時よりもかなり遅くなったということがありますね。早い出力方法ってあるんでしょうか</div></div></div><div class="message event" id="message-1582882426.041500"><div class="content"><div class="summary"><div class="message__header user">hexirp</div><div class="message__timestamp date"><a class="date" href="#message-1582882426.041500">2020-02-28&nbsp;18:33:46 +0900</a></div></div><div class="message__body description"><a href='https://github.com/commercialhaskell/rio/blob/b01145fd4df4ee80b39996a04450a764ae8baffa/rio/src/RIO/Prelude/Logger.hs#L349-L362'>https://github.com/commercialhaskell/rio/blob/b01145fd4df4ee80b39996a04450a764ae8baffa/rio/src/RIO/Prelude/Logger.hs#L349-L362</a><br/>この部分が、おそらく実際に使われている実装だと思います。その先まではよくわかりませんが。</div></div></div><div class="message event" id="message-1582882481.041800"><div class="content"><div class="summary"><div class="message__header user">igrep</div><div class="message__timestamp date"><a class="date" href="#message-1582882481.041800">2020-02-28&nbsp;18:34:41 +0900</a></div></div><div class="message__body description"><a href='https://haskell-jp.slack.com/archives/C5666B6BB/p1582882311041200'>https://haskell-jp.slack.com/archives/C5666B6BB/p1582882311041200</a> の質問も含めて、 <code>Utf8Builder</code> というやつが速いから <code><http://Data.Text.IO|Data.Text.IO>.putStrLn</code> よりも速いんだろうし、 <code>putStrLn</code> の代わりに <code>Utf8Builder</code> とやらを使えば速くなるんじゃないっすかね。<br/>ただこの手のビルダー類、ほかにもいくつか作られていたと記憶しているので、探すのもよいかと。</div></div></div><div class="message event" id="message-1582884640.042400"><div class="content"><div class="summary"><div class="message__header user">hiroto.shioi</div><div class="message__timestamp date"><a class="date" href="#message-1582884640.042400">2020-02-28&nbsp;19:10:40 +0900</a></div></div><div class="message__body description">ビルダーについていろいろ調べてみます。ありがとう！</div></div></div><div class="message event" id="message-1582942007.042900"><div class="content"><div class="summary"><div class="message__header user">as_capabl</div><div class="message__timestamp date"><a class="date" href="#message-1582942007.042900">2020-02-29&nbsp;11:06:47 +0900</a></div></div><div class="message__body description">はい、その同型で <code>c ~ ()</code> としたものを考えればいいかと思っていたのですが、 <code>Mealy a b</code> から <code>a -&gt; Mealy () b</code> への関数で、元の情報を落とさないようなものが作れないのです</div></div></div><div class="message event" id="message-1582942087.043200"><div class="content"><div class="summary"><div class="message__header user">as_capabl</div><div class="message__timestamp date"><a class="date" href="#message-1582942087.043200">2020-02-29&nbsp;11:08:07 +0900</a></div></div><div class="message__body description">同型って「型と型のSetとしての同型」の事ではないのだろうか</div></div></div><div class="message event" id="message-1582942236.043400"><div class="content"><div class="summary"><div class="message__header user">as_capabl</div><div class="message__timestamp date"><a class="date" href="#message-1582942236.043400">2020-02-29&nbsp;11:10:36 +0900</a></div></div><div class="message__body description">あるいは、ArrowApplyが扱っているのって要するに冪対象だと思っていて、その同型というのは <a href='https://ja.wikipedia.org/wiki/%E5%86%AA%E5%AF%BE%E8%B1%A1#%E5%AE%9A%E7%BE%A9'>https://ja.wikipedia.org/wiki/%E5%86%AA%E5%AF%BE%E8%B1%A1#%E5%AE%9A%E7%BE%A9</a> にあるhomの式だと思うのですが、それをHaskellにエンコードすると <code>arr (b, c) d === arr b (arr c d)</code> が正しくて、右辺の形がちょっと違うのではと</div></div></div><div class="message event" id="message-1582942592.043800"><div class="content"><div class="summary"><div class="message__header user">as_capabl</div><div class="message__timestamp date"><a class="date" href="#message-1582942592.043800">2020-02-29&nbsp;11:16:32 +0900</a></div></div><div class="message__body description">実際、 <code>Mealy (a, b) c</code> を <code>Mealy a (Mealy b c)</code> で表すのは、まさにMealyのArrowApply(app)の定義がはまりそうな感じがします</div></div></div><div class="message event" id="message-1582943597.044100"><div class="content"><div class="summary"><div class="message__header user">as_capabl</div><div class="message__timestamp date"><a class="date" href="#message-1582943597.044100">2020-02-29&nbsp;11:33:17 +0900</a></div></div><div class="message__body description">圏論に強い人の意見を聞きたいです</div></div></div><div class="message event" id="message-1582943771.044500"><div class="content"><div class="summary"><div class="message__header user">hexirp</div><div class="message__timestamp date"><a class="date" href="#message-1582943771.044500">2020-02-29&nbsp;11:36:11 +0900</a></div></div><div class="message__body description"><code>a -&gt; b ==&gt; Mealy a b</code> はできるけど <code>Mealy a b ==&gt; a -&gt; b</code> はできないわけで、 as_capabl さんの考察があっているように思います</div></div></div><div class="message event" id="message-1582944179.044700"><div class="content"><div class="summary"><div class="message__header user">hexirp</div><div class="message__timestamp date"><a class="date" href="#message-1582944179.044700">2020-02-29&nbsp;11:42:59 +0900</a></div></div><div class="message__body description">Idioms are oblivious, arrows are meticulous, monads are promiscuous という論文にこのあたりのことが書かれているらしいです</div></div></div><div class="message event" id="message-1583025662.047200"><div class="content"><div class="summary"><div class="message__header user">hexirp</div><div class="message__timestamp date"><a class="date" href="#message-1583025662.047200">2020-03-01&nbsp;10:21:02 +0900</a></div></div><div class="message__body description"><a href='https://www.stackage.org/haddock/lts-15.1/bytestring-0.10.10.0/Data-ByteString-Builder.html#v:hPutBuilder'>https://www.stackage.org/haddock/lts-15.1/bytestring-0.10.10.0/Data-ByteString-Builder.html#v:hPutBuilder</a><br/><code>hPutBuilder</code> というのが件の関数の中心で使われているんですが、 <code>Handle</code> のバッファを使って <code>Builder</code> を実行するから早いとか書いてありますね。</div></div></div><div class="message event" id="message-1583065035.050000"><div class="content"><div class="summary"><div class="message__header user">junji.hashimoto</div><div class="message__timestamp date"><a class="date" href="#message-1583065035.050000">2020-03-01&nbsp;21:17:15 +0900</a></div></div><div class="message__body description">すみませんよくわかってないのですが、ステートモナドだとなにか過不足があるのでしょうか？</div></div></div><div class="message event" id="message-1583065098.051400"><div class="content"><div class="summary"><div class="message__header user">junji.hashimoto</div><div class="message__timestamp date"><a class="date" href="#message-1583065098.051400">2020-03-01&nbsp;21:18:18 +0900</a></div></div><div class="message__body description">ミーリーマシンをつかうのはなにか回路的な記述をするためでしょうか？</div></div></div><div class="message event" id="message-1583120992.052100"><div class="content"><div class="summary"><div class="message__header user">as_capabl</div><div class="message__timestamp date"><a class="date" href="#message-1583120992.052100">2020-03-02&nbsp;12:49:52 +0900</a></div></div><div class="message__body description">（電子回路をシミュレーションできるかどうかは別として）回路的記述をするためで間違いないです。ステートモナドが一個の値を</div></div></div><div class="message event" id="message-1583121050.052300"><div class="content"><div class="summary"><div class="message__header user">as_capabl</div><div class="message__timestamp date"><a class="date" href="#message-1583121050.052300">2020-03-02&nbsp;12:50:50 +0900</a></div></div><div class="message__body description">繰り返し読み書きするようになっているのに対し、ミーリマシンは入力の列を受け取って出力の列を返すように動きます</div></div></div><div class="message event" id="message-1583131632.055100"><div class="content"><div class="summary"><div class="message__header user">hexirp</div><div class="message__timestamp date"><a class="date" href="#message-1583131632.055100">2020-03-02&nbsp;15:47:12 +0900</a></div></div><div class="message__body description">単純に State モナドとの違いを挙げるならば、ミーリマシンは、状態を分離および隠蔽して、途中で計算を止めたり再開したりできるという性質を持っています。</div></div></div><div class="message event" id="message-1583131697.056500"><div class="content"><div class="summary"><div class="message__header user">hexirp</div><div class="message__timestamp date"><a class="date" href="#message-1583131697.056500">2020-03-02&nbsp;15:48:17 +0900</a></div></div><div class="message__body description">私は、このうち Coroutine モナドに似た途中で計算を止めたり再開できるという性質を主に目的にしていました</div></div></div><div class="message event" id="message-1583155942.058800"><div class="content"><div class="summary"><div class="message__header user">9647142</div><div class="message__timestamp date"><a class="date" href="#message-1583155942.058800">2020-03-02&nbsp;22:32:22 +0900</a></div></div><div class="message__body description">キーが整数で絶対に直前にinsertしたキー+1しかinsertしないとしてもListとかVectorよりMapとかのほうが良いんでしょうか?</div></div></div><div class="message event" id="message-1583159785.059000"><div class="content"><div class="summary"><div class="message__header user">UUR9NQ680</div><div class="message__timestamp date"><a class="date" href="#message-1583159785.059000">2020-03-02&nbsp;23:36:25 +0900</a></div></div><div class="message__body description">@UUR9NQ680 has joined the channel</div></div></div><div class="message event" id="message-1583192315.059300"><div class="content"><div class="summary"><div class="message__header user">igrep</div><div class="message__timestamp date"><a class="date" href="#message-1583192315.059300">2020-03-03&nbsp;08:38:35 +0900</a></div></div><div class="message__body description">理屈はさておきcriterionなどで計測してみるのが一番確実かと</div></div></div><div class="message event" id="message-1583192756.059800"><div class="content"><div class="summary"><div class="message__header user">igrep</div><div class="message__timestamp date"><a class="date" href="#message-1583192756.059800">2020-03-03&nbsp;08:45:56 +0900</a></div></div><div class="message__body description">自分が想像できる範囲では、やり方とかinsertした後の使い方（ランダムアクセスかシーケンシャルアクセスか、とか）に寄るのでは、と思います。<br/>リストだって1個ずつ追加するだけだったら、最後の要素のキーを0と見なして使えば、少なくとも追加する処理はO(1)ですし。</div></div></div><div class="message event" id="message-1583193085.060000"><div class="content"><div class="summary"><div class="message__header user">igrep</div><div class="message__timestamp date"><a class="date" href="#message-1583193085.060000">2020-03-03&nbsp;08:51:25 +0900</a></div></div><div class="message__body description">どういうユースケースか存じませんが、List, Vector, Map以外にも有効そうなデータ構造はあると思うので、参考までに <a href='https://wiki.haskell.jp/%E3%83%87%E3%83%BC%E3%82%BF%E6%A7%8B%E9%80%A0%E5%88%97%E4%BC%9D'>https://wiki.haskell.jp/%E3%83%87%E3%83%BC%E3%82%BF%E6%A7%8B%E9%80%A0%E5%88%97%E4%BC%9D</a> もどうぞ</div></div></div><div class="message event" id="message-1583202009.062200"><div class="content"><div class="summary"><div class="message__header user">junji.hashimoto</div><div class="message__timestamp date"><a class="date" href="#message-1583202009.062200">2020-03-03&nbsp;11:20:09 +0900</a></div></div><div class="message__body description">シミュレーターには向いているかもしれないですが<br/>回路の合成を考えると使いにくいですよね<br/>なにかいいフレームワークはありますか？<br/></div></div></div><div class="message event" id="message-1583202029.062900"><div class="content"><div class="summary"><div class="message__header user">junji.hashimoto</div><div class="message__timestamp date"><a class="date" href="#message-1583202029.062900">2020-03-03&nbsp;11:20:29 +0900</a></div></div><div class="message__body description">clashがお手ごろだと思ってます</div></div></div><div class="message event" id="message-1583203147.063100"><div class="content"><div class="summary"><div class="message__header user">fumieval</div><div class="message__timestamp date"><a class="date" href="#message-1583203147.063100">2020-03-03&nbsp;11:39:07 +0900</a></div></div><div class="message__body description">回路的記述というのはあくまでプログラムを表現する手法を指していて、ClashのようにVerilogなどにコンパイルするという意味ではないと思います</div></div></div><div class="message event" id="message-1583204344.063300"><div class="content"><div class="summary"><div class="message__header user">9647142</div><div class="message__timestamp date"><a class="date" href="#message-1583204344.063300">2020-03-03&nbsp;11:59:04 +0900</a></div></div><div class="message__body description">ralパッケージの提供するrandom access list使ってみようと思います</div></div></div></div><div class="pager ui pagination menu"><a href="../../html/C5666B6BB/79.html" class="pager__previous item">Previous</a><a href="../../" class="pager__top item">Top</a></div></div></body></html>