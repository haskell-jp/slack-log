<!DOCTYPE html><html><head><meta charset="utf-8"><title>haskell-jp / questions #4</title><link rel="stylesheet" href="../../messages.css" type="text/css" media="screen"></head><body><h1>haskell-jp / questions #4</h1><div class="pager"><a href="../../html/C5666B6BB/3.html" class="pager__previous">Previous</a><a href="../../" class="pager__top">Top</a><a href="../../html/C5666B6BB/5.html" class="pager__next">Next</a></div><div class="message_list"><div class="message" id="message-1510470054.000057"><div class="message__timestamp">2017-11-12<br/>16:00:54 +0900</div><div class="message__header">mizunashi-mana</div><div class="message__body">型に言及するには，制約が <code>Monoid</code> しかないので，情報が足りないのではないでしょうか？</div></div><div class="message" id="message-1510470161.000004"><div class="message__timestamp">2017-11-12<br/>16:02:41 +0900</div><div class="message__header">mizunashi-mana</div><div class="message__body">多相関数というのは割と結構強い制約で，例えばFunctor則は <code>fmap</code> が多相関数なのでどちらかの則があれば自動的にもう一方を満たします(<https://www.schoolofhaskell.com/user/edwardk/snippets/fmap>)</div></div><div class="message" id="message-1510470210.000039"><div class="message__timestamp">2017-11-12<br/>16:03:30 +0900</div><div class="message__header">mizunashi-mana</div><div class="message__body">なので， Foldableも多相関数を利用してる場合その時点で割と実装が限られて来ます (もっとも，ボトムを定義中に使われると色々と壊れるのですが)</div></div><div class="message" id="message-1510470466.000002"><div class="message__timestamp">2017-11-12<br/>16:07:46 +0900</div><div class="message__header">1to100pen</div><div class="message__body">そういう意味では、多相関数を使ってなくて Functor であってもなくてもよく（Functor でもなおかつという方が面白いですが）いかにも不自然な感じのする Foldable の例があるかという質問と思ってください。</div></div><div class="message" id="message-1510470608.000024"><div class="message__timestamp">2017-11-12<br/>16:10:08 +0900</div><div class="message__header">mizunashi-mana</div><div class="message__body">それはあり得ると思いますが，多相関数でない以上FoldableではないのでそれはfoldやfoldMapの型を特殊化したものと型が一致したただの別の関数ということになってしまうのではないでしょうか？</div></div><div class="message" id="message-1510470730.000054"><div class="message__timestamp">2017-11-12<br/>16:12:10 +0900</div><div class="message__header">mizunashi-mana</div><div class="message__body">なお， Foldableをもう少し弱めたものならば <a href='https://hackage.haskell.org/package/recursion-schemes-5.0.2/docs/Data-Functor-Foldable.html#t:Recursive'>https://hackage.haskell.org/package/recursion-schemes-5.0.2/docs/Data-Functor-Foldable.html#t:Recursive</a> などがあります</div></div><div class="message" id="message-1510471096.000003"><div class="message__timestamp">2017-11-12<br/>16:18:16 +0900</div><div class="message__header">1to100pen</div><div class="message__body">うむむむ、リストとリスト以外のモノイドで実装を分けて書けないので多相的な実装しか書けないですね。確かに。</div></div><div class="message" id="message-1510471145.000029"><div class="message__timestamp">2017-11-12<br/>16:19:05 +0900</div><div class="message__header">mizunashi-mana</div><div class="message__body">これがfoldのチュートリアルみたいです．これを読んでみると疑問が解決するかもしれません？（ちょっと僕も読んでみます）<br/><a href='http://www.cs.nott.ac.uk/~pszgmh/fold.pdf'>http://www.cs.nott.ac.uk/~pszgmh/fold.pdf</a></div></div><div class="message" id="message-1510471478.000017"><div class="message__timestamp">2017-11-12<br/>16:24:38 +0900</div><div class="message__header">1to100pen</div><div class="message__body">では、木の形だけで判断するとして好きに選んだいくつかのある木のときだけは mempty にしてそれ以外では concat した値にするとしたら整合性や不自然さはどうでしょう。</div></div><div class="message" id="message-1510471674.000018"><div class="message__timestamp">2017-11-12<br/>16:27:54 +0900</div><div class="message__header">mizunashi-mana</div><div class="message__body">多分それも代数的には意味のある構造なのだと思います．それを木という代数的構造で考えると不自然なのですが，別の代数と考えるとそのfoldを考えてるようなものなのだと思います</div></div><div class="message" id="message-1510471721.000041"><div class="message__timestamp">2017-11-12<br/>16:28:41 +0900</div><div class="message__header">mizunashi-mana</div><div class="message__body">なので，Foldable的にはおかしくないのだと思うのですが(ちょっとFoldableの背景には明るくないので，明確には言えないです)</div></div><div class="message" id="message-1510472257.000025"><div class="message__timestamp">2017-11-12<br/>16:37:37 +0900</div><div class="message__header">1to100pen</div><div class="message__body">そもそもこのことを考え始めたきっかけは「Haskell 教養としての関数型プログラミング」に 「Foldable は並べられるという性質」とあって「並べられる」っぽっくない Foldable の例はないだろうかと考え始めたのでした。</div></div><div class="message" id="message-1510472334.000066"><div class="message__timestamp">2017-11-12<br/>16:38:54 +0900</div><div class="message__header">mizunashi-mana</div><div class="message__body">なるほど．並べられるというより並べ方を定義するの方が分かりやすいかもしれません</div></div><div class="message" id="message-1510472424.000018"><div class="message__timestamp">2017-11-12<br/>16:40:24 +0900</div><div class="message__header">mizunashi-mana</div><div class="message__body">foldMapを定義すれば基本的にtoListが定義できるので</div></div><div class="message" id="message-1510472550.000014"><div class="message__timestamp">2017-11-12<br/>16:42:30 +0900</div><div class="message__header">1to100pen</div><div class="message__body">まあ「並べる」とはどういう意味かということに帰着されて <code>toList t = build (\ c n -&gt; foldr c n t)</code> を「並べる」ということだ言ってしまえばその通りかもしれませんが普通の直感とは多分違うような気が。</div></div><div class="message" id="message-1510472730.000004"><div class="message__timestamp">2017-11-12<br/>16:45:30 +0900</div><div class="message__header">mizunashi-mana</div><div class="message__body">まあ確かに普通の直感とは異なるかもしれません．ただ，普通の直感の並べ方をもっと形式的に表せないかというのがfoldMapのアイデアの元になってて,</div></div><div class="message" id="message-1510472843.000090"><div class="message__timestamp">2017-11-12<br/>16:47:23 +0900</div><div class="message__header">mizunashi-mana</div><div class="message__body">リストに対してのfoldMapが出来てそれでtoListがちゃんと表せて，木もフラットにする方法がやっぱり同じ方法で出来て，じゃあFoldableにまとめたら他の代数でも同じように並べ方が定義できるようになったという感じだと思います．</div></div><div class="message" id="message-1510473084.000007"><div class="message__timestamp">2017-11-12<br/>16:51:24 +0900</div><div class="message__header">mizunashi-mana</div><div class="message__body">なので直感的な感覚から始まって，色々な並べるをうまく表せるFoldableを一つの並べるの定義方法だと思えば，非直感的な並べ方に対しても同じようなことができてその並べ方に沿って並べるをアルゴリズムの一部として使うようなものが一般的に書けるという点では，Foldableも並べられるという性質を持っているといって問題ないのではないでしょうか？</div></div><div class="message" id="message-1510473916.000008"><div class="message__timestamp">2017-11-12<br/>17:05:16 +0900</div><div class="message__header">1to100pen</div><div class="message__body">うーん、そうですね。上に書いたときどき mempty になる例も列に並ぶのをさぼるグループがいると考えれば「並べる」と言える気がしてきました。自分のコピーを作って複数人分潜り込ませて並ぶというのもありかな。</div></div><div class="message" id="message-1510474985.000053"><div class="message__timestamp">2017-11-12<br/>17:23:05 +0900</div><div class="message__header">mizunashi-mana</div><div class="message__body"><pre>
newtype Square a = Square a
</pre><br/>とかだったら意味論的にはありだと思いますね</div></div><div class="message" id="message-1510481874.000020"><div class="message__timestamp">2017-11-12<br/>19:17:54 +0900</div><div class="message__header">1to100pen</div><div class="message__body">リストも（標準のリストFoldableとは違いますが）<br/><pre>
fold [] = mempty
fold [m1] = m1 &lt;&gt; m1
fold [m1, m2] = m2
fold [m1, m2, m3] = m1 &lt;&gt; m3 &lt;&gt; m2 &lt;&gt; m3
fold [m1, m2, m3, m4] = mempty
...
</pre><br/>のように要素と &lt;&gt;  と memtpy だけを組み合わせているかぎりどのように定義しても Foldable になりそうですね。</div></div><div class="message" id="message-1510504726.000031"><div class="message__timestamp">2017-11-13<br/>01:38:46 +0900</div><div class="message__header">1to100pen</div><div class="message__body">あれ、toList の話に自分で build を出しましたが build は cata, ana を想定してない一般には定義されてないですよね。toList は fold からどう定義できるんでしたっけ。Foldableパッケージには toList = elems と書いてあるだけでその elems はどう定義するのでしょう。上の例では<br/><pre>
elems [m1] = [m1,m1]
elems [m1,m2] = [m2]
...
</pre><br/>と定義するという堂々巡りしているだけ？</div></div><div class="message" id="message-1510512428.000022"><div class="message__timestamp">2017-11-13<br/>03:47:08 +0900</div><div class="message__header">mizunashi-mana</div><div class="message__body">どの <code>Foldable</code> を見てるかはよく分かりませんが，現状のbase( <a href='https://hackage.haskell.org/package/base-4.10.0.0/docs/src/Data.Foldable.html#line-230'>https://hackage.haskell.org/package/base-4.10.0.0/docs/src/Data.Foldable.html#line-230</a> )では， <code>toList = build (\ c n -&gt; foldr c n t)</code> がデフォルトになっています． <code>build</code> は <a href='https://hackage.haskell.org/package/base-4.10.0.0/docs/src/GHC.Base.html#line-871'>https://hackage.haskell.org/package/base-4.10.0.0/docs/src/GHC.Base.html#line-871</a> ですね．リストを作るためのビルダーになっていて， foldr/build変換なども適用されるようになります</div></div><div class="message" id="message-1510555268.000089"><div class="message__timestamp">2017-11-13<br/>15:41:08 +0900</div><div class="message__header">ncaq</div><div class="message__body">一回stack buildでcabalファイルを生成してから使えばpackage.yamlにも使えるのでは?手で編集できないほど依存ライブラリの数が多ければわかりませんが…</div></div><div class="message" id="message-1510561822.000162"><div class="message__timestamp">2017-11-13<br/>17:30:22 +0900</div><div class="message__header">1to100pen</div><div class="message__body">ううう、build はそうでした。上で書いた fold の例だと <code>toList [m1] = m1:m1:[] = [m1,m1]</code> ですね。<br/>elems と書いてあったのは <code>instance Foldable (Array i)</code> の中のところでした。<br/><code>'toList = '</code> で検索したのが失敗だった orz。</div></div><div class="message" id="message-1510715994.000101"><div class="message__timestamp">2017-11-15<br/>12:19:54 +0900</div><div class="message__header">1to100pen</div><div class="message__body">前に書いていた <code>fold . fmap f = f . fold</code> は f はモノイド準同型を前提してということですか。</div></div><div class="message" id="message-1510726603.000115"><div class="message__timestamp">2017-11-15<br/>15:16:43 +0900</div><div class="message__header">mizunashi-mana</div><div class="message__body">あ，そうですね． <code>f</code> がモノイド準同型であることが必要です</div></div><div class="message" id="message-1510731561.000247"><div class="message__timestamp">2017-11-15<br/>16:39:21 +0900</div><div class="message__header">brackss1</div><div class="message__body">初歩的な質問なのですが<br/><code>import qualified Data.Text as T</code>とすると<br/><code>T.Text</code>と型にもTが付くんですか?</div></div><div class="message" id="message-1510731628.000105"><div class="message__timestamp">2017-11-15<br/>16:40:28 +0900</div><div class="message__header">igrep</div><div class="message__body">はい。</div></div><div class="message" id="message-1510731645.000081"><div class="message__timestamp">2017-11-15<br/>16:40:45 +0900</div><div class="message__header">brackss1</div><div class="message__body">ありがとうございます。</div></div><div class="message" id="message-1510733750.000262"><div class="message__timestamp">2017-11-15<br/>17:15:50 +0900</div><div class="message__header">wado</div><div class="message__body">型を <code>T.Text</code> にしたくない場合はこんな感じで定義されてることが多いですね！<br/><br/><pre>
import Data.Text (Text)
import qualified Data.Text as T
</pre><br/><br/><code>Data.Map</code> を <code>import</code> する際にも良くみかけます:grinning:</div></div><div class="message" id="message-1510734420.000172"><div class="message__timestamp">2017-11-15<br/>17:27:00 +0900</div><div class="message__header">kakkun61</div><div class="message__body">wado さんの提示してるやり方よくしますね</div></div><div class="message" id="message-1510735436.000187"><div class="message__timestamp">2017-11-15<br/>17:43:56 +0900</div><div class="message__header">brackss1</div><div class="message__body">括弧付きimportのほうが優先順位が高いんですね</div></div><div class="message" id="message-1510735901.000080"><div class="message__timestamp">2017-11-15<br/>17:51:41 +0900</div><div class="message__header">wado</div><div class="message__body">モジュールの括弧は優先順位とは全く無関係です。括弧によってモジュールから <code>import</code> するもの (関数や型など) を明示的に列挙できます。<br/><br/><pre>
import Data.Text (Text)
</pre><br/><br/>上記は <code>Text</code> 型のみを <code>import</code> します。その際、 <code>qualified ... as</code> 形式ではないため <code>Text</code> という表記で利用できます。<br/><br/><pre>
import qualified Data.Text as T
</pre><br/><br/>上記は <code>Text</code> モジュールで <code>export</code> されているもの全てが <code>import</code> されます。(`T.Text`, <code>T.null</code>, etc...)。こちらは <code>qualified ... as</code> 形式なので全て <code>T.</code> という修飾詞つきの表記で利用できます。( <code>Prelude</code> や他のモジュールで定義されている関数 (や型) の名前と被る場合に使います。)<br/>具体例:<br/> - [Text.null](<https://www.stackage.org/haddock/lts-9.13/text-1.2.2.2/Data-Text.html#v:null>)<br/> - [Prelude.null](<https://www.stackage.org/haddock/lts-9.13/base-4.9.1.0/Prelude.html#v:null>)。<br/><br/>なので上記ように <code>import</code> を2つ書いた場合は <code>Text</code> 型は <code>Text</code> と <code>T.Text</code> の両方の形式で利用できるという理解が正しいです。<br/><br/>ただ両方利用できても、 <code>T.Text</code> って書くの面倒なので <code>Text</code> しか使わないという感じです。<br/><br/><code>T.Text</code> を <code>import</code> しないようにするためには <code>hiding</code> キーワードを使って明示的に <code>import</code> しないものを指定します。(`hiding` は暗黙的に <code>Prelude</code> から <code>import</code> されているものを隠したい場合によく利用します。 <code>import Prelude hiding (div)</code>)<br/><br/><pre>
import Data.Text (Text)
import qualified Data.Text as T hiding (Text)
</pre><br/><br/>長くなりましたが、だいたいこんな感じだと思います。</div></div><div class="message" id="message-1510744302.000321"><div class="message__timestamp">2017-11-15<br/>20:11:42 +0900</div><div class="message__header">brackss1</div><div class="message__body">なるほど。<br/>ありがとうございます:musical_note:</div></div><div class="message" id="message-1510790576.000058"><div class="message__timestamp">2017-11-16<br/>09:02:56 +0900</div><div class="message__header">takuo</div><div class="message__body">Stackを使った開発でのghc-modの利用について質問させてください．Stackage LTS-8.xにはghc-modがあったので問題なくインストールできましたが，LTS-9.xからは外されて(?)しまい，cabal-installで別途導入しようとしても途中でエラーになってしまいます．LTS-9.xでghc-modを利用できている方はどのようにやっていらっしゃるのでしょうか．</div></div><div class="message" id="message-1510791571.000276"><div class="message__timestamp">2017-11-16<br/>09:19:31 +0900</div><div class="message__header">kazu</div><div class="message__body">ghc-modは、もう僕の手を離れているので、よく分かりません。</div></div><div class="message" id="message-1510791592.000054"><div class="message__timestamp">2017-11-16<br/>09:19:52 +0900</div><div class="message__header">kazu</div><div class="message__body">GHC 8.0.2では使えますし、僕も stack なしで使っています。</div></div><div class="message" id="message-1510791612.000091"><div class="message__timestamp">2017-11-16<br/>09:20:12 +0900</div><div class="message__header">kazu</div><div class="message__body">なお、ghc-modは、まだ GHC 8.2.x には対応していません。</div></div><div class="message" id="message-1510792155.000150"><div class="message__timestamp">2017-11-16<br/>09:29:15 +0900</div><div class="message__header">wado</div><div class="message__body"><code>lts-9</code> 系でも <code>stack install ghc-mod</code> でインストールできたような気がします。</div></div><div class="message" id="message-1510792785.000086"><div class="message__timestamp">2017-11-16<br/>09:39:45 +0900</div><div class="message__header">takuo</div><div class="message__body">試しにやってみたらインストールできたようです（macOS 10.13.1, Stack LTS-9.13）．LTS-9.x になって以来パッケージリストに ghc-mod が含まれていないので stack install ではできないものと思って試していませんでした．ありがとうございます．</div></div><div class="message" id="message-1510792839.000180"><div class="message__timestamp">2017-11-16<br/>09:40:39 +0900</div><div class="message__header">naohaq</div><div class="message__body">便乗ですが、今だとEmacsでhaskellのコードを書く場合は <code>haskell-mode</code> を使っておくのがいいんでしょうか。(というかそれ以外に選択肢がない？)</div></div><div class="message" id="message-1510794752.000033"><div class="message__timestamp">2017-11-16<br/>10:12:32 +0900</div><div class="message__header">kazu</div><div class="message__body">はい。elpaに上がっているhaskell-modeが最新だと思います。</div></div><div class="message" id="message-1510798655.000193"><div class="message__timestamp">2017-11-16<br/>11:17:35 +0900</div><div class="message__header">myuon_myon</div><div class="message__body">単にsyntax highlightくらいできればいいならhaskell-modeでいいと思います<br/>もっとIDE的な機能が欲しければinteroっていうプラグインがありますね</div></div><div class="message" id="message-1510879403.000061"><div class="message__timestamp">2017-11-17<br/>09:43:23 +0900</div><div class="message__header">kazu</div><div class="message__body">ある typeclass の instance を reexport する方法って、Haskellにはないんでしたっけ？</div></div><div class="message" id="message-1510882435.000032"><div class="message__timestamp">2017-11-17<br/>10:33:55 +0900</div><div class="message__header">igrep</div><div class="message__body">普通に <a href='https://github.com/tfausak/autoexporter'>https://github.com/tfausak/autoexporter</a> などでやるように module ごと reexport すればできたように思います。<br/>ちょっと記憶が怪しい（しかもTHによる例）ので恐縮ですが、<br/><a href='https://github.com/igrep/typesafe-precure/blob/5dc0800ae8f8f4e002ee3d32d92ae6450b86d653/src/ACME/PreCure/Textbook/KirakiraALaMode/Instances.hs'>https://github.com/igrep/typesafe-precure/blob/5dc0800ae8f8f4e002ee3d32d92ae6450b86d653/src/ACME/PreCure/Textbook/KirakiraALaMode/Instances.hs</a> の時点のtypesafe-precureは<br/><code>ACME.PreCure.Textbook.KirakiraALaMode.Instances</code> でインスタンスしか定義していない module を export して、<br/>更に src/ACME/PreCure/Textbook/KirakiraALaMode.hs などでreexport していました。</div></div><div class="message" id="message-1510890461.000059"><div class="message__timestamp">2017-11-17<br/>12:47:41 +0900</div><div class="message__header">as_capabl</div><div class="message__body">” All instances defined in a module A are imported automatically when importing A, or importing any module that imports A, directly or indirectly.”  <a href='https://wiki.haskell.org/Orphan_instance'>https://wiki.haskell.org/Orphan_instance</a> だそうで、有無を言わさず自動的に再エクスポートされるみたいです</div></div><div class="message" id="message-1510994045.000043"><div class="message__timestamp">2017-11-18<br/>17:34:05 +0900</div><div class="message__header">brackss1</div><div class="message__body">誰かText.EDEに詳しい人いませんか</div></div><div class="message" id="message-1510994928.000036"><div class="message__timestamp">2017-11-18<br/>17:48:48 +0900</div><div class="message__header">brackss1</div><div class="message__body"><code>env = fromPairs ["list" .=["AA","BB","CC"]]</code></div></div><div class="message" id="message-1510994949.000038"><div class="message__timestamp">2017-11-18<br/>17:49:09 +0900</div><div class="message__header">brackss1</div><div class="message__body">こうしてもうまくレンダリングできません</div></div></div><div class="pager"><a href="../../html/C5666B6BB/3.html" class="pager__previous">Previous</a><a href="../../" class="pager__top">Top</a><a href="../../html/C5666B6BB/5.html" class="pager__next">Next</a></div></body></html>