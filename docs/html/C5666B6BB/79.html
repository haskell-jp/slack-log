<!DOCTYPE html><html><head><meta charset="utf-8"><title>haskell-jp / questions #79</title><link rel="stylesheet" href="../../messages.css" type="text/css" media="screen"></head><body><h1>haskell-jp / questions #79</h1><div class="pager"><a href="../../html/C5666B6BB/78.html" class="pager__previous">Previous</a><a href="../../" class="pager__top">Top</a></div><div class="message_list"><div class="message" id="message-1581045679.081100"><div class="message__timestamp">2020-02-07<br/>12:21:19 +0900</div><div class="message__header">igrep</div><div class="message__body">そうですね。正確には、 <code>[e| |]</code> のなかで束縛されてない変数が自動で <code>unboundVarE $ mkName "e"</code> されるところが、です。</div></div><div class="message" id="message-1581047019.081300"><div class="message__timestamp">2020-02-07<br/>12:43:39 +0900</div><div class="message__header">mizunashi-mana</div><div class="message__body">うーんと，検討外れの答えをしていたらすいません．QuasiQuote の中の式は，<br/>1. パース時そのまま一緒に Haskell の式として解析され Ast になります．<br/>2. で，そのままリネームされます．<br/>3. その時に，値の変数は，スコープ内にない変数は unboundVarE 相当に，スコープ内に変数がある場合はそのままその変数に解決され varE 相当で解決されます．<br/>QuasiQuote はあまりドキュメントがないですが，基本的に変数の解決の挙動は， <strike><code>Language.Haskell.TH.lookupValueName</code> に合わせてありますね</strike> 通常のHaskell 式としてのスコープ解決に合わせてあるが正解ですね．なので， <code>lookupValueName</code> とは異なる挙動になるのですね</div></div><div class="message" id="message-1581048785.082000"><div class="message__timestamp">2020-02-07<br/>13:13:05 +0900</div><div class="message__header">mizunashi-mana</div><div class="message__body">訂正はどっちかというと lookupValueName の挙動を僕が誤解してたからなんですが、 QuasiQuote の挙動の方は個人的には割と自然な挙動だと思っていて、quote を書いたところで解決できる変数が解決されず、splice 時まで遅延されるのはむしろ特殊な挙動な気がします</div></div><div class="message" id="message-1581048950.082200"><div class="message__timestamp">2020-02-07<br/>13:15:50 +0900</div><div class="message__header">igrep</div><div class="message__body"><blockquote> quote を書いたところで解決できる変数が解決されず、splice 時まで遅延されるのはむしろ特殊な挙動</blockquote>ん？それって <code>[e| |]</code> の挙動では？</div></div><div class="message" id="message-1581049440.082400"><div class="message__timestamp">2020-02-07<br/>13:24:00 +0900</div><div class="message__header">igrep</div><div class="message__body"><strike>話をドキュメントの話に戻しますが、これが件の挙動についての記述かなぁ。</strike><br/><strike><a href='https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#extension-TemplateHaskellQuotes'>https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#extension-TemplateHaskellQuotes</a></strike><br/><blockquote><strike>Local names, which are not in scope at splice locations, are actually evaluated when the quotation is processed.</strike></blockquote><strike>なんか "splice" と "quotation" という用語の使い方が違う気がしますが...</strike><br/>すみません、やっぱ違うっぽいですね...</div></div><div class="message" id="message-1581049685.082800"><div class="message__timestamp">2020-02-07<br/>13:28:05 +0900</div><div class="message__header">mizunashi-mana</div><div class="message__body">splice と言うのは TH 式を実際に Haskell の式に展開するフェーズのことで、quote を TH 式に展開するフェーズとは異なることに注意です</div></div><div class="message" id="message-1581049840.083000"><div class="message__timestamp">2020-02-07<br/>13:30:40 +0900</div><div class="message__header">mizunashi-mana</div><div class="message__body">thE = [e|v|]<br/>f v = $(thE)<br/>において、thE の値を計算するのが quotation processing / f の式を計算するのが splice です</div></div><div class="message" id="message-1581049921.083200"><div class="message__timestamp">2020-02-07<br/>13:32:01 +0900</div><div class="message__header">mizunashi-mana</div><div class="message__body">lookupValueName は splice 時に与えられた名前を解決し、quote 中の変数は quote processing 時に名前を解決します</div></div><div class="message" id="message-1581050004.083400"><div class="message__timestamp">2020-02-07<br/>13:33:24 +0900</div><div class="message__header">igrep</div><div class="message__body">あっ、もしかしてquoteの中の束縛されてない変数の話じゃなくてquoteの中で見える変数の話、ということですか？<br/>それなら納得です。</div></div><div class="message" id="message-1581051934.083700"><div class="message__timestamp">2020-02-07<br/>14:05:34 +0900</div><div class="message__header">mizunashi-mana</div><div class="message__body">ここまでの話は，`v` が見えない状況で <code>[e|v|]</code> が <code>unboundVarE $ mkName "v"</code> 相当になるのは何故かという説明のつもりでしたが，元の質問は<br/><pre>&gt;&gt;&gt; :set -XTemplateHaskell
&gt;&gt;&gt; import <http://Language.Haskell.TH|Language.Haskell.TH>
&gt;&gt;&gt; let e = () in $(unboundVarE $ mkName "e")
()</pre><br/>の挙動がなぜこうなってるのか単純に分からないということですか？<br/><blockquote>正確には、 [e| |] のなかで束縛されてない変数が自動で unboundVarE $ mkName “e” されるところが、です。</blockquote>の文面がどういうことを言いたいのかいまいち分かってないです</div></div><div class="message" id="message-1581053139.083900"><div class="message__timestamp">2020-02-07<br/>14:25:39 +0900</div><div class="message__header">mizunashi-mana</div><div class="message__body">ここまでの話は、splice においてTH 式の内容を Haskell の式に設置させる時にどう名前解決されるかの話はしていなくて、lookupValueName の話も含め TH 式の Name がどう解決されるかの話をしています</div></div><div class="message" id="message-1581054673.084100"><div class="message__timestamp">2020-02-07<br/>14:51:13 +0900</div><div class="message__header">igrep</div><div class="message__body"><blockquote>ここまでの話は，`v` が見えない状況で <code>[e|v|]</code> が <code>unboundVarE $ mkName "v"</code> 相当になるのは何故かという説明のつもりでしたが</blockquote>はい、その認識で合っています。<br/><br/>そしてようやく気づきましたが<br/><blockquote>lookupValueName は splice 時に与えられた名前を解決し、quote 中の変数は quote processing 時に名前を解決します</blockquote>どうやらここがわかっていないようです。<br/>念のため確認ですがここでいう「quote 中の変数」とは`[e|v|]` における <code>v</code> ですよね？<br/>quote processingが（`v`が <code>[e|v|]</code> の外には定義されてない状態で） <code>[e|v|]</code> を`unboundVarE $ mkName "v"` に変換するという意味ならば、`v`は定義されてないのですし、「quote processing 時に名前を解決」できず、結局spliceするときに解決することになるのでは？</div></div><div class="message" id="message-1581058743.084300"><div class="message__timestamp">2020-02-07<br/>15:59:03 +0900</div><div class="message__header">mizunashi-mana</div><div class="message__body">quote processing での名前解決と言ってるのは，正確には変数が quote processing 時に解決できるならその名前 n で varE n に，それ以外の時は unboundVarE n にするということを言っています．で， unboundVarE n の splice 時の解決方法に，quote で書かれた変数かということは関係ありません．<br/>unboundVarE n は，unresolved identifier を表すということになっていますが，正確には identifier expected to be resolved というニュアンスが正しく， splice 時のリネーム時に通常のリネームと同じように (元々の Haskell プログラムも最初変数部分は全て unboundVarE で構成され，リネーム時に varE に解決されます) 解決されるため，<br/><pre>&gt;&gt;&gt; let e = () in $(unboundVarE $ mkName "e")
()</pre><br/>という挙動になります</div></div><div class="message" id="message-1581141363.084800"><div class="message__timestamp">2020-02-08<br/>14:56:03 +0900</div><div class="message__header">smalltalker74</div><div class="message__body">@smalltalker74 has joined the channel</div></div></div><div class="pager"><a href="../../html/C5666B6BB/78.html" class="pager__previous">Previous</a><a href="../../" class="pager__top">Top</a></div></body></html>