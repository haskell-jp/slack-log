<!DOCTYPE html><html><head><meta charset="utf-8"><title>haskell-jp / math #6</title><link rel="stylesheet" href="../../main.css" type="text/css" media="screen"></head><body><div class="ui container"><h1>haskell-jp / math #6</h1><div class="pager ui pagination menu"><a href="../../html/C7Y71415W/5.html" class="pager__previous item">Previous</a><a href="../../" class="pager__top item">Top</a><a href="../../html/C7Y71415W/7.html" class="pager__next item">Next</a></div><div class="message_list ui feed"><div class="message event" id="message-1539679621.000100"><div class="content"><div class="summary"><div class="message__header user">igrep</div><div class="message__timestamp date">2018-10-16&nbsp;17:47:01 +0900</div></div><div class="message__body description">:thinking_face:.oO(定理証明器関係のchannelも作ろうかな...)</div></div></div><div class="message event" id="message-1539683228.000100"><div class="content"><div class="summary"><div class="message__header user">junji.hashimoto</div><div class="message__timestamp date">2018-10-16&nbsp;18:47:08 +0900</div></div><div class="message__body description"><a href='https://www.cl.cam.ac.uk/~caw77/papers/mechanising-and-verifying-the-webassembly-specification-draft.pdf'>https://www.cl.cam.ac.uk/~caw77/papers/mechanising-and-verifying-the-webassembly-specification-draft.pdf</a><br/>これですかね。<br/>誤解していたらすみません。<br/>どんな時でも型がちゃんと付いておかしなことにならないことを証明した？</div></div></div><div class="message event" id="message-1539683765.000100"><div class="content"><div class="summary"><div class="message__header user">igrep</div><div class="message__timestamp date">2018-10-16&nbsp;18:56:05 +0900</div></div><div class="message__body description">ありがとうございます！読んでみます！</div></div></div><div class="message event" id="message-1539700499.000100"><div class="content"><div class="summary"><div class="message__header user">myuon_myon</div><div class="message__timestamp date">2018-10-16&nbsp;23:34:59 +0900</div></div><div class="message__body description">pdf斜め読みした感じだとtype soundness示したっぽいですね</div></div></div><div class="message event" id="message-1539728063.000100"><div class="content"><div class="summary"><div class="message__header user">hexirp</div><div class="message__timestamp date">2018-10-17&nbsp;07:14:23 +0900</div></div><div class="message__body description">この話について「あれ？JMeqはCoqでも普通に定義できるよ？」って思って、Coqで色々試してみたら、このコードでいう <code>≅-elim</code> が <code>JMeq_eq</code> (このコードでの <code>≅→≡</code>) を仮定しただけでは証明できず、 <code>eq_JMeq</code> (このコードでの <code>≡→≅</code> 。公理なしで証明可能) が <code>JMeq_eq</code> の左逆射になることを仮定する必要があるっぽいなど、色々面白いことが分かりました<br/><a href='https://haskell-jp.slack.com/archives/C5666B6BB/p1538806549000100?thread_ts=1538705462.000100&amp;channel=C5666B6BB&amp;message_ts=1538806549.000100'>https://haskell-jp.slack.com/archives/C5666B6BB/p1538806549000100?thread_ts=1538705462.000100&amp;channel=C5666B6BB&amp;message_ts=1538806549.000100</a></div></div></div><div class="message event" id="message-1539728284.000100"><div class="content"><div class="summary"><div class="message__header user">hexirp</div><div class="message__timestamp date">2018-10-17&nbsp;07:18:04 +0900</div></div><div class="message__body description">ちなみにJMeqが定義できるというのはこんな感じ (ソースコード: <a href='https://github.com/Hexirp/progra-gist/commit/c2f3c7eebd1a465517af912e740f6864d9280486'>https://github.com/Hexirp/progra-gist/commit/c2f3c7eebd1a465517af912e740f6864d9280486</a>)<br/><pre>
Inductive JMeq (A : Type) (a : A) : forall B : Type, B -&gt; Type :=
| JMeq_refl : JMeq A a A a
.
</pre></div></div></div><div class="message event" id="message-1539732421.000100"><div class="content"><div class="summary"><div class="message__header user">igrep</div><div class="message__timestamp date">2018-10-17&nbsp;08:27:01 +0900</div></div><div class="message__body description">つまり<br/><blockquote>どんな時でも型がちゃんと付いておかしなことにならないことを証明した？</blockquote>のことですかね。</div></div></div><div class="message event" id="message-1539740728.000100"><div class="content"><div class="summary"><div class="message__header user">myuon_myon</div><div class="message__timestamp date">2018-10-17&nbsp;10:45:28 +0900</div></div><div class="message__body description">type soundnessは一度型が付けばおかしなことにはならない、であって、型がいつでもつくことは含まないです(今回もそれは無理だと思います)</div></div></div><div class="message event" id="message-1539740830.000100"><div class="content"><div class="summary"><div class="message__header user">myuon_myon</div><div class="message__timestamp date">2018-10-17&nbsp;10:47:10 +0900</div></div><div class="message__body description">(あとtype checkerに関する定理とinterpreterに関する定理も示したっぽいが詳細は真面目に読まないと分からなそう…)</div></div></div><div class="message event" id="message-1540509093.000100"><div class="content"><div class="summary"><div class="message__header user">igrep</div><div class="message__timestamp date">2018-10-26&nbsp;08:11:33 +0900</div></div><div class="message__body description">今週のHaskell :haskell: Weeklyから！ :tada: :blue_book:<br/><a href='https://np.reddit.com/r/haskell/comments/9q6edo/category_theory_for_programmers_by_bartosz/'>https://np.reddit.com/r/haskell/comments/9q6edo/category_theory_for_programmers_by_bartosz/</a></div></div></div><div class="message event" id="message-1541549352.001000"><div class="content"><div class="summary"><div class="message__header user">yuya.gt</div><div class="message__timestamp date">2018-11-07&nbsp;09:09:12 +0900</div></div><div class="message__body description">@yuya.gt has joined the channel</div></div></div><div class="message event" id="message-1541559921.002700"><div class="content"><div class="summary"><div class="message__header user">hiroto.shioi</div><div class="message__timestamp date">2018-11-07&nbsp;12:05:21 +0900</div></div><div class="message__body description">このペーパーに記述されている数式（表現？）をわかりやすく解説している書籍/資料ってありますかね。。<br/><a href='https://cardanodocs.com/files/formal-specification-of-the-cardano-wallet.pdf'>https://cardanodocs.com/files/formal-specification-of-the-cardano-wallet.pdf</a></div></div></div><div class="message event" id="message-1541576801.003200"><div class="content"><div class="summary"><div class="message__header user">hiroto.shioi</div><div class="message__timestamp date">2018-11-07&nbsp;16:46:41 +0900</div></div><div class="message__body description">@lotz OK! 書いた本人に聞いてみます。何かわかったら共有するね。</div></div></div><div class="message event" id="message-1541576866.003400"><div class="content"><div class="summary"><div class="message__header user">lotz</div><div class="message__timestamp date">2018-11-07&nbsp;16:47:46 +0900</div></div><div class="message__body description">ありがとうございます :ok_woman:</div></div></div><div class="message event" id="message-1541578552.007300"><div class="content"><div class="summary"><div class="message__header user">aiya000</div><div class="message__timestamp date">2018-11-07&nbsp;17:15:52 +0900</div></div><div class="message__body description">ゲーテルの不完全性定理を数学ガール読んで触れてるんだけど<br/>「形式的体系に矛盾する文を公理として入れると、任意の文が証明可能になってしまう」というの<br/>「単純型付きラムダ計算の意味論に無限型を入れると、任意の式が型付け可能になってしまう」というのにめっちゃ似てる気がする</div></div></div><div class="message event" id="message-1541836217.007800"><div class="content"><div class="summary"><div class="message__header user">dimension.sf</div><div class="message__timestamp date">2018-11-10&nbsp;16:50:17 +0900</div></div><div class="message__body description">@dimension.sf has joined the channel</div></div></div><div class="message event" id="message-1541861911.018800"><div class="content"><div class="summary"><div class="message__header user">cosmiafu</div><div class="message__timestamp date">2018-11-10&nbsp;23:58:31 +0900</div></div><div class="message__body description">英語ですみません、解答がくれた方いたら日本語でも英語でも大丈夫です <blockquote>&lt;</blockquote><br/>nLab says:<br/><br/><blockquote>a free <code>C</code>-object on <code>x</code> consists of an object <code>y ∈ C</code> together with a morphism<br/><code>η : x -&gt; U y</code>  in <code>D</code> there exists a unique <code>g : y -&gt; z</code> for every <code>f : x -&gt; U z ∈ C</code></blockquote><br/><a href='https://ncatlab.org/nlab/show/free+object'>https://ncatlab.org/nlab/show/free+object</a> paragraph 4 of section 1.<br/><br/>And I knows, though not 100% sure, that for a endofunctor <code>f</code>, the <code>Free f</code> is the <code>y</code>, and the <code>C</code> is the category of monads, and <code>D</code> is the category of endofunctors, U is the forgeful functor simply forgetting the identity and the composition of monad.<br/><br/>My question is, what is the <code>x</code> and <code>η : x -&gt; U(Free f)</code>?<br/>It seems that <code>x</code> can be the identity functor, and <code>η</code> is just the identity natrual transformation of <code>Free f</code> monad, is that right?<br/>If it is not right, what is <code>x</code> and <code>η</code>?<br/>If it is right, is there any other possible definition of <code>x</code> and <code>η</code>?<br/><br/>Thanks in advance.</div></div></div><div class="message event" id="message-1541994448.019400"><div class="content"><div class="summary"><div class="message__header user">sean.westfall</div><div class="message__timestamp date">2018-11-12&nbsp;12:47:28 +0900</div></div><div class="message__body description">@sean.westfall has joined the channel</div></div></div><div class="message event" id="message-1541994635.019600"><div class="content"><div class="summary"><div class="message__header user">as_capabl</div><div class="message__timestamp date">2018-11-12&nbsp;12:50:35 +0900</div></div><div class="message__body description">Free objectについてはこのスレッドで初めて知りましたが、Free monadとの関係は確かに興味深いですね、勉強してみたい</div></div></div><div class="message event" id="message-1541994722.019800"><div class="content"><div class="summary"><div class="message__header user">as_capabl</div><div class="message__timestamp date">2018-11-12&nbsp;12:52:02 +0900</div></div><div class="message__body description">理解できていなかったら申し訳ないのですが、 <code>η</code> が identity natrual transformation だとすると <code>x</code> は <code>U(Free f)</code> では？</div></div></div><div class="message event" id="message-1542014416.020200"><div class="content"><div class="summary"><div class="message__header user">1to100pen</div><div class="message__timestamp date">2018-11-12&nbsp;18:20:16 +0900</div></div><div class="message__body description">質問の意図がよくわかってないですが<br/>C がモナド圏、D が自己関手圏、U が忘却関手の場合の自己関手 x に対する a free C-object on x は<br/><pre>
Free x と η: x -&gt; U (Free x) からなる組
</pre><br/>ではないですかね。<br/><pre>
data Free f a = Impure (f (Free f a)) | Pure a
</pre><br/>とすると、具体的には η は次の liftF（「haskell lifF」でググれば見つかるのと本質的に同じやつ）<br/><pre>
liftF :: x a -&gt; Free x a
liftF = Impure . fmap Pure
</pre><br/>ここで U は忘却関手なので U (Free x) と Free x を同一視して書いています。<br/><br/>x が Identity関手ならば free C-object on Identity は<br/>Free Identity と liftF: Identity  -&gt; U (Free Identity) からなる組<br/>ではないかと。<br/>ちなみに Free Identityモナドは自然数の加算モノイドによる Writerモナドと同型のような気がします。（自然数が Impure のネストの深さを表す）</div></div></div><div class="message event" id="message-1542041376.021600"><div class="content"><div class="summary"><div class="message__header user">cosmiafu</div><div class="message__timestamp date">2018-11-13&nbsp;01:49:36 +0900</div></div><div class="message__body description">おお、確かに <code>x</code> は <code>Free f</code> の f なら <code>η : f -&gt; Free f</code> の方がidentity よりよっぽど意味があると思う。<br/><br/>ちなみに最初のスレッドの <code>identity functor</code> はHaskellのIdentityではなく、本物のIdentityの方。つまり <code>type I a = a</code>の方、残念だがHaskellにはこれを定義してもinstanceを定義できない<br/><br/>ありがとうございます</div></div></div><div class="message event" id="message-1542042079.022400"><div class="content"><div class="summary"><div class="message__header user">cosmiafu</div><div class="message__timestamp date">2018-11-13&nbsp;02:01:19 +0900</div></div><div class="message__body description">やはりちゃんと順番で勉強しなきゃだめなのね。。。<br/><br/><a href='https://ncatlab.org/nlab/show/free+functor#free_objects'>https://ncatlab.org/nlab/show/free+functor#free_objects</a></div></div></div><div class="message event" id="message-1542085076.023000"><div class="content"><div class="summary"><div class="message__header user">1to100pen</div><div class="message__timestamp date">2018-11-13&nbsp;13:57:56 +0900</div></div><div class="message__body description">補足：<br/>C がモナド圏、D が自己関手圏、U が忘却関手の場合の there exists a unique <code>g : y -&gt; z</code> for every <code>f : x -&gt; U z ∈ C</code> の g を f から構成するのが<br/><pre>
g = foldFree f
</pre><br/>だと思います。<br/>foldFree <a href='http://hackage.haskell.org/package/free-5.1/docs/src/Control.Monad.Free.html#foldFree'>http://hackage.haskell.org/package/free-5.1/docs/src/Control.Monad.Free.html#foldFree</a><br/>この関数のコメントが "The very definition of a free monad is that given a natural transformation you get a monad homomorphism."</div></div></div><div class="message event" id="message-1542429521.024500"><div class="content"><div class="summary"><div class="message__header user">mihchang</div><div class="message__timestamp date">2018-11-17&nbsp;13:38:41 +0900</div></div><div class="message__body description">@mihchang has joined the channel</div></div></div><div class="message event" id="message-1542803607.024800"><div class="content"><div class="summary"><div class="message__header user">jeedo</div><div class="message__timestamp date">2018-11-21&nbsp;21:33:27 +0900</div></div><div class="message__body description">@jeedo has joined the channel</div></div></div><div class="message event" id="message-1545133585.000300"><div class="content"><div class="summary"><div class="message__header user">e1q18048</div><div class="message__timestamp date">2018-12-18&nbsp;20:46:25 +0900</div></div><div class="message__body description">@e1q18048 has joined the channel</div></div></div><div class="message event" id="message-1545703394.000200"><div class="content"><div class="summary"><div class="message__header user">aayhrot</div><div class="message__timestamp date">2018-12-25&nbsp;11:03:14 +0900</div></div><div class="message__body description">@aayhrot has joined the channel</div></div></div><div class="message event" id="message-1547108561.000500"><div class="content"><div class="summary"><div class="message__header user">fmr23s</div><div class="message__timestamp date">2019-01-10&nbsp;17:22:41 +0900</div></div><div class="message__body description">@fmr23s has joined the channel</div></div></div><div class="message event" id="message-1547645110.000800"><div class="content"><div class="summary"><div class="message__header user">kilo7998</div><div class="message__timestamp date">2019-01-16&nbsp;22:25:10 +0900</div></div><div class="message__body description">@kilo7998 has joined the channel</div></div></div><div class="message event" id="message-1547863295.001100"><div class="content"><div class="summary"><div class="message__header user">takechi101010</div><div class="message__timestamp date">2019-01-19&nbsp;11:01:35 +0900</div></div><div class="message__body description">@takechi101010 has joined the channel</div></div></div><div class="message event" id="message-1547907396.001300"><div class="content"><div class="summary"><div class="message__header user">igrep</div><div class="message__timestamp date">2019-01-19&nbsp;23:16:36 +0900</div></div><div class="message__body description"><a href='https://identicalsnowflake.github.io/Cantor.html'>https://identicalsnowflake.github.io/Cantor.html</a><br/>カントールの対角線論法をHaskellのコードで解説</div></div></div><div class="message event" id="message-1548381201.003000"><div class="content"><div class="summary"><div class="message__header user">igrep</div><div class="message__timestamp date">2019-01-25&nbsp;10:53:21 +0900</div></div><div class="message__body description">:tada: :books: 本になったんですね！ <a href='https://damepo-lab.booth.pm/items/1051034'>https://damepo-lab.booth.pm/items/1051034</a><br/><a href='https://twitter.com/mod_poppo/status/1088487524433981440'>https://twitter.com/mod_poppo/status/1088487524433981440</a></div></div></div><div class="message event" id="message-1548552031.004800"><div class="content"><div class="summary"><div class="message__header user">hexirp</div><div class="message__timestamp date">2019-01-27&nbsp;10:20:31 +0900</div></div><div class="message__body description">圏論関係の記事を書いたんで載せときます <a href='https://hexirp.github.io/blog/articles/category_theory_for_traversable'>https://hexirp.github.io/blog/articles/category_theory_for_traversable</a></div></div></div><div class="message event" id="message-1548652458.005500"><div class="content"><div class="summary"><div class="message__header user">aiya000</div><div class="message__timestamp date">2019-01-28&nbsp;14:14:18 +0900</div></div><div class="message__body description">めっちゃ興味あります！！！<br/>ありがとうございます！！<br/>後で読みます！！！</div></div></div><div class="message event" id="message-1548760952.006500"><div class="content"><div class="summary"><div class="message__header user">koyama</div><div class="message__timestamp date">2019-01-29&nbsp;20:22:32 +0900</div></div><div class="message__body description">@koyama has joined the channel</div></div></div><div class="message event" id="message-1549696762.007600"><div class="content"><div class="summary"><div class="message__header user">tkskzyk0925</div><div class="message__timestamp date">2019-02-09&nbsp;16:19:22 +0900</div></div><div class="message__body description">「合成射の結合律」を圏の公理の1つというのに違和感がありますが、皆さん的にはどうでしょう？？<br/><br/>1. 合成射が存在しなければならない<br/>2. 合成射は、合成元の射それぞれ (がたどる経路) と可換 ⇒ 可換性に関する公理<br/><br/>上記を定めて、それらによって結合律が導出されるという方が、思考の流れとしてはしっくりくるかなと</div></div></div><div class="message event" id="message-1549719857.009700"><div class="content"><div class="summary"><div class="message__header user">koyama</div><div class="message__timestamp date">2019-02-09&nbsp;22:44:17 +0900</div></div><div class="message__body description">可換性というのはそれ単独で公理化できるようなものなのでしょうか？　あれはどちらかというと「常に成り立つものではないが、成り立つ時に限りいいことがあるよ」というシロモノに感じるのですが…</div></div></div><div class="message event" id="message-1549771096.010300"><div class="content"><div class="summary"><div class="message__header user">tkskzyk0925</div><div class="message__timestamp date">2019-02-10&nbsp;12:58:16 +0900</div></div><div class="message__body description">もちろん、射 <code>f: a → b</code> , <code>g: b → c</code> , <code>h: a → c</code> が存在したからと言って、 <code>h</code> が <code>f</code> , <code>g</code> の合成射とは限らないですが、2つの射 <code>f</code> , <code>g</code> の作用や関係性を合成射 <code>g ⚬ f</code> は1つで表すとするわけですよね？<br/><br/>これを簡潔に言おうとすれば「可換であるとは何か？」が必要になりますし、なおかつその他の議論でも可換図式は頻繁に登場するわけですから、公理として必要じゃないかなと思った次第です<br/><br/>ただ単独で公理化できるの？というのは確かにわからんですね…</div></div></div><div class="message event" id="message-1549860571.000200"><div class="content"><div class="summary"><div class="message__header user">tkskzyk0925</div><div class="message__timestamp date">2019-02-11&nbsp;13:49:31 +0900</div></div><div class="message__body description">そもそもで、 <code>合成射は、合成元の射それぞれ (がたどる経路) と可換</code> とならないような合成射って考えることができるんでしょうか？ (もし考えることができるのであれば、可換性は公理として必要なくなるなと)</div></div></div><div class="message event" id="message-1549866686.000400"><div class="content"><div class="summary"><div class="message__header user">myuon_myon</div><div class="message__timestamp date">2019-02-11&nbsp;15:31:26 +0900</div></div><div class="message__body description">(あまり議論を理解してないのですが)その2点を認めると結合律が導出できる、というのがよく分からないです</div></div></div><div class="message event" id="message-1549889439.000600"><div class="content"><div class="summary"><div class="message__header user">tkskzyk0925</div><div class="message__timestamp date">2019-02-11&nbsp;21:50:39 +0900</div></div><div class="message__body description">@myuon_myon<br/>「合成射の存在」と「合成射の可換性」をこの図式によって「公理」として定めれば…<br/>(本当は唯一性は可換であることから言えるのでいりませんが)</div></div></div><div class="message event" id="message-1549889486.001000"><div class="content"><div class="summary"><div class="message__header user">tkskzyk0925</div><div class="message__timestamp date">2019-02-11&nbsp;21:51:26 +0900</div></div><div class="message__body description">@myuon_myon<br/>「結合律」は以下のように「定理」として導出できるのでは？ということです</div></div></div><div class="message event" id="message-1549889887.001600"><div class="content"><div class="summary"><div class="message__header user">myuon_myon</div><div class="message__timestamp date">2019-02-11&nbsp;21:58:07 +0900</div></div><div class="message__body description">@tkskzyk0925 ありがとうございます、論点理解しました :hand: <br/>それを証明とするには「合成はf,gを先にしてもg,hを先にしてもよい」が必要で、それが結合律ですので真ん中の射を経由するところで暗黙的に使っているのではないかと思います</div></div></div><div class="message event" id="message-1549937803.001800"><div class="content"><div class="summary"><div class="message__header user">tkskzyk0925</div><div class="message__timestamp date">2019-02-12&nbsp;11:16:43 +0900</div></div><div class="message__body description">ちょっと可換図式の書き方がまずかったかも知れないですね<br/><br/>ここで自分がずっともやもやしているのは、<br/><br/>- 可換性によって、合成射がミニマムな射の組み合わせ ( <code>h ⚬ (g ⚬ f)</code> であれば、 <code>h</code> , <code>g</code> , <code>f</code> ) に分解できる<br/>- 同じようなミニマムな射の組み合わせを持つ合成射 ( <code>h</code> , <code>g</code> , <code>f</code> から構成できる <code>(h ⚬ g) ⚬ f)</code> ) は、可換性により等しい<br/><br/>と言えないか？ということです</div></div></div><div class="message event" id="message-1549938043.002000"><div class="content"><div class="summary"><div class="message__header user">tkskzyk0925</div><div class="message__timestamp date">2019-02-12&nbsp;11:20:43 +0900</div></div><div class="message__body description"></div></div></div><div class="message event" id="message-1549938391.002400"><div class="content"><div class="summary"><div class="message__header user">myuon_myon</div><div class="message__timestamp date">2019-02-12&nbsp;11:26:31 +0900</div></div><div class="message__body description">分解するタイミングでかっこをはずしてますが、そこにトリックがあると思われます<br/>分解しても射はもとあった合成の順番を勝手に変えてはならず、 <code>h ⚬ (g ⚬ f)</code> であれば、 <code>h</code> , ( <code>g</code> , <code>f</code> )と必ず括弧を付ける必要があるのではと(この分解後、括弧の付け替えを許すのが結合律です)</div></div></div><div class="message event" id="message-1549938528.002800"><div class="content"><div class="summary"><div class="message__header user">tkskzyk0925</div><div class="message__timestamp date">2019-02-12&nbsp;11:28:48 +0900</div></div><div class="message__body description">なるほど、確かに括弧を一律ではずして良いという保証はないですね<br/><br/>ひとまず腑に落ちました、ありがとうございます :haskell:</div></div></div><div class="message event" id="message-1549952841.003100"><div class="content"><div class="summary"><div class="message__header user">koyama</div><div class="message__timestamp date">2019-02-12&nbsp;15:27:21 +0900</div></div><div class="message__body description">なんとなく、可換図式って、そういう「本当は気をつけなくちゃいけない細かいところ」を忘れてしまいがちになる気がしています…<br/>可換図式って要は単に「等式」を図に書き換えているだけなので、元の等式が何なのかを結局意識する必要があるんだと思います。<br/>つまり「可換性により等しい」っていう言い方はたぶん意味がなくて、「等しいということを可換図式で表すことにします」っていうだけなんじゃないかなあ、と思います</div></div></div><div class="message event" id="message-1549953207.003300"><div class="content"><div class="summary"><div class="message__header user">koyama</div><div class="message__timestamp date">2019-02-12&nbsp;15:33:27 +0900</div></div><div class="message__body description">で、「可換とは何か？」という疑念があったと思うんですが、それってつまり「（射と射が）等しいとはどういうことか？」っていう話なのでは、と思います。<br/>実際、 Hask圏（Haskellの型が対象で関数が射となる圏）で、関数と関数が「等しい」といわれても、関数同士は Eq で比較できないし、 <code>((\x -&gt; x + 1) . (\x -&gt; x + 2))</code> と <code>(\x -&gt; x + 3)</code> が等しいってどうして言えるの？みたいな疑念はあると思うんですよね</div></div></div></div><div class="pager ui pagination menu"><a href="../../html/C7Y71415W/5.html" class="pager__previous item">Previous</a><a href="../../" class="pager__top item">Top</a><a href="../../html/C7Y71415W/7.html" class="pager__next item">Next</a></div></div></body></html>