[
    {
        "ts": "1585548122.008700",
        "text": "あ、なるほど、representational 以外の role 持つやつだと表示されるんですね。ありがとうございます、解決しました",
        "user": "U57D08Z9U",
        "type": "message"
    },
    {
        "ts": "1585548203.008900",
        "text": "解決したみたいでよかったです。\nいちおう、8.8.3で\n```GHCi, version 8.8.3: <https://www.haskell.org/ghc/>  :? for help\nghci&gt; :set -XTypeFamilies\nghci&gt; :set -XGADTs\nghci&gt; type family F a\nghci&gt; data T a b c = MkT b (F c)\nghci&gt; :i T\ntype role T phantom representational nominal\ndata T a b c = MkT b (F c)\n        -- Defined at &lt;interactive&gt;:4:1```\nでした。",
        "user": "U6BUS25MX",
        "type": "message"
    },
    {
        "ts": "1585553848.009400",
        "text": "<@U4LGTMTMK> set the channel topic: お悩み相談専用チャンネル。回答は原則スレッド機能でやりましょう。複数の質問を同時に投稿しやすくするための配慮です。",
        "user": "U4LGTMTMK",
        "type": "message"
    },
    {
        "ts": "1585559354.009800",
        "text": "popl 2011 年からの概念なんですね。勉強せねば。\nありがとうございます。",
        "user": "U0108S1LS2W",
        "type": "message"
    },
    {
        "ts": "1585560874.010200",
        "text": "equivalent な型を同じ role をもつというのですね。",
        "user": "U0108S1LS2W",
        "type": "message"
    },
    {
        "ts": "1585562533.010500",
        "text": "どういう equivalent を持ってくるかが重要で、ここでは representational equivalent という概念を持ってきます。なお、やってる事は基本的に structural equivalent とあまり変わりませんが、role system によって各データ型の equivalent のレベルを調整できる点が異なります。その調整を行うために指定するのが(パラメータの) role です",
        "user": "U57D08Z9U",
        "type": "message"
    },
    {
        "ts": "1585562644.010700",
        "text": "representational equivalent とは直感的には、実行時に同じ表現を持つということを表します",
        "user": "U57D08Z9U",
        "type": "message"
    },
    {
        "ts": "1585566505.011300",
        "text": "ありがとうございます。",
        "user": "U0108S1LS2W",
        "type": "message"
    },
    {
        "ts": "1585619243.011700",
        "text": "<@U011352B5LY> has joined the channel",
        "user": "U011352B5LY",
        "type": "message"
    },
    {
        "ts": "1585710648.014800",
        "text": "hourglassパッケージにおける `WeekDay` <https://hackage.haskell.org/package/hourglass-0.2.12/docs/Time-Types.html#t:WeekDay> と `Date` を受け取って、「指定した日付から次のhoge曜日まで何日かかるかを返す」関数 `daysUntilNext` という関数を定義してみました。もっとクールな計算方法があれば教えていただきたいです。\nなんかうまいことやれば  `if` とかで分岐しなくて済みそうなんですが、ぱっと思いつきませんでした。\n```daysUntilNext :: WeekDay -&gt; Date -&gt; Int\ndaysUntilNext nextWeekDay baseDate =\n    if nextWeekDay &gt; baseWeekDay\n      then fromEnum nextWeekDay - fromEnum baseWeekDay\n      else fromEnum nextWeekDay - fromEnum baseWeekDay + 7\n    where\n      baseWeekDay = getWeekDay baseDate```",
        "user": "U4LGTMTMK",
        "type": "message"
    },
    {
        "ts": "1585710885.014900",
        "text": "例えば、以下のように計算します:\n• 今日（2020年4月1日(水)）から次の月曜日（2020年4月6日）であれば `5`\n• 今週日曜日（2020年4月5日）から次の月曜日であれば `1`\n• 今週月曜日（2020年3月30日）から次の月曜日であれば `7`",
        "user": "U4LGTMTMK",
        "type": "message"
    },
    {
        "ts": "1585713632.015100",
        "text": "```(fromEnum nextWeekDay - fromEnum baseWeekDay) `mod` 7```\n すればいいかと思いましたが、月→月が0になってしまうので良くないですね",
        "user": "U570660KX",
        "type": "message"
    },
    {
        "ts": "1585713767.015400",
        "text": "負の数の剰余は、ちょっと前にTwitterでバズってたツイートがあった気がする",
        "user": "U570660KX",
        "type": "message"
    },
    {
        "ts": "1585713924.015700",
        "text": "どちらにしても、完全に分岐をなくすのはやっぱ難しそうですね...",
        "user": "U4LGTMTMK",
        "type": "message"
    },
    {
        "ts": "1585714709.016000",
        "text": "少し汚いですが、こんな感じでどうでしょうか？",
        "user": "ULBC77RC3",
        "type": "message"
    },
    {
        "ts": "1585719148.016600",
        "text": "今試してみたらテスト通りました。ありがとうございます！",
        "user": "U4LGTMTMK",
        "type": "message"
    }
]