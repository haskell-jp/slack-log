[
    {
        "text": "はじめて質問させていただきます。\nHaskell学習中の者で、理解が進まない箇所があるのでお力添えいただきたく思います:man-bowing:\n（続く...）",
        "type": "message",
        "ts": "1663570888.297569",
        "user": "U02B9UAPCQ4"
    },
    {
        "text": "少し長いのでスレッドにて続きを書かせていただきます。\n\n末尾再起最適化について学習をしているのですが、\n①「Haskellは遅延評価なので末尾再起をしてもうまみがない」と言っている記事がある\n②「末尾再起として挙げられているコードがそもそも末尾再起じゃない」という指摘をされている記事がある\nため、混乱を極めております。\n\n`関数の処理の末尾が再起呼び出しで終了している`\n`末尾再起最適化することによって関数呼び出しごとにコールスタックを生成しなくなるのでスタックオーバーフローしない`\nというのが今のところの理解です。\n\nそこで質問なのですが、\n①以下のb,cの例は末尾再起最適化されている例といえるでしょうか？\n②末尾再起最適化されている場合、実行時には実際にコールスタックの生成が抑制されているのでしょうか？\n```a. よく見る末尾再起じゃない定義\nfib :: Integer -&gt; Integer\nfib 0 = 0\nfib 1 = 1\nfib n = fib (n - 1) + fib (n - 2)\n=======================================================\nb. 末尾再起?\nfibResult :: (Integer, Integer, Integer) -&gt; Integer\nfibResult (x, _, 0) = x\nfibResult (x, y, idx) = fibResult (y, x + y, idx - 1)\n\nfib :: Integer -&gt; Integer\nfib x = fibResult (0, 1, x)\n=======================================================\nc. 末尾再起?\nfib :: Integer -&gt; Integer\nfib n = fib' n 1 0\n    where\n        fib' m x y\n            | m == 0 = 1\n            | m == 1 = x\n            | otherwise = fib' (m - 1) (x + y) (x)```",
        "type": "message",
        "ts": "1663570910.914239",
        "user": "U02B9UAPCQ4"
    },
    {
        "text": "「Haskellは遅延評価なので末尾再起をしてもうまみがない」だと思ってますが他の人の意見も聞きたい",
        "type": "message",
        "ts": "1663575290.771499",
        "user": "U4L0B71L1"
    },
    {
        "text": "あと、「式」の関数に「末尾再帰」は当てはまらない気がしますがどうなんでしょう\n「末尾再帰」は「手続き」に対してのみ「末尾再帰かどうかが言える」んじゃないかなと思うんですが？\n質問に質問を付け加えてしまってすみません",
        "type": "message",
        "ts": "1663575828.351519",
        "user": "U4L0B71L1"
    },
    {
        "text": "間違ってたらすみませんがコールスタックはHaskellにないような気が。\n「Haskellは末尾再帰をしてもうまみがない」はその通りだと思います、コールスタックがなく、サンク(予定されている計算を記憶)があります。\nまた、Haskellでは再帰を末尾にすることによる最適化もされないと認識しています。\n\nその例だとサンクが潰れていませんので、計算が実際に実行される前にはサンクによりメモリが使用されます。\nもしサンクを潰したければ、正格評価にする必要があります。(代わりに無限リストなどができなくなるデメリットはありますが、それが問題なければ)\nただし、Haskellは全体を全て正格評価する方法はないはずで(自分は知らない)、部分部分を正格評価にすることはできますが、\n弱冠頭正規形の制約や評価のタイミングを把握しなければ「したつもりでなってない」ということになる可能性があります。\nしかし、上手く行けばいわゆるコールスタックもサンクも使用しない状態にできるとは思われます。\n\nただ一般的には、Haskellでメモリを気にするのはかなり難しい気がします、\n余程のこだわりがなければ、メモリを気にしないか、メモリを気にできる言語を使用するかを選んだ方が良いと思います。\n\n自分も熟練者とは言えないので、間違ってるところがあるかもしれません。",
        "type": "message",
        "ts": "1663577075.903479",
        "user": "U02JVFSJT38"
    },
    {
        "text": "質問に沿って答えると、\n①以下のb,cの例は末尾再起最適化されている例といえるでしょうか？\n→なっていません、Haskellでそもそもその最適化はされません\n②末尾再起最適化されている場合、実行時には実際にコールスタックの生成が抑制されているのでしょうか？\n→なっていませんが、コールスタックはありません、ただし実行前にサンクがあります\n\nと自分は認識してます。",
        "type": "message",
        "ts": "1663577366.695129",
        "user": "U02JVFSJT38"
    },
    {
        "text": "<@U4L0B71L1>\nご確認ありがとうございます。\n&gt; 「末尾再帰」は「手続き」に対してのみ「末尾再帰かどうかが言える」んじゃないかなと思うんですが？\nすみません、そういった観点は持っておりませんでした。\n例が適切ではなかったでしょうか？\n末尾再起については学習中のため、ご容赦ください。",
        "type": "message",
        "ts": "1663578579.374159",
        "user": "U02B9UAPCQ4"
    },
    {
        "text": "<@U02JVFSJT38>\nありがとうございます。\n周辺知識も交えてご回答いただけて、勉強になります。\n&gt; もしサンクを潰したければ、正格評価にする必要があります。\nちなみに、正格評価にするとサンクを使用しなくなると思いますが、この場合はコールスタックを使うことになりますか？",
        "type": "message",
        "ts": "1663580269.100909",
        "user": "U02B9UAPCQ4"
    },
    {
        "text": "訂正させて下さい。\n&gt;また、Haskellでは再帰を末尾にすることによる最適化もされないと認識しています\nこれは違ったようです。\nHaskellでの末尾再帰は、\n遅延評価では最適化自体はあるが結局サンクが作られる\n正格評価では最適化され、サンクもコールスタックもない\nということっぽいです。\n\n以下を参考にしました\n<https://opaupafz2.hatenablog.com/entry/2021/09/18/230521#fn-30fc4e27>\n\n上記によると、Haskellにはそもそもコールスタックがないとのことですので、接している情報が正しければ使われません。\n気にするのはサンクだけです。",
        "type": "message",
        "ts": "1663582244.321399",
        "user": "U02JVFSJT38"
    },
    {
        "text": "<@U02JVFSJT38>\nご追記、リンクの添付ありがとうございます:man-bowing:\nHaskellの評価の仕方についてはもっと理解を深めなくてはいけないですね、、参考にさせていただきます！",
        "type": "message",
        "ts": "1663584170.908059",
        "user": "U02B9UAPCQ4"
    },
    {
        "text": "訂正：\n①以下のb,cの例は末尾再起最適化されている例といえるでしょうか？\n→最適化自体は働くように見えます\n②末尾再起最適化されている場合、実行時には実際にコールスタックの生成が抑制されているのでしょうか？\n→コールスタックはありませんが、遅延評価である限りサンクがあります\n\n自分もまだまだ勉強しないといけませんね",
        "type": "message",
        "ts": "1663584183.835759",
        "user": "U02JVFSJT38"
    },
    {
        "text": "再帰定義が生成する計算プロセス進行の「かたち」を考えると判りやすくなると思います。\nSICPに判りやすく正確な（個人の感想です）説明があります。\n<https://sicp.iijlab.net/fulltext/x121.html>\n注釈も含め端的に説明されています。参考になると思います。\nHaskellの場合は蓄積(アキュミュレーション)が遅延されるので、\n結局、反復プロセスになるように書いても蓄積部分に遅延演算(deffered operation)がのこって\nしまうので、うまみがないと言われてしまうわけです。",
        "type": "message",
        "ts": "1663592339.517529",
        "user": "U4KU9ABL0"
    },
    {
        "text": "<@U4KU9ABL0>\nありがとうございます！\n参考にいたします:man-bowing:",
        "type": "message",
        "ts": "1663600221.983639",
        "user": "U02B9UAPCQ4"
    }
]