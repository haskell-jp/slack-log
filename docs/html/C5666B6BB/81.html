<!DOCTYPE html><html><head><meta charset="utf-8"><title>haskell-jp / questions #81</title><link rel="stylesheet" href="../../main.css" type="text/css" media="screen"></head><body><div class="ui container"><h1>haskell-jp / questions #81</h1><div class="pager ui pagination menu"><a href="../../html/C5666B6BB/80.html" class="pager__previous item">Previous</a><a href="../../" class="pager__top item">Top</a></div><div class="message_list ui feed"><div class="message event" id="message-1583666327.077700"><div class="content"><div class="summary"><div class="message__header user">tcokygets</div><div class="message__timestamp date"><a class="date" href="#message-1583666327.077700">2020-03-08&nbsp;20:18:47 +0900</a></div></div><div class="message__body description">いえ 何もしてないのにいつのまにかこうなってしまったので……それにいくら再インストールしても同じ問題が発生しちゃうんですよ もう手詰まりで</div></div></div><div class="message event" id="message-1583666429.077900"><div class="content"><div class="summary"><div class="message__header user">igrep</div><div class="message__timestamp date"><a class="date" href="#message-1583666429.077900">2020-03-08&nbsp;20:20:29 +0900</a></div></div><div class="message__body description">何のコマンドを実行したら発生したんですか？それともコマンドじゃなくてエディターを起動したときとか？<br/>あと、GHCはどうやってインストールしましたか？</div></div></div><div class="message event" id="message-1583672131.078200"><div class="content"><div class="summary"><div class="message__header user">koowashi</div><div class="message__timestamp date"><a class="date" href="#message-1583672131.078200">2020-03-08&nbsp;21:55:31 +0900</a></div></div><div class="message__body description">@koowashi has joined the channel</div></div></div><div class="message event" id="message-1583714881.078500"><div class="content"><div class="summary"><div class="message__header user">niijimatakashi993</div><div class="message__timestamp date"><a class="date" href="#message-1583714881.078500">2020-03-09&nbsp;09:48:01 +0900</a></div></div><div class="message__body description">@niijimatakashi993 has joined the channel</div></div></div><div class="message event" id="message-1583916124.078800"><div class="content"><div class="summary"><div class="message__header user">k.kent8192</div><div class="message__timestamp date"><a class="date" href="#message-1583916124.078800">2020-03-11&nbsp;17:42:04 +0900</a></div></div><div class="message__body description"><a href='https://teratail.com/questions/246485'>https://teratail.com/questions/246485</a></div></div></div><div class="message event" id="message-1583916141.079400"><div class="content"><div class="summary"><div class="message__header user">k.kent8192</div><div class="message__timestamp date"><a class="date" href="#message-1583916141.079400">2020-03-11&nbsp;17:42:21 +0900</a></div></div><div class="message__body description">この件に関する回答を募集しています。</div></div></div><div class="message event" id="message-1583916194.080800"><div class="content"><div class="summary"><div class="message__header user">k.kent8192</div><div class="message__timestamp date"><a class="date" href="#message-1583916194.080800">2020-03-11&nbsp;17:43:14 +0900</a></div></div><div class="message__body description">調べてもなかなか分からなくて…</div></div></div><div class="message event" id="message-1583984783.084300"><div class="content"><div class="summary"><div class="message__header user">hexirp</div><div class="message__timestamp date"><a class="date" href="#message-1583984783.084300">2020-03-12&nbsp;12:46:23 +0900</a></div></div><div class="message__body description"><a href='https://github.com/haskell/bytestring/blob/95fe6bdf13c9cc86c1c880164f7844d61d989574/Data/ByteString/Builder/Internal.hs#L348-L353'>https://github.com/haskell/bytestring/blob/95fe6bdf13c9cc86c1c880164f7844d61d989574/Data/ByteString/Builder/Internal.hs#L348-L353</a><br/>bytestring パッケージの Builder の実装ってどうしてこうなっているんですか？　予想としては差分リストと BufferRange を状態に持つアロー的な何か ( <a href='http://hackage.haskell.org/package/arrows-0.4.4.2/docs/Control-Arrow-Transformer-CoState.html'>http://hackage.haskell.org/package/arrows-0.4.4.2/docs/Control-Arrow-Transformer-CoState.html</a> ) の組み合わせだと思っています。</div></div></div><div class="message event" id="message-1584024050.093000"><div class="content"><div class="summary"><div class="message__header user">k.marumaru524</div><div class="message__timestamp date"><a class="date" href="#message-1584024050.093000">2020-03-12&nbsp;23:40:50 +0900</a></div></div><div class="message__body description">おひさしぶりです<br/><br/>Haskellで、repl付きのinterprerを実装するときの話です。<br/>以下の、HaskellでSchemeを作るサイトでは、inteprerの環境の型にIORefを使用しています。<br/><a href='https://ja.wikibooks.org/wiki/48%E6%99%82%E9%96%93%E3%81%A7Scheme%E3%82%92%E6%9B%B8%E3%81%93%E3%81%86/%E5%A4%89%E6%95%B0%E3%81%A8%E4%BB%A3%E5%85%A5'>https://ja.wikibooks.org/wiki/48%E6%99%82%E9%96%93%E3%81%A7Scheme%E3%82%92%E6%9B%B8%E3%81%93%E3%81%86/%E5%A4%89%E6%95%B0%E3%81%A8%E4%BB%A3%E5%85%A5</a><br/><br/><br/>ここで3つ質問があります。<br/>1. なぜStateが適していなくて、IORefが適しているのか<br/>2. IORefを使った場合にenvを持ち回らない方法はあるのか<br/>3. Stateを使ったときにreplが正しく動かないのはそういうものなのか、単純に僕の実装が悪いのか<br/>特に、1,2についてお聞きしたいです。<br/>質問はさておき、最終的にやりたいことは「envを持ち回らずにreplでevalを実行すること」です<br/><br/><br/>1に関しては、上記のページの上の方に解説がありますが、理由をよく理解できませんでした。<br/>関数の呼び出しの際にenvが入れ子になっていくのはわかりますが、そのときになぜStateではだめで、IORefならうまく機能するのかがわかりません<br/><br/><br/>2に関して、上のサイトを少し参考にして実装していっているものが以下です。IORefを使っていてeval関数はenvを引き回しています。StateモナドやReaderモナドを使うときのようにenvを隠蔽する必要はあるのでしょうか<br/><a href='https://github.com/mrsekut/Hytl/blob/86cca753fc/src/Eval.hs'>https://github.com/mrsekut/Hytl/blob/86cca753fc/src/Eval.hs</a><br/><br/><br/>3に関して、「これIORefじゃなくてStateにすればenv隠蔽できるやん！」と早とちりして途中まで実装したものが以下になります。Stateを使うことでenvを持ち回る事がなくなりましたが、replで動かしたときに変数呼び出しがうまく機能しません。というのも、一行入力する毎にStateあるEnvが空になっているようです。これは単に僕のreplの実装が悪いだけなのか、IOが絡む場合はStateだけではうまく動かないのか、というのをお聞きしたいです。<br/><a href='https://github.com/mrsekut/Hytl/blob/2bbf7c4058/src/Eval.hs'>https://github.com/mrsekut/Hytl/blob/2bbf7c4058/src/Eval.hs</a><br/><br/><br/><br/>よろしくおねがいします。</div></div></div><div class="message event" id="message-1584056490.093500"><div class="content"><div class="summary"><div class="message__header user">igrep</div><div class="message__timestamp date"><a class="date" href="#message-1584056490.093500">2020-03-13&nbsp;08:41:30 +0900</a></div></div><div class="message__body description">取り急ぎ。<br/><blockquote>なぜStateが適していなくて、IORefが適しているのか</blockquote>例外が発生したときに、途中まで更新していたstateを保存する方法がないためです。<br/>ちなみに、`StateT` を重ねたMonad stackが <code>MonadUnliftIO</code>のインスタンスじゃないのも同じ理由です。<br/><br/><blockquote>IORefを使った場合にenvを持ち回らない方法はあるのか</blockquote><code>ReaderT</code> を使いましょう。<br/>ここまでのことはいわゆる「ReaderT Design Pattern」の原典である <a href='https://www.fpcomplete.com/blog/2017/06/readert-design-pattern'>https://www.fpcomplete.com/blog/2017/06/readert-design-pattern</a> でも触れられています。</div></div></div><div class="message event" id="message-1584057448.093800"><div class="content"><div class="summary"><div class="message__header user">mizunashi-mana</div><div class="message__timestamp date"><a class="date" href="#message-1584057448.093800">2020-03-13&nbsp;08:57:28 +0900</a></div></div><div class="message__body description">@igrepさんが言ってるのは一般的な State の問題点でここでの問題点としてはかなりズレてると思います<br/><br/>今回 IORef を使用することのポイントは、式を評価する際環境を容易に変えられ、かつ環境を可変に保てるという点だと思います。State では強制的に全環境が共通のものになってしまいますが、IORef を使った場合は eval に渡す環境を変えるだけでクロージャの評価にも流用できます。それがおそらく元文献が言いたいことだと思います。<br/><br/>ところで、通常 Env の引回しを明示的にしたくなくて、でもたまに局所的に環境を変えたいという需要が、Reader モナドで実現できるというのは同意です。Eval = ReaderT Env IO とすれば前者はそのまま実現できて、後者は Reader の local メソッド で実現できます <br/><br/>ところで3番目のはコメントアウトしてる部分は型が合って内容に見えるんですが、変数の参照はどうやって実装したんでしょう?</div></div></div><div class="message event" id="message-1584057723.094200"><div class="content"><div class="summary"><div class="message__header user">igrep</div><div class="message__timestamp date"><a class="date" href="#message-1584057723.094200">2020-03-13&nbsp;09:02:03 +0900</a></div></div><div class="message__body description">実際REPLの実装にStateを使ったら間違いなく該当する問題にハマりますし（だから、Haskelineは <code>ReaderT IO</code> を使っている）、挙げている文献を読まず意図を汲まなかったのは私の落ち度ですが、「ずれている」という言い方はちょっと引っかかりますね...。 :confused:</div></div></div><div class="message event" id="message-1584059700.094500"><div class="content"><div class="summary"><div class="message__header user">mizunashi-mana</div><div class="message__timestamp date"><a class="date" href="#message-1584059700.094500">2020-03-13&nbsp;09:35:00 +0900</a></div></div><div class="message__body description">@igrep すいません、言葉選びが悪かったですが、上の「ずれている」は全く役に立たないと言っているわけではなく、<@UCM4G8PGW>さんに対して元文献で言ってることとは話が違うと言うことが分かるようにという意図での発言でした。元文献で言ってること以上に State ではなく Reader を使う意義があるというのは、私も同意です</div></div></div><div class="message event" id="message-1584063006.094800"><div class="content"><div class="summary"><div class="message__header user">fumieval</div><div class="message__timestamp date"><a class="date" href="#message-1584063006.094800">2020-03-13&nbsp;10:30:06 +0900</a></div></div><div class="message__body description">BuildStepはADT版Freeのように操作を再帰的に繋げたコルーチン的構造で、そのままだと結合が遅いので差分リストのようにしているのだと理解しています</div></div></div><div class="message event" id="message-1584067451.098200"><div class="content"><div class="summary"><div class="message__header user">hexirp</div><div class="message__timestamp date"><a class="date" href="#message-1584067451.098200">2020-03-13&nbsp;11:44:11 +0900</a></div></div><div class="message__body description">頭から抜けていたんですが、操作というのが先でした。この理解であっているみたいですね。全称量化されている r は ST モナドのような操作を制限するためのものですかね？</div></div></div><div class="message event" id="message-1584068842.098600"><div class="content"><div class="summary"><div class="message__header user">k.marumaru524</div><div class="message__timestamp date"><a class="date" href="#message-1584068842.098600">2020-03-13&nbsp;12:07:22 +0900</a></div></div><div class="message__body description">igrepさん、mizunashi-manaさん、ご返事ありがとうございます。なるほど、Readerを使うのが良さそうですね。僕の実装ではまだ例外処理を書いていないのでStateを使ったときの問題に出くわしていなかったので気づけてよかったです（この辛さもまた試してみたいですが）<br/><br/><br/>実装するときに以下のような経過をたどりました<br/>IORefが良いらしい→できた→env消したい→Readerを使うと良いらしい→Readerつかう→え、これStateじゃないとムリでは？→Stateつかう→replが動かんくなった、ムリなのかなやっぱりIORefにするか→env復活するじゃん嫌だ→質問<br/><br/>３番目のリンクのコメントアウトの型がずれているのはこの経過で前の段階のものが残っているからです<br/><br/>Readerのlocalなどに対する理解が甘かったようです。Readerの理解と実装を今晩トライしてみて躓いたらまた質問させていただきます。</div></div></div><div class="message event" id="message-1584072790.099000"><div class="content"><div class="summary"><div class="message__header user">mizunashi-mana</div><div class="message__timestamp date"><a class="date" href="#message-1584072790.099000">2020-03-13&nbsp;13:13:10 +0900</a></div></div><div class="message__body description">補足ですが、コメントで言っている Reader を使うとは IORef を使った Env を Reader で渡すということです。Reader 単体では読み込みしかできないので、環境への書き込みが行なえませんが、IORef を読み込むことで可変にできます</div></div></div><div class="message event" id="message-1584072986.099300"><div class="content"><div class="summary"><div class="message__header user">as_capabl</div><div class="message__timestamp date"><a class="date" href="#message-1584072986.099300">2020-03-13&nbsp;13:16:26 +0900</a></div></div><div class="message__body description">あえてStateTモナドで実装するなら、runEvalの型を`Exp -&gt; StateT Env IO Int` として、Repl.hsの方でevalStateTしてやる感じになるかと思います。evalStateTを抜けたら状態は消えてしまいますので。</div></div></div><div class="message event" id="message-1584096697.099700"><div class="content"><div class="summary"><div class="message__header user">fumieval</div><div class="message__timestamp date"><a class="date" href="#message-1584096697.099700">2020-03-13&nbsp;19:51:37 +0900</a></div></div><div class="message__body description">同じモジュールにあるPutモナドの実装との兼ね合いなのか、結果を持たせられるようになっているようです</div></div></div><div class="message event" id="message-1584148905.100300"><div class="content"><div class="summary"><div class="message__header user">hexirp</div><div class="message__timestamp date"><a class="date" href="#message-1584148905.100300">2020-03-14&nbsp;10:21:45 +0900</a></div></div><div class="message__body description"><a href='https://github.com/haskell/bytestring/blob/95fe6bdf13c9cc86c1c880164f7844d61d989574/Data/ByteString/Builder/Internal.hs#L438-L456'>https://github.com/haskell/bytestring/blob/95fe6bdf13c9cc86c1c880164f7844d61d989574/Data/ByteString/Builder/Internal.hs#L438-L456</a><br/>あー、なるほど。ありがとうございました！</div></div></div><div class="message event" id="message-1584159088.100800"><div class="content"><div class="summary"><div class="message__header user">call_magic</div><div class="message__timestamp date"><a class="date" href="#message-1584159088.100800">2020-03-14&nbsp;13:11:28 +0900</a></div></div><div class="message__body description">@call_magic has joined the channel</div></div></div><div class="message event" id="message-1584191331.101100"><div class="content"><div class="summary"><div class="message__header user">info693</div><div class="message__timestamp date"><a class="date" href="#message-1584191331.101100">2020-03-14&nbsp;22:08:51 +0900</a></div></div><div class="message__body description">@info693 has joined the channel</div></div></div><div class="message event" id="message-1584212837.101300"><div class="content"><div class="summary"><div class="message__header user">haskellcoding29</div><div class="message__timestamp date"><a class="date" href="#message-1584212837.101300">2020-03-15&nbsp;04:07:17 +0900</a></div></div><div class="message__body description">@haskellcoding29 has joined the channel</div></div></div><div class="message event" id="message-1584489695.102200"><div class="content"><div class="summary"><div class="message__header user">zionian693</div><div class="message__timestamp date"><a class="date" href="#message-1584489695.102200">2020-03-18&nbsp;09:01:35 +0900</a></div></div><div class="message__body description">@zionian693 has joined the channel</div></div></div><div class="message event" id="message-1584574648.104600"><div class="content"><div class="summary"><div class="message__header user">shunsuke.masuda</div><div class="message__timestamp date"><a class="date" href="#message-1584574648.104600">2020-03-19&nbsp;08:37:28 +0900</a></div></div><div class="message__body description">お久しぶりです。<br/>指定した時刻までスレッドを休止してくれる関数をご存知ですか？<br/>threadDelayは、指定した時間間隔になりますが、例えば毎分０５秒に処理をしたい、というような場合は「次の分の０５秒　ー　現在時刻」の秒数を計算してセットしてあげる必要があります。</div></div></div><div class="message event" id="message-1584574673.105200"><div class="content"><div class="summary"><div class="message__header user">shunsuke.masuda</div><div class="message__timestamp date"><a class="date" href="#message-1584574673.105200">2020-03-19&nbsp;08:37:53 +0900</a></div></div><div class="message__body description">それでもよいのですが、既存の関数があれば使いたいです。</div></div></div><div class="message event" id="message-1584574907.105300"><div class="content"><div class="summary"><div class="message__header user">igrep</div><div class="message__timestamp date"><a class="date" href="#message-1584574907.105300">2020-03-19&nbsp;08:41:47 +0900</a></div></div><div class="message__body description"><a href='https://hackage.haskell.org/package/cron-0.6.2/docs/System-Cron-Schedule.html'>https://hackage.haskell.org/package/cron-0.6.2/docs/System-Cron-Schedule.html</a> が割とメンテされている方です。<br/>ただこれ、もともとcronの時刻指定の文字列をパースするという目的のパッケージだったためか、単に「指定した時刻に実行する」という目的にはオーバーキルなんですよねぇ :confused:<br/>なので、実はちょうど私も同じようなニーズがあったこともあり、一部の関数をexportするよう提案しています。<br/><a href='https://github.com/MichaelXavier/cron/issues/43'>https://github.com/MichaelXavier/cron/issues/43</a></div></div></div><div class="message event" id="message-1584658781.105800"><div class="content"><div class="summary"><div class="message__header user">U0100JBRCFL</div><div class="message__timestamp date"><a class="date" href="#message-1584658781.105800">2020-03-20&nbsp;07:59:41 +0900</a></div></div><div class="message__body description">@U0100JBRCFL has joined the channel</div></div></div></div><div class="pager ui pagination menu"><a href="../../html/C5666B6BB/80.html" class="pager__previous item">Previous</a><a href="../../" class="pager__top item">Top</a></div></div></body></html>