<!DOCTYPE html><html><head><meta charset="utf-8"><title>haskell-jp / questions #64</title><link rel="stylesheet" href="/slack-log/messages.css" type="text/css" media="screen"></head><body><h1>haskell-jp / questions #64</h1><div class="pager"><a href="/slack-log/html/C5666B6BB/63.html" class="pager__previous">Previous</a><a href="/slack-log/" class="pager__top">Top</a><a href="/slack-log/html/C5666B6BB/65.html" class="pager__next">Next</a></div><div class="message_list"><div class="message" id="message-1561621843.063700"><div class="message__timestamp">2019-06-27<br/>16:50:43 +0900</div><div class="message__header">shunsuke.masuda</div><div class="message__body">こんにちは。いつもお世話になります。<br/>関数の定義で型変数を使った場合、実際にどの型が使われたかを、その関数内部で取得することはできますか？  ログ出力を目的としていて、`typeOf`を使えばよいのですが、それだと冗長になるケースがありまして、お尋ねしています。<br/><br/>以下のケースで`f`の中で`typeOf g`とすれば`String-&gt;IO [Integer]`が取れるのですが、関心があるのは <code>Integer</code> だけなので、それを取得する方法がないか探しています。<br/><br/><pre>
g::String-&gt;IO [Integer]
g = ...

f::(Eq a)=&gt;String-&gt;(String-&gt;IO [a])-&gt;IO Bool
f x g = ..   -- "Integerだよ"というメッセージを表示したい。 
</pre></div></div><div class="message" id="message-1561621997.063800"><div class="message__timestamp">2019-06-27<br/>16:53:17 +0900</div><div class="message__header">igrep</div><div class="message__body"><code>g</code> を実行した後だけになっちゃいますが、 <code>typeOf &lt;$&gt; g x</code> すればよいのではないかと。</div></div><div class="message" id="message-1561622154.064000"><div class="message__timestamp">2019-06-27<br/>16:55:54 +0900</div><div class="message__header">igrep</div><div class="message__body">あるいは、 <code>funResultTy</code> やその辺りの関数を使えばできそうです（詳細確認中）。<br/><a href='https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Typeable.html#v:funResultTy'>https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Typeable.html#v:funResultTy</a><br/>おそらくこっちがより正当な方法でしょうね。。。</div></div><div class="message" id="message-1561622372.064200"><div class="message__timestamp">2019-06-27<br/>16:59:32 +0900</div><div class="message__header">igrep</div><div class="message__body"><code>funResultTy</code> の第2引数はなんなんだろう、と思ったら、引数の型を表すみたいです。<br/>GHCiで試したところ :point_down: となってました。<br/><br/><pre>
&gt; import Data.Typeable
&gt; import Data.Proxy
&gt; funResultTy (typeRep (Proxy :: Proxy (String -&gt; IO [Integer]))) (typeRep (Proxy :: Proxy String))
Just (IO [Integer])
</pre></div></div><div class="message" id="message-1561622671.064700"><div class="message__timestamp">2019-06-27<br/>17:04:31 +0900</div><div class="message__header">ishaninaritaina623</div><div class="message__body">@ishaninaritaina623 has joined the channel</div></div><div class="message" id="message-1561622900.064900"><div class="message__timestamp">2019-06-27<br/>17:08:20 +0900</div><div class="message__header">as_capabl</div><div class="message__body">Typeableを使って良いならば、ScopedTypeVariableを使って書けます。<br/><br/><pre>
{-# LANGUAGE ScopedTypeVariables #-}
...
f :: forall a. (Typeable a, Eq a) =&gt; String -&gt; (String-&gt;IO [a]) -&gt; IO Bool
f _ _ =
  do
    print $ typeOf (undefined :: a)
    return True
</pre></div></div><div class="message" id="message-1561623233.065700"><div class="message__timestamp">2019-06-27<br/>17:13:53 +0900</div><div class="message__header">as_capabl</div><div class="message__body">undefinedはダサいので <code>typeRep (Proxy :: Proxy a)</code> としたり、さらにTypeApplicationsを有効にして <code>typeRep (Proxy @a) </code> にするともっと良さそうです</div></div><div class="message" id="message-1561626075.066100"><div class="message__timestamp">2019-06-27<br/>18:01:15 +0900</div><div class="message__header">minorinoki_haskjp</div><div class="message__body">いずれにせよ <code>Typeable a</code> は必要ですね。 <code>Typeable</code> 制約のない型変数から型の名前を取得することはできないので。<br/><code>f</code> が普通の関数であれば定義を変えれば良いだけですが、型クラスのメソッドだったりするとちょっと厄介かもしれません。</div></div><div class="message" id="message-1561627141.066300"><div class="message__timestamp">2019-06-27<br/>18:19:01 +0900</div><div class="message__header">minorinoki_haskjp</div><div class="message__body">ScopedTypeVariablesを使わない方法としては<br/><pre>
fnToProxy :: (String -&gt; IO [a]) -&gt; Proxy a
fnToProxy _ = Proxy
</pre><br/>という補助関数を用意して <code>typeRep (fnToProxy g)</code> とするという手があります。</div></div><div class="message" id="message-1561637543.066500"><div class="message__timestamp">2019-06-27<br/>21:12:23 +0900</div><div class="message__header">as_capabl</div><div class="message__body">とんでもなく邪悪ですが、RULESプラグマを使って型制約の追加を回避する方法があったり……<br/><br/><pre>
printType :: Proxy a -&gt; IO ()
printType _ = putStrLn "&lt;unknown&gt;"
{-# NOINLINE printType #-}

printTypeT :: Typeable a =&gt; Proxy a -&gt; IO ()
printTypeT p = print $ typeRep p

{-# RULES
"T-String" forall (p::Proxy String). printType p = printTypeT p
"T-Integer" forall (p::Proxy Integer). printType p = printTypeT p
#-}
{-以下来そうな型を列挙-}

f :: forall a. Eq a =&gt; String -&gt; (String-&gt;IO [a]) -&gt; IO Bool
f _ _ =
 do
   printType (Proxy :: Proxy a)
   return True
</pre></div></div><div class="message" id="message-1561675035.069700"><div class="message__timestamp">2019-06-28<br/>07:37:15 +0900</div><div class="message__header">igrep</div><div class="message__body">この件、まだ試せてないのですが思いつきました。<br/>Template Haskellをコンパイル時ではなく実行時に実行すればできるはずです。 <code>Q</code> モナドは <code>runQ</code> 関数で <code>IO</code> に変換できるので。<br/>プロファイリングもできるはず。</div></div><div class="message" id="message-1561706911.070500"><div class="message__timestamp">2019-06-28<br/>16:28:31 +0900</div><div class="message__header">shunsuke.masuda</div><div class="message__body">みなさん、ありがとうございいました。<br/><br/>今回は、 @as_capabl さんの、 <code>typeRep (Proxy :: Proxy a)</code>  の方法で対応することにしました。<br/><br/><code>typeOf (undefined :: a)</code> は、hlint 2.1では何もいわれなかったのですが、2.2に上げたら、  <code>typeRep (Proxy :: Proxy a)</code>  をサジェスチョンしてきました。</div></div><div class="message" id="message-1561781497.071100"><div class="message__timestamp">2019-06-29<br/>13:11:37 +0900</div><div class="message__header">kl459</div><div class="message__body">@kl459 has joined the channel</div></div><div class="message" id="message-1561807775.071400"><div class="message__timestamp">2019-06-29<br/>20:29:35 +0900</div><div class="message__header">kakinouchi_6283</div><div class="message__body">@kakinouchi_6283 has joined the channel</div></div><div class="message" id="message-1561823512.071800"><div class="message__timestamp">2019-06-30<br/>00:51:52 +0900</div><div class="message__header">ueno.denshi.kobo</div><div class="message__body">@ueno.denshi.kobo has joined the channel</div></div><div class="message" id="message-1561858731.072100"><div class="message__timestamp">2019-06-30<br/>10:38:51 +0900</div><div class="message__header">kakkun61</div><div class="message__body">お願いします <a href='https://stackoverflow.com/questions/56821863/what-should-feed-for-pattern-synonyms-types-of-complete-pragma'>https://stackoverflow.com/questions/56821863/what-should-feed-for-pattern-synonyms-types-of-complete-pragma</a></div></div><div class="message" id="message-1561947676.072600"><div class="message__timestamp">2019-07-01<br/>11:21:16 +0900</div><div class="message__header">kakkun61</div><div class="message__body">日本人主語抜かしがち</div></div><div class="message" id="message-1561989232.072900"><div class="message__timestamp">2019-07-01<br/>22:53:52 +0900</div><div class="message__header">3m2dyzxu</div><div class="message__body">@3m2dyzxu has joined the channel</div></div><div class="message" id="message-1562035365.073500"><div class="message__timestamp">2019-07-02<br/>11:42:45 +0900</div><div class="message__header">gettaplacetogo</div><div class="message__body">@gettaplacetogo has joined the channel</div></div><div class="message" id="message-1562042607.073700"><div class="message__timestamp">2019-07-02<br/>13:43:27 +0900</div><div class="message__header">kakkun61</div><div class="message__body">やはり多相な型は書けなかった。<br/>ただし、単相な型を複数書くことが許されてた。<br/>でも、孤児プラグマはダメだった。<br/><code>Single</code> クラスとインスタンスの <code>Only</code> をパッケージ分けようとしてたのにな。<br/><pre>
{-# COMPLETE Single :: Only #-}
{-# COMPLETE Single :: Identity #-}
</pre></div></div><div class="message" id="message-1562136295.074200"><div class="message__timestamp">2019-07-03<br/>15:44:55 +0900</div><div class="message__header">addokoda</div><div class="message__body">@addokoda has joined the channel</div></div><div class="message" id="message-1562163345.074500"><div class="message__timestamp">2019-07-03<br/>23:15:45 +0900</div><div class="message__header">cojna.slack</div><div class="message__body">@cojna.slack has joined the channel</div></div><div class="message" id="message-1562201404.075500"><div class="message__timestamp">2019-07-04<br/>09:50:04 +0900</div><div class="message__header">shunsuke.masuda</div><div class="message__body">みなさんこんにちは。<br/>以下のようなコードで、 “process” 関数の型を変えずに “server”関数の結果をキャッシュするような方法はありますか？<br/>IOモナドが登場するのは “server”関数のが原因なので、どうせなら “server”関数内部でキャッシュを実現したい。<br/>[CachedIO](<http://hackage.haskell.org/package/cached-io-1.1.0.0/docs/Control-Concurrent-CachedIO.html>)というパッケージをみましたが、これは <code>cachedIO</code> でIOアクションを包んでキャッシュを実現するもので、 <code>cachedIO</code> そのものを、関数呼び出しをまたがって、誰かがが保持していないといけないので、ちょっと違いました。<br/><br/><pre>
module Main where

import           Control.Monad (forM_)

main :: IO ()
main = forM_ [1..] $ \_ -&gt;
  do putStrLn "[Enter your key]"
     key &lt;- getLine
     process key &gt;&gt;= putStrLn

process::String-&gt;IO String
process key = do
  ret &lt;- server key
  return $ if ret then "Success" else "Failure"

server::String-&gt;IO Bool
-- ^このIOアクションの引数ー結果をキャッシュしたい。
server key
  | key == "ABC" = putStrLn "Accessing heavy resource." &gt;&gt; return True
  | otherwise = putStrLn "Yet another heavy resource access." &gt;&gt; return False
</pre></div></div><div class="message" id="message-1562206217.076100"><div class="message__timestamp">2019-07-04<br/>11:10:17 +0900</div><div class="message__header">kakkun61</div><div class="message__body">可変なハッシュテーブルでいけそうかと思いましたけど、それを渡さないといけませんね……<br/>unsafe な関数でグローバルな可変参照作れば何とかなるでしょうが、おすすめしません。</div></div><div class="message" id="message-1562209769.076300"><div class="message__timestamp">2019-07-04<br/>12:09:29 +0900</div><div class="message__header">igrep</div><div class="message__body">おっしゃるとおり <code>unsafePerformIO</code> を使わない限り無理かと思います。<br/>そういう、「すべての関数が意識するべきでない値」は、いわゆるReaderT IOパターンで隠すのが得策かと。<br/><br/><code>IORef (HashMap String Bool)</code> みたいな型を <code>Env</code> に含める形になるでしょう。<br/>更新時は <code>atomicModifyIORef'</code> を使うのを忘れずに！</div></div><div class="message" id="message-1562218706.076700"><div class="message__timestamp">2019-07-04<br/>14:38:26 +0900</div><div class="message__header">ncaq</div><div class="message__body">最近そういうことしたかったのでファイルにシリアライズしてぶちこみました<br/><a href='https://github.com/ncaq/dic-nico-intersection-pixiv/blob/d5f240c3f4bdcb657c5c852b77b42d3a292c1abe/src/Main.hs#L94'>https://github.com/ncaq/dic-nico-intersection-pixiv/blob/d5f240c3f4bdcb657c5c852b77b42d3a292c1abe/src/Main.hs#L94</a></div></div><div class="message" id="message-1562223631.077200"><div class="message__timestamp">2019-07-04<br/>16:00:31 +0900</div><div class="message__header">shunsuke.masuda</div><div class="message__body">@ncaq さんの例をみて思いついたのですが、私の場合はキャッシュさせたいデータが少量なので、`setEnv` で環境変数を使ってキャッシュさせる方法もありそうです。使い方として筋悪な気がする一方、もともとキャッシュさせたいデータが、環境変数の外部化みたいなものなので、意味的にそれほど遠いわけでもない。</div></div><div class="message" id="message-1562242132.077400"><div class="message__timestamp">2019-07-04<br/>21:08:52 +0900</div><div class="message__header">yharuhi39</div><div class="message__body"><code>StateVar</code> 使うとかどうなんでしょうかね。並列アクセスは。明記されてないのでなんとも言えませんが少なくとも <code>unsafePeformIO</code> を直接使うよりは安全そう？？ （とはいえ私も <code>IORef</code> を使うとは思いますが）</div></div><div class="message" id="message-1562244867.077900"><div class="message__timestamp">2019-07-04<br/>21:54:27 +0900</div><div class="message__header">takumi8819</div><div class="message__body">@takumi8819 has joined the channel</div></div><div class="message" id="message-1562324288.078100"><div class="message__timestamp">2019-07-05<br/>19:58:08 +0900</div><div class="message__header">kakkun61</div><div class="message__body">これ最外型構築子を書くような気がしてきた</div></div><div class="message" id="message-1562395856.078400"><div class="message__timestamp">2019-07-06<br/>15:50:56 +0900</div><div class="message__header">shin.harad</div><div class="message__body">@shin.harad has joined the channel</div></div><div class="message" id="message-1562489774.079400"><div class="message__timestamp">2019-07-07<br/>17:56:14 +0900</div><div class="message__header">niceage6690</div><div class="message__body">@niceage6690 has joined the channel</div></div><div class="message" id="message-1562569514.079800"><div class="message__timestamp">2019-07-08<br/>16:05:14 +0900</div><div class="message__header">trigger-happy</div><div class="message__body">@trigger-happy has joined the channel</div></div><div class="message" id="message-1562667584.082400"><div class="message__timestamp">2019-07-09<br/>19:19:44 +0900</div><div class="message__header">junji.hashimoto</div><div class="message__body">既出だったらすみません<br/>cabal v2 testでghcの環境変数のセットアップがうまくいかなくてパッケージが読み込めないエラーがでて<br/>doctestが使えないですがどうされてますか？</div></div><div class="message" id="message-1562667646.083700"><div class="message__timestamp">2019-07-09<br/>19:20:46 +0900</div><div class="message__header">junji.hashimoto</div><div class="message__body">本家にもissueはあがってますが<br/>はやく使いたいのです</div></div><div class="message" id="message-1562667688.084500"><div class="message__timestamp">2019-07-09<br/>19:21:28 +0900</div><div class="message__header">junji.hashimoto</div><div class="message__body">そもそもdoctestは人気がないのでしょうか</div></div><div class="message" id="message-1562668488.085100"><div class="message__timestamp">2019-07-09<br/>19:34:48 +0900</div><div class="message__header">syocy</div><div class="message__body">自分が半年前に cabal new build でプロジェクトを作ったときは doctest は動いていたのですが最近動かなくなったのでしょうか。 <a href='https://github.com/syocy/xorshift-plus/blob/master/tests/doctest/Main.hs'>https://github.com/syocy/xorshift-plus/blob/master/tests/doctest/Main.hs</a></div></div><div class="message" id="message-1562668600.087300"><div class="message__timestamp">2019-07-09<br/>19:36:40 +0900</div><div class="message__header">junji.hashimoto</div><div class="message__body">わからないですね<br/>一度でもv1で動かすと状態が残って通るばあいもあってよくわからないですね</div></div><div class="message" id="message-1562715481.088200"><div class="message__timestamp">2019-07-10<br/>08:38:01 +0900</div><div class="message__header">maoe</div><div class="message__body">cabal-installのバージョン等がわからないのでなんとも言えませんが <code>--write-ghc-environment-files=never</code> がデフォルトになった影響かもしれません。<https://github.com/haskell/cabal/issues/4542></div></div><div class="message" id="message-1562730323.088800"><div class="message__timestamp">2019-07-10<br/>12:45:23 +0900</div><div class="message__header">maoe</div><div class="message__body">あとは常にcabal test経由でいいのであれば <a href='http://hackage.haskell.org/package/cabal-doctest'>http://hackage.haskell.org/package/cabal-doctest</a> を使うという手もあります。cabal的にはcustom setupは非推奨っぽいのでネイティブでdoctestに対応してくれると良いのですが。。。</div></div><div class="message" id="message-1562732546.089100"><div class="message__timestamp">2019-07-10<br/>13:22:26 +0900</div><div class="message__header">ncaq</div><div class="message__body">私は｢そもそもアプリケーションだからドキュメントテストなんて必要なかった｣と気がついてテストをhspecに移動させてしまいましたね</div></div><div class="message" id="message-1562740680.089400"><div class="message__timestamp">2019-07-10<br/>15:38:00 +0900</div><div class="message__header">hato2000</div><div class="message__body">@hato2000 has joined the channel</div></div><div class="message" id="message-1562740749.089700"><div class="message__timestamp">2019-07-10<br/>15:39:09 +0900</div><div class="message__header">statiolake</div><div class="message__body">@statiolake has joined the channel</div></div><div class="message" id="message-1562817505.090200"><div class="message__timestamp">2019-07-11<br/>12:58:25 +0900</div><div class="message__header">junji.hashimoto</div><div class="message__body">ありがとうございます<br/>確認します</div></div><div class="message" id="message-1562848999.091400"><div class="message__timestamp">2019-07-11<br/>21:43:19 +0900</div><div class="message__header">deltalphan</div><div class="message__body">@deltalphan has joined the channel</div></div><div class="message" id="message-1562914026.091800"><div class="message__timestamp">2019-07-12<br/>15:47:06 +0900</div><div class="message__header">e2fde7ded7anxbne05se</div><div class="message__body">@e2fde7ded7anxbne05se has joined the channel</div></div><div class="message" id="message-1562946424.092100"><div class="message__timestamp">2019-07-13<br/>00:47:04 +0900</div><div class="message__header">tos.lunar</div><div class="message__body">@tos.lunar has joined the channel</div></div><div class="message" id="message-1563154547.097400"><div class="message__timestamp">2019-07-15<br/>10:35:47 +0900</div><div class="message__header">yharuhi39</div><div class="message__body">質問なのですが cabal で ghc-optionsをコマンドライン引数で渡す方法ってありますかね？ といいますのも。 私はよく-fno-codeを使うのですが、これを渡す方法がなくcabal ファイルにフラグとしてNoCodeみたいなのを用意してそれが有効なときに ghc-options に加えるみたいなことをしているのですが全く同じライブラリが二重でインストールされるのは辛いです。 確かに生成される型情報が違う可能性は0ではないですが。。。</div></div><div class="message" id="message-1563157133.097500"><div class="message__timestamp">2019-07-15<br/>11:18:53 +0900</div><div class="message__header">fumieval</div><div class="message__body"><code>cabal new-build --ghc-options="-fno-code"</code> のようにして渡せるので、それが一番手っ取り早いと思います</div></div><div class="message" id="message-1563160458.097800"><div class="message__timestamp">2019-07-15<br/>12:14:18 +0900</div><div class="message__header">yharuhi39</div><div class="message__body">知りませんでした。。。</div></div></div><div class="pager"><a href="/slack-log/html/C5666B6BB/63.html" class="pager__previous">Previous</a><a href="/slack-log/" class="pager__top">Top</a><a href="/slack-log/html/C5666B6BB/65.html" class="pager__next">Next</a></div></body></html>