[
    {
        "ts": "1760848332.180029",
        "text": "山本悠滋です。\n今日は <https://shinjukugyoen.connpass.com/event/371150/> に参加しているので、合間にいつもどおりmakeMistakesToLearnHaskellの続きを進められていたらします。",
        "type": "message",
        "user": "U4LGTMTMK"
    },
    {
        "ts": "1760864420.240629",
        "text": "",
        "type": "message",
        "user": null
    },
    {
        "ts": "1760865294.201419",
        "text": "先週行った、rename 関数 case 式対応の確認をしていました。\n確認したいテストケースを rename 関数に渡す方法の試行錯誤や、渡して処理した結果の正否確認に手間取ってしまいました。\n確認した結果、実装内容が間違っていたことがわかり、修正を行い何とか正しい結果が得られるようになりました。\nEx.6.4 の問題文を見ると、freeVars_case, abstract_case, collectSCs_case の定義を与えてテストするようにとありましたが、\ncollectSCs_e 関数は case 式に最初から対応済みのようで、case 式を含むコア言語プログラムのラムダリフティングも一応できましたので、\nこの問題はひとまず完了とさせていただこうと思います。",
        "type": "message",
        "user": "U04BD6ZFKQ8"
    },
    {
        "ts": "1760865302.002589",
        "text": "Competitive Programming in Haskell: Tree path decomposition, part I: 読了　先々週の課題の２つ目 \"Factor-Full Tree\" の解説のその１　続きが来週にあるとのことで　難度が今まで最高の Difficulty: Hard 7.4 なので　さすがに最終解決までに２回を掛けるらしい　自分の解は「異なる素数を各枝に配する」ものであって WA (testcase 7/36) 判定でした　まさしく解説のとおり木の枝数が長い path がある場合に label が integer overflow になってしまうからで　いろいろ模索しても解けなかった　想定解は来週までお預け　加えて類似問題２問を与えられてしまう　トホホ．．．　出直します",
        "type": "message",
        "user": "U584T7GAH"
    },
    {
        "ts": "1760869742.728419",
        "text": "電車の中などでmakeMistakesToLearnHaskellを進めてました。\n<https://github.com/haskell-jp/makeMistakesToLearnHaskell/commit/50aafbc8965053754841e1e8e657ef4f44c860cc>",
        "type": "message",
        "user": "U4LGTMTMK"
    },
    {
        "ts": "1760871592.356479",
        "text": "書籍: 関数型プログラミング実践入門を読みつつ、手を動かせました。\n特にフィボナッチ数列で遊んでHaskellすげぇぇ!となりました。\n一応Qiitaにもまとめておいたので、よりエレガントな実装とかあれば教えてください!\n\n<https://qiita.com/sigma_devsecops/items/24e05b6248b717aa4067>",
        "type": "message",
        "user": "U09ME60J23W"
    },
    {
        "ts": "1761451222.021999",
        "text": "",
        "type": "message",
        "user": null
    },
    {
        "ts": "1761451650.233949",
        "text": "<https://byorgey.github.io/blog/posts/2024/08/08/TreeDecomposition.html|Competitive Programming in Haskell: Tree path decomposition, part II>:  Brent Yorgey 先生の blog をもとに Kattis の問題を解きます",
        "type": "message",
        "user": "U584T7GAH"
    },
    {
        "ts": "1761452605.852289",
        "text": "S.K.です。ちょっと遅くなってしまいましたが、今週もお世話になります。よろしくお願いいたします。\n今週も Implementing Functional Languages: a tutorial の Chapter 6 Lambda Lifting の続きを進めて行こうと思います。",
        "type": "message",
        "user": "U04BD6ZFKQ8"
    },
    {
        "ts": "1761464164.391099",
        "text": "山本悠滋です。昼寝などしていて遅くなってしまいましたが、いつもどおりmakeMistakesToLearnHaskellやHaskell-jp Blogの続きをします。",
        "type": "message",
        "user": "U4LGTMTMK"
    },
    {
        "ts": "1761469205.099199",
        "text": "",
        "type": "message",
        "user": null
    },
    {
        "ts": "1761469348.013969",
        "text": "makeMistakesToLearnHaskellの進捗: <https://github.com/haskell-jp/makeMistakesToLearnHaskell/commit/a9ccbc1eddb3622c0157d8f3a37f884e0b53920f>\n課題15はやっぱ長い...",
        "type": "message",
        "user": "U4LGTMTMK"
    },
    {
        "ts": "1761469376.982839",
        "text": "Haskell-jp Blogの続きも延長戦で少しはします。",
        "type": "message",
        "user": "U4LGTMTMK"
    },
    {
        "ts": "1761470439.686799",
        "text": "Ex.6.5 に対応中です。\nテキストに載っていた例を含む次のテストプログラム\n\nf = \\\\x. x+1;\nmain = f 4\n\nの動作確認結果を元に方針を決めて実装中です。\n時間がかかってしまってますが、自分に可能なペースで進めて行こうと思います。",
        "type": "message",
        "user": "U04BD6ZFKQ8"
    },
    {
        "ts": "1761472741.227309",
        "text": "Competitive Programming in Haskell: tree path decomposition, part II: 読了　先々々週の課題の２つ目 \"Factor-Full Tree\" の最終解説　木を道に分解して (pathDecomposition) その高さ順に　素数の冪を割り当てる　そうすると　それらの積がそれぞれ個別でありながら　最大でも integer overflow を起こさないようにできるとね　ナルドねぇ　これに類似して先週の課題 \"Floating Formations\" だがその困難さに匙を投げていたが　かすかに光明が見えてきた　まず biconnected components を抽出して　残りの森（木のリスト）を道に分解して　それらを高さの順に　助け舟を出せばよいのでは？　それを目指して実装中",
        "type": "message",
        "user": "U584T7GAH"
    },
    {
        "ts": "1761478880.443319",
        "text": "Haskell-jp Blogの進捗:\n- <https://github.com/haskell-jp/blog/commit/3e58bf7d4cd1bb13608110ec8739f3a163e5a663>\n- <https://github.com/haskell-jp/blog/commit/2c2802d6804959b10064ca34567c56ba595bf98a>",
        "type": "message",
        "user": "U4LGTMTMK"
    }
]