<!DOCTYPE html><html><head><meta charset="utf-8"><title>haskell-jp / questions #67</title><link rel="stylesheet" href="../../messages.css" type="text/css" media="screen"></head><body><h1>haskell-jp / questions #67</h1><div class="pager"><a href="../../html/C5666B6BB/66.html" class="pager__previous">Previous</a><a href="../../" class="pager__top">Top</a></div><div class="message_list"><div class="message" id="message-1564557369.063600"><div class="message__timestamp">2019-07-31<br/>16:16:09 +0900</div><div class="message__header">mizunashi-mana</div><div class="message__body">一応補足ですが，現在の GHC では full laziness が入るタイミングが調整されていて，<br/><pre>
factMemo :: Int -&gt; Integer
factMemo = (map fact' [0..] !!)
  where
    fact' 0 = 1
    fact' n = fromIntegral n * factMemo (n - 1)

fact :: Int -&gt; Integer
fact x = map fact' [0..] !! x
  where
    fact' 0 = 1
    fact' n = fromIntegral n * fact (n - 1)
</pre><br/>はどちらも <code>fact'</code> は外に出されます．このため， <code>map fact' [0..]</code> も CAF として扱われます． GHCi のバイトコード出すパスでは， core 2 core のパスが少し簡略化されてるので， full laziness が真面目に入ってないだけだと思いますね．<br/><br/>なので，スーパーコンビネータかどうかは指標の一つではありますが，実際にはどう最適化が入るかによって CAF になるかはかなり左右されます</div></div><div class="message" id="message-1564577136.064100"><div class="message__timestamp">2019-07-31<br/>21:45:36 +0900</div><div class="message__header">flugel428</div><div class="message__body">@flugel428 has joined the channel</div></div><div class="message" id="message-1564580251.064400"><div class="message__timestamp">2019-07-31<br/>22:37:31 +0900</div><div class="message__header">cynthia7engineer</div><div class="message__body">@cynthia7engineer has joined the channel</div></div><div class="message" id="message-1564587041.064600"><div class="message__timestamp">2019-08-01<br/>00:30:41 +0900</div><div class="message__header">y_taka_23</div><div class="message__body">Liquid Haskell について言えば、`{-@ @-}` は GHC にとっては単なるコメントなのでもっと早い段階で消えそう……な気がしますが根拠はないです。</div></div><div class="message" id="message-1564590486.066800"><div class="message__timestamp">2019-08-01<br/>01:28:06 +0900</div><div class="message__header">yharuhi39</div><div class="message__body">確かに あれはただのコメントでプラグまですらなかったですね:persevere: 雰囲気的に(?) 型が削除される以前に消されてそうですね…</div></div><div class="message" id="message-1564617187.071600"><div class="message__timestamp">2019-08-01<br/>08:53:07 +0900</div><div class="message__header">cutsea110</div><div class="message__body">はい、”外に出す”ということをコンパイラがやるかどうかはまた別ですもんね. <blockquote>真面目に入ってない</blockquote>ただ後者のfact’がxを巻き込まずに外に出せるとすると意味論的に変わっちゃわないのかなという疑問が湧いてきたんだけど…</div></div><div class="message" id="message-1564632506.072200"><div class="message__timestamp">2019-08-01<br/>13:08:26 +0900</div><div class="message__header">miau.jp</div><div class="message__body">@miau.jp has joined the channel</div></div><div class="message" id="message-1564646022.072500"><div class="message__timestamp">2019-08-01<br/>16:53:42 +0900</div><div class="message__header">jmsf0203</div><div class="message__body">@jmsf0203 has joined the channel</div></div><div class="message" id="message-1564668616.072700"><div class="message__timestamp">2019-08-01<br/>23:10:16 +0900</div><div class="message__header">mizunashi-mana</div><div class="message__body">GHC の最適化は通常 equational reasoning に基づいて行われてるので，その意味で意味論が変わるものはあまりないと思いますね (Haskell はちゃんとした formal semantics はないので，ある程度簡略化したラムダ計算の体系の元でということにはなりますが)．<br/><br/>CAF を static closure にして欲しくないという話であれば， <a href='https://stackoverflow.com/questions/6090932/how-to-make-a-caf-not-a-caf-in-haskell/6091166#6091166'>https://stackoverflow.com/questions/6090932/how-to-make-a-caf-not-a-caf-in-haskell/6091166#6091166</a> みたいな話があって，今回の場合 <code>map fact' [0..]</code> の部分を切り出して， <code>fact</code> の引数を受け取るようにして <code>NOINLINE</code> すればいいと思いますね．と，思ったんですが，<br/><pre>
fact2 :: Int -&gt; Integer
fact2 x = factMemo2 x fact' !! x
  where
    fact' 0 = 1
    fact' n = fromIntegral n * fact' (n - 1)

factMemo2 :: Int -&gt; (Int -&gt; Integer) -&gt; [Integer]
factMemo2 _ f = map f [0..]
{-# NOINLINE factMemo2 #-}
</pre><br/>みたいなのだと， w/w が入って <code>factMemo2</code> の参照が worker の方に書き換えられてしまいますね… 一応次の形式にすると <code>-O</code> ならいい感じに CAF 化を妨害できるみたいです:<br/><pre>
fact2 :: Int -&gt; Integer
fact2 x = factMemo2 (x &lt; 0) fact' !! x
  where
    fact' 0 = 1
    fact' n = fromIntegral n * fact' (n - 1)

factMemo2 :: Bool -&gt; (Int -&gt; Integer) -&gt; [Integer]
factMemo2 !_ f = map f [0..]
{-# NOINLINE factMemo2 #-}
</pre></div></div><div class="message" id="message-1564848108.073200"><div class="message__timestamp">2019-08-04<br/>01:01:48 +0900</div><div class="message__header">tamuhey</div><div class="message__body">@tamuhey has joined the channel</div></div><div class="message" id="message-1564990128.075100"><div class="message__timestamp">2019-08-05<br/>16:28:48 +0900</div><div class="message__header">igrep</div><div class="message__body">みなさんHTMLを出力するときに、どんなテンプレートエンジンを使っていますか？<br/>こちらのissue <a href='https://github.com/haskell-jp/slack-log/issues/20'>https://github.com/haskell-jp/slack-log/issues/20</a> に取り組む際の参考にしようと思います。</div></div><div class="message" id="message-1564990231.075500"><div class="message__timestamp">2019-08-05<br/>16:30:31 +0900</div><div class="message__header">lotz</div><div class="message__body">楽なんで Mustache です :raising_hand: （型の活用はあんまりできないやつですが）<br/><a href='http://hackage.haskell.org/package/stache'>http://hackage.haskell.org/package/stache</a></div></div><div class="message" id="message-1564990257.075900"><div class="message__timestamp">2019-08-05<br/>16:30:57 +0900</div><div class="message__header">igrep</div><div class="message__body">blaze-htmlとか使うからテンプレートエンジン使いません！だと今回のケースはちょっとつらい。<br/>ユーザーがカスタマイズできるように外部のテンプレートエンジンを使おう、という趣旨なので</div></div><div class="message" id="message-1564990349.076100"><div class="message__timestamp">2019-08-05<br/>16:32:29 +0900</div><div class="message__header">igrep</div><div class="message__body">Mustacheやっぱ定番ですかね。<br/>ユーザーがカスタマイズするという要件なので型が緩いのはこの際気にしません！ :muscle:<br/>起動時にテンプレートをコンパイルしてチェックする、みたいな考慮は必要でしょうね... mustacheならそれもできたはず。</div></div><div class="message" id="message-1564993898.076500"><div class="message__timestamp">2019-08-05<br/>17:31:38 +0900</div><div class="message__header">nekmatar</div><div class="message__body">@nekmatar has joined the channel</div></div><div class="message" id="message-1564998373.076700"><div class="message__timestamp">2019-08-05<br/>18:46:13 +0900</div><div class="message__header">matsubara0507</div><div class="message__body">blaze-html はテンプレートエンジンとはまた違うか :tashikani:</div></div><div class="message" id="message-1565050460.077000"><div class="message__timestamp">2019-08-06<br/>09:14:20 +0900</div><div class="message__header">as_capabl</div><div class="message__body">関連議論を全部は追い切れていないのですが、再コンパイルが問題であるなら、現状の仕組みをrunghcで動かすのはどうでしょうか？</div></div><div class="message" id="message-1565051059.077200"><div class="message__timestamp">2019-08-06<br/>09:24:19 +0900</div><div class="message__header">as_capabl</div><div class="message__body">Dhallもテンプレートエンジンとして使える事を謳っているのですが、現状パフォーマンスがすこぶる悪いのが難点です <a href='http://www.haskellforall.com/2017/06/dhall-is-now-template-engine.html'>http://www.haskellforall.com/2017/06/dhall-is-now-template-engine.html</a></div></div><div class="message" id="message-1565054059.077800"><div class="message__timestamp">2019-08-06<br/>10:14:19 +0900</div><div class="message__header">igrep</div><div class="message__body">我々だけでなく、ほかのSlack Workspaceの管理者も使えるように、実行ファイルのリリースも視野に入れているので、runghcだとちとつらいですね...<br/><a href='https://github.com/haskell-jp/slack-log/issues/22'>https://github.com/haskell-jp/slack-log/issues/22</a></div></div><div class="message" id="message-1565083258.080300"><div class="message__timestamp">2019-08-06<br/>18:20:58 +0900</div><div class="message__header">igrep</div><div class="message__body"><a href='https://qiita.com/autotaker1984/items/5ec0bbd5a44e146dbada'>https://qiita.com/autotaker1984/items/5ec0bbd5a44e146dbada</a> を読んでいて気になったのですが、<br/>リストリテラル <code>[1, 2, 3]</code> が <code>build  (\c n -&gt; c 1 (c 2 (c 3 n)))</code> に変換されるというルールはどこに載っているでしょうか？<br/>baseパッケージのGHC.List moduleやGHC.Base moduleを探してみましたが見つかりませんでした。<br/>きっとコンパイラーのどこかの層に組み込まれているから、librariesの方を見てもわからないってことですよね...</div></div><div class="message" id="message-1565089371.080600"><div class="message__timestamp">2019-08-06<br/>20:02:51 +0900</div><div class="message__header">mizunashi-mana</div><div class="message__body">一応 <a href='https://gitlab.haskell.org/ghc/ghc/blob/ghc-8.6.5-release/compiler/deSugar/DsExpr.hs#L837'>https://gitlab.haskell.org/ghc/ghc/blob/ghc-8.6.5-release/compiler/deSugar/DsExpr.hs#L837</a> の部分がそうです。リテラルは Haskell レベルだといじれないので通常は脱糖で扱われることになりますね</div></div><div class="message" id="message-1565245599.082900"><div class="message__timestamp">2019-08-08<br/>15:26:39 +0900</div><div class="message__header">t.mitsuchi3</div><div class="message__body">リスト、木、グラフみたいな基本的なデータ構造のうえでの、ソートとか探索とかの基本的なアルゴリズムについて Haskell でのコードをまとめたサイトとか本はなにかありますか？</div></div><div class="message" id="message-1565245790.083100"><div class="message__timestamp">2019-08-08<br/>15:29:50 +0900</div><div class="message__header">igrep</div><div class="message__body">ぱっと思いつくのは <a href='https://scrapbox.io/haskell-shoen/%E3%83%AC%E3%82%B7%E3%83%94%E9%9B%86'>https://scrapbox.io/haskell-shoen/%E3%83%AC%E3%82%B7%E3%83%94%E9%9B%86</a> と <a href='https://wiki.haskell.jp/%E3%83%87%E3%83%BC%E3%82%BF%E6%A7%8B%E9%80%A0%E5%88%97%E4%BC%9D'>https://wiki.haskell.jp/%E3%83%87%E3%83%BC%E3%82%BF%E6%A7%8B%E9%80%A0%E5%88%97%E4%BC%9D</a> ですが、前者は建設中っぽいし後者はデータ構造そのものの紹介で操作については言及してないしなぁ...</div></div><div class="message" id="message-1565246125.083500"><div class="message__timestamp">2019-08-08<br/>15:35:25 +0900</div><div class="message__header">t.mitsuchi3</div><div class="message__body">ありがとうございます！</div></div><div class="message" id="message-1565246591.083700"><div class="message__timestamp">2019-08-08<br/>15:43:11 +0900</div><div class="message__header">t.mitsuchi3</div><div class="message__body">なかなかまとまってる資料が見当たらず、いまのところは Data.Tree とか Data.Graph とかのソースを読んでいます。</div></div></div><div class="pager"><a href="../../html/C5666B6BB/66.html" class="pager__previous">Previous</a><a href="../../" class="pager__top">Top</a></div></body></html>