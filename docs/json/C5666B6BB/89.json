[
    {
        "ts": "1596815300.200700",
        "text": "Haskell の `head` / `tail` は単連結リストの言葉ですね。Haskell のリストはそのまま単連結リストなので、単連結リストの先頭を示す `head` とそれ以降を示す `tail` という言葉を関数名にそのまま流用したものです。\n\n確かにコマンドの `head` / `tail` を想定すると、ギョッとする命名かもしれませんね",
        "user": "U57D08Z9U",
        "type": "message"
    },
    {
        "ts": "1596848095.201100",
        "text": "ちなみに、 `head :: [a] -&gt; Int -&gt; [a]` に相当するものとして `take` があります（引数の順番は逆なので注意）。\nそれを使って `first` みたいなものを作れば良かったんじゃない、という意図なのかも知れませんが。",
        "user": "U4LGTMTMK",
        "type": "message"
    },
    {
        "ts": "1596863604.208500",
        "text": "`head` はなくてはならないものかというと必ずしもそういうことはなくて、 `xs :: [a]` について、 `let (hd:tl) = xs in (hd,tlを使った式)` とすれば先頭の要素とそれ以外を取り出せます。",
        "user": "U61BA2X0U",
        "type": "message"
    },
    {
        "ts": "1596871961.208700",
        "text": "ご回答ありがとうございます。\n\n<@U57D08Z9U>\n単連結リストは日本語でいうところの単方向リスト(Singly linked list)でしょうか？\n\n<@U4LGTMTMK>\n少し話が逸れますが、 `take` がその順番になってる理由は、取る数よりリストの方が適用する種類が多いからそうなってるんでしょうか？",
        "user": "U7YMV774J",
        "type": "message"
    },
    {
        "ts": "1596873824.208900",
        "text": "はい、そうだと思います。",
        "user": "U4LGTMTMK",
        "type": "message"
    },
    {
        "ts": "1596892952.216500",
        "text": "LensのPrismの使い方について質問です\nPrismを `set`や `over`で `ASetter` として使えることは分かったのですが、Prismの中身に `Lens`を使用してアクセスしたいと思った時にやり方がわかりません。(例を下に載せます)\n現在は↓の `makeBelongTo` のようにしているものの、Characterの値コンストラクタが変わったら変更しなくてはいけなくなり、じゃあPrismにしたメリットないのでは、と悩んでいます。\n```data Character = Animal {\n                    _name  :: String\n                  , _age  :: Int\n                  , _memberOf :: Maybe String\n                  }\n               | Object {\n                    _name :: String\n                  , _memberOf :: Maybe String\n                  }\n              deriving (Show)\n\nmakePrisms ''Character\nmakeLenses ''Character\n\n-- この関数を\nmakeBelengTo :: String -&gt; Character -&gt; Character\nmakeBelengTo belongTo c@(Animal n a _) = Animal n a (Just belongTo)\nmakeBelengTo belongTo c@(Object n _)   = Object n (Just belongTo)\n\n-- こんな感じにしたい(これだと動かない)\nmakeBelongToWithLens :: String -&gt; Character -&gt; Character\nmakeBelongToWithLens belongTo = set (_Animal.memberOf) (Just belongTo)\n                              . set (_Object.memberOf) (Just belongTo)```\nまた、\n```set (_Animal._3) (Just belongTo)```\nのような解法は見つけたのですが、結局タプルの位置を指定しているためこれならPrismのメリットがないな…と思っています。",
        "user": "ULTBB86UC",
        "type": "message"
    },
    {
        "ts": "1596920248.216800",
        "text": "外泊中なので試せないのですが、普通に `set memberOf (Just belongTo)` か `c{_memberOf=Just belongTo}`で行けないでしょうか。",
        "user": "U570660KX",
        "type": "message"
    },
    {
        "ts": "1596950153.217000",
        "text": "あっ確かに…\n実際に書いているコードでLensの名前が違ったのでこんな書き方にしていましたが、よく考えたら同じ名前にすれば大丈夫でした…(違う名前にする必要がなかったです)\nそれを元にして考えたら他の部分もうまく行きました！ありがとうございます",
        "user": "ULTBB86UC",
        "type": "message"
    },
    {
        "ts": "1597058715.217300",
        "text": "<@U018KEA7Y83> has joined the channel",
        "user": "U018KEA7Y83",
        "type": "message"
    },
    {
        "ts": "1597069878.217500",
        "text": "<@U018J8X6WFP> has joined the channel",
        "user": "U018J8X6WFP",
        "type": "message"
    },
    {
        "ts": "1597078487.220600",
        "text": "megaparsec 固有の質問なのですが、`Text.Megaparsec.Char.Lexer.lineFold` ができることは同モジュールの `indentBlock` と同じなんでしょうか？`indentBlock` でできなくて `lineFold` ならできることがある？単に書き味の違い？\n\nHackage\n• <https://hackage.haskell.org/package/megaparsec-8.0.0/docs/Text-Megaparsec-Char-Lexer.html#v:lineFold>\n• <https://hackage.haskell.org/package/megaparsec-8.0.0/docs/Text-Megaparsec-Char-Lexer.html#v:indentBlock>\nチュートリアル\n• <https://markkarpov.com/tutorial/megaparsec.html#indentationsensitive-parsing>",
        "user": "U4L0B71L1",
        "type": "message"
    },
    {
        "ts": "1597078851.220700",
        "text": "どっちにしろこれを使って Haskell のオフサイドルールをパースするのは難しいかなぁ。言語レポートに掲載されてるアルゴリズムと等価なパーサーになってるかの保証が難しそう。",
        "user": "U4L0B71L1",
        "type": "message"
    },
    {
        "ts": "1597215041.239900",
        "text": "`Data.Yaml` のパーサーコンビネーターの作り方について質問です\n`decodeFileEither`などで読み込んだYamlの中にあるパスをさらに読み込んでパースがしたいのですが、一度他の型を経由させる方法しか思いつかなくて迷っています。\nパーサー(`Parser a` )内部でIOを使うことは可能でしょうか(パース結果をFilePathとして、そのファイルも読みにいくことは可能でしょうか)\n`runParser` 内部にある `f` がどうにかできないのかなと思っているのですがよくわからず…\n何かいい方法があれば知りたいです…\n\n例としては:\n```data:\n  - path: foo.yaml\n    offset: (0, 1)\n  ...```\nというファイルを `decodeFileEither` で読んだ時、`foo.yaml` も読み込んで結果に含めたいです。\n\n現在は一度しか入れ子にならないため、一つ中間用の型を用意してその型に(パスはStringとして保存して)変換した後、その中にしまったパスをさらに `decodeFileEither` で読んでいます。\n\n\n```data ActualData = ActuallData ...\n\ndata IntermediateData = IntermidiateData { path :: FilePath, ... }\n\nload :: FilePath -&gt; IO (Either ParseException ActualData)\nload fp = do\n  intermediate &lt;- decodeFileEither fp\n  includedData &lt;- decodeFileEither $ path intermediate\n  return -- intermediate と includedData を使用して、ActualData を生成する```\n実際に使っている例だとこれになります。( `Face` をデコードするために、一度 `FaceFile` としてデコードした後に読み直している)\n<https://github.com/Cj-bc/faclig/blob/master/src/Graphics/Asciiart/Faclig/Types.hs#L36-L57>\n\nしかし、\n\n• 途中に他の型をできれば挟みたくない\n• 入れ子を何重にもしたいので、一度で解決できるようにしたい\nという理由があり、なんとかできないのかなと悩んでいます。",
        "user": "ULTBB86UC",
        "type": "message"
    },
    {
        "ts": "1597215389.240100",
        "text": "&gt; パーサー(`Parser a` )内部でIOを使うことは可能でしょうか\n少なくとも、これはできないと思います。\nここでの `Parser a` は <https://hackage.haskell.org/package/aeson-1.4.6.0/docs/Data-Aeson-Types.html#t:Parser> で、 IO を含まないので。",
        "user": "U56L7EVNY",
        "type": "message"
    },
    {
        "ts": "1597215514.240400",
        "text": "HKDにしてYAMLをパースした結果\nとして `Record IO` を返すようにするか、そこまでしなくとも `IO` 型の値をフィールドに含めるのはいかがでしょうか？\nHKDについては <https://qiita.com/thimura/items/85bdeeca6ced74c89478> とか  <http://fumieval.hatenablog.com/entry/2019/12/25/224329> を。",
        "user": "U4LGTMTMK",
        "type": "message"
    },
    {
        "ts": "1597215807.240700",
        "text": "同じ議論が <https://haskell-jp.slack.com/archives/C4M4TT8JJ/p1554720210064400> でもありましたね...\n確かにこのスレッドへの返信の通りreflectionパッケージを使うという手もありますね。",
        "user": "U4LGTMTMK",
        "type": "message"
    },
    {
        "ts": "1597216076.241100",
        "text": "`Record`については全く知らなかったので調べてみます！\nフィールドにIO型を含めた場合、最終的にはIOを取り外す処理は一括でできるのでしょうか…?(各フィールドの値をそれぞれ取り出す必要があるように思えているのですがそうでもない？)\nとりあえず、いただいたリンクとrefrectionを調べてみます！",
        "user": "ULTBB86UC",
        "type": "message"
    },
    {
        "ts": "1597216223.241300",
        "text": "最終的に `IO (Parser a)` みたいにできるんじゃないかな、HKD なら",
        "user": "U56L7EVNY",
        "type": "message"
    },
    {
        "ts": "1597216235.241500",
        "text": "&gt; 最終的にはIOを取り外す処理は一括でできるのでしょうか\nえぇ、その部分はbarbiesに任せられるはず。そこを一括でできるのがbarbiesの強みなので",
        "user": "U4LGTMTMK",
        "type": "message"
    },
    {
        "ts": "1597216358.241700",
        "text": "`Parser (IO a)` （もっと正確には、 `Compose Parser IO a` ）から `IO a` に変換して最終的に `Identity a` として取り出せるようになるかと。",
        "user": "U4LGTMTMK",
        "type": "message"
    },
    {
        "ts": "1597216534.241900",
        "text": "色々教えてくださりありがとうございます！\nゆっくり噛み砕いてみます",
        "user": "ULTBB86UC",
        "type": "message"
    },
    {
        "ts": "1597410968.242400",
        "text": "<@U0191KH0SA0> has joined the channel",
        "user": "U0191KH0SA0",
        "type": "message"
    },
    {
        "ts": "1598117687.000200",
        "text": "<@U019PLHJQ65> has joined the channel",
        "user": "U019PLHJQ65",
        "type": "message"
    },
    {
        "ts": "1598162532.000400",
        "text": "<@U019BASD7D0> has joined the channel",
        "user": "U019BASD7D0",
        "type": "message"
    },
    {
        "ts": "1598189810.003900",
        "text": "<@U01A1C1LQSU> has joined the channel",
        "user": "U01A1C1LQSU",
        "type": "message"
    }
]