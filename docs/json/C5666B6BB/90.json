[
    {
        "ts": "1600500174.000400",
        "text": "<@U01B0F7BE2E> has joined the channel",
        "user": "U01B0F7BE2E",
        "type": "message"
    },
    {
        "ts": "1600571689.000600",
        "text": "<@U01ALBPA1QX> has joined the channel",
        "user": "U01ALBPA1QX",
        "type": "message"
    },
    {
        "ts": "1600584709.000800",
        "text": "こんな感じの型って既存のパッケージにありますか？\n```data EList e a = End e | ECons a (EList e a)```\nリストの末尾に情報を1個付け加えたいのです。",
        "user": "U4LGTMTMK",
        "type": "message"
    },
    {
        "ts": "1600584884.000900",
        "text": "補足すると、こういう形のリストに対して、主に結合演算をしたいです。",
        "user": "U4LGTMTMK",
        "type": "message"
    },
    {
        "ts": "1600585010.001100",
        "text": "`(List a, e)` の同型ということですか？",
        "user": "U4L0B71L1",
        "type": "message"
    },
    {
        "ts": "1600585095.001300",
        "text": "だと思いますし、それでいいかな...",
        "user": "U4LGTMTMK",
        "type": "message"
    },
    {
        "ts": "1600585857.001500",
        "text": "と、思ったけど今回の問題に割と固有（でも一般化はできそう？）な気がしたので独自に作っちゃいます。詳しい事情はそのパッケージリリースしたとき書きます。",
        "user": "U4LGTMTMK",
        "type": "message"
    },
    {
        "ts": "1600587771.003600",
        "text": "This message was deleted.",
        "user": "USLACKBOT",
        "type": "message"
    },
    {
        "ts": "1600588064.003700",
        "text": "もくもく会中の独り言であれば <#CUPBC8WCE|mokumoku-online> にお願いします！ :pray:",
        "user": "U4LGTMTMK",
        "type": "message"
    },
    {
        "ts": "1600588499.003900",
        "text": "まっちがえた",
        "user": "U4L0B71L1",
        "type": "message"
    },
    {
        "ts": "1600593599.004500",
        "text": "<@U01AY5T04N9> has joined the channel",
        "user": "U01AY5T04N9",
        "type": "message"
    },
    {
        "ts": "1600609671.004600",
        "text": "`Data.List.NonEmpty` では",
        "user": "U5G2BCVBN",
        "type": "message"
    },
    {
        "ts": "1600609701.004800",
        "text": "あ，違う型なのか",
        "user": "U5G2BCVBN",
        "type": "message"
    },
    {
        "ts": "1600629095.005100",
        "text": "<@U01AYF03HHB> has joined the channel",
        "user": "U01AYF03HHB",
        "type": "message"
    },
    {
        "ts": "1600736594.005300",
        "text": "<@U01BGV3SUNM> has joined the channel",
        "user": "U01BGV3SUNM",
        "type": "message"
    },
    {
        "ts": "1600753892.005400",
        "text": "どのようなプログラムですか？Jsaddleを使っていますか？確かにghcjs の開発は停止しているそうです。GHC8.8, や8.10 はないですね。",
        "user": "U5U5RDTA4",
        "type": "message"
    },
    {
        "ts": "1600758537.005700",
        "text": "<@U01B4SYCQMR> has joined the channel",
        "user": "U01B4SYCQMR",
        "type": "message"
    },
    {
        "ts": "1600821584.000400",
        "text": "ByteString 0.11 では、内部のコンストラクタが PS から BS になり、offset フィールドがなくなります。これに伴い、foreign pointer は、必ずそのByteStringのバッファの先頭を指します。drop なんかで、バッファを共有する場合、foreign pointer がいろんなところを指すようになりますが、この方法でバッファはうまく GC できるんでしょうか？",
        "user": "U56MBRKR9",
        "type": "message"
    },
    {
        "ts": "1600826197.000500",
        "text": "```data ForeignPtr a = ForeignPtr Addr# ForeignPtrContents```\nの定義を見れば分かる通り、ForeignPtrには既にアドレスと実体を表す値(MutableByteArray#など)の二つが入っています。故にplusForeignPtrなどは安全に定義できます",
        "user": "U4KUNQF9N",
        "type": "message"
    },
    {
        "ts": "1600829656.000700",
        "text": "なるほど！ ありがとうございました。",
        "user": "U56MBRKR9",
        "type": "message"
    },
    {
        "ts": "1600845249.001000",
        "text": "<@U01B4CEG34M> has joined the channel",
        "user": "U01B4CEG34M",
        "type": "message"
    },
    {
        "ts": "1600944992.004400",
        "text": "これに関連してずっと気になっていたのですが，\n<https://haskell-jp.slack.com/archives/C5666B6BB/p1600826197000500?thread_ts=1600821584.000400&amp;cid=C5666B6BB>\n```data Finalizers\n  = NoFinalizers\n  | CFinalizers (Weak# ())\n  | HaskellFinalizers [IO ()]\n\ndata ForeignPtrContents\n  = PlainForeignPtr !(IORef Finalizers)\n  | MallocPtr      (MutableByteArray# RealWorld) !(IORef Finalizers)\n  | PlainPtr       (MutableByteArray# RealWorld)\n\ndata ForeignPtr a = ForeignPtr Addr# ForeignPtrContents```\nこの定義で，`ForeignPtr` が `IORef Finalizers` への参照を保持している理由，というか，この `Finalizer` という名前の由来がよくわからないんですよね………．GCされるときにただ捨てられるものを指して `Finalizer` とはどういうことなのか．",
        "user": "UL1HFJATE",
        "type": "message"
    },
    {
        "ts": "1600945536.004600",
        "text": "ただ捨てられる，ってのも変だな．“garbage collector (or compilers) should treat `ForeignPtrContents` specially” とか書いているのを見たことないので，ふっつーに扱われるんだろうな，と思っている，と言うのが正しい．",
        "user": "UL1HFJATE",
        "type": "message"
    },
    {
        "ts": "1600953249.007000",
        "text": "最近追加されたコメントによると、ファイナライザの登録時に `mkWeak#` を使っているのがポイントのようですね <https://gitlab.haskell.org/ghc/ghc/-/blob/a1f34d37b47826e86343e368a5c00f1a4b1f2bce/libraries/base/GHC/ForeignPtr.hs#L586|https://gitlab.haskell.org/ghc/ghc/-/blob/a1f34d37b47826e86343e368a5c00f1a4b1f2bce/libraries/base/GHC/ForeignPtr.hs#L586>",
        "user": "UGM9F7XQS",
        "type": "message"
    },
    {
        "ts": "1600956771.007400",
        "text": "mkWeak#でweak pointerを作ってcapabilityごとに保持しているweak pointerのリストに追加します。GCは参照されていないweak pointerをリストアップしてscheduleFinalizersを呼び出し、リスト中のweak pointerのfinalizerを順次呼ぶという流れだと思います。Cのfinalizerはidle GCでも呼ばれていたような記憶があります。\nmkWeak#はrts/PrimOps.cmmのstg_mkWeakzhを、scheduleFinalizersはrts/Weak.cを見ると見つかります。",
        "user": "U4M9NJ7QE",
        "type": "message"
    },
    {
        "ts": "1600998780.007600",
        "text": "Finalizer とは、対象オブジェクトを捨てるために呼び出すコードのことですね。",
        "user": "U56MBRKR9",
        "type": "message"
    },
    {
        "ts": "1601021437.007800",
        "text": "対象オブジェクトが何らかの(メモリ以外の)資源、例えばファイルハンドルを扱うものだった場合、GC でそのオブジェクトが捨てられるときにはファイルを閉じる必要があります。そのような処理をするのが finalizer です。",
        "user": "U61BA2X0U",
        "type": "message"
    }
]