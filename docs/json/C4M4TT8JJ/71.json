[
    {
        "ts": "1585282246.113400",
        "text": "<@U4MMHDSNT> 遅い反応ですが、3つの構成子の件。\ndataの直和型には、expression problemがあります。\nなので、コードを完全に自分で管理でき、後から構成子を増やすことに問題がなければ、単純にdataを使います。\nユーザが拡張する可能性があるなら、PatternSynonymsを使います。",
        "user": "U56MBRKR9",
        "type": "message"
    },
    {
        "ts": "1585292882.121600",
        "text": "```[n] := ∀ X1,...,Xn . X1 + ... + Xn \nin_n,k :: [n-1] -&gt; [n]```\nのような抽象概念があれば、\nEither つかうかどうか問題は解決しそうだと思いましたが\n実際あるのでしょうか。",
        "user": "U0108S1LS2W",
        "type": "message"
    },
    {
        "ts": "1585293157.123200",
        "text": "( dependent type をもつシステムでは、型と項の垣根がないので、普通に定義できそうですが、\nHaskell だと厳しいのだろうか。)",
        "user": "U0108S1LS2W",
        "type": "message"
    },
    {
        "ts": "1585293275.124800",
        "text": "拡張可能和みたいなのを指しているんですかね？\nライブラリーとしてはいくつか提供しているものがありますね。\n<https://hackage.haskell.org/package/extensible-0.8/docs/Data-Extensible-Sum.html> とか",
        "user": "U4LGTMTMK",
        "type": "message"
    },
    {
        "ts": "1585293339.125300",
        "text": "おおお、それです。ありがとうございます！",
        "user": "U0108S1LS2W",
        "type": "message"
    },
    {
        "ts": "1585293431.126600",
        "text": "確かに便利ではあるんですが、競合するものがいくつかあって標準もなかったり、記述が標準よりも冗長になりがちだったりで、なかなかおいそれと使おうとはならないのが悩ましいんですよねぇ :disappointed_relieved:",
        "user": "U4LGTMTMK",
        "type": "message"
    },
    {
        "ts": "1585347712.132200",
        "text": "Thanks &gt; <@U56MBRKR9>",
        "user": "U4MMHDSNT",
        "type": "message"
    },
    {
        "ts": "1585382847.148900",
        "text": "Haskell でsubtype を定義する方法ってありますか？\n例えば、NaturalNumbers `N` に対して、EvenNumbers `E` を `N` のsubtype としてユーザーが定義したいような状況です。",
        "user": "U0108S1LS2W",
        "type": "message"
    },
    {
        "ts": "1585383333.150700",
        "text": "コンパイラが型推論に部分型を用いているならば、\n部分型をユーザー定義した場合、型推論器の挙動が少し変わってくるな、と思ったので、そういう仕様が提供されているのか気になりました。",
        "user": "U0108S1LS2W",
        "type": "message"
    },
    {
        "ts": "1585384639.154400",
        "text": "subtype がユーザ定義できる言語の想定仕様としては、\n例えば、\n• Prelude に Set が内包されていると仮定して、subset =&gt; subtype という法則が内部言語に存在する\n• subtype relation が Prelude に定義されていて、ユーザ定義されたsubtype relation が内部言語と競合しないことを確かめてからそれらを取り入れる\nなどが考えられるのではないかと思いましたが、\nこのような機能は、Haskell にはふくまれていないのではないかと思う。\n（二つ目の機能があればの空想の話ですが、もしそれを安易な競合チェックで済ましてしまえば、部分型の推論器を容易にハックできてしまうのではないかなどとも思いました。だからこのような機能は現時点ではない？）",
        "user": "U0108S1LS2W",
        "type": "message"
    },
    {
        "ts": "1585389955.156000",
        "text": "最後の仕様の話はよくわからないけど、多くの言語で継承などによって実現されてる機能はないです",
        "user": "U56L7EVNY",
        "type": "message"
    },
    {
        "ts": "1585390434.156300",
        "text": "ありがとうございます。",
        "user": "U0108S1LS2W",
        "type": "message"
    },
    {
        "ts": "1585437555.157300",
        "text": "<@U0111FK01HD> has joined the channel",
        "user": "U0111FK01HD",
        "type": "message"
    },
    {
        "ts": "1585456248.157700",
        "text": "詳しい <https://qiita.com/mod_poppo/items/80c442a1d95471e6ac55>\n自前でrewrite rule書かないと最適化はされないのか... :disappointed:",
        "user": "U4LGTMTMK",
        "type": "message"
    },
    {
        "ts": "1585460704.158000",
        "text": "記事中にもありますが、あくまで Addr 用の変換関数が用意できる場合、それを元に rewrite rule が書けるという話で、厳密に言えば最適化ではありません\n\nunpackCString との rewrite による変換がない場合でも、foldr で pack 処理が書いてあり、インライン展開できるなら、foldr / build は入るようになっています (この場合、unpack 処理は unpackFoldrCString# という関数で行なわれ、リストは生成されません)",
        "user": "U57D08Z9U",
        "type": "message"
    },
    {
        "ts": "1585472241.158400",
        "text": "おお、すみません、周辺をちゃんと読めてませんでした",
        "user": "U4LGTMTMK",
        "type": "message"
    }
]