<!DOCTYPE html><html><head><meta charset="utf-8"><title>haskell-jp / questions #51</title><link rel="stylesheet" href="../../messages.css" type="text/css" media="screen"></head><body><h1>haskell-jp / questions #51</h1><div class="pager"><a href="../../html/C5666B6BB/50.html" class="pager__previous">Previous</a><a href="../../" class="pager__top">Top</a><a href="../../html/C5666B6BB/52.html" class="pager__next">Next</a></div><div class="message_list"><div class="message" id="message-1551963300.155300"><div class="message__timestamp">2019-03-07<br/>21:55:00 +0900</div><div class="message__header">koyama</div><div class="message__body">もし本当に「リストの長さが違っていて長い方のリストの後ろの方に Nothing がある場合も Nothing」にしたいなら、先にそれぞれ sequence してから liftA2 zip して fmap fromList すればよさそうですね</div></div><div class="message" id="message-1551963329.155500"><div class="message__timestamp">2019-03-07<br/>21:55:29 +0900</div><div class="message__header">koyama</div><div class="message__body"><code>fmap fromList $ liftA2 zip (sequence keys) (sequence values)</code></div></div><div class="message" id="message-1551963387.156600"><div class="message__timestamp">2019-03-07<br/>21:56:27 +0900</div><div class="message__header">koyama</div><div class="message__body">せっかくだから <code>fromList &lt;$&gt; liftA2 zip (sequence keys) (sequence values)</code> と書きたいか^^;</div></div><div class="message" id="message-1551963404.157300"><div class="message__timestamp">2019-03-07<br/>21:56:44 +0900</div><div class="message__header">kazu</div><div class="message__body">なぜapplicativeスタイルで書かないのだ？</div></div><div class="message" id="message-1551963411.157500"><div class="message__timestamp">2019-03-07<br/>21:56:51 +0900</div><div class="message__header">koyama</div><div class="message__body">いや書きましたｗ</div></div><div class="message" id="message-1551963424.157700"><div class="message__timestamp">2019-03-07<br/>21:57:04 +0900</div><div class="message__header">koyama</div><div class="message__body">liftA2 までやるとちょっと読みにくいかなーと^^;</div></div><div class="message" id="message-1551963440.158300"><div class="message__timestamp">2019-03-07<br/>21:57:20 +0900</div><div class="message__header">kazu</div><div class="message__body">丸括弧で囲む。</div></div><div class="message" id="message-1551963464.158500"><div class="message__timestamp">2019-03-07<br/>21:57:44 +0900</div><div class="message__header">koyama</div><div class="message__body"><code>fromList &lt;$&gt; (zip &lt;$&gt; sequence keys &lt;*&gt; sequence values)</code> ですね、はい^^;</div></div><div class="message" id="message-1551963668.158700"><div class="message__timestamp">2019-03-07<br/>22:01:08 +0900</div><div class="message__header">koyama</div><div class="message__body">あ、これちがうな、なんかペアがつくれてないな</div></div><div class="message" id="message-1551963702.158900"><div class="message__timestamp">2019-03-07<br/>22:01:42 +0900</div><div class="message__header">koyama</div><div class="message__body">これだと keyばっかりのリストとvalueばっかりのリストがペアになるだけでした^^;</div></div><div class="message" id="message-1551963789.159100"><div class="message__timestamp">2019-03-07<br/>22:03:09 +0900</div><div class="message__header">shogo.otake</div><div class="message__body">なるほど！とても勉強になります！！</div></div><div class="message" id="message-1551963814.159300"><div class="message__timestamp">2019-03-07<br/>22:03:34 +0900</div><div class="message__header">koyama</div><div class="message__body">あれ、いや<br/>ちゃんとペアできてた</div></div><div class="message" id="message-1551963875.161000"><div class="message__timestamp">2019-03-07<br/>22:04:35 +0900</div><div class="message__header">kazu</div><div class="message__body">等価な変換で結果が違う方がおかしい。</div></div><div class="message" id="message-1551963896.161200"><div class="message__timestamp">2019-03-07<br/>22:04:56 +0900</div><div class="message__header">koyama</div><div class="message__body">いや、元のやつが間違ってるかと思ったのでした…目がおかしかったようです</div></div><div class="message" id="message-1551963968.161400"><div class="message__timestamp">2019-03-07<br/>22:06:08 +0900</div><div class="message__header">shogo.otake</div><div class="message__body">こんな初心者の質問に皆さんいろんな意見を出して頂けてとても嬉しいです！:relaxed:</div></div><div class="message" id="message-1551963978.161600"><div class="message__timestamp">2019-03-07<br/>22:06:18 +0900</div><div class="message__header">koyama</div><div class="message__body">で、もちろんそれぞれ sequence するということはそれぞれスキャンし終えてからもう一度 zip でたどることになるんですけど、それが仕様ならそうするしかないですよね</div></div><div class="message" id="message-1551964083.161800"><div class="message__timestamp">2019-03-07<br/>22:08:03 +0900</div><div class="message__header">shogo.otake</div><div class="message__body">あ、ちなみに今回の僕のケースだとkeysとvaluesでサイズが違う場合があります</div></div><div class="message" id="message-1551964115.162000"><div class="message__timestamp">2019-03-07<br/>22:08:35 +0900</div><div class="message__header">koyama</div><div class="message__body">ただ、まあ、元のコードはスキャンの回数よりもむしろ fromJust が部分関数なあたりが怖いので、それをなくせれば良さそうな感じはしますね</div></div><div class="message" id="message-1551964158.162200"><div class="message__timestamp">2019-03-07<br/>22:09:18 +0900</div><div class="message__header">shogo.otake</div><div class="message__body">はい！allでチェック済みとはいえ部分関数を使っていたのですごくどうにかしたい気持ちがありました</div></div><div class="message" id="message-1551964651.162500"><div class="message__timestamp">2019-03-07<br/>22:17:31 +0900</div><div class="message__header">hiroto.shioi</div><div class="message__body">僕も勉強になった！そして最終的にこうなった。(これは間違っています)<br/><br/><pre>
some ::　(Ord key) =&gt; [Maybe key] -&gt; [Maybe value] -&gt; Maybe (M.Map key value)
some keys values = M.fromList &lt;$&gt; zipWithM f keys values
  where
    f :: Maybe key -&gt; Maybe value -&gt; Maybe (key, value)
    f mkey mvalue = (,) &lt;$&gt; mkey &lt;*&gt; mvalue
</pre></div></div><div class="message" id="message-1551964710.162800"><div class="message__timestamp">2019-03-07<br/>22:18:30 +0900</div><div class="message__header">koyama</div><div class="message__body">ああ、つまり「長い方の後ろのほうにある Nothing」は無視するほうの仕様になったんですね</div></div><div class="message" id="message-1551965074.163300"><div class="message__timestamp">2019-03-07<br/>22:24:34 +0900</div><div class="message__header">hiroto.shioi</div><div class="message__body">そうだった。。忘れてた。。もう寝ます</div></div><div class="message" id="message-1551966936.164100"><div class="message__timestamp">2019-03-07<br/>22:55:36 +0900</div><div class="message__header">autotaker</div><div class="message__body">各リストをちょうど一回ずつ舐めるようにするなら<br/><pre>
foldM step (M.empty,values) keys &gt;&gt;= (\(acc,l) -&gt; acc &lt;$ sequence_ l)
        where
        step (!acc, []) mkey = (acc, []) &lt;$ mkey
        step (!acc, mval:vals) mkey = 
            (,vals) &lt;$&gt; (M.insert &lt;$&gt; mkey &lt;*&gt; mval &lt;*&gt; pure acc)
</pre><br/>みたいな感じですけど、さすがにkazuさんのいう通り再帰関数書いた方が読みやすいですね。</div></div><div class="message" id="message-1551969570.165800"><div class="message__timestamp">2019-03-07<br/>23:39:30 +0900</div><div class="message__header">cutsea110</div><div class="message__body"><blockquote>あ、ちなみに今回の僕のケースだとkeysとvaluesでサイズが違う場合があります</blockquote><br/>それなら自分ならこう<br/><br/><pre>
pairWith f (Just x) (Just y) = Just (f x y)
pairWith _ _        _        = Nothing

pair = pairWith (,)
left = pairWith const
-- right = pairWith (flip const)
cross f g (x, y) = (f x, g y)

some :: [Maybe a] -&gt; [Maybe b] -&gt; Maybe [(a, b)]
some xs ys = sequence ps `left` sequence rs
  where
    dummy = repeat (Just undefined)
    (ps, rs) = go xs ys []
    go []     ys     ps = (ps, zipWith pair dummy ys)
    go xs     []     ps = (ps, zipWith pair xs dummy)
    go (x:xs) (y:ys) ps = cross (pair x y:) id $ go xs ys ps
</pre><br/>多分最初に書いたのもfの実装で欲しかったのはむしろpairだったか.</div></div><div class="message" id="message-1551972496.166200"><div class="message__timestamp">2019-03-08<br/>00:28:16 +0900</div><div class="message__header">koyama</div><div class="message__body">後ろを <code>Just undefined</code> で詰めるんですね^^;</div></div><div class="message" id="message-1551973691.166400"><div class="message__timestamp">2019-03-08<br/>00:48:11 +0900</div><div class="message__header">cutsea110</div><div class="message__body">undefinedは積極的に使っていくタチです.(undefined忌み嫌っているけど...)</div></div><div class="message" id="message-1551974756.166600"><div class="message__timestamp">2019-03-08<br/>01:05:56 +0900</div><div class="message__header">koyama</div><div class="message__body">pairWith って liftA2 だったりしませんか</div></div><div class="message" id="message-1551974989.166800"><div class="message__timestamp">2019-03-08<br/>01:09:49 +0900</div><div class="message__header">koyama</div><div class="message__body">@cutsea110 さんの見ながら直してたらこんなんできました<br/><pre>
(&lt;:&gt;) = liftA2 (:)
(&lt;.&gt;) = liftA2 (,)
left  = liftA2 const

some :: [Maybe a] -&gt; [Maybe b] -&gt; Maybe [(a,b)]
some (x:xs) (y:ys) = (x &lt;.&gt; y) &lt;:&gt; some xs ys
some []     ys     = Just [] `left` sequence ys
some xs     []     = Just [] `left` sequence xs
</pre></div></div><div class="message" id="message-1551975060.167000"><div class="message__timestamp">2019-03-08<br/>01:11:00 +0900</div><div class="message__header">koyama</div><div class="message__body"># <code>&lt;,&gt;</code> が作りたかったけどカンマは無理だった…</div></div><div class="message" id="message-1551975529.167300"><div class="message__timestamp">2019-03-08<br/>01:18:49 +0900</div><div class="message__header">cutsea110</div><div class="message__body">liftA2のためにControl.Applicative入れるんならcrossもControl.Arrow ((***))をimportするか.<br/>最近はこのテの小さいサンプルコードの場合にはimportを書かずに済ませたいのだけどbaseの範囲なら別に良いか.</div></div><div class="message" id="message-1551975825.167600"><div class="message__timestamp">2019-03-08<br/>01:23:45 +0900</div><div class="message__header">koyama</div><div class="message__body">たしかにこれ、 Control.Applicative をまるっと import すると some がぶつかるんですよね^^;</div></div><div class="message" id="message-1551977750.167800"><div class="message__timestamp">2019-03-08<br/>01:55:50 +0900</div><div class="message__header">nobsun</div><div class="message__body">hylomorphism の具体例として書くのがいいとおもいます．recursion-schemesを使えばカッコいいけど，まぁリスト限定で以下のようにするのもありかな．<br/><pre>
import Data.Map (Map)
import qualified Data.Map as M

some :: Ord k =&gt; ([Maybe k], [Maybe v]) -&gt; Maybe (Map k v)
some = hylo phi z psi
  where
    z = Just M.empty
    phi (Just Nothing, _) _ = Nothing
    phi (_, Just Nothing) _ = Nothing
    phi _ Nothing = Nothing
    phi (Nothing, _) _     = z
    phi (_, Nothing) _     = z
    phi (Just (Just k), Just (Just v)) (Just m) = Just (M.insert k v m)
    psi ([], [])   = Nothing
    psi (k:ks, []) = Just ((Just k, Nothing), (ks, []))
    psi ([], v:vs) = Just ((Nothing, Just v), ([], vs))
    psi (k:ks,v:vs) = Just ((Just k, Just v), (ks,vs))
    
hylo :: (b -&gt; c -&gt; c) -&gt; c -&gt; (a -&gt; Maybe (b, a)) -&gt; a -&gt; c
hylo phi z psi x = case psi x of
  Nothing      -&gt; z
  Just (y, x') -&gt; phi y (hylo phi z psi x')
</pre></div></div><div class="message" id="message-1551980343.168000"><div class="message__timestamp">2019-03-08<br/>02:39:03 +0900</div><div class="message__header">cohei</div><div class="message__body">hylomorphism まで出てくると、 [The Evolution of a Haskell Programmer](<https://www.willamette.edu/~fruehr/haskell/evolution.html>) を思いだしました :sweat_smile:</div></div><div class="message" id="message-1551980707.168300"><div class="message__timestamp">2019-03-08<br/>02:45:07 +0900</div><div class="message__header">nobsun</div><div class="message__body">つ「関数プログラミングの楽しみ」「関数プログラミング珠玉のアルゴリズムデザイン」</div></div><div class="message" id="message-1551980753.168500"><div class="message__timestamp">2019-03-08<br/>02:45:53 +0900</div><div class="message__header">nobsun</div><div class="message__body">:grinning:</div></div><div class="message" id="message-1551996577.202600"><div class="message__timestamp">2019-03-08<br/>07:09:37 +0900</div><div class="message__header">cutsea110</div><div class="message__body">初見これhylo?って思ったけどナルホド<br/><br/>リストにspecializeされてるから関手がMaybeなので分からなかったけどphi . fmap hylo . psi versionの方なのね.<br/><br/>cata . anaと同じもんだとザツに理解してたけどまたちょっと流れが違って面白いもんですね<br/>合成するパスが違えば流れも違うんだなぁと当たり前のことを今更納得しました<br/><br/>ただ今回の場合はMaybeが3階層に出現しててpsiの意味を把握するのなかなか大変だと思う<br/><br/>これもしMaybeのリストじゃなくてMaybeのbinary treeだったらMaybe -Either-Maybeとかになってもっと判別しやすかったかな</div></div><div class="message" id="message-1551996916.202800"><div class="message__timestamp">2019-03-08<br/>07:15:16 +0900</div><div class="message__header">nobsun</div><div class="message__body">recursion-schemes パッケージの Data.Functor.Foldable をつかったほうが，むしろ，スッキリわかるかも？<br/><pre>
buildMap :: Ord k =&gt; ([Maybe k], [Maybe v]) -&gt; Maybe (Map k v)
buildMap = hylo phi psi
  where
    z = Just M.empty
    phi Nil                                            = z
    phi (Cons (Just Nothing, _)              _      )  = Nothing
    phi (Cons (_, Just Nothing)              _      )  = Nothing
    phi (Cons _                              Nothing)  = Nothing
    phi (Cons (Nothing, _)                   _      )  = z
    phi (Cons (_, Nothing)                   _      )  = z
    phi (Cons (Just (Just k), Just (Just v)) (Just m)) = Just (M.insert k v m)
    psi ([], [])    = Nil
    psi (k:ks, [])  = Cons (Just k, Nothing) (ks, [])
    psi ([], v:vs)  = Cons (Nothing, Just v) ([], vs)
    psi (k:ks,v:vs) = Cons (Just k, Just v)  (ks,vs)
</pre></div></div><div class="message" id="message-1551997351.203000"><div class="message__timestamp">2019-03-08<br/>07:22:31 +0900</div><div class="message__header">nobsun</div><div class="message__body">Maybe は内側が元データのもの，外側が元データのリストにあるかどうかを表していて，短い分はNothingが充填されています．</div></div><div class="message" id="message-1551997946.203200"><div class="message__timestamp">2019-03-08<br/>07:32:26 +0900</div><div class="message__header">cutsea110</div><div class="message__body">元のコードでphiのrhsのNothingもdouble meaningくさいですよね.</div></div><div class="message" id="message-1551997963.203400"><div class="message__timestamp">2019-03-08<br/>07:32:43 +0900</div><div class="message__header">cutsea110</div><div class="message__body">doubleじゃなくduplexか</div></div><div class="message" id="message-1551998106.203600"><div class="message__timestamp">2019-03-08<br/>07:35:06 +0900</div><div class="message__header">cutsea110</div><div class="message__body">最初のはunfoldの停止サインで2,3番目のパターンのNothingはNothingなkかvがあるから潰していると</div></div><div class="message" id="message-1551998500.203800"><div class="message__timestamp">2019-03-08<br/>07:41:40 +0900</div><div class="message__header">nobsun</div><div class="message__body">はいそうです．<br/>3重Maybeの一番外は[]のベース函手ListF aのNil と Cons を表現したものですね．</div></div><div class="message" id="message-1552001848.207400"><div class="message__timestamp">2019-03-08<br/>08:37:28 +0900</div><div class="message__header">cutsea110</div><div class="message__body">hyloって自分で書くときは気にならないと思いますが中間データ型として何を見て(想定して)いるのかが隠れてしまって分かりづらいので敢えてローカルでも型を明示すると良いのかなと思ってます</div></div><div class="message" id="message-1552002484.210700"><div class="message__timestamp">2019-03-08<br/>08:48:04 +0900</div><div class="message__header">cutsea110</div><div class="message__body">ghc packageって初めて使ってみたけど-package ghcを与えるんですね.<br/>emacs使ってるんですけどロードできなくてコンパイル通すのも辛い.<br/>なんか設定しないとやってらんないですね,これは...</div></div><div class="message" id="message-1552037862.213500"><div class="message__timestamp">2019-03-08<br/>18:37:42 +0900</div><div class="message__header">wado</div><div class="message__body">スレッドの内容をページに反映させました。空白を含む場合について全然考えていませんでした。ありがとうございます:star:<br/><a href='https://haskell.e-bigmoon.com/stack/etc/stylish-haskell.html'>https://haskell.e-bigmoon.com/stack/etc/stylish-haskell.html</a></div></div><div class="message" id="message-1552040954.214400"><div class="message__timestamp">2019-03-08<br/>19:29:14 +0900</div><div class="message__header">hs.ioling.hs</div><div class="message__body"><a href='https://twitter.com/hsjoihs/status/1103965106616983552'>https://twitter.com/hsjoihs/status/1103965106616983552</a><br/>「Haskellの演算子に使う記号で、なんかこういうのにはこれを使うみたいな慣習」がまとまっていたりする記事とかってありますかね？</div></div><div class="message" id="message-1552042552.218100"><div class="message__timestamp">2019-03-08<br/>19:55:52 +0900</div><div class="message__header">yharuhi39</div><div class="message__body">一応学術誌に頻出するようなのは、それと近いものにするとかあるみたいですが、後は型が別の演算子に似てたらそれに似せるとか、そういう程度ではないのでしょうか。 正直無数にありすぎて実質無法地帯な感は否めませんが、、、 と個人的に思ってます</div></div><div class="message" id="message-1552045137.218500"><div class="message__timestamp">2019-03-08<br/>20:38:57 +0900</div><div class="message__header">fumieval</div><div class="message__body"><a href='https://twitter.com/fumieval/status/1103983314270973953'>https://twitter.com/fumieval/status/1103983314270973953</a></div></div><div class="message" id="message-1552105140.220200"><div class="message__timestamp">2019-03-09<br/>13:19:00 +0900</div><div class="message__header">trueshot86</div><div class="message__body">@trueshot86 has joined the channel</div></div><div class="message" id="message-1552105322.220500"><div class="message__timestamp">2019-03-09<br/>13:22:02 +0900</div><div class="message__header">elkel53930</div><div class="message__body">@elkel53930 has joined the channel</div></div></div><div class="pager"><a href="../../html/C5666B6BB/50.html" class="pager__previous">Previous</a><a href="../../" class="pager__top">Top</a><a href="../../html/C5666B6BB/52.html" class="pager__next">Next</a></div></body></html>