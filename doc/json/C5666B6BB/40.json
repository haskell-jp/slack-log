[
    {
        "ts": "1548749827.354400",
        "text": "ああ、でもやっぱ Glasgow ノリなんですかね、単語のチョイスが",
        "user": "UF8SE896V",
        "type": "message"
    },
    {
        "ts": "1548749845.354600",
        "text": "プログラミング Ruby でも使われているあたり、Haskell に限らないみたいです <https://books.google.co.jp/books?id=Dif2bl2KRUYC&amp;pg=PA368>",
        "user": "U5LEE6C1J",
        "type": "message"
    },
    {
        "ts": "1548750111.355100",
        "text": "原著の著者（の一人）はこの方かな <https://en.wikipedia.org/wiki/Dave_Thomas_(programmer)> イギリス人のようですね",
        "user": "UF8SE896V",
        "type": "message"
    },
    {
        "ts": "1548750189.355400",
        "text": "いやイギリス人とは書いてないか。 Imperial College London で学んだ、だけですね",
        "user": "UF8SE896V",
        "type": "message"
    },
    {
        "ts": "1548750272.355600",
        "text": "まあでもイギリス圏の人は wurble を使う流儀があるのだとわかりました。ありがとうございます",
        "user": "UF8SE896V",
        "type": "message"
    },
    {
        "ts": "1548750311.355800",
        "text": "(ひょっとして Haskeller なら常識的なことを知らないだけかとドキドキしてた…^^;)",
        "user": "UF8SE896V",
        "type": "message"
    },
    {
        "ts": "1548750627.356000",
        "text": "さておき、型クラスを OOP のインタフェースになぞらえて説明するのは有益だと思いますか？それとも有害だと思いますか？　私は、「あえて似たものを探すのなら」という限定つきであれば悪くない説明だと思っていますが、無条件に同じものだと思ってしまうと弊害がありそうで怖い説明だと感じています",
        "user": "UF8SE896V",
        "type": "message"
    },
    {
        "ts": "1548750927.356200",
        "text": "弊害その1: Eq a =&gt; [a] というのは [Int] とか [Double] とかの総称ではあるけど 「同値比較できる型のものがいろいろ混じっているリスト」のことではない（そういうのが欲しいなら ghc 拡張で [forall a. Eq a =&gt; a] と書かねばならない）という点が抜けている",
        "user": "UF8SE896V",
        "type": "message"
    },
    {
        "ts": "1548751366.356500",
        "text": "弊害その2: …って書こうとしたけど特定の具体例を列挙することの方が弊害な気がしてきたのでやめます^^;",
        "user": "UF8SE896V",
        "type": "message"
    },
    {
        "ts": "1548753131.356700",
        "text": "はい、型クラスの説明については私も概ね同意見ですがそろそろ別スレッドにすべきじゃないかと。。。 :sweat_smile:",
        "user": "U4LGTMTMK",
        "type": "message"
    },
    {
        "ts": "1548755238.358200",
        "text": "家に帰ってきたらすごい通知が来てた笑笑後でじっくり読みたいと思います。わざわざ長文を書いてくださった方やコメントしてくださった方ありがとうございます:blush:",
        "user": "UFDKZJBLK",
        "type": "message"
    },
    {
        "ts": "1548761183.361500",
        "text": "半ば世間話なんですけども、serverless-haskell を使ったことある方がいたら感想を聞きたいです。今、これとは別のアプローチ (aws-lambda-haskell-runtime + SAM) で Haskell のサーバレスアプリケーションのサンプルを書いているのですが、比較材料になればと思いまして。<https://github.com/seek-oss/serverless-haskell>",
        "user": "U4M4XHKB8",
        "type": "message"
    },
    {
        "ts": "1548816899.362800",
        "text": "前に触ったときはglibcのバージョンが合わないみたいなエラーで動きませんでした :cry: ",
        "user": "U560KD6DN",
        "type": "message"
    },
    {
        "ts": "1548819986.363000",
        "text": "&gt; （言葉遣いの厳密さに目をつむって）ざっくりとした理解するには悪くないんじゃないかと思いますが...。\n誤った記述が正しい記述より優れているということは断じてありえないと思います。誤った記述から得られるのは誤った理解のみで、いずれ修正しないといけないので時間の無駄にしかなりません。特に、最初から間違った考えを取り込んでしまったとき、その誤りを直すコストは大きいです",
        "user": "U4KUNQF9N",
        "type": "message"
    },
    {
        "ts": "1548821482.363400",
        "text": "この記事の間違いについて明記しておきます。 <http://capm-network.com/?tag=Haskell-%E5%9E%8B%E3%82%AF%E3%83%A9%E3%82%B9>\n\n&gt; 型クラスとは、型の振る舞いを定義するものです。\n振る舞いを持つのは関数などの操作であって、「型の振る舞い」というのは意味をなしていない表現です。\n&gt; オブジェクト指向におけるクラスとは概念が異なり、Interfaceや抽象クラスに相当します。\n近い意味合いを持っているのは確かです。\n&gt; インスタンスとは、型クラスの制約を満たすように定義した型のことです。\nインスタンスは型ではないです。\n&gt; オブジェクト指向におけるインスタンス（クラスの実体）とは概念が異なり、クラスの実装（Implement）に相当します\n意味合いは近いかも知れませんが、先に述べられたように、存在量化などを使わない限り同一の型で扱えないためOOPのクラスに例えるのはあまりいい考えには見えません。\n&gt; 条件式\n意味不明でした。\n&gt; Eqのインスタンスは、等価性検査の型に使われ、「==」や「/=」で比較できる型を表します。\n繰り返しですがインスタンスは型ではありません。等価性検査の型というのもよく意味がわかりません。\n&gt; Int、Bool、Charといった基本的なデータは全てEqのインスタンスとなります。\nそれら3つはEqのインスタンスですが、それらはデータ型であってデータではないです。\n&gt; Ordのインスタンスは、順序を持った型に使われ、大小の比較ができることを保証する。(&lt;)、(&lt;=)、(&gt;)、(&gt;=)の四つの比較関数は全て同一の型を持ちます。\nここはおおむね正しいです。\n&gt; Showのインスタンスは、文字列表現を返します。\nインスタンスは値を返すものではありません。\n&gt; 文字列表現を返すshow関数やprint関数は、Showのインスタンスです。\n関数はインスタンスとは異なる概念です。先の「インスタンスとは…型のことです」という記述とも矛盾しています。またprint関数はIOアクションを返します。\n&gt; derivingキーワードを使えば，Haskellが型クラスの文脈での振る舞いを自動導出します。\n「型クラスの文脈での振る舞い」の意味がわかりませんでした。実装を導出すると言いたいのでしょうか… :thinking:\n&gt; 自動導出できるクラスは以下の通りです。\nIxが抜けています。",
        "user": "U4KUNQF9N",
        "type": "message"
    },
    {
        "ts": "1548823472.365100",
        "text": "勝手に補足すると、このスレッドが文脈です <https://haskell-jp.slack.com/archives/C5666B6BB/p1548731081317700>",
        "user": "U5LEE6C1J",
        "type": "message"
    },
    {
        "ts": "1548827909.367400",
        "text": "&gt; インスタンスは型ではないです。\nというのは？確かに Monad クラスなどのインスタンスは型コンストラクタであって型ではありませんけど、 Eq クラスについてはインスタンスは型であるといっていいのではないでしょうか？",
        "user": "UF8SE896V",
        "type": "message"
    },
    {
        "ts": "1548828146.370200",
        "text": "｢インスタンスを実装した型｣はあるでしょうがインスタンス自体は型ではないのでは(曖昧な概念理解)",
        "user": "U57CUMWQ6",
        "type": "message"
    },
    {
        "ts": "1548828302.373500",
        "text": "非スレッドで続けていいのか微妙なのですが、なるほど、型そのものだととらえるのは確かに理解のさまたげになりそうですね。 Int 型は Eq のインスタンスである、という言い方自体はして良いけれどそれは厳密には「Int 型には Eq のインスタンスとしての定義が存在する」というべきである、といったとこでしょうか",
        "user": "UF8SE896V",
        "type": "message"
    },
    {
        "ts": "1548828343.373800",
        "text": "インスタンスはある型(間の関係)が型クラスに規定された性質を持っていることを保証する(Haskellにおける現実としては“保証したい“程度ですが)証明オブジェクトです．(過激派)",
        "user": "U5G2BCVBN",
        "type": "message"
    },
    {
        "ts": "1548828704.380000",
        "text": "Coq ならば本当に、型クラスには「保証する性質」を表明しますよね（…といいつつ Coq は使ったことがないので伝聞知識ですが^^;）",
        "user": "UF8SE896V",
        "type": "message"
    },
    {
        "ts": "1548828903.380300",
        "text": "確かに元の文章だと「インスタンスとは（中略）型のことです」となっているので、これだと「インスタンス = 型」という説明になってしまいますよね...",
        "user": "U57DM8PBK",
        "type": "message"
    },
    {
        "ts": "1548829005.380500",
        "text": "原文を尊重すると「ある型Aが型クラスBのインスタンスであるとは、型Aが型クラスBの制約を満たすように定義されている状態のことである」ぐらいに書いておけば大丈夫ですかね。",
        "user": "U57DM8PBK",
        "type": "message"
    },
    {
        "ts": "1548834226.384600",
        "text": "うーん、「型Hogeは型クラスFooのインスタンスだよ」みたいな言い方は日常的にすると思うんですが、そんなに「インスタンス is a 型」として捉えるのはダメですかね... :confused:\n厳密な言い方じゃないのは事実としてもどうせ型と1対1で存在するものだし、言ってはいけないと言うほどのものではないかと思うのですが...",
        "user": "U4LGTMTMK",
        "type": "message"
    },
    {
        "ts": "1548834531.388600",
        "text": "どっちかというとインスタンスは値なので「is 型」は理解が遠くなりません？",
        "user": "U5G2BCVBN",
        "type": "message"
    },
    {
        "ts": "1548834547.388700",
        "text": "同意しますが、たしかに初学者には言葉遣いに気を付けた方がいいポイントなのかなという気もします。型そのものの定義とはちょっと離れたところに書けるというのは Haskell の instance 宣言の特徴でもあるので…",
        "user": "UF8SE896V",
        "type": "message"
    },
    {
        "ts": "1548834658.388900",
        "text": "あと、明らかに型ではなく「型コンストラクタ」を取るクラスもいっぱいある（Functor とか Monad とか）ので、その意味でも気を付けた方がいいんだろうな、という点にも後で気づきました^^;",
        "user": "UF8SE896V",
        "type": "message"
    },
    {
        "ts": "1548834962.390200",
        "text": "型と型コンストラクターをうまく総称する言葉がないので、その辺はどこで見ても曖昧になっている気がしますね。。。 :sweat:",
        "user": "U4LGTMTMK",
        "type": "message"
    },
    {
        "ts": "1548834990.390400",
        "text": "まあ、無引数の型コンストラクタ（kind が * の型コンストラクタ）、ということにしてしまえば、全部「型コンストラクタ」でいいと思いますが。",
        "user": "UF8SE896V",
        "type": "message"
    },
    {
        "ts": "1548835231.392300",
        "text": "Haskell にそこそこ慣れてからであれば、「Int 型は Num のインスタンスである」という表現をしても「Num  a =&gt; の a に Int を入れることができる」という意味として把握できるので、そういう表現自体が禁止されるわけではないと思います。",
        "user": "UF8SE896V",
        "type": "message"
    },
    {
        "ts": "1548835436.392600",
        "text": "その「Num a の a に Int を入れることができる」ということと同時に「この Num a =&gt; の関数には、 (+), (-), (*) などが辞書として暗黙の引数で渡されるんだ」ということがつながるぐらいイメージがつながれば、「インスタンスは型そのものではなく値のことである」というところもわかったことになると思うんですけどね^^;",
        "user": "UF8SE896V",
        "type": "message"
    },
    {
        "ts": "1548835924.393800",
        "text": "「値」といった時にそれが「関数」を含む概念であるということも最初は気づきにくいところなので、なんと説明するのがいいか悩ましいところですね…",
        "user": "UF8SE896V",
        "type": "message"
    },
    {
        "ts": "1548836013.394000",
        "text": "個人的には、 sort と sortBy の関係を見た時にいろいろと合点がいった覚えがあります。ああそうか、Ord ってのは単に sortBy のデフォルト値を型に対して一個だけ選べる仕組みなんだな、と。",
        "user": "UF8SE896V",
        "type": "message"
    },
    {
        "ts": "1548836319.394400",
        "text": "「振る舞い」というのはオブジェクト指向でよく出てくる言葉で、\n「多態＝同一のインターフェイスに対してクラス毎に異なる振る舞いを定義できる」という言い方をしますよね。\n\nこれを型クラスの世界に対応させると、\n\n- 型クラス &lt;=&gt; インターフェイス\n- インスタンス &lt;=&gt; クラス\n\nなので、「型クラスとは、型の振る舞いを定義するものです」というのは単純にズレているように思います。\nあえて言うなら、振る舞いを定義しているのはインスタンス宣言（≒オブジェクト指向のクラス宣言に対応）のところになるかと。",
        "user": "U570660KX",
        "type": "message"
    },
    {
        "ts": "1548836606.395100",
        "text": "「ズレている」に同意します。たぶんそもそも一つ一つの言葉の選び方にあまり注意を払っていないんだと思います。「どんな振る舞いを実装すべきかを宣言する」ということを「定義する」と言ってしまっているような、そんな感じのテキトーさ加減を感じます",
        "user": "UF8SE896V",
        "type": "message"
    },
    {
        "ts": "1548836784.395900",
        "text": "ところで Ix が deriving 可能だというのはいまさら知りました^^;  <https://www.haskell.org/onlinereport/haskell2010/haskellch4.html#x10-780004.3.3> ここには Ix は列挙されていないので…（Ix は Prelude には含まれていないからですね）",
        "user": "UF8SE896V",
        "type": "message"
    },
    {
        "ts": "1548836820.396100",
        "text": "型を行、型クラスを列とする表のセルがインスタンスという捉え方ができるので、「インスタンスは型」というのは「インスタンスはクラス」と同じくらい的はずれな表現だと思います",
        "user": "U4KUNQF9N",
        "type": "message"
    },
    {
        "ts": "1548836883.396300",
        "text": "型コンストラクタについて補足ですが、IntやBoolなどももちろん(無引数の)型コンストラクタで、通常インスタンス宣言は型コンストラクタに対してなされるものです",
        "user": "U4KUNQF9N",
        "type": "message"
    },
    {
        "ts": "1548836977.396700",
        "text": "<https://www.haskell.org/onlinereport/haskell2010/haskellch19.html#x27-22700019.2> ここには書いてあるので、最後までちゃんと読めってことですね^^;",
        "user": "UF8SE896V",
        "type": "message"
    },
    {
        "ts": "1548837296.397200",
        "text": "縦横の表のイメージはわかりやすいですね。まずはそのイメージを持つことが重要であることは同意します。ただ、そのイメージを十分に持っている前提であれば「Num のインスタンスは Int, Integer, Double など」と言って通じると思うので、要は学習レベル次第ですよね…",
        "user": "UF8SE896V",
        "type": "message"
    },
    {
        "ts": "1548837458.397400",
        "text": "「型はクラスのインスタンスになる(T is an instance of C)」\n「インスタンスは型である(An instance is a type such that...)」\n英語で書くと違いがわかりやすいと思います",
        "user": "U4KUNQF9N",
        "type": "message"
    },
    {
        "ts": "1548837774.397700",
        "text": "気になって標準も読んでみたんですが、どちらかというと\n- 型 is an instance\n- class methodsがoverloaded operations （fumiさんのおっしゃる「セル」）\nと聞こえます。\n <https://www.haskell.org/onlinereport/haskell2010/haskellch4.html#x10-630004.1>\n\nすごいH本でもp.27に「ある型クラスのインスタンスである型は、...」\nという記述がありますし、やっぱり一般的な理解と異なっているのではないかと思います。 :confused:",
        "user": "U4LGTMTMK",
        "type": "message"
    },
    {
        "ts": "1548837942.398000",
        "text": "縦横の表の理解は別に特殊ではないと思うんですが、「この列のインスタンスは〇行目と〇行目に定義されている」という表現を「この列のインスタンスは〇行と〇行だ」と省略していいかどうか、じゃないですかねえ？",
        "user": "UF8SE896V",
        "type": "message"
    },
    {
        "ts": "1548838025.398200",
        "text": "\"T is an instance of C\"を\"T is an instance\"と切ってしまうのは大きな飛躍があります。「IntはNumのインスタンスである」「IntはEqのインスタンスである」ではなく「Intはインスタンスである」と言っても通じないのではないでしょうか？",
        "user": "U4KUNQF9N",
        "type": "message"
    },
    {
        "ts": "1548838158.398400",
        "text": "問題となっているのは、「型コンストラクタTは型クラスCのインスタンスである」を逆転させて「インスタンスは型である」と言ってしまったことだと捉えています",
        "user": "U4KUNQF9N",
        "type": "message"
    },
    {
        "ts": "1548838235.398600",
        "text": "えっと、具体的にいうと、\n＞＞インスタンスとは、型クラスの制約を満たすように定義した型のことです。\n＞インスタンスは型ではないです。\nこっちはおっしゃるとおりの問題があると思うんですが、\n＞＞Eqのインスタンスは、等価性検査の型に使われ、「==」や「/=」で比較できる型を表します。\n＞繰り返しですがインスタンスは型ではありません。\nこっちは「Eq のインスタンス」の話しかしていないので指摘は言い過ぎではないかと思いました",
        "user": "UF8SE896V",
        "type": "message"
    },
    {
        "ts": "1548838286.398800",
        "text": "確かに、「Eqのインスタンス」と言えば、インスタンスとなる型の集合を指していることはわかりますね",
        "user": "U4KUNQF9N",
        "type": "message"
    },
    {
        "ts": "1548838395.399000",
        "text": "「等価性検査の型に使われ」のところがちょっとよく分からない言い方ですが、そこを除外すれば正しい事を言っているように思います",
        "user": "U570660KX",
        "type": "message"
    },
    {
        "ts": "1548838395.399200",
        "text": "ただまあ、なんかこう、一生懸命議論する価値のある文章でないことは確かなので^^; 「忘れてください」の一言で切り捨てたのはさすがだなと思いました^^;",
        "user": "UF8SE896V",
        "type": "message"
    },
    {
        "ts": "1548838672.403000",
        "text": "ところでむしろ私は\n＞Ordのインスタンスは、順序を持った型に使われ、大小の比較ができることを保証する。(&lt;)、(&lt;=)、(&gt;)、(&gt;=)の四つの比較関数は全て同一の型を持ちます。\nのところ（fumieval さんは「ここはおおむね正しいです」とされたところ）について、怪しさを感じました。\n確かに正しく解釈できる文ではありますが、なんでわざわざ「四つの比較関数」だけを取り出してたり（compare, max, min はどこにいった？）、それらが「同一の型を持ちます」とここで解説するのか？というあたりに、「これひょっとして a-&gt;a-&gt;Bool の a と a が同じ型であることを言っているんじゃないか？」という疑念が。",
        "user": "UF8SE896V",
        "type": "message"
    }
]