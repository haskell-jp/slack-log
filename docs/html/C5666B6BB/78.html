<!DOCTYPE html><html><head><meta charset="utf-8"><title>haskell-jp / questions #78</title><link rel="stylesheet" href="../../main.css" type="text/css" media="screen"></head><body><div class="ui container"><h1>haskell-jp / questions #78</h1><div class="pager ui pagination menu"><a href="../../html/C5666B6BB/77.html" class="pager__previous item">Previous</a><a href="../../" class="pager__top item">Top</a><a href="../../html/C5666B6BB/79.html" class="pager__next item">Next</a></div><div class="message_list ui feed"><div class="message event" id="message-1579674288.041000"><div class="content"><div class="summary"><div class="message__header user">ncaq</div><div class="message__timestamp date">2020-01-22&nbsp;15:24:48 +0900</div></div><div class="message__body description">前悩んだ時は <code>LANG=C</code> で言語指定したらビルドできました</div></div></div><div class="message event" id="message-1579674403.041200"><div class="content"><div class="summary"><div class="message__header user">maoe</div><div class="message__timestamp date">2020-01-22&nbsp;15:26:43 +0900</div></div><div class="message__body description">フォローアップを忘れていました。have-quartz-gtkフラグが必要です。cabalなら<br/><code>cabal build --with-gcc=gcc-9 --constraint="gtk +have-quartz-gtk"</code> でいけると思います。</div></div></div><div class="message event" id="message-1579674551.041500"><div class="content"><div class="summary"><div class="message__header user">maoe</div><div class="message__timestamp date">2020-01-22&nbsp;15:29:11 +0900</div></div><div class="message__body description">ちなみに`cabal install gtk --with-gcc=gcc-9` を試されていますがcabal v3以降ではプロジェクト外での cabal install は実行ファイルをインストールするコマンドです。ライブラリをインストールする場合は <code>cabal install --lib</code> を使う必要があります。</div></div></div><div class="message event" id="message-1579695907.046100"><div class="content"><div class="summary"><div class="message__header user">gettaplacetogo</div><div class="message__timestamp date">2020-01-22&nbsp;21:25:07 +0900</div></div><div class="message__body description">競プロ用に`Data.Vector.Fusion.Bundle.Monadic`を弄っていて，<br/><pre>-- | Monadic streams
data Bundle m v a = Bundle { sElems  :: Stream m a
                           , sChunks :: Stream m (Chunk v a)
                           , sVector :: Maybe (v a)
                           , sSize   :: Size
                           }</pre><br/>を見たんですが，この第三フィールド(`sVector`)，なんで存在するのか分かる方っていらっしゃいます？ <code>Data.Vector.Generic.unstream</code>でさえこれを消費しているように見えないので，本当になんのためにあるのか分からなくて……．</div></div></div><div class="message event" id="message-1579701801.046400"><div class="content"><div class="summary"><div class="message__header user">syani4732</div><div class="message__timestamp date">2020-01-22&nbsp;23:03:21 +0900</div></div><div class="message__body description">@syani4732 has joined the channel</div></div></div><div class="message event" id="message-1579764984.046600"><div class="content"><div class="summary"><div class="message__header user">kakkun61</div><div class="message__timestamp date">2020-01-23&nbsp;16:36:24 +0900</div></div><div class="message__body description">詳しいことは分からないですが <code>sVector</code> ができた経緯としては <code>fromVector</code> でもらった vector をそのまま保存するためみたいですね<br/><a href='https://github.com/haskell/vector/commit/f375eff766f1fbecfc2944da3a7034c22658590a#diff-a5466f1eaf4aa39e68b2095915f3fde1L1590-R1594'>https://github.com/haskell/vector/commit/f375eff766f1fbecfc2944da3a7034c22658590a#diff-a5466f1eaf4aa39e68b2095915f3fde1L1590-R1594</a></div></div></div><div class="message event" id="message-1579766903.046900"><div class="content"><div class="summary"><div class="message__header user">kakkun61</div><div class="message__timestamp date">2020-01-23&nbsp;17:08:23 +0900</div></div><div class="message__body description">試しに <code>sVector</code> を消してコンパイル通してみましたが、確かに取り出してないように見えますね<br/><a href='https://github.com/haskell/vector/compare/master...kakkun61:remove-svector'>https://github.com/haskell/vector/compare/master...kakkun61:remove-svector</a></div></div></div><div class="message event" id="message-1579777889.049600"><div class="content"><div class="summary"><div class="message__header user">gettaplacetogo</div><div class="message__timestamp date">2020-01-23&nbsp;20:11:29 +0900</div></div><div class="message__body description">ですよね…。ありがとうございます。まあ、fromVectorで代入されてるのは見てるんですけど、やっぱよくわからないですね…。外部ライブラリで使用させてあげるためとか？　それとも歴史的な理由か…。</div></div></div><div class="message event" id="message-1579906992.049900"><div class="content"><div class="summary"><div class="message__header user">igrep</div><div class="message__timestamp date">2020-01-25&nbsp;08:03:12 +0900</div></div><div class="message__body description">英語で聞くのは大変かとは思いますがどうやらここにvectorパッケージのメンテナはいないようなので<br/><a href='https://github.com/haskell/vector/issues'>https://github.com/haskell/vector/issues</a> か適当なML（恐らくlibraries@haskell.org あたり？）で聞かないとこれ以上のことはわからないと思います:disappointed_relieved:</div></div></div><div class="message event" id="message-1579945531.050200"><div class="content"><div class="summary"><div class="message__header user">ap.gr.le</div><div class="message__timestamp date">2020-01-25&nbsp;18:45:31 +0900</div></div><div class="message__body description">@ap.gr.le has joined the channel</div></div></div><div class="message event" id="message-1579966853.050400"><div class="content"><div class="summary"><div class="message__header user">gettaplacetogo</div><div class="message__timestamp date">2020-01-26&nbsp;00:40:53 +0900</div></div><div class="message__body description">ですよね………．でも，英語で聞くのは問題ないんですが，「存在することに問題(issue)がある」というふうには思えなかったので，とりあえずここで聞いてみたんですよね</div></div></div><div class="message event" id="message-1579967817.050600"><div class="content"><div class="summary"><div class="message__header user">gettaplacetogo</div><div class="message__timestamp date">2020-01-26&nbsp;00:56:57 +0900</div></div><div class="message__body description">と思ったけど，issueはproblemじゃないんだから，バグでも改善点でもない単なる疑問点でも聞いていいのか………？</div></div></div><div class="message event" id="message-1579994137.050900"><div class="content"><div class="summary"><div class="message__header user">igrep</div><div class="message__timestamp date">2020-01-26&nbsp;08:15:37 +0900</div></div><div class="message__body description">「存在することに問題(issue)」は十分ありえますよ。余計なフィールド（実際にはまだ容疑だけですが）があると言うことはそれだけでこうして意味を調べる時間を割かないといけない原因になりますし、新しい機能を追加したりするときに検討事項を増やす要因になり得ます。<br/>ユーザーに直接影響を与えることは（多分）ないでしょうがメンテナンスの負荷を多かれ少なかれ上げることになるので立派な問題だと思います。</div></div></div><div class="message event" id="message-1580015626.051100"><div class="content"><div class="summary"><div class="message__header user">gettaplacetogo</div><div class="message__timestamp date">2020-01-26&nbsp;14:13:46 +0900</div></div><div class="message__body description">ふむ</div></div></div><div class="message event" id="message-1580016168.051300"><div class="content"><div class="summary"><div class="message__header user">gettaplacetogo</div><div class="message__timestamp date">2020-01-26&nbsp;14:22:48 +0900</div></div><div class="message__body description"><a href='https://github.com/haskell/vector/issues/269'>https://github.com/haskell/vector/issues/269</a> とりあえずissueにしました．</div></div></div><div class="message event" id="message-1580017122.051600"><div class="content"><div class="summary"><div class="message__header user">gettaplacetogo</div><div class="message__timestamp date">2020-01-26&nbsp;14:38:42 +0900</div></div><div class="message__body description">正直忙しそうで申し訳ないのですけどね………</div></div></div><div class="message event" id="message-1580023135.052000"><div class="content"><div class="summary"><div class="message__header user">masa1023tora</div><div class="message__timestamp date">2020-01-26&nbsp;16:18:55 +0900</div></div><div class="message__body description">@masa1023tora has joined the channel</div></div></div><div class="message event" id="message-1580192957.052500"><div class="content"><div class="summary"><div class="message__header user">hitoshi</div><div class="message__timestamp date">2020-01-28&nbsp;15:29:17 +0900</div></div><div class="message__body description">@hitoshi has joined the channel</div></div></div><div class="message event" id="message-1580315147.052800"><div class="content"><div class="summary"><div class="message__header user">hayato.daikichi</div><div class="message__timestamp date">2020-01-30&nbsp;01:25:47 +0900</div></div><div class="message__body description">@hayato.daikichi has joined the channel</div></div></div><div class="message event" id="message-1580343114.055900"><div class="content"><div class="summary"><div class="message__header user">misaki</div><div class="message__timestamp date">2020-01-30&nbsp;09:11:54 +0900</div></div><div class="message__body description">基本的なことなのですが、たとえば<br/><pre>
main :: IO ()
main = do
                 putStrLn “string”
                 putStrLn “string”
</pre><br/>がメモイズされないのってなぜですか？<br/>IO独自で阻害する何かがあるのか、もっと一般的なことなのでしょうか。</div></div></div><div class="message event" id="message-1580346074.056100"><div class="content"><div class="summary"><div class="message__header user">kazu</div><div class="message__timestamp date">2020-01-30&nbsp;10:01:14 +0900</div></div><div class="message__body description">何がメモ化されるべきだと考えているのですか？</div></div></div><div class="message event" id="message-1580346254.056300"><div class="content"><div class="summary"><div class="message__header user">igrep</div><div class="message__timestamp date">2020-01-30&nbsp;10:04:14 +0900</div></div><div class="message__body description">一つ目の <code>putStrLn "string"</code> がメモ化されて1回しか出力されないのでは、という話ですかね？</div></div></div><div class="message event" id="message-1580347091.058000"><div class="content"><div class="summary"><div class="message__header user">misaki</div><div class="message__timestamp date">2020-01-30&nbsp;10:18:11 +0900</div></div><div class="message__body description">そうです！<br/>メモ化されるべきではないですが、メモ化されるべきではないという明示がない同引数の関数をメモ化していないのはIO自体に細工があるのでしょうか？</div></div></div><div class="message event" id="message-1580347603.059600"><div class="content"><div class="summary"><div class="message__header user">kazu</div><div class="message__timestamp date">2020-01-30&nbsp;10:26:43 +0900</div></div><div class="message__body description">うーん。フィボナッチの計算などでいうメモ化のことであれば、Haskellでもメモ化のためのライブラリなどを使わないとメモ化されないと思います。</div></div></div><div class="message event" id="message-1580347630.060100"><div class="content"><div class="summary"><div class="message__header user">kazu</div><div class="message__timestamp date">2020-01-30&nbsp;10:27:10 +0900</div></div><div class="message__body description">参考： <a href='https://www.ipsj.or.jp/07editj/promenade/4608.pdf'>https://www.ipsj.or.jp/07editj/promenade/4608.pdf</a></div></div></div><div class="message event" id="message-1580347701.061600"><div class="content"><div class="summary"><div class="message__header user">misaki</div><div class="message__timestamp date">2020-01-30&nbsp;10:28:21 +0900</div></div><div class="message__body description">あれ、そうでしたっけ。<br/>資料ありがとうございます。<br/>読んでみます。<br/><br/>もう少しHaskellのメモ化戦略について調べてみますorz</div></div></div><div class="message event" id="message-1580347817.061800"><div class="content"><div class="summary"><div class="message__header user">igrep</div><div class="message__timestamp date">2020-01-30&nbsp;10:30:17 +0900</div></div><div class="message__body description">（もう回答済みで恐縮ですが）そもそも、別々の場所にあるたまたま同じ形の式が自動でメモ化されるなんてことはありません。<br/>じゃぁどういう条件だとメモ化されるの、というと、結構複雑です、こちらのスレッドや記事なども参考にどうぞ、とだけ :sweat_smile:<br/><a href='https://haskell-jp.slack.com/archives/C5666B6BB/p1564340963043600'>https://haskell-jp.slack.com/archives/C5666B6BB/p1564340963043600</a><br/><a href='http://www.kotha.net/hperf/basics.html'>http://www.kotha.net/hperf/basics.html</a><br/><a href='https://kakkun61.hatenablog.com/entry/2019/07/29/%E9%96%A2%E6%95%B0%E3%81%AE%E3%83%A1%E3%83%A2%E5%8C%96'>https://kakkun61.hatenablog.com/entry/2019/07/29/%E9%96%A2%E6%95%B0%E3%81%AE%E3%83%A1%E3%83%A2%E5%8C%96</a></div></div></div><div class="message event" id="message-1580347830.062100"><div class="content"><div class="summary"><div class="message__header user">kazu</div><div class="message__timestamp date">2020-01-30&nbsp;10:30:30 +0900</div></div><div class="message__body description">これも： <a href='https://github.com/kazu-yamamoto/recursion-drill/blob/master/drill/7.md'>https://github.com/kazu-yamamoto/recursion-drill/blob/master/drill/7.md</a></div></div></div><div class="message event" id="message-1580347914.063700"><div class="content"><div class="summary"><div class="message__header user">misaki</div><div class="message__timestamp date">2020-01-30&nbsp;10:31:54 +0900</div></div><div class="message__body description">たぶん、メモイズが提供される高階関数とHaskell自体の機能を混同してました。<br/>ありがとうございました。<br/><br/><a href='https://stackoverflow.com/questions/13059381/an-option-to-make-memoization-the-default-behaviour-of-haskell'>https://stackoverflow.com/questions/13059381/an-option-to-make-memoization-the-default-behaviour-of-haskell</a></div></div></div><div class="message event" id="message-1580347943.064200"><div class="content"><div class="summary"><div class="message__header user">kazu</div><div class="message__timestamp date">2020-01-30&nbsp;10:32:23 +0900</div></div><div class="message__body description">自動的にメモ化されるとなると、コンパイラが動的計画法を自動的に実装してくれることになりますが、一般的にそんなことはしません。</div></div></div><div class="message event" id="message-1580347980.064800"><div class="content"><div class="summary"><div class="message__header user">misaki</div><div class="message__timestamp date">2020-01-30&nbsp;10:33:00 +0900</div></div><div class="message__body description">資料ありがとうございます！<br/>助かります！</div></div></div><div class="message event" id="message-1580349241.068000"><div class="content"><div class="summary"><div class="message__header user">misaki</div><div class="message__timestamp date">2020-01-30&nbsp;10:54:01 +0900</div></div><div class="message__body description">すみません、高階関数の機能ではなくcommon subexpression eliminationについてでした！<br/><br/><blockquote>So GHC does do CSE, but only in specific circumstances --- see the GHC manual. (Section??)</blockquote>詳細への参照が「セクション？？」になってます笑<br/><br/>単純にこのIOのケースではCSEは動かないし、そんなにCSEが動く場面はないよ、ということでした。<br/><br/><a href='https://wiki.haskell.org/GHC_optimisations#Common_subexpression_elimination'>https://wiki.haskell.org/GHC_optimisations#Common_subexpression_elimination</a></div></div></div><div class="message event" id="message-1580350731.068400"><div class="content"><div class="summary"><div class="message__header user">mizunashi-mana</div><div class="message__timestamp date">2020-01-30&nbsp;11:18:51 +0900</div></div><div class="message__body description">ところで，CSE が動けば IO はメモ化されますが，IO のメモ化とIO effect のメモ化は異なる概念なので，effect がメモ化されるわけではありません:<br/><pre>main = let e = putStrLn "string" in e &gt;&gt; e</pre><br/>で，e の二回目の呼び出しは (最適化を考えなければ)メモ化されますが， string は2回出力されます．GHC の場合，IO は単純な State モナドで実装されているので，e は状態操作関数が束縛されていると思えば良くて，状態操作関数をメモ化したところで，関数の実行は2回行われるので作用は2回行われるというのが，作用がメモ化されない要因ですね<br/>(ただし，この前提は最適化次第では崩れる場合があり，特にインライン展開の順番には GHC は気を使っていて，IO 相当の状態操作関数はインライン展開が幾つか阻害される場合があります)</div></div></div><div class="message event" id="message-1580350852.068600"><div class="content"><div class="summary"><div class="message__header user">mizunashi-mana</div><div class="message__timestamp date">2020-01-30&nbsp;11:20:52 +0900</div></div><div class="message__body description">最適化を考えない場合の話は，State モナドでも同様なので，State モナドの作用がメモ化されないのはなぜか考えてみるのがいい気がします</div></div></div><div class="message event" id="message-1580378035.069500"><div class="content"><div class="summary"><div class="message__header user">alex</div><div class="message__timestamp date">2020-01-30&nbsp;18:53:55 +0900</div></div><div class="message__body description">@alex has joined the channel</div></div></div><div class="message event" id="message-1580547253.069900"><div class="content"><div class="summary"><div class="message__header user">benibana2001</div><div class="message__timestamp date">2020-02-01&nbsp;17:54:13 +0900</div></div><div class="message__body description">@benibana2001 has joined the channel</div></div></div><div class="message event" id="message-1580714826.070100"><div class="content"><div class="summary"><div class="message__header user">pontyan12</div><div class="message__timestamp date">2020-02-03&nbsp;16:27:06 +0900</div></div><div class="message__body description">stackでgccを指定するやり方がちょっと調べてもわからないんですよね、、<br/><br/><br/>いただいたbuildコマンドを試したところ<br/><pre>unrecognized 'build' option `--constraint=gtk +have-quartz-gtk'</pre><br/>と言うエラーが出ました。<br/><br/>cabalのバージョンが<br/><pre>cabal-install version 2.4.1.0
compiled using version 2.4.1.0 of the Cabal library </pre><br/>遅れてるのでしょうか？</div></div></div><div class="message event" id="message-1580790916.070400"><div class="content"><div class="summary"><div class="message__header user">liveinwood</div><div class="message__timestamp date">2020-02-04&nbsp;13:35:16 +0900</div></div><div class="message__body description">@liveinwood has joined the channel</div></div></div><div class="message event" id="message-1580871369.072800"><div class="content"><div class="summary"><div class="message__header user">fujino</div><div class="message__timestamp date">2020-02-05&nbsp;11:56:09 +0900</div></div><div class="message__body description">@fujino has joined the channel</div></div></div><div class="message event" id="message-1580880396.073000"><div class="content"><div class="summary"><div class="message__header user">cj.bc-sd</div><div class="message__timestamp date">2020-02-05&nbsp;14:26:36 +0900</div></div><div class="message__body description">参照透過性に関する質問です<br/><br/>関数内で定義された関数にて、外側の関数の引数を(引数を経由するのではなく)利用している場合、その内側の関数は参照透過性があるといえるのでしょうか<br/>その関数が実行される状況では“外側の関数の引数“は決まっているので透過性がありそうなものの、引数以外のデータに依存しているのでどうなのだろうと思っています。<br/><br/>具体例としては、以下のようなコードで、 <code>g</code>は参照透過性があると言えるのでしょうか<br/><br/><pre>
f :: Int -&gt; String
f x = let g = if x == 0
                    then "empty"
                    else (show x)
         in g</pre><br/><br/>又、以下のようにすれば確実に参照透過性が保たれると思うのですが、そこまでして参照透過性を保った方がいいのでしょうか<br/><br/>f :: Int -&gt; String<br/><pre>f x = let g a = if a == 0
                    then "empty"
                    else (show a)
         in g x</pre></div></div></div><div class="message event" id="message-1580883787.073100"><div class="content"><div class="summary"><div class="message__header user">9647142</div><div class="message__timestamp date">2020-02-05&nbsp;15:23:07 +0900</div></div><div class="message__body description">外側の関数の引数(変数)は定数扱いとかそんな感じっぽそう<br/>クロージャとかカリー化とかで調べたら答えがわかりそう</div></div></div><div class="message event" id="message-1580884412.073300"><div class="content"><div class="summary"><div class="message__header user">9647142</div><div class="message__timestamp date">2020-02-05&nbsp;15:33:32 +0900</div></div><div class="message__body description">そんなことなさそう...</div></div></div><div class="message event" id="message-1580888067.073600"><div class="content"><div class="summary"><div class="message__header user">cj.bc-sd</div><div class="message__timestamp date">2020-02-05&nbsp;16:34:27 +0900</div></div><div class="message__body description">自分も、外側は定数として扱えるのかな〜とも思ったりしたのですがどうなんですかね…<br/>とりあえず、設計するときにどっちの方が好まれるのかが気になっています。</div></div></div><div class="message event" id="message-1580895349.073900"><div class="content"><div class="summary"><div class="message__header user">restartsugar</div><div class="message__timestamp date">2020-02-05&nbsp;18:35:49 +0900</div></div><div class="message__body description">@restartsugar has joined the channel</div></div></div><div class="message event" id="message-1580899525.074100"><div class="content"><div class="summary"><div class="message__header user">igrep</div><div class="message__timestamp date">2020-02-05&nbsp;19:45:25 +0900</div></div><div class="message__body description"><blockquote> とりあえず、設計するときにどっちの方が好まれるのかが気になっています。</blockquote>その意味ですと、どちらも一長一短あるのでなんともいえないですね...<br/>最適化のしやすさも絡んでいたような...<br/><br/>個人的には積極的に自由変数として参照する方が、少なくとも書くのは楽なんで好きですが。<br/>ほかの方の意見も気になります。<br/>（なので、「Also sent to the channel」しました）</div></div></div><div class="message event" id="message-1580906420.078700"><div class="content"><div class="summary"><div class="message__header user">fumieval</div><div class="message__timestamp date">2020-02-05&nbsp;21:40:20 +0900</div></div><div class="message__body description">この例のようにローカルでない変数を参照していたとしても、その変数もまた参照透過性があるので、参照透過性が損なわれることを心配する必要はありません(cf. <a href='https://en.wikipedia.org/wiki/Referential_transparency#Examples_and_counterexamples'>https://en.wikipedia.org/wiki/Referential_transparency#Examples_and_counterexamples</a>)。余分な引数を減らすことはプログラムの高速化につながるので積極的にやっていきましょう</div></div></div><div class="message event" id="message-1580947362.079700"><div class="content"><div class="summary"><div class="message__header user">igrep</div><div class="message__timestamp date">2020-02-06&nbsp;09:02:42 +0900</div></div><div class="message__body description">Template Haskellの <code>[e| |]</code> について、:point_down: のようなちょっと面白い挙動を見つけたんですが、これはどこのドキュメントに書かれているでしょうか？<br/><br/>Template Haskellのマクロを定義しているコード: Lib.hs<br/><pre>{-# LANGUAGE TemplateHaskell #-}

module Lib where

import <http://Language.Haskell.TH|Language.Haskell.TH> (ExpQ)

-- definedInMainはLib.hsでは定義されてない！
expq :: ExpQ
expq = [e| putStrLn definedInMain |]</pre><br/>Lib.hsが定義したマクロを展開するコード: test.hs<br/><pre>{-# LANGUAGE TemplateHaskell #-}

import Lib

main :: IO ()
main = do
  -- 代わりに、test.hsで定義する
  let definedInMain = "hello!"
  $(expq)</pre><br/>というLib.hsとtest.hsを書いたとき、Lib.hsの <code>[e| putStrLn definedInMain |]</code> で定義されていない、 <code>definedInMain</code> をマクロを展開しているtest.hsから参照する、という挙動です。</div></div></div><div class="message event" id="message-1580966592.080300"><div class="content"><div class="summary"><div class="message__header user">cj.bc-sd</div><div class="message__timestamp date">2020-02-06&nbsp;14:23:12 +0900</div></div><div class="message__body description">なるほど！みなさんありがとうございます！</div></div></div><div class="message event" id="message-1581031328.080600"><div class="content"><div class="summary"><div class="message__header user">maoe</div><div class="message__timestamp date">2020-02-07&nbsp;08:22:08 +0900</div></div><div class="message__body description">--constraintオプションがいつからあったのかはわかりませんが、cabal-installは古いGHCでも使えるので、常に最新のバージョンを使うのがおすすめです。</div></div></div><div class="message event" id="message-1581045562.080800"><div class="content"><div class="summary"><div class="message__header user">mizunashi-mana</div><div class="message__timestamp date">2020-02-07&nbsp;12:19:22 +0900</div></div><div class="message__body description">質問がよく分かってないですが，<br/><pre>haskell
&gt;&gt;&gt; :set -XTemplateHaskell
&gt;&gt;&gt; import <http://Language.Haskell.TH|Language.Haskell.TH>
&gt;&gt;&gt; let e = () in $(unboundVarE $ mkName "e")
()</pre><br/>が面白い挙動ということですか？</div></div></div></div><div class="pager ui pagination menu"><a href="../../html/C5666B6BB/77.html" class="pager__previous item">Previous</a><a href="../../" class="pager__top item">Top</a><a href="../../html/C5666B6BB/79.html" class="pager__next item">Next</a></div></div></body></html>