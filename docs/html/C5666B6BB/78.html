<!DOCTYPE html><html><head><meta charset="utf-8"><title>haskell-jp / questions #78</title><link rel="stylesheet" href="../../messages.css" type="text/css" media="screen"></head><body><h1>haskell-jp / questions #78</h1><div class="pager"><a href="../../html/C5666B6BB/77.html" class="pager__previous">Previous</a><a href="../../" class="pager__top">Top</a></div><div class="message_list"><div class="message" id="message-1579674288.041000"><div class="message__timestamp">2020-01-22<br/>15:24:48 +0900</div><div class="message__header">ncaq</div><div class="message__body">前悩んだ時は <code>LANG=C</code> で言語指定したらビルドできました</div></div><div class="message" id="message-1579674403.041200"><div class="message__timestamp">2020-01-22<br/>15:26:43 +0900</div><div class="message__header">maoe</div><div class="message__body">フォローアップを忘れていました。have-quartz-gtkフラグが必要です。cabalなら<br/><code>cabal build --with-gcc=gcc-9 --constraint="gtk +have-quartz-gtk"</code> でいけると思います。</div></div><div class="message" id="message-1579674551.041500"><div class="message__timestamp">2020-01-22<br/>15:29:11 +0900</div><div class="message__header">maoe</div><div class="message__body">ちなみに`cabal install gtk --with-gcc=gcc-9` を試されていますがcabal v3以降ではプロジェクト外での cabal install は実行ファイルをインストールするコマンドです。ライブラリをインストールする場合は <code>cabal install --lib</code> を使う必要があります。</div></div><div class="message" id="message-1579695907.046100"><div class="message__timestamp">2020-01-22<br/>21:25:07 +0900</div><div class="message__header">gettaplacetogo</div><div class="message__body">競プロ用に`Data.Vector.Fusion.Bundle.Monadic`を弄っていて，<br/><pre>-- | Monadic streams
data Bundle m v a = Bundle { sElems  :: Stream m a
                           , sChunks :: Stream m (Chunk v a)
                           , sVector :: Maybe (v a)
                           , sSize   :: Size
                           }</pre><br/>を見たんですが，この第三フィールド(`sVector`)，なんで存在するのか分かる方っていらっしゃいます？ <code>Data.Vector.Generic.unstream</code>でさえこれを消費しているように見えないので，本当になんのためにあるのか分からなくて……．</div></div><div class="message" id="message-1579701801.046400"><div class="message__timestamp">2020-01-22<br/>23:03:21 +0900</div><div class="message__header">syani4732</div><div class="message__body">@syani4732 has joined the channel</div></div><div class="message" id="message-1579764984.046600"><div class="message__timestamp">2020-01-23<br/>16:36:24 +0900</div><div class="message__header">kakkun61</div><div class="message__body">詳しいことは分からないですが <code>sVector</code> ができた経緯としては <code>fromVector</code> でもらった vector をそのまま保存するためみたいですね<br/><a href='https://github.com/haskell/vector/commit/f375eff766f1fbecfc2944da3a7034c22658590a#diff-a5466f1eaf4aa39e68b2095915f3fde1L1590-R1594'>https://github.com/haskell/vector/commit/f375eff766f1fbecfc2944da3a7034c22658590a#diff-a5466f1eaf4aa39e68b2095915f3fde1L1590-R1594</a></div></div><div class="message" id="message-1579766903.046900"><div class="message__timestamp">2020-01-23<br/>17:08:23 +0900</div><div class="message__header">kakkun61</div><div class="message__body">試しに <code>sVector</code> を消してコンパイル通してみましたが、確かに取り出してないように見えますね<br/><a href='https://github.com/haskell/vector/compare/master...kakkun61:remove-svector'>https://github.com/haskell/vector/compare/master...kakkun61:remove-svector</a></div></div><div class="message" id="message-1579777889.049600"><div class="message__timestamp">2020-01-23<br/>20:11:29 +0900</div><div class="message__header">gettaplacetogo</div><div class="message__body">ですよね…。ありがとうございます。まあ、fromVectorで代入されてるのは見てるんですけど、やっぱよくわからないですね…。外部ライブラリで使用させてあげるためとか？　それとも歴史的な理由か…。</div></div><div class="message" id="message-1579906992.049900"><div class="message__timestamp">2020-01-25<br/>08:03:12 +0900</div><div class="message__header">igrep</div><div class="message__body">英語で聞くのは大変かとは思いますがどうやらここにvectorパッケージのメンテナはいないようなので<br/><a href='https://github.com/haskell/vector/issues'>https://github.com/haskell/vector/issues</a> か適当なML（恐らくlibraries@haskell.org あたり？）で聞かないとこれ以上のことはわからないと思います:disappointed_relieved:</div></div><div class="message" id="message-1579945531.050200"><div class="message__timestamp">2020-01-25<br/>18:45:31 +0900</div><div class="message__header">ap.gr.le</div><div class="message__body">@ap.gr.le has joined the channel</div></div><div class="message" id="message-1579966853.050400"><div class="message__timestamp">2020-01-26<br/>00:40:53 +0900</div><div class="message__header">gettaplacetogo</div><div class="message__body">ですよね………．でも，英語で聞くのは問題ないんですが，「存在することに問題(issue)がある」というふうには思えなかったので，とりあえずここで聞いてみたんですよね</div></div><div class="message" id="message-1579967817.050600"><div class="message__timestamp">2020-01-26<br/>00:56:57 +0900</div><div class="message__header">gettaplacetogo</div><div class="message__body">と思ったけど，issueはproblemじゃないんだから，バグでも改善点でもない単なる疑問点でも聞いていいのか………？</div></div><div class="message" id="message-1579994137.050900"><div class="message__timestamp">2020-01-26<br/>08:15:37 +0900</div><div class="message__header">igrep</div><div class="message__body">「存在することに問題(issue)」は十分ありえますよ。余計なフィールド（実際にはまだ容疑だけですが）があると言うことはそれだけでこうして意味を調べる時間を割かないといけない原因になりますし、新しい機能を追加したりするときに検討事項を増やす要因になり得ます。<br/>ユーザーに直接影響を与えることは（多分）ないでしょうがメンテナンスの負荷を多かれ少なかれ上げることになるので立派な問題だと思います。</div></div><div class="message" id="message-1580015626.051100"><div class="message__timestamp">2020-01-26<br/>14:13:46 +0900</div><div class="message__header">gettaplacetogo</div><div class="message__body">ふむ</div></div><div class="message" id="message-1580016168.051300"><div class="message__timestamp">2020-01-26<br/>14:22:48 +0900</div><div class="message__header">gettaplacetogo</div><div class="message__body"><a href='https://github.com/haskell/vector/issues/269'>https://github.com/haskell/vector/issues/269</a> とりあえずissueにしました．</div></div><div class="message" id="message-1580017122.051600"><div class="message__timestamp">2020-01-26<br/>14:38:42 +0900</div><div class="message__header">gettaplacetogo</div><div class="message__body">正直忙しそうで申し訳ないのですけどね………</div></div><div class="message" id="message-1580023135.052000"><div class="message__timestamp">2020-01-26<br/>16:18:55 +0900</div><div class="message__header">masa1023tora</div><div class="message__body">@masa1023tora has joined the channel</div></div><div class="message" id="message-1580192957.052500"><div class="message__timestamp">2020-01-28<br/>15:29:17 +0900</div><div class="message__header">hitoshi</div><div class="message__body">@hitoshi has joined the channel</div></div><div class="message" id="message-1580315147.052800"><div class="message__timestamp">2020-01-30<br/>01:25:47 +0900</div><div class="message__header">hayato.daikichi</div><div class="message__body">@hayato.daikichi has joined the channel</div></div><div class="message" id="message-1580343114.055900"><div class="message__timestamp">2020-01-30<br/>09:11:54 +0900</div><div class="message__header">misaki</div><div class="message__body">基本的なことなのですが、たとえば<br/><pre>
main :: IO ()
main = do
                 putStrLn “string”
                 putStrLn “string”
</pre><br/>がメモイズされないのってなぜですか？<br/>IO独自で阻害する何かがあるのか、もっと一般的なことなのでしょうか。</div></div><div class="message" id="message-1580346074.056100"><div class="message__timestamp">2020-01-30<br/>10:01:14 +0900</div><div class="message__header">kazu</div><div class="message__body">何がメモ化されるべきだと考えているのですか？</div></div><div class="message" id="message-1580346254.056300"><div class="message__timestamp">2020-01-30<br/>10:04:14 +0900</div><div class="message__header">igrep</div><div class="message__body">一つ目の <code>putStrLn "string"</code> がメモ化されて1回しか出力されないのでは、という話ですかね？</div></div><div class="message" id="message-1580347091.058000"><div class="message__timestamp">2020-01-30<br/>10:18:11 +0900</div><div class="message__header">misaki</div><div class="message__body">そうです！<br/>メモ化されるべきではないですが、メモ化されるべきではないという明示がない同引数の関数をメモ化していないのはIO自体に細工があるのでしょうか？</div></div><div class="message" id="message-1580347603.059600"><div class="message__timestamp">2020-01-30<br/>10:26:43 +0900</div><div class="message__header">kazu</div><div class="message__body">うーん。フィボナッチの計算などでいうメモ化のことであれば、Haskellでもメモ化のためのライブラリなどを使わないとメモ化されないと思います。</div></div><div class="message" id="message-1580347630.060100"><div class="message__timestamp">2020-01-30<br/>10:27:10 +0900</div><div class="message__header">kazu</div><div class="message__body">参考： <a href='https://www.ipsj.or.jp/07editj/promenade/4608.pdf'>https://www.ipsj.or.jp/07editj/promenade/4608.pdf</a></div></div><div class="message" id="message-1580347701.061600"><div class="message__timestamp">2020-01-30<br/>10:28:21 +0900</div><div class="message__header">misaki</div><div class="message__body">あれ、そうでしたっけ。<br/>資料ありがとうございます。<br/>読んでみます。<br/><br/>もう少しHaskellのメモ化戦略について調べてみますorz</div></div><div class="message" id="message-1580347817.061800"><div class="message__timestamp">2020-01-30<br/>10:30:17 +0900</div><div class="message__header">igrep</div><div class="message__body">（もう回答済みで恐縮ですが）そもそも、別々の場所にあるたまたま同じ形の式が自動でメモ化されるなんてことはありません。<br/>じゃぁどういう条件だとメモ化されるの、というと、結構複雑です、こちらのスレッドや記事なども参考にどうぞ、とだけ :sweat_smile:<br/><a href='https://haskell-jp.slack.com/archives/C5666B6BB/p1564340963043600'>https://haskell-jp.slack.com/archives/C5666B6BB/p1564340963043600</a><br/><a href='http://www.kotha.net/hperf/basics.html'>http://www.kotha.net/hperf/basics.html</a><br/><a href='https://kakkun61.hatenablog.com/entry/2019/07/29/%E9%96%A2%E6%95%B0%E3%81%AE%E3%83%A1%E3%83%A2%E5%8C%96'>https://kakkun61.hatenablog.com/entry/2019/07/29/%E9%96%A2%E6%95%B0%E3%81%AE%E3%83%A1%E3%83%A2%E5%8C%96</a></div></div><div class="message" id="message-1580347830.062100"><div class="message__timestamp">2020-01-30<br/>10:30:30 +0900</div><div class="message__header">kazu</div><div class="message__body">これも： <a href='https://github.com/kazu-yamamoto/recursion-drill/blob/master/drill/7.md'>https://github.com/kazu-yamamoto/recursion-drill/blob/master/drill/7.md</a></div></div><div class="message" id="message-1580347914.063700"><div class="message__timestamp">2020-01-30<br/>10:31:54 +0900</div><div class="message__header">misaki</div><div class="message__body">たぶん、メモイズが提供される高階関数とHaskell自体の機能を混同してました。<br/>ありがとうございました。<br/><br/><a href='https://stackoverflow.com/questions/13059381/an-option-to-make-memoization-the-default-behaviour-of-haskell'>https://stackoverflow.com/questions/13059381/an-option-to-make-memoization-the-default-behaviour-of-haskell</a></div></div><div class="message" id="message-1580347943.064200"><div class="message__timestamp">2020-01-30<br/>10:32:23 +0900</div><div class="message__header">kazu</div><div class="message__body">自動的にメモ化されるとなると、コンパイラが動的計画法を自動的に実装してくれることになりますが、一般的にそんなことはしません。</div></div><div class="message" id="message-1580347980.064800"><div class="message__timestamp">2020-01-30<br/>10:33:00 +0900</div><div class="message__header">misaki</div><div class="message__body">資料ありがとうございます！<br/>助かります！</div></div><div class="message" id="message-1580349241.068000"><div class="message__timestamp">2020-01-30<br/>10:54:01 +0900</div><div class="message__header">misaki</div><div class="message__body">すみません、高階関数の機能ではなくcommon subexpression eliminationについてでした！<br/><br/><blockquote>So GHC does do CSE, but only in specific circumstances --- see the GHC manual. (Section??)</blockquote>詳細への参照が「セクション？？」になってます笑<br/><br/>単純にこのIOのケースではCSEは動かないし、そんなにCSEが動く場面はないよ、ということでした。<br/><br/><a href='https://wiki.haskell.org/GHC_optimisations#Common_subexpression_elimination'>https://wiki.haskell.org/GHC_optimisations#Common_subexpression_elimination</a></div></div><div class="message" id="message-1580350731.068400"><div class="message__timestamp">2020-01-30<br/>11:18:51 +0900</div><div class="message__header">mizunashi-mana</div><div class="message__body">ところで，CSE が動けば IO はメモ化されますが，IO のメモ化とIO effect のメモ化は異なる概念なので，effect がメモ化されるわけではありません:<br/><pre>main = let e = putStrLn "string" in e &gt;&gt; e</pre><br/>で，e の二回目の呼び出しは (最適化を考えなければ)メモ化されますが， string は2回出力されます．GHC の場合，IO は単純な State モナドで実装されているので，e は状態操作関数が束縛されていると思えば良くて，状態操作関数をメモ化したところで，関数の実行は2回行われるので作用は2回行われるというのが，作用がメモ化されない要因ですね<br/>(ただし，この前提は最適化次第では崩れる場合があり，特にインライン展開の順番には GHC は気を使っていて，IO 相当の状態操作関数はインライン展開が幾つか阻害される場合があります)</div></div><div class="message" id="message-1580350852.068600"><div class="message__timestamp">2020-01-30<br/>11:20:52 +0900</div><div class="message__header">mizunashi-mana</div><div class="message__body">最適化を考えない場合の話は，State モナドでも同様なので，State モナドの作用がメモ化されないのはなぜか考えてみるのがいい気がします</div></div><div class="message" id="message-1580378035.069500"><div class="message__timestamp">2020-01-30<br/>18:53:55 +0900</div><div class="message__header">alex</div><div class="message__body">@alex has joined the channel</div></div><div class="message" id="message-1580547253.069900"><div class="message__timestamp">2020-02-01<br/>17:54:13 +0900</div><div class="message__header">benibana2001</div><div class="message__body">@benibana2001 has joined the channel</div></div></div><div class="pager"><a href="../../html/C5666B6BB/77.html" class="pager__previous">Previous</a><a href="../../" class="pager__top">Top</a></div></body></html>