<!DOCTYPE html><html><head><meta charset="utf-8"><title>haskell-jp / questions #87</title><link rel="stylesheet" href="../../main.css" type="text/css" media="screen"></head><body><div class="ui container"><h1>haskell-jp / questions #87</h1><div class="pager ui pagination menu"><a href="../../html/C5666B6BB/86.html" class="pager__previous item">Previous</a><a href="../../" class="pager__top item">Top</a></div><div class="message_list ui feed"><div class="message event" id="message-1592620487.062600"><div class="content"><div class="summary"><div class="message__header user">cj.bc-sd</div><div class="message__timestamp date"><a class="date" href="#message-1592620487.062600">2020-06-20&nbsp;11:34:47 +0900</a></div></div><div class="message__body description">返信遅くなりましたがうまく行きました！！！<br/>ありがとうございます！！<br/>Lensはoverやsetやviewと使うものだという固定概念がありました…今度からもっと型を注意してみるようにしてみます<br/><br/><pre>Prelude Control.Lens&gt; _2 (\a -&gt; print ("PRINTED: " ++ show a) &gt;&gt; return (Just "a")) (("hoge",6), 1.20)
"PRINTED: 1.2"
(("hoge",6),Just "a")
Prelude Control.Lens&gt; (_1 . _2) (\a -&gt; print ("PRINTED: " ++ show a) &gt;&gt; return (Just "a")) (("hoge",6), 1.20)
"PRINTED: 6"
(("hoge",Just "a"),1.2)</pre><br/>そうなんですねwすごい偶然</div></div></div><div class="message event" id="message-1592726883.064100"><div class="content"><div class="summary"><div class="message__header user">dex10619</div><div class="message__timestamp date"><a class="date" href="#message-1592726883.064100">2020-06-21&nbsp;17:08:03 +0900</a></div></div><div class="message__body description">初歩的な質問ですが、お尋ねさせてください。<br/>仮定として、Main.hsに以下のような相対パス指定のファイル読み込みのコードが書かれているとします。<br/><br/><pre>readFile "../hoge.txt" --1つ上の階層のパスからファイルを読み込み</pre><br/>この時、current working directoryに依存せずに、「Main.hsファイルを起点とした相対パス指定」でファイルを読み込みたいです。<br/>（「stack exec XXX-exe」でプロセスを起動すると、current working directory起点とした相対パス指定になるため、場合によりうまく動かないです。）<br/><br/>上記のやりたいことを実現するための、お決まりのパターンとかってありますか？<br/>getCurrentDirectoryだと、簡単には行かなそうです。</div></div></div><div class="message event" id="message-1592729423.064300"><div class="content"><div class="summary"><div class="message__header user">matonix</div><div class="message__timestamp date"><a class="date" href="#message-1592729423.064300">2020-06-21&nbsp;17:50:23 +0900</a></div></div><div class="message__body description">私が同じような問題に当たっときは「コンパイル時に相対パス指定したファイルを埋め込む」という方法を取りました。<br/>以下のパッケージがそのような手段を提供しています。<br/><a href='https://hackage.haskell.org/package/file-embed-0.0.12.0'>https://hackage.haskell.org/package/file-embed-0.0.12.0</a><br/>他の方法をご存じの方がいらっしゃいましたらよろしくお願いします（私も気になってます…）</div></div></div><div class="message event" id="message-1592730211.064700"><div class="content"><div class="summary"><div class="message__header user">dex10619</div><div class="message__timestamp date"><a class="date" href="#message-1592730211.064700">2020-06-21&nbsp;18:03:31 +0900</a></div></div><div class="message__body description">@matonix<br/>回答ありがとうございます。上記の方法はなかなかテクニカルですね。。<br/>意外と手軽にできる方法はなかったりするのですかね:cry:</div></div></div><div class="message event" id="message-1592730946.064900"><div class="content"><div class="summary"><div class="message__header user">igrep</div><div class="message__timestamp date"><a class="date" href="#message-1592730946.064900">2020-06-21&nbsp;18:15:46 +0900</a></div></div><div class="message__body description">コンパイル時のことって基本的に忘れられてしまうので難しいですね。<br/>イマイチ目的が想像できませんが、プロジェクトルートからの相対パスか、 <a href='https://www.haskell.org/cabal/users-guide/developing-packages.html?highlight=paths_#accessing-data-files-from-package-code'>https://www.haskell.org/cabal/users-guide/developing-packages.html?highlight=paths_#accessing-data-files-from-package-code</a> などに書かれている <code>Paths_pkgname</code> を使った方が賢明かと思います。<br/>それでもコンパイルされる <code>Main.hs</code> の場所が欲しい、ということであれば、Template Haskellの <code>location</code> が使えるかな、と思ったけどこれはフルパスはとれないっぽいな<br/><a href='http://hackage.haskell.org/package/template-haskell-2.16.0.0/docs/Language-Haskell-TH-Syntax.html#v:location'>http://hackage.haskell.org/package/template-haskell-2.16.0.0/docs/Language-Haskell-TH-Syntax.html#v:location</a></div></div></div><div class="message event" id="message-1592732425.067800"><div class="content"><div class="summary"><div class="message__header user">kakkun61</div><div class="message__timestamp date"><a class="date" href="#message-1592732425.067800">2020-06-21&nbsp;18:40:25 +0900</a></div></div><div class="message__body description">自分も <code>Paths_pkgname</code> が正攻法に思います</div></div></div><div class="message event" id="message-1592732460.068500"><div class="content"><div class="summary"><div class="message__header user">maoe</div><div class="message__timestamp date"><a class="date" href="#message-1592732460.068500">2020-06-21&nbsp;18:41:00 +0900</a></div></div><div class="message__body description">コンパイル時に指定したパスが実行時にも存在することが保証されている前提ならCPPを有効にして <code>__FILE__</code> マクロを使う手もあります。</div></div></div><div class="message event" id="message-1592733614.068800"><div class="content"><div class="summary"><div class="message__header user">dex10619</div><div class="message__timestamp date"><a class="date" href="#message-1592733614.068800">2020-06-21&nbsp;19:00:14 +0900</a></div></div><div class="message__body description">@igrep @kakkun61 @maoe<br/>なるほど、ありがとうございます！<br/>確かに<br/><br/><blockquote>コンパイル時のことって基本的に忘れられてしまうので難しいですね。</blockquote>これが真理な気がしてきました。。</div></div></div><div class="message event" id="message-1592734058.069000"><div class="content"><div class="summary"><div class="message__header user">dex10619</div><div class="message__timestamp date"><a class="date" href="#message-1592734058.069000">2020-06-21&nbsp;19:07:38 +0900</a></div></div><div class="message__body description">基本的にstackを利用してprojectを作成する際は、実行体である.exeファイルはstackのサンドボックス内に作られるので、プロセスの起動もサンドボックス内の特定のディレクトリで行う、という形をとるのが素直な気がしてきました:bow:</div></div></div><div class="message event" id="message-1593074145.069800"><div class="content"><div class="summary"><div class="message__header user">ym0429_ma4ma</div><div class="message__timestamp date"><a class="date" href="#message-1593074145.069800">2020-06-25&nbsp;17:35:45 +0900</a></div></div><div class="message__body description">@ym0429_ma4ma has joined the channel</div></div></div><div class="message event" id="message-1593243213.070100"><div class="content"><div class="summary"><div class="message__header user">znmxodq1</div><div class="message__timestamp date"><a class="date" href="#message-1593243213.070100">2020-06-27&nbsp;16:33:33 +0900</a></div></div><div class="message__body description">@znmxodq1 has joined the channel</div></div></div><div class="message event" id="message-1593512177.070500"><div class="content"><div class="summary"><div class="message__header user">falgon53</div><div class="message__timestamp date"><a class="date" href="#message-1593512177.070500">2020-06-30&nbsp;19:16:17 +0900</a></div></div><div class="message__body description">@falgon53 has joined the channel</div></div></div><div class="message event" id="message-1593575176.070800"><div class="content"><div class="summary"><div class="message__header user">sdghrwihl456</div><div class="message__timestamp date"><a class="date" href="#message-1593575176.070800">2020-07-01&nbsp;12:46:16 +0900</a></div></div><div class="message__body description">@sdghrwihl456 has joined the channel</div></div></div><div class="message event" id="message-1593672664.071100"><div class="content"><div class="summary"><div class="message__header user">kazuki.matsuo.728</div><div class="message__timestamp date"><a class="date" href="#message-1593672664.071100">2020-07-02&nbsp;15:51:04 +0900</a></div></div><div class="message__body description">@kazuki.matsuo.728 has joined the channel</div></div></div><div class="message event" id="message-1593710468.075000"><div class="content"><div class="summary"><div class="message__header user">dex10619</div><div class="message__timestamp date"><a class="date" href="#message-1593710468.075000">2020-07-03&nbsp;02:21:08 +0900</a></div></div><div class="message__body description">「プログラミングHaskell 第2版」１３章の「モナドパーサー」を読んでいますが、<br/>以下の式がどう簡約されていき、最終的に[("1", "a")]と評価されているのか分からず、苦戦中。。<br/><br/>これ、どのような順序で式が評価されていってるのでしょう。。<br/><pre>&gt;parse (some digit) "1a"
[("1","a")]</pre><br/>以下の簡約の仕方だと、永遠に評価が終わらない。<br/><br/><pre>-- many x = some x &lt;|&gt; pure []
-- some x = pure (:) &lt;*&gt; x &lt;*&gt; many x

parse (some digit) "1a"
parse (pure (:) &lt;*&gt; digit &lt;*&gt; many digit) "1a"
parse (pure (:) &lt;*&gt; digit &lt;*&gt; (some digit &lt;|&gt; pure [])) "1a"
parse (pure (:) &lt;*&gt; digit &lt;*&gt; ((pure (:) &lt;*&gt; digit &lt;*&gt; many digit) &lt;|&gt; pure [])) "1a"
…（以下略）</pre><br/><br/>ちなみに、以下のコードを叩いてみたら、次の結果となったので、末尾の相互再帰(many/some)の部分は遅延評価されているように思えますが、具体的にどう簡約されていくのかが分からないです。。<br/><br/><pre>&gt;parse (some digit) (repeat 'a')
[] --これは直ちに結果（empty)を返す</pre><br/><pre>&gt;parse (some digit) (repeat '1')
*** Exception: stack overflow --スタックオーバーフローが発生</pre><br/><br/>＜補足＞<br/>上記の元となる実装は以下です。<br/><br/><pre>newtype Parser a = Parser (String -&gt; [(a, String)])                                                                                                                                                                                           

parse :: Parser a -&gt; String -&gt; [(a, String)]
parse (Parser p) inp = p inp 

instance Alternative Parser where
  empty  = Parser (\inp -&gt; []) 
  p &lt;|&gt; q = Parser (\inp -&gt; case parse p inp of
                              [] -&gt; parse q inp 
                              [(a, out)] -&gt; [(a, out)])
  many x = some x &lt;|&gt; pure []
  some x = pure (:) &lt;*&gt; x &lt;*&gt; many x


instance Functor Parser where
  fmap f p = Parser (\inp -&gt; case parse p inp of
                               [] -&gt; []
                               [(a, out)] -&gt; [(f a, out)])

instance Applicative Parser where
  pure v = Parser (\inp -&gt; [(v, inp)])
  pf &lt;*&gt; pa = Parser (\inp -&gt; case parse pf inp of
                                [] -&gt; []
                                [(f, out)] -&gt; parse (fmap f pa) out)

instance Monad Parser where
  return = pure
  p &gt;&gt;= f = Parser (\inp -&gt; case parse p inp of
                         [] -&gt; []
                         [(v, out)] -&gt; parse (f v) out)

item :: Parser Char
item = Parser (\inp -&gt; case inp of
                          [] -&gt; []
                          (x:xs) -&gt; [(x, xs)])

sat :: (Char -&gt; Bool) -&gt; Parser Char
sat p = do
  x &lt;- item
  if p x then return x else empty

digit :: Parser Char
digit = sat isDigit</pre><br/></div></div></div><div class="message event" id="message-1593734605.075100"><div class="content"><div class="summary"><div class="message__header user">igrep</div><div class="message__timestamp date"><a class="date" href="#message-1593734605.075100">2020-07-03&nbsp;09:03:25 +0900</a></div></div><div class="message__body description">ちょっと今試す余裕がないので取り急ぎの回答を。<br/>引数の文字列を消費していないからあたかも無限に続くように見えるのです。先に <code>parse</code> を展開してみてください。<br/>ただ、手で簡約するのはしんどいと思うので、`parse` や <code>many</code> , <code>some</code> の引数と戻り値を評価するタイミングで <code>trace</code> (`many` や <code>some</code> ではそのままでは <code>traceShowId</code> が使えないので注意) してみたり、その上でGHCi の <code>:sprint</code> で戻り値がどう評価されるか見たり、 あるいはもしかしたら <a href='http://felsin9.de/nnis/ghc-vis/'>http://felsin9.de/nnis/ghc-vis/</a> が役に立つかも知れません。</div></div></div><div class="message event" id="message-1593734714.075300"><div class="content"><div class="summary"><div class="message__header user">igrep</div><div class="message__timestamp date"><a class="date" href="#message-1593734714.075300">2020-07-03&nbsp;09:05:14 +0900</a></div></div><div class="message__body description">もう一点訂正させてください。<br/><blockquote>末尾の相互再帰(many/some)の部分</blockquote><code>many</code> と <code>some</code> における再帰は末尾再帰ではないです。（末尾再帰ちゃんとできてるならスタックオーバーフローもしないはずですし<br/><br/>末尾再帰の正確な定義については検索してください :pray:</div></div></div><div class="message event" id="message-1593736937.075700"><div class="content"><div class="summary"><div class="message__header user">mizunashi-mana</div><div class="message__timestamp date"><a class="date" href="#message-1593736937.075700">2020-07-03&nbsp;09:42:17 +0900</a></div></div><div class="message__body description">基本的には、遅延評価と覚えるのではなく、いちばん外側の式から簡約されていくと思えばいいです<br/><br/><code>parse (some digit) "1a"</code> は <code>(parse (some digit)) "1a"</code> の略記なので、いちばん最初は <code>e1 e2</code> (`e1 = parse (some digit)`、`e2 = "1a"`) の形の簡約から始まります。<br/><br/><code>e1 e2</code> の形の簡約方法は、`e1` を <code>(\x -&gt; ...)</code> の形かコンストラクタへの部分適用まで評価した後、`e2` を適用するというものです。今回は、まず <code>parse (some digit)</code> をその形まで簡約します。<br/><br/><code>parse (some digit)</code> もやっぱり、`e1 e2` の形なので、さらに <code>parse</code> の簡約を行います。`parse` はその定義から <code>\(Parse p) inp -&gt; p inp</code> の形に簡約されます。</div></div></div><div class="message event" id="message-1593737455.076000"><div class="content"><div class="summary"><div class="message__header user">mizunashi-mana</div><div class="message__timestamp date"><a class="date" href="#message-1593737455.076000">2020-07-03&nbsp;09:50:55 +0900</a></div></div><div class="message__body description">次に、`(\(Parse p) inp -&gt; p inp) (some digit)` の適用が始まります。<br/><br/><code>(\(Parse p) inp -&gt; p inp)</code> は <code>\x inp -&gt; case x of { Parse p -&gt; p inp }</code> の略記なので、まず適用結果は <code>\inp -&gt; case (some digit) of { Parse p -&gt; p inp }</code> になります。</div></div></div><div class="message event" id="message-1593738026.076200"><div class="content"><div class="summary"><div class="message__header user">mizunashi-mana</div><div class="message__timestamp date"><a class="date" href="#message-1593738026.076200">2020-07-03&nbsp;10:00:26 +0900</a></div></div><div class="message__body description">で、一番最初の <code>parse (some digit) "1a"</code> が <code>(\inp -&gt; case (some digit) of { Parse p -&gt; p inp }) "1a"</code> になり、適用操作が始まります。その結果 <code>case (some digit) of { Parse p -&gt; p "1a" }</code> になります。<br/><br/>ここからがちょっと特殊で、`Parse` 型が <code>data</code> か <code>newtype</code> かで簡約方法が異なります。今回は <code>newtype</code> なので、その場合の簡約方法を見ていきます。<br/><br/>まず、今の一番外側の式の形は <code>case e1 of { ... }</code> になるので、この形の簡約方法が適用されます。`case` の形は結構複雑で、その全容は <a href='https://www.haskell.org/onlinereport/haskell2010/haskellch3.html#x8-580003.17'>https://www.haskell.org/onlinereport/haskell2010/haskellch3.html#x8-580003.17</a> に書かれています。<br/><br/>今回の <code>case e1 of { Parse p -&gt; p "1a" }</code> でのパターン <code>Parse p</code> の場合、`newtype` によるコンストラクタ <code>Parse</code> はないものとして扱われ、`e1` は <code>p</code> に直接紐づかされます。これは、Haskell の式では表現できないですが、気分的には <code>cast&lt;String -&gt; ...&gt;(some digit) "1a"</code> みたいな感じで <code>e1</code> は <code>Parse</code> 型ではなく <code>String -&gt; ...</code> 型の値として扱われるようになります。<br/><br/>で、また <code>e1 e2</code> の形の簡約が適用されます。この場合 <code>cast&lt;...&gt;( )</code> はないものと思ってもらってよくて、`some digit` をまず簡約するという流れになります</div></div></div><div class="message event" id="message-1593739585.076600"><div class="content"><div class="summary"><div class="message__header user">mizunashi-mana</div><div class="message__timestamp date"><a class="date" href="#message-1593739585.076600">2020-07-03&nbsp;10:26:25 +0900</a></div></div><div class="message__body description"><code>some digit</code> はやっぱり <code>e1 e2</code> の形をしているので、今までの流れと同じく <code>some</code> の定義から <code>(\x -&gt; pure (:) &lt;*&gt; x &lt;*&gt; many x) digit</code> になった後、`x` に <code>digit</code> が紐づき <code>pure (:) &lt;*&gt; digit &lt;*&gt; many digit</code>  のように簡約されます<br/><br/>(実際には変数 <code>x</code> の領域が作られ、そこに <code>digit</code> と紐づいてることが記憶され、簡約結果は変数 <code>x</code> を残しそこの簡約が走ると記憶領域が参照されその時初めて <code>digit</code> に置き換わりますが、今回は省略します)</div></div></div><div class="message event" id="message-1593739797.076800"><div class="content"><div class="summary"><div class="message__header user">mizunashi-mana</div><div class="message__timestamp date"><a class="date" href="#message-1593739797.076800">2020-07-03&nbsp;10:29:57 +0900</a></div></div><div class="message__body description"><code>pure (:) &lt;*&gt; digit &lt;*&gt; many digit</code> は <code>&lt;*&gt;</code> が左結合なので、`(&lt;*&gt;) ((&lt;*&gt;) (pure (:)) digit) (many digit)` の略記になります。なので、`e1 = (&lt;*&gt;) ((&lt;*&gt;) (pure (:)) digit)`、`e2 = many digit` においていちばん外側の式の形が <code>e1 e2</code> になる式です。</div></div></div><div class="message event" id="message-1593740157.077200"><div class="content"><div class="summary"><div class="message__header user">mizunashi-mana</div><div class="message__timestamp date"><a class="date" href="#message-1593740157.077200">2020-07-03&nbsp;10:35:57 +0900</a></div></div><div class="message__body description">よって、今までの流れ通り <code>(&lt;*&gt;) ((&lt;*&gt;) (pure (:)) digit)</code> の簡約が実行されます。これは <code>(&lt;*&gt;)</code> の定義が <code>(\pf pa -&gt; Parser (\inp -&gt; case parse pf of ...))</code> なのでそれに展開され、その後 <code>pf</code> に <code>(&lt;*&gt;) (pure (:)) digit</code> が紐づいて <code>\pa -&gt; Parser (\inp -&gt; case parse ((&lt;*&gt;) (pure (:)) digit) inp of ...)</code> になります。<br/><br/>で、最初に戻って今度は <code>pa</code> に <code>many digit</code> が紐づいて <code>Parser (\inp -&gt; case parse ((&lt;*&gt;) (pure (:)) digit) inp of ...)</code> になります。<br/><br/><code>newtype</code> の <code>Parser</code> コンストラクタは無視してよいので <code>cast&lt;...&gt;(some digit)</code> は <code>\inp -&gt; case parse ((&lt;*&gt;) (pure (:)) digit) inp of ...</code> にようやく簡約されることになります</div></div></div><div class="message event" id="message-1593740255.077500"><div class="content"><div class="summary"><div class="message__header user">mizunashi-mana</div><div class="message__timestamp date"><a class="date" href="#message-1593740255.077500">2020-07-03&nbsp;10:37:35 +0900</a></div></div><div class="message__body description">で、`inp` に <code>"1a"</code> が紐づき <code>case parse ((&lt;*&gt;) (pure (:)) digit) "1a" of ...</code> の簡約が始まります</div></div></div><div class="message event" id="message-1593740818.077700"><div class="content"><div class="summary"><div class="message__header user">mizunashi-mana</div><div class="message__timestamp date"><a class="date" href="#message-1593740818.077700">2020-07-03&nbsp;10:46:58 +0900</a></div></div><div class="message__body description"><code>case e1 of ...</code> は基本的にはマッチするパターンを最初から探していき、その過程で <code>e1</code> が簡約されていきます。今回は、<br/><pre>case parse ((&lt;*&gt;) (pure (:)) digit) "1a" of
  [] -&gt; []
  [(f, out)] -&gt; parse (fmap f (many digit)) out</pre><br/>が省略なしで書いた現在の簡約結果なので、最初のパターンは <code>[]</code> になります。この場合、`[]` は <code>data</code> による型なので <code>parse ((&lt;*&gt;) (pure (:)) digit) "1a"</code> を <code>\x -&gt; ...</code> かコンストラクタへの部分適用の形になるまで評価します。<br/><br/>その過程で <code>((&lt;*&gt;) (pure (:)) digit)</code> の部分が簡約されますが、これは今までの流れと大体同様なので、その過程は省略します。</div></div></div><div class="message event" id="message-1593741163.077900"><div class="content"><div class="summary"><div class="message__header user">mizunashi-mana</div><div class="message__timestamp date"><a class="date" href="#message-1593741163.077900">2020-07-03&nbsp;10:52:43 +0900</a></div></div><div class="message__body description">最終的に、`parse ((&lt;*&gt;) (pure (:)) digit) "1a"` は<br/><pre>case parse (pure (:)) "1a" of
  [] -&gt; []
  [(f, out)] -&gt; parse (fmap f digit) out</pre><br/>になります。<br/><br/>で、また <code>parse (pure (:)) "1a"</code> の簡約が実行されることになります。これは、進めると <code>[((:), "1a")]</code> になります。<br/><br/>よって、<br/><pre>case [((:), "1a")] of
  [] -&gt; []
  [(f, out)] -&gt; parse (fmap f digit) out</pre><br/>に簡約が進むことになります</div></div></div><div class="message event" id="message-1593741323.078500"><div class="content"><div class="summary"><div class="message__header user">mizunashi-mana</div><div class="message__timestamp date"><a class="date" href="#message-1593741323.078500">2020-07-03&nbsp;10:55:23 +0900</a></div></div><div class="message__body description">これは <code>[]</code> のパターンマッチに失敗し、今度は <code>[(f, out)]</code> のパターンが参照されます。こちらには成功するので、`f` に <code>(:)</code> が、`out` に <code>"1a"</code> が紐づき <code>parse (fmap (:) digit) "1a"</code> に簡約が進みます</div></div></div><div class="message event" id="message-1593744349.078700"><div class="content"><div class="summary"><div class="message__header user">mizunashi-mana</div><div class="message__timestamp date"><a class="date" href="#message-1593744349.078700">2020-07-03&nbsp;11:45:49 +0900</a></div></div><div class="message__body description">ここからは省略気味で進めます。`parse (fmap (:) digit) "1a"` は、<br/><pre>case parse digit "1a" of
  [] -&gt; []
  [(a, out)] -&gt; [((:) a, out)]</pre><br/>に簡約が進み、`parse digit "1a"` の簡約が始まります。<br/><br/><code>parse digit "1a"</code> の簡約において、`digit` の簡約が始まります。`digit` はその定義から、`sat isDigit` に展開され、`sat` の定義から<br/><pre>do
  x &lt;- item
  if isDigit x then return x else empty</pre><br/>に簡約されます。ところで、この式は、以下の略記になります<br/><pre>item &gt;&gt;= \x -&gt; if isDigit x then return x else empty</pre></div></div></div><div class="message event" id="message-1593744647.078900"><div class="content"><div class="summary"><div class="message__header user">mizunashi-mana</div><div class="message__timestamp date"><a class="date" href="#message-1593744647.078900">2020-07-03&nbsp;11:50:47 +0900</a></div></div><div class="message__body description">で、この式はさらに <code>(&gt;&gt;=) item (\x -&gt; if isDigit x then return x else empty</code> の略記なので、`(&gt;&gt;=)` の定義から<br/><pre>\inp -&gt; case parse item inp of
  [] -&gt; []
  [(v, out)] -&gt; parse ((\x -&gt; if isDigit x then return x else empty) v) out</pre><br/>に展開されることになります。後は <code>inp</code> に <code>"1a"</code> が紐づいて<br/><pre>case parse item "1a" of
  [] -&gt; []
  [(v, out)] -&gt; parse ((\x -&gt; if isDigit x then return x else empty) v) out</pre><br/>の簡約が始まることになります</div></div></div><div class="message event" id="message-1593744767.079100"><div class="content"><div class="summary"><div class="message__header user">mizunashi-mana</div><div class="message__timestamp date"><a class="date" href="#message-1593744767.079100">2020-07-03&nbsp;11:52:47 +0900</a></div></div><div class="message__body description">これまでと同様 <code>[]</code> パターンから <code>parse item "1a"</code> の簡約が始まり、<br/><pre>case "1a" of
  [] -&gt; []
  (x:xs) -&gt; [(x, xs)]</pre><br/>へと簡約が行われ、`"1a"` は <code>['1', 'a']</code> の略記で、これは <code>'1':('a':[])</code> の略記なので、`(x:xs)` のパターンマッチに成功し <code>[('1', "a")]</code> が出てくることになります</div></div></div><div class="message event" id="message-1593745248.079300"><div class="content"><div class="summary"><div class="message__header user">mizunashi-mana</div><div class="message__timestamp date"><a class="date" href="#message-1593745248.079300">2020-07-03&nbsp;12:00:48 +0900</a></div></div><div class="message__body description">その手順を続けていくと、`parse (fmap (:) digit) "1a"` は<br/><pre>[((:) '1', "a")]</pre><br/>になることになります。後は、そのまま簡約を上記の手順で進めていくと、`parse (some digit) "1a"` が最終的に <code>[("1", "a")]</code> になる過程が分かると思います</div></div></div><div class="message event" id="message-1593748902.082800"><div class="content"><div class="summary"><div class="message__header user">dex10619</div><div class="message__timestamp date"><a class="date" href="#message-1593748902.082800">2020-07-03&nbsp;13:01:42 +0900</a></div></div><div class="message__body description">@mizunashi-mana <br/>詳細な解説ありがとうございます！:sob:<br/>後でじっくり読ませていただきます！:man-bowing:<br/><br/>@igrep <br/>デバッグ手順のご教示ありがとうございます！勉強になります:smile:<br/>あ、末尾再帰ではないですね:sweat_drops:日本語の表現がおかしくてすみません:man-bowing:<br/>:sprintは後で試してみます！</div></div></div><div class="message event" id="message-1593751113.083300"><div class="content"><div class="summary"><div class="message__header user">mizunashi-mana</div><div class="message__timestamp date"><a class="date" href="#message-1593751113.083300">2020-07-03&nbsp;13:38:33 +0900</a></div></div><div class="message__body description">ついでに、`parse (some digit) (repeat '1')` が stack overflow するやつは、ぱっと見<br/><pre>many x = some x &lt;|&gt; pure []</pre><br/>この定義が問題ですね (詳しく見てないので、間違ってたらすいません)<br/><br/>ずっとマッチし続ける場合 <code>some x</code> のパースがどんどん進行していきその過程で <code>many x</code> がどんどん再帰的に展開されます。で、`many x` が展開された際、使用されない <code>pure []</code> が遅延されたまま残り続けることになります。<br/><br/>なので、`many x` が展開された分だけ、遅延された <code>pure []</code> に相当するオブジェクトが増え続けます。<br/><br/>通常この遅延されたオブジェクトはヒープ領域に格納されていくので、通常はヒープオーバフローになるんですが、実は Haskell の GHCi は通常のコンパイル結果と異なる簡易的なスタックマシンでコードを実行するので、GHCi 上ではスタックにこの遅延されたオブジェクトが積まれていき、スタックオーバフローになるんだと思いますね</div></div></div><div class="message event" id="message-1593751502.083700"><div class="content"><div class="summary"><div class="message__header user">mizunashi-mana</div><div class="message__timestamp date"><a class="date" href="#message-1593751502.083700">2020-07-03&nbsp;13:45:02 +0900</a></div></div><div class="message__body description">Haskell の実行マシンはちょっと特殊で、全ての関数呼び出しは単なるジャンプ (末尾呼び出し相当) なので、末尾再帰でないからスタックオーバーフローが起きるというわけではありません。<br/><br/>ただ、通常の言語と傾向としては似ていて、many / some の相互再帰で、many が some を実行した結果を見て <code>pure []</code> を計算するか判断しなければいけなくて、そのためには many が展開された時のフレームを何らかの方法で退避しておかなければいけないのは共通です。<br/><br/>それが通常の言語ではスタック退避なのが、Haskell ではフレームの代わりに遅延オブジェクトをヒープに退避させる (GHCi ならスタックに退避させる) ことになる傾向はあります<br/><br/>(ただ、これは一概に完全に対応するわけではなく、たまたま Haskell だとうまくオブジェクトが消費されたり、逆に普通の言語だと退避が起きない状況で退避が起きたりということはありますね)</div></div></div><div class="message event" id="message-1593757926.084100"><div class="content"><div class="summary"><div class="message__header user">jaxuzb</div><div class="message__timestamp date"><a class="date" href="#message-1593757926.084100">2020-07-03&nbsp;15:32:06 +0900</a></div></div><div class="message__body description">@jaxuzb has joined the channel</div></div></div><div class="message event" id="message-1593761609.084400"><div class="content"><div class="summary"><div class="message__header user">kakkun61</div><div class="message__timestamp date"><a class="date" href="#message-1593761609.084400">2020-07-03&nbsp;16:33:29 +0900</a></div></div><div class="message__body description"></div></div></div><div class="message event" id="message-1593761714.084800"><div class="content"><div class="summary"><div class="message__header user">kakkun61</div><div class="message__timestamp date"><a class="date" href="#message-1593761714.084800">2020-07-03&nbsp;16:35:14 +0900</a></div></div><div class="message__body description">途中で寝てしまってる間に他の方の回答が付いた＆途中で力付きたのですが手動簡約の供養として貼りました（どこかミスしてる自身がある）</div></div></div><div class="message event" id="message-1593765706.086500"><div class="content"><div class="summary"><div class="message__header user">dex10619</div><div class="message__timestamp date"><a class="date" href="#message-1593765706.086500">2020-07-03&nbsp;17:41:46 +0900</a></div></div><div class="message__body description">@kakkun61 <br/>ありがとうございます！:sob:<br/>勉強になります:man-bowing:</div></div></div><div class="message event" id="message-1593912783.090100"><div class="content"><div class="summary"><div class="message__header user">mizunashi-mana</div><div class="message__timestamp date"><a class="date" href="#message-1593912783.090100">2020-07-05&nbsp;10:33:03 +0900</a></div></div><div class="message__body description">TemplateHaskell の Type データを，(型クラス自分で定義する以外で) 型から作る方法ってありますか？イメージとしては，<br/><pre>import qualified <http://Language.Haskell.TH|Language.Haskell.TH> as TH

_ :: (...) =&gt; Proxy a -&gt; TH.Type</pre><br/>みたいな型の関数が書けることを想定してます．</div></div></div><div class="message event" id="message-1593915847.090200"><div class="content"><div class="summary"><div class="message__header user">fumieval</div><div class="message__timestamp date"><a class="date" href="#message-1593915847.090200">2020-07-05&nbsp;11:24:07 +0900</a></div></div><div class="message__body description">パッと思いついたのは、TypeableのsplitTyConAppで型情報を分解して、各TyConをNameに変換するというやり方です。自分ではまだ試していませんが</div></div></div><div class="message event" id="message-1593927098.090600"><div class="content"><div class="summary"><div class="message__header user">mizunashi-mana</div><div class="message__timestamp date"><a class="date" href="#message-1593927098.090600">2020-07-05&nbsp;14:31:38 +0900</a></div></div><div class="message__body description">その方法で，うまくいきそうです．ありがとうございます</div></div></div><div class="message event" id="message-1593969526.094700"><div class="content"><div class="summary"><div class="message__header user">dex10619</div><div class="message__timestamp date"><a class="date" href="#message-1593969526.094700">2020-07-06&nbsp;02:18:46 +0900</a></div></div><div class="message__body description">GHCiによるデバッグ時に、出力される内容に分からないことがありましたので質問させてください。<br/>(GHCiデバッグに限らない内容ですが、ポチポチしているときに改めて気になりました。。）<br/><br/>GHCiにて、「:break 2」コマンドを打つと、現在ロードされているモジュールの2行目にブレークポイントが貼られ、<br/>以下のような内容が出力されます。<br/><pre>*Main&gt; :break 2
Breakpoint 0 activated at qsort.hs:2:15-46</pre><br/>上記の、<br/><pre>qsort.hs:2:15-46</pre><br/>の末尾の「15-46」という数字は何を指しているのでしょうか？<br/>この数字が、デバッグ時に役立つ情報なのかどうかが分からず。<br/><br/>ちなみに、上記のqsort.hsファイルは次のような内容で、全体で5行しかないため、<br/>ファイルの行数とは無関係とは思われますが。。<br/><br/><pre>qsort [] = []
qsort (a:as) = qsort left ++ [a] ++ qsort right
 where (left,right) = (filter (&lt;=a) as, filter (&gt;a) as)

main = print (qsort [8, 4, 0, 3, 1, 23, 11, 18])</pre><br/>※qsort.hsの内容や、操作したコマンドは以下のURLと同じです。<br/>ポチポチしていた時に気になったため質問させていただきました。<br/><br/><a href='https://downloads.haskell.org/~ghc/7.6.3/docs/html/users_guide/ghci-debugger.html'>https://downloads.haskell.org/~ghc/7.6.3/docs/html/users_guide/ghci-debugger.html</a></div></div></div><div class="message event" id="message-1593970829.094800"><div class="content"><div class="summary"><div class="message__header user">cohei</div><div class="message__timestamp date"><a class="date" href="#message-1593970829.094800">2020-07-06&nbsp;02:40:29 +0900</a></div></div><div class="message__body description"><code>2:15-46</code> で2行目の15文字目から46文字目という範囲、すなわち <code>qsort left ++ [a] ++ qsort right</code> を表しています。<br/>どこかにはっきり説明があるというわけでもない (たぶん) ので、ハマりますよね…</div></div></div><div class="message event" id="message-1593971185.096000"><div class="content"><div class="summary"><div class="message__header user">dex10619</div><div class="message__timestamp date"><a class="date" href="#message-1593971185.096000">2020-07-06&nbsp;02:46:25 +0900</a></div></div><div class="message__body description">@cohei <br/>ありがとうございます！<br/>そういうことだったんですね！モヤモヤが晴れました:smile:</div></div></div><div class="message event" id="message-1593974679.096500"><div class="content"><div class="summary"><div class="message__header user">orfj18</div><div class="message__timestamp date"><a class="date" href="#message-1593974679.096500">2020-07-06&nbsp;03:44:39 +0900</a></div></div><div class="message__body description">@orfj18 has joined the channel</div></div></div><div class="message event" id="message-1593987296.096800"><div class="content"><div class="summary"><div class="message__header user">igrep</div><div class="message__timestamp date"><a class="date" href="#message-1593987296.096800">2020-07-06&nbsp;07:14:56 +0900</a></div></div><div class="message__body description">補足: <a href='https://ghcguide.haskell.jp/8.0.2/users_guide/ghci.html#setting-breakpoints'>https://ghcguide.haskell.jp/8.0.2/users_guide/ghci.html#setting-breakpoints</a> でも触れているとおり、識別子や行番号・桁番号でもブレークポイントの位置を指定できるのでそうなっているものと思われます。</div></div></div><div class="message event" id="message-1594007590.097700"><div class="content"><div class="summary"><div class="message__header user">dex10619</div><div class="message__timestamp date"><a class="date" href="#message-1594007590.097700">2020-07-06&nbsp;12:53:10 +0900</a></div></div><div class="message__body description">@igrep  <br/>なるほど！<br/>そういう時に役立ちますね！</div></div></div></div><div class="pager ui pagination menu"><a href="../../html/C5666B6BB/86.html" class="pager__previous item">Previous</a><a href="../../" class="pager__top item">Top</a></div></div></body></html>