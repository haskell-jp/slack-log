<!DOCTYPE html><html><head><meta charset="utf-8"><title>haskell-jp / random #28</title><link rel="stylesheet" href="/slack-log/messages.css" type="text/css" media="screen"></head><body><h1>haskell-jp / random #28</h1><div class="pager"><a href="/slack-log/html/C4M4TT8JJ/27.html" class="pager__previous">Previous</a><a href="/slack-log/" class="pager__top">Top</a><a href="/slack-log/html/C4M4TT8JJ/29.html" class="pager__next">Next</a></div><div class="message_list"><div class="message" id="message-1541316919.048200"><div class="message__timestamp">2018-11-04<br/>16:35:19 +0900</div><div class="message__header">koyojb</div><div class="message__body">@koyojb has joined the channel</div></div><div class="message" id="message-1541321220.051500"><div class="message__timestamp">2018-11-04<br/>17:47:00 +0900</div><div class="message__header">fumieval</div><div class="message__body"><a href='#C4P499EPQ'>english</a> 、 <a href='#C8KBGEBR7'>code-review</a> 、 <a href='#C7002UTC6'>kinds</a>  チャンネルはアーカイブしてしまってもいいと思ったのですがどうでしょう？情報を集中させ、より多くの人が発言にアクセスできるようにするというのが動機です</div></div><div class="message" id="message-1541321648.052600"><div class="message__timestamp">2018-11-04<br/>17:54:08 +0900</div><div class="message__header">mizunashi-mana</div><div class="message__body"><a href='#C7002UTC6'>kinds</a> に関しては賛成です．他のチャンネルに関しては棄権で</div></div><div class="message" id="message-1541384537.053300"><div class="message__timestamp">2018-11-05<br/>11:22:17 +0900</div><div class="message__header">kakkun61</div><div class="message__body">現状、追えないほど <a href='#C4M4TT8JJ'>random</a> が活発というわけでもないので <a href='#C4M4TT8JJ'>random</a> に集約させるのは自分は賛成です<br/>新規参入者にとってもチャネルが多いのはどこに入るべきか迷うように思います<br/><a href='#C4M4TT8JJ'>random</a> の流速が速すぎるようになったら再分離の検討をすればよいと思います</div></div><div class="message" id="message-1541386326.053600"><div class="message__timestamp">2018-11-05<br/>11:52:06 +0900</div><div class="message__header">nobsun</div><div class="message__body">ようやく理解できたような気がします．<br/>メモを公開してあります．(不備の指摘などいただけると嬉しいです) ありがとうございました．<br/><a href='https://scrapbox.io/ny-sketch-book/%E5%A4%89%E6%95%B0%E3%82%92%E6%9D%9F%E7%B8%9B%E3%81%99%E3%82%8B%E3%81%AE%E3%81%AF%E5%80%A4%E3%81%A7%E3%81%AF%E3%81%AA%E3%81%84%E3%81%AE%E3%81%8B'>https://scrapbox.io/ny-sketch-book/%E5%A4%89%E6%95%B0%E3%82%92%E6%9D%9F%E7%B8%9B%E3%81%99%E3%82%8B%E3%81%AE%E3%81%AF%E5%80%A4%E3%81%A7%E3%81%AF%E3%81%AA%E3%81%84%E3%81%AE%E3%81%8B</a></div></div><div class="message" id="message-1541396381.055000"><div class="message__timestamp">2018-11-05<br/>14:39:41 +0900</div><div class="message__header">kakkun61</div><div class="message__body">CI した <a href='https://travis-ci.org/kakkun61/pixela-client-haskell'>https://travis-ci.org/kakkun61/pixela-client-haskell</a></div></div><div class="message" id="message-1541408950.057400"><div class="message__timestamp">2018-11-05<br/>18:09:10 +0900</div><div class="message__header">as_capabl</div><div class="message__body"><blockquote>実際，[Lazyな(おもちゃ)言語 <a href='https://gist.github.com/nobsun/5b310dd4a397af624690b6ca4b0af2c8]も`interp`は意味関数'>https://gist.github.com/nobsun/5b310dd4a397af624690b6ca4b0af2c8]も`interp`は意味関数</a>(semantic function あるいは meaning function)という表示意味論で登場する意味を決める関数なわけで，操作意味論における簡約過程を書いたものではない．計算済みかどうかを意識して区別していない(できないし，必要もない)のはその所為である．</blockquote><br/>意味論については議論の途中で出てきたURLを踏んだりして勉強している所で、これは私見なのですが。denotativeに評価器を定義したいなら、ステップを陽に見えるように書かない限り、ちゃんとした定義にならないのではないかと思います。<br/><br/>現状だと⊥をdenoteする式に対してinterpを動かすと「プログラムが停止しない」という結果が得られる訳ですが、これはHaskellの持つ操作的意味論によって意味づけられているだけで、数学的にはinterpは部分関数で、⊥に相当する部分がill-definedなのではないかと思います。</div></div><div class="message" id="message-1541409005.057600"><div class="message__timestamp">2018-11-05<br/>18:10:05 +0900</div><div class="message__header">as_capabl</div><div class="message__body">Haskellにおいてステップを陽に書くなら、Iterモナドを用いると綺麗になりそう。 <a href='http://hackage.haskell.org/package/free-5.1/docs/Control-Monad-Trans-Iter.html#t:Iter'>http://hackage.haskell.org/package/free-5.1/docs/Control-Monad-Trans-Iter.html#t:Iter</a></div></div><div class="message" id="message-1541409444.057800"><div class="message__timestamp">2018-11-05<br/>18:17:24 +0900</div><div class="message__header">nobsun</div><div class="message__body">はい，ご指摘のとおりです．Div e1 e2 の意味がHaskellのdivに依存しているからです．</div></div><div class="message" id="message-1541410842.058100"><div class="message__timestamp">2018-11-05<br/>18:40:42 +0900</div><div class="message__header">as_capabl</div><div class="message__body">divというか、 let inf = inf + 1 in inf みたいなのの事を想定していました。こういうものの意味論をきちんと定義するために、Wikipediaの記事で言うところのprogressionを使った手法を導入したはずなので、表示的意味論でinterpを定義するなら考慮しないと駄目では、と思った次第 <a href='https://ja.wikipedia.org/wiki/%E8%A1%A8%E7%A4%BA%E7%9A%84%E6%84%8F%E5%91%B3%E8%AB%96'>https://ja.wikipedia.org/wiki/%E8%A1%A8%E7%A4%BA%E7%9A%84%E6%84%8F%E5%91%B3%E8%AB%96</a></div></div><div class="message" id="message-1541413326.058400"><div class="message__timestamp">2018-11-05<br/>19:22:06 +0900</div><div class="message__header">nobsun</div><div class="message__body">⊥を表示する式で停止するのは，Lazyおもちゃ言語では div ？ 0 だけですが．</div></div><div class="message" id="message-1541413713.058700"><div class="message__timestamp">2018-11-05<br/>19:28:33 +0900</div><div class="message__header">as_capabl</div><div class="message__body">申し訳ない、「停止しない」でした（訂正済）</div></div><div class="message" id="message-1541414633.058900"><div class="message__timestamp">2018-11-05<br/>19:43:53 +0900</div><div class="message__header">nobsun</div><div class="message__body">そうですねぇ．⊥から始まる近似列を実装しなければなりませんが，たとえば，inf = inf + 1 の場合，infの値はその近似列の極限になるわけで， +1 が値構成子 Succ :: Nat -&gt; Nat で構成されていればなんとかなるかもしれませんが，その場合は，inf ≠ ⊥ですねぇ．実装上は単に停止しないということで表現する以外は思いつかなかったです．</div></div><div class="message" id="message-1541415322.059300"><div class="message__timestamp">2018-11-05<br/>19:55:22 +0900</div><div class="message__header">nobsun</div><div class="message__body">単にsuccでいいのかな．</div></div><div class="message" id="message-1541416495.059600"><div class="message__timestamp">2018-11-05<br/>20:14:55 +0900</div><div class="message__header">nobsun</div><div class="message__body">+ がプリミティブだとむずかしそう．</div></div><div class="message" id="message-1541416821.059800"><div class="message__timestamp">2018-11-05<br/>20:20:21 +0900</div><div class="message__header">mizunashi-mana</div><div class="message__body">すいません，あれから少し不動点意味論の勉強をして，言いたかったことやHaskellの仕様が混乱していないという主張の意味がわかりました．<br/><br/>ところで，僕も @as_capabl さんと同じ疑問は持ったのですが，個人的にはHaskellの意味関数を[]，Toy言語の意味関数を[| |]とした時，[|e|] = [interp e]でHaskellの意味領域に接地させることで，意味関数と主張しているのだと思っていました．</div></div><div class="message" id="message-1541416884.060000"><div class="message__timestamp">2018-11-05<br/>20:21:24 +0900</div><div class="message__header">mizunashi-mana</div><div class="message__body">primitiveの場合単に [e1 + e2] = { ⊥ if [e1] = ⊥ || [e2] = ⊥; [e1] + [e2] else }で定義すればいいのではないでしょうか？</div></div><div class="message" id="message-1541417510.060400"><div class="message__timestamp">2018-11-05<br/>20:31:50 +0900</div><div class="message__header">mizunashi-mana</div><div class="message__body">あ，それで1つ前で言いたかったのは，例えばparallel ifなどを実装する際多分そのままの定義ではできなくて，それは何故できないかというと<br/><blockquote>⊥に相当する部分がill-defined</blockquote><br/>が効いてきてるのではないかなと思ったという感じです(あんまり説明になっていないかも)</div></div><div class="message" id="message-1541417934.060600"><div class="message__timestamp">2018-11-05<br/>20:38:54 +0900</div><div class="message__header">nobsun</div><div class="message__body">停止が判定できないので，[e]=⊥が判定できないです．</div></div><div class="message" id="message-1541418838.060900"><div class="message__timestamp">2018-11-05<br/>20:53:58 +0900</div><div class="message__header">yuya.gt</div><div class="message__body">@yuya.gt has joined the channel</div></div><div class="message" id="message-1541418987.061100"><div class="message__timestamp">2018-11-05<br/>20:56:27 +0900</div><div class="message__header">nobsun</div><div class="message__body"><blockquote>例えばparallel ifなどを実装する際多分そのままの定義ではできなくて</blockquote>parallel-orのことでしょうか？多分，⊥のように計算が停止しない値ではなく，値にバインドされていない変数が表示する値(emptyMVarの中身)みたいな計算をブロックするような値を考えないといけないですね．(たぶん)</div></div><div class="message" id="message-1541419459.061300"><div class="message__timestamp">2018-11-05<br/>21:04:19 +0900</div><div class="message__header">nobsun</div><div class="message__body">asyncパッケージにあるControl.Concurrent.Async.raceみたいなもの実装のことですよね．</div></div><div class="message" id="message-1541421279.062600"><div class="message__timestamp">2018-11-05<br/>21:34:39 +0900</div><div class="message__header">mizunashi-mana</div><div class="message__body">はい，C[pif L then M else N](env) = { [M](env) if [L](env) = true; [N](env) if [L](env) = false; [N](env) if [L](env) = ⊥ and [M](env) = [N](env); ⊥ else } みたいなやつですね．parallel orでも同じ議論ができますし，そっちの方が単純なのでそっちで考えてもらっても大丈夫です．<br/><br/><blockquote>停止が判定できないので，[e] = ⊥が判定できないです．</blockquote><br/>これがよく分からないのですが，別に意味論上は停止するかどうかは判定しなくてよくて，その表示を満たせば良いと思うのですが，何か勘違いしてるでしょうか？実装上は， <code>seq e1 . seq e2 $ e1 + e2</code> で問題ないはずです(Haskellの場合はそもそもe1 + e2でもいいですね)</div></div><div class="message" id="message-1541421361.064700"><div class="message__timestamp">2018-11-05<br/>21:36:01 +0900</div><div class="message__header">aiya000</div><div class="message__body">「MonadPlusは高階なモノイドである」っていう主張、妥当か否か？<br/>（e.g. MonadPlus Maybe は <code>Nothing mplus Just = Just</code> かつ右についてもそう）</div></div><div class="message" id="message-1541421754.065400"><div class="message__timestamp">2018-11-05<br/>21:42:34 +0900</div><div class="message__header">nobsun</div><div class="message__body">また，自分の言っていることが混乱しているような気がしてきました．すみません．<br/><blockquote>⊥に相当する部分がill-defined</blockquote>がよく判っていない気がします(私が)．どうなっていれば，well-definedですか？</div></div><div class="message" id="message-1541422083.065600"><div class="message__timestamp">2018-11-05<br/>21:48:03 +0900</div><div class="message__header">nobsun</div><div class="message__body">ああ．プリミティブの場合はおっしゃるとおりですね．</div></div><div class="message" id="message-1541422537.065800"><div class="message__timestamp">2018-11-05<br/>21:55:37 +0900</div><div class="message__header">mizunashi-mana</div><div class="message__body">要は，⊥となるtermへの扱いが明確に定められていなくて，Haskellの式が結果的に計算が停止しないので評価器も停止しないようになっているだけで，por のような⊥の扱いが重要になる場合にそれが問題になりそうというのが言いたいことでした．個人的には，<br/><blockquote>Haskellの意味関数を[]，Toy言語の意味関数を[| |]とした時，[|e|] = [interp e]でHaskellの意味領域に接地させることで，意味関数と主張している</blockquote>ということでも問題ないとは思うのですが，denotativeと主張するならHaskellに接地させるのでなくtermに対する定義が明確になっていて，<br/><blockquote>let inf = inf + 1 in inf みたいなの</blockquote>に対する定義が明示されているべきだという主張も分かる気がするという感じです(これが明示されていれば，おそらくporの導入もそれほど難しくないのかなという．例えば， @as_capabl さんがいうように評価器がちゃんとステップを陽に見えるよう書かれていれば，porはステップを同時進行させることで実装できるはずです)</div></div><div class="message" id="message-1541423029.066000"><div class="message__timestamp">2018-11-05<br/>22:03:49 +0900</div><div class="message__header">nobsun</div><div class="message__body">プログラムのコードでいうと，ValueにBotが含まれているべきということになりますか？</div></div><div class="message" id="message-1541423286.066200"><div class="message__timestamp">2018-11-05<br/>22:08:06 +0900</div><div class="message__header">mizunashi-mana</div><div class="message__body">それもありますが，主に<br/><blockquote>progressionを使った手法を導入したはずなので、表示的意味論でinterpを定義するなら考慮しないと駄目では</blockquote>ですね．多分ValueにBotを導入しただけではporは実装できないはずです(片方が停止しなくてももう片方が停止してtrueになれば結果が返せるので)</div></div><div class="message" id="message-1541423354.066400"><div class="message__timestamp">2018-11-05<br/>22:09:14 +0900</div><div class="message__header">nobsun</div><div class="message__body">x por y = if isBot x then y else x は無理ですよね．</div></div><div class="message" id="message-1541423596.066600"><div class="message__timestamp">2018-11-05<br/>22:13:16 +0900</div><div class="message__header">mizunashi-mana</div><div class="message__body">はい，その定義は二重にだめで，isBotがおそらく停止するように実装するのが無理なのと，⊥ por falseは通常⊥になるはずっていうのですね(なので，結構実装は難しいはずです)</div></div><div class="message" id="message-1541423830.066900"><div class="message__timestamp">2018-11-05<br/>22:17:10 +0900</div><div class="message__header">nobsun</div><div class="message__body"><blockquote>let inf = inf + 1 in infに対する定義がなされているべき</blockquote>これがそもそもできそうもない(私の能力的に)</div></div><div class="message" id="message-1541424338.067100"><div class="message__timestamp">2018-11-05<br/>22:25:38 +0900</div><div class="message__header">mizunashi-mana</div><div class="message__body">(まあ，本題からかなり外れる気がするのでどうなんですかね？個人的には，<br/><blockquote>実際，[Lazyな(おもちゃ)言語 <a href='https://gist.github.com/nobsun/5b310dd4a397af624690b6ca4b0af2c8]も`interp`は意味関数'>https://gist.github.com/nobsun/5b310dd4a397af624690b6ca4b0af2c8]も`interp`は意味関数</a>(semantic function あるいは meaning function)という表示意味論で登場する意味を決める関数なわけで，操作意味論における簡約過程を書いたものではない</blockquote>という文が気になったというだけなので．後この議論で不動点意味論の気持ちが分かったので，感謝の気持ちしかないです)</div></div><div class="message" id="message-1541426114.068900"><div class="message__timestamp">2018-11-05<br/>22:55:14 +0900</div><div class="message__header">hexirp</div><div class="message__body">よく分からないんですけど、Alt によって任意の MonadPlus は Monoid になるのと関係ありそうな気が<br/><a href='https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Monoid.html#t:Alt'>https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Monoid.html#t:Alt</a></div></div><div class="message" id="message-1541426790.069100"><div class="message__timestamp">2018-11-05<br/>23:06:30 +0900</div><div class="message__header">nobsun</div><div class="message__body">意味が定められない = ⊥  ?</div></div><div class="message" id="message-1541461047.071200"><div class="message__timestamp">2018-11-06<br/>08:37:27 +0900</div><div class="message__header">as_capabl</div><div class="message__body">Iterモナドを使えば行ける...と思ったんですけど、意外に難しくてまだ組み途中です</div></div><div class="message" id="message-1541465882.071400"><div class="message__timestamp">2018-11-06<br/>09:58:02 +0900</div><div class="message__header">cosmiafu</div><div class="message__body">Alternative は (Hask, (), (,)) -&gt; (Hask, Void, Either)の monoidal functorだから、monoidっぽいのは間違いなし<br/><br/>f Void &lt;-&gt; f a — trivial<br/>f a -&gt; f b -&gt; f (Either a b) &lt;-&gt; f a -&gt; f a -&gt; f a — trivial</div></div><div class="message" id="message-1541476050.075400"><div class="message__timestamp">2018-11-06<br/>12:47:30 +0900</div><div class="message__header">nobsun</div><div class="message__body">interpをinterpFの不動点として定義してできたことにする．じゃだめかな？ &lt;- 適当にいってます．</div></div><div class="message" id="message-1541476188.077500"><div class="message__timestamp">2018-11-06<br/>12:49:48 +0900</div><div class="message__header">hexirp</div><div class="message__body">Monoidal functor であるという条件からこの二つの関数が得られて、<br/><br/>() -&gt; f Void<br/>forall a b. (f a, f b) -&gt; f (Either a b)<br/><br/>これが Alternative である条件の二つの関数と対応するということですよね？<br/><br/>forall a. f a<br/>forall a. f a -&gt; f a -&gt; f a<br/><br/>（一瞬、forall a. f Void &lt;-&gt; f a に見えてびっくりした）</div></div><div class="message" id="message-1541477861.078100"><div class="message__timestamp">2018-11-06<br/>13:17:41 +0900</div><div class="message__header">cosmiafu</div><div class="message__body">ww<br/>そうです、その &lt;-&gt; はisomorphicの記号みたいなものww</div></div><div class="message" id="message-1541514848.078600"><div class="message__timestamp">2018-11-06<br/>23:34:08 +0900</div><div class="message__header">as_capabl</div><div class="message__body"><a href='https://gist.github.com/as-capabl/9dfb4cff6c08f6b5027741e2fc4bf40b'>https://gist.github.com/as-capabl/9dfb4cff6c08f6b5027741e2fc4bf40b</a> por実装したやつできました</div></div><div class="message" id="message-1541565541.079500"><div class="message__timestamp">2018-11-07<br/>13:39:01 +0900</div><div class="message__header">nobsun</div><div class="message__body">これは，call-by-name だけど，call-by-needじゃないようですが，そこは意図的ですか？</div></div><div class="message" id="message-1541568543.079700"><div class="message__timestamp">2018-11-07<br/>14:29:03 +0900</div><div class="message__header">as_capabl</div><div class="message__body">なるほど、そこは意識できてなかったです。おそらく改良すればcall-by-needも実装可能ですが、考える事が増えそうですね</div></div><div class="message" id="message-1541568733.080000"><div class="message__timestamp">2018-11-07<br/>14:32:13 +0900</div><div class="message__header">nobsun</div><div class="message__body">単純にnormalizeがcall-by-need用になっていないだけです．</div></div><div class="message" id="message-1541570676.081000"><div class="message__timestamp">2018-11-07<br/>15:04:36 +0900</div><div class="message__header">as_capabl</div><div class="message__body">たまたま正格版のコードを元にして作り始めて、そうすると非正格評価に戻したときlet内でbotが呼び出しエラーになる事が分かって、結果的にほとんどnormalizeしていない形に修正しました。上の非正格版のnormを埋め込めば動くかどうか。</div></div><div class="message" id="message-1541570756.081200"><div class="message__timestamp">2018-11-07<br/>15:05:56 +0900</div><div class="message__header">as_capabl</div><div class="message__body">それはそれとして、このスレッドの本題としては「変数に束縛されるのはIter Valueだが、これを『値』とみなして良いのかどうか」かと</div></div><div class="message" id="message-1541574197.082100"><div class="message__timestamp">2018-11-07<br/>16:03:17 +0900</div><div class="message__header">nobsun</div><div class="message__body">そうですね．Iter Value は値ではなく計算なので，「変数に束縛されるのは値ではなく，値を求める計算」ということになります．ただし，解釈器interp の最終結果すなわち，式が表示するものが，Iter Valueであるとするなら，Iter Valueを改めて値と読んでもよいと思います．</div></div><div class="message" id="message-1541575484.082400"><div class="message__timestamp">2018-11-07<br/>16:24:44 +0900</div><div class="message__header">nobsun</div><div class="message__body">ちょっと強引かな．<br/><br/>Lazy版を修正してみました．Porの意味は勝手に替えてしまいましたが，動くようです．<br/><a href='https://gist.github.com/nobsun/5b310dd4a397af624690b6ca4b0af2c8'>https://gist.github.com/nobsun/5b310dd4a397af624690b6ca4b0af2c8</a></div></div><div class="message" id="message-1541578294.083400"><div class="message__timestamp">2018-11-07<br/>17:11:34 +0900</div><div class="message__header">aiya000</div><div class="message__body">ありがとうございます！<br/>とても参考になりました<br/><br/>MonadPlusは高階なモノイドである<br/>（任意のMonadPlusはAltを介して任意のaに対してMonoidである）<br/>って感じに主張しようかな:face_with_rolling_eyes:<br/><br/>monoidal functor、また何なのか忘れたのでみてみよw</div></div><div class="message" id="message-1541579700.083600"><div class="message__timestamp">2018-11-07<br/>17:35:00 +0900</div><div class="message__header">mizunashi-mana</div><div class="message__body">そういえば， <@U570660KX> さんのだと<br/>```<br/>&gt;&gt;&gt; eval $ Div (Con 1) (Con 0) `Por` Div (Con 1) (Con 1)<br/>*** Exception: divide by zero<br/>```<br/>になるんですね( <@U4KU9ABL0> の修正見るまで気づかなかった)．本来のdenotational semanticsに立ち戻るならIter ValueはあくまでValueの近似であって，Iter Value ~ Valueとみなしても良いのではないでしょうか？まあただdenotationalにも近似を束縛する，計算を束縛するとも言えるかもしれないですね．</div></div></div><div class="pager"><a href="/slack-log/html/C4M4TT8JJ/27.html" class="pager__previous">Previous</a><a href="/slack-log/" class="pager__top">Top</a><a href="/slack-log/html/C4M4TT8JJ/29.html" class="pager__next">Next</a></div></body></html>