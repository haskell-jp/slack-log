<!DOCTYPE html><html><head><meta charset="utf-8"><title>haskell-jp / questions #89</title><link rel="stylesheet" href="../../main.css" type="text/css" media="screen"></head><body><div class="ui container"><h1>haskell-jp / questions #89</h1><div class="pager ui pagination menu"><a href="../../html/C5666B6BB/88.html" class="pager__previous item">Previous</a><a href="../../" class="pager__top item">Top</a></div><div class="message_list ui feed"><div class="message event" id="message-1596815300.200700"><div class="content"><div class="summary"><div class="message__header user">mizunashi-mana</div><div class="message__timestamp date"><a class="date" href="#message-1596815300.200700">2020-08-08&nbsp;00:48:20 +0900</a></div></div><div class="message__body description">Haskell の <code>head</code> / <code>tail</code> は単連結リストの言葉ですね。Haskell のリストはそのまま単連結リストなので、単連結リストの先頭を示す <code>head</code> とそれ以降を示す <code>tail</code> という言葉を関数名にそのまま流用したものです。<br/><br/>確かにコマンドの <code>head</code> / <code>tail</code> を想定すると、ギョッとする命名かもしれませんね</div></div></div><div class="message event" id="message-1596848095.201100"><div class="content"><div class="summary"><div class="message__header user">igrep</div><div class="message__timestamp date"><a class="date" href="#message-1596848095.201100">2020-08-08&nbsp;09:54:55 +0900</a></div></div><div class="message__body description">ちなみに、 <code>head :: [a] -&gt; Int -&gt; [a]</code> に相当するものとして <code>take</code> があります（引数の順番は逆なので注意）。<br/>それを使って <code>first</code> みたいなものを作れば良かったんじゃない、という意図なのかも知れませんが。</div></div></div><div class="message event" id="message-1596863604.208500"><div class="content"><div class="summary"><div class="message__header user">naohaq</div><div class="message__timestamp date"><a class="date" href="#message-1596863604.208500">2020-08-08&nbsp;14:13:24 +0900</a></div></div><div class="message__body description"><code>head</code> はなくてはならないものかというと必ずしもそういうことはなくて、 <code>xs :: [a]</code> について、 <code>let (hd:tl) = xs in (hd,tlを使った式)</code> とすれば先頭の要素とそれ以外を取り出せます。</div></div></div><div class="message event" id="message-1596871961.208700"><div class="content"><div class="summary"><div class="message__header user">takatheshi</div><div class="message__timestamp date"><a class="date" href="#message-1596871961.208700">2020-08-08&nbsp;16:32:41 +0900</a></div></div><div class="message__body description">ご回答ありがとうございます。<br/><br/>@mizunashi-mana<br/>単連結リストは日本語でいうところの単方向リスト(Singly linked list)でしょうか？<br/><br/>@igrep<br/>少し話が逸れますが、 <code>take</code> がその順番になってる理由は、取る数よりリストの方が適用する種類が多いからそうなってるんでしょうか？</div></div></div><div class="message event" id="message-1596873824.208900"><div class="content"><div class="summary"><div class="message__header user">igrep</div><div class="message__timestamp date"><a class="date" href="#message-1596873824.208900">2020-08-08&nbsp;17:03:44 +0900</a></div></div><div class="message__body description">はい、そうだと思います。</div></div></div><div class="message event" id="message-1596892952.216500"><div class="content"><div class="summary"><div class="message__header user">cj.bc-sd</div><div class="message__timestamp date"><a class="date" href="#message-1596892952.216500">2020-08-08&nbsp;22:22:32 +0900</a></div></div><div class="message__body description">LensのPrismの使い方について質問です<br/>Prismを <code>set</code>や <code>over</code>で <code>ASetter</code> として使えることは分かったのですが、Prismの中身に <code>Lens</code>を使用してアクセスしたいと思った時にやり方がわかりません。(例を下に載せます)<br/>現在は↓の <code>makeBelongTo</code> のようにしているものの、Characterの値コンストラクタが変わったら変更しなくてはいけなくなり、じゃあPrismにしたメリットないのでは、と悩んでいます。<br/><pre>data Character = Animal {
                    _name  :: String
                  , _age  :: Int
                  , _memberOf :: Maybe String
                  }
               | Object {
                    _name :: String
                  , _memberOf :: Maybe String
                  }
              deriving (Show)

makePrisms ''Character
makeLenses ''Character

-- この関数を
makeBelengTo :: String -&gt; Character -&gt; Character
makeBelengTo belongTo c@(Animal n a _) = Animal n a (Just belongTo)
makeBelengTo belongTo c@(Object n _)   = Object n (Just belongTo)

-- こんな感じにしたい(これだと動かない)
makeBelongToWithLens :: String -&gt; Character -&gt; Character
makeBelongToWithLens belongTo = set (_Animal.memberOf) (Just belongTo)
                              . set (_Object.memberOf) (Just belongTo)</pre><br/>また、<br/><pre>set (_Animal._3) (Just belongTo)</pre><br/>のような解法は見つけたのですが、結局タプルの位置を指定しているためこれならPrismのメリットがないな…と思っています。</div></div></div><div class="message event" id="message-1596920248.216800"><div class="content"><div class="summary"><div class="message__header user">as_capabl</div><div class="message__timestamp date"><a class="date" href="#message-1596920248.216800">2020-08-09&nbsp;05:57:28 +0900</a></div></div><div class="message__body description">外泊中なので試せないのですが、普通に <code>set memberOf (Just belongTo)</code> か <code>c{_memberOf=Just belongTo}</code>で行けないでしょうか。</div></div></div><div class="message event" id="message-1596950153.217000"><div class="content"><div class="summary"><div class="message__header user">cj.bc-sd</div><div class="message__timestamp date"><a class="date" href="#message-1596950153.217000">2020-08-09&nbsp;14:15:53 +0900</a></div></div><div class="message__body description">あっ確かに…<br/>実際に書いているコードでLensの名前が違ったのでこんな書き方にしていましたが、よく考えたら同じ名前にすれば大丈夫でした…(違う名前にする必要がなかったです)<br/>それを元にして考えたら他の部分もうまく行きました！ありがとうございます</div></div></div><div class="message event" id="message-1597058715.217300"><div class="content"><div class="summary"><div class="message__header user">kerf_cat</div><div class="message__timestamp date"><a class="date" href="#message-1597058715.217300">2020-08-10&nbsp;20:25:15 +0900</a></div></div><div class="message__body description">@kerf_cat has joined the channel</div></div></div><div class="message event" id="message-1597069878.217500"><div class="content"><div class="summary"><div class="message__header user">hosoda</div><div class="message__timestamp date"><a class="date" href="#message-1597069878.217500">2020-08-10&nbsp;23:31:18 +0900</a></div></div><div class="message__body description">@hosoda has joined the channel</div></div></div><div class="message event" id="message-1597078487.220600"><div class="content"><div class="summary"><div class="message__header user">kakkun61</div><div class="message__timestamp date"><a class="date" href="#message-1597078487.220600">2020-08-11&nbsp;01:54:47 +0900</a></div></div><div class="message__body description">megaparsec 固有の質問なのですが、`Text.Megaparsec.Char.Lexer.lineFold` ができることは同モジュールの <code>indentBlock</code> と同じなんでしょうか？`indentBlock` でできなくて <code>lineFold</code> ならできることがある？単に書き味の違い？<br/><br/>Hackage<br/>• <a href='https://hackage.haskell.org/package/megaparsec-8.0.0/docs/Text-Megaparsec-Char-Lexer.html#v:lineFold'>https://hackage.haskell.org/package/megaparsec-8.0.0/docs/Text-Megaparsec-Char-Lexer.html#v:lineFold</a><br/>• <a href='https://hackage.haskell.org/package/megaparsec-8.0.0/docs/Text-Megaparsec-Char-Lexer.html#v:indentBlock'>https://hackage.haskell.org/package/megaparsec-8.0.0/docs/Text-Megaparsec-Char-Lexer.html#v:indentBlock</a><br/>チュートリアル<br/>• <a href='https://markkarpov.com/tutorial/megaparsec.html#indentationsensitive-parsing'>https://markkarpov.com/tutorial/megaparsec.html#indentationsensitive-parsing</a></div></div></div><div class="message event" id="message-1597078851.220700"><div class="content"><div class="summary"><div class="message__header user">kakkun61</div><div class="message__timestamp date"><a class="date" href="#message-1597078851.220700">2020-08-11&nbsp;02:00:51 +0900</a></div></div><div class="message__body description">どっちにしろこれを使って Haskell のオフサイドルールをパースするのは難しいかなぁ。言語レポートに掲載されてるアルゴリズムと等価なパーサーになってるかの保証が難しそう。</div></div></div><div class="message event" id="message-1597215041.239900"><div class="content"><div class="summary"><div class="message__header user">cj.bc-sd</div><div class="message__timestamp date"><a class="date" href="#message-1597215041.239900">2020-08-12&nbsp;15:50:41 +0900</a></div></div><div class="message__body description"><code>Data.Yaml</code> のパーサーコンビネーターの作り方について質問です<br/><code>decodeFileEither</code>などで読み込んだYamlの中にあるパスをさらに読み込んでパースがしたいのですが、一度他の型を経由させる方法しか思いつかなくて迷っています。<br/>パーサー(`Parser a` )内部でIOを使うことは可能でしょうか(パース結果をFilePathとして、そのファイルも読みにいくことは可能でしょうか)<br/><code>runParser</code> 内部にある <code>f</code> がどうにかできないのかなと思っているのですがよくわからず…<br/>何かいい方法があれば知りたいです…<br/><br/>例としては:<br/><pre>data:
  - path: foo.yaml
    offset: (0, 1)
  ...</pre><br/>というファイルを <code>decodeFileEither</code> で読んだ時、`foo.yaml` も読み込んで結果に含めたいです。<br/><br/>現在は一度しか入れ子にならないため、一つ中間用の型を用意してその型に(パスはStringとして保存して)変換した後、その中にしまったパスをさらに <code>decodeFileEither</code> で読んでいます。<br/><br/><br/><pre>data ActualData = ActuallData ...

data IntermediateData = IntermidiateData { path :: FilePath, ... }

load :: FilePath -&gt; IO (Either ParseException ActualData)
load fp = do
  intermediate &lt;- decodeFileEither fp
  includedData &lt;- decodeFileEither $ path intermediate
  return -- intermediate と includedData を使用して、ActualData を生成する</pre><br/>実際に使っている例だとこれになります。( <code>Face</code> をデコードするために、一度 <code>FaceFile</code> としてデコードした後に読み直している)<br/><a href='https://github.com/Cj-bc/faclig/blob/master/src/Graphics/Asciiart/Faclig/Types.hs#L36-L57'>https://github.com/Cj-bc/faclig/blob/master/src/Graphics/Asciiart/Faclig/Types.hs#L36-L57</a><br/><br/>しかし、<br/><br/>• 途中に他の型をできれば挟みたくない<br/>• 入れ子を何重にもしたいので、一度で解決できるようにしたい<br/>という理由があり、なんとかできないのかなと悩んでいます。</div></div></div><div class="message event" id="message-1597215389.240100"><div class="content"><div class="summary"><div class="message__header user">matsubara0507</div><div class="message__timestamp date"><a class="date" href="#message-1597215389.240100">2020-08-12&nbsp;15:56:29 +0900</a></div></div><div class="message__body description"><blockquote>パーサー(`Parser a` )内部でIOを使うことは可能でしょうか</blockquote>少なくとも、これはできないと思います。<br/>ここでの <code>Parser a</code> は <a href='https://hackage.haskell.org/package/aeson-1.4.6.0/docs/Data-Aeson-Types.html#t:Parser'>https://hackage.haskell.org/package/aeson-1.4.6.0/docs/Data-Aeson-Types.html#t:Parser</a> で、 IO を含まないので。</div></div></div><div class="message event" id="message-1597215514.240400"><div class="content"><div class="summary"><div class="message__header user">igrep</div><div class="message__timestamp date"><a class="date" href="#message-1597215514.240400">2020-08-12&nbsp;15:58:34 +0900</a></div></div><div class="message__body description">HKDにしてYAMLをパースした結果<br/>として <code>Record IO</code> を返すようにするか、そこまでしなくとも <code>IO</code> 型の値をフィールドに含めるのはいかがでしょうか？<br/>HKDについては <a href='https://qiita.com/thimura/items/85bdeeca6ced74c89478'>https://qiita.com/thimura/items/85bdeeca6ced74c89478</a> とか  <a href='http://fumieval.hatenablog.com/entry/2019/12/25/224329'>http://fumieval.hatenablog.com/entry/2019/12/25/224329</a> を。</div></div></div><div class="message event" id="message-1597215807.240700"><div class="content"><div class="summary"><div class="message__header user">igrep</div><div class="message__timestamp date"><a class="date" href="#message-1597215807.240700">2020-08-12&nbsp;16:03:27 +0900</a></div></div><div class="message__body description">同じ議論が <a href='https://haskell-jp.slack.com/archives/C4M4TT8JJ/p1554720210064400'>https://haskell-jp.slack.com/archives/C4M4TT8JJ/p1554720210064400</a> でもありましたね...<br/>確かにこのスレッドへの返信の通りreflectionパッケージを使うという手もありますね。</div></div></div><div class="message event" id="message-1597216076.241100"><div class="content"><div class="summary"><div class="message__header user">cj.bc-sd</div><div class="message__timestamp date"><a class="date" href="#message-1597216076.241100">2020-08-12&nbsp;16:07:56 +0900</a></div></div><div class="message__body description"><code>Record</code>については全く知らなかったので調べてみます！<br/>フィールドにIO型を含めた場合、最終的にはIOを取り外す処理は一括でできるのでしょうか…?(各フィールドの値をそれぞれ取り出す必要があるように思えているのですがそうでもない？)<br/>とりあえず、いただいたリンクとrefrectionを調べてみます！</div></div></div><div class="message event" id="message-1597216223.241300"><div class="content"><div class="summary"><div class="message__header user">matsubara0507</div><div class="message__timestamp date"><a class="date" href="#message-1597216223.241300">2020-08-12&nbsp;16:10:23 +0900</a></div></div><div class="message__body description">最終的に <code>IO (Parser a)</code> みたいにできるんじゃないかな、HKD なら</div></div></div><div class="message event" id="message-1597216235.241500"><div class="content"><div class="summary"><div class="message__header user">igrep</div><div class="message__timestamp date"><a class="date" href="#message-1597216235.241500">2020-08-12&nbsp;16:10:35 +0900</a></div></div><div class="message__body description"><blockquote>最終的にはIOを取り外す処理は一括でできるのでしょうか</blockquote>えぇ、その部分はbarbiesに任せられるはず。そこを一括でできるのがbarbiesの強みなので</div></div></div><div class="message event" id="message-1597216358.241700"><div class="content"><div class="summary"><div class="message__header user">igrep</div><div class="message__timestamp date"><a class="date" href="#message-1597216358.241700">2020-08-12&nbsp;16:12:38 +0900</a></div></div><div class="message__body description"><code>Parser (IO a)</code> （もっと正確には、 <code>Compose Parser IO a</code> ）から <code>IO a</code> に変換して最終的に <code>Identity a</code> として取り出せるようになるかと。</div></div></div><div class="message event" id="message-1597216534.241900"><div class="content"><div class="summary"><div class="message__header user">cj.bc-sd</div><div class="message__timestamp date"><a class="date" href="#message-1597216534.241900">2020-08-12&nbsp;16:15:34 +0900</a></div></div><div class="message__body description">色々教えてくださりありがとうございます！<br/>ゆっくり噛み砕いてみます</div></div></div><div class="message event" id="message-1597410968.242400"><div class="content"><div class="summary"><div class="message__header user">bluehighwayjp</div><div class="message__timestamp date"><a class="date" href="#message-1597410968.242400">2020-08-14&nbsp;22:16:08 +0900</a></div></div><div class="message__body description">@bluehighwayjp has joined the channel</div></div></div><div class="message event" id="message-1598117687.000200"><div class="content"><div class="summary"><div class="message__header user">yagusu1231</div><div class="message__timestamp date"><a class="date" href="#message-1598117687.000200">2020-08-23&nbsp;02:34:47 +0900</a></div></div><div class="message__body description">@yagusu1231 has joined the channel</div></div></div><div class="message event" id="message-1598162532.000400"><div class="content"><div class="summary"><div class="message__header user">fujio</div><div class="message__timestamp date"><a class="date" href="#message-1598162532.000400">2020-08-23&nbsp;15:02:12 +0900</a></div></div><div class="message__body description">@fujio has joined the channel</div></div></div><div class="message event" id="message-1598189810.003900"><div class="content"><div class="summary"><div class="message__header user">sereronnrot</div><div class="message__timestamp date"><a class="date" href="#message-1598189810.003900">2020-08-23&nbsp;22:36:50 +0900</a></div></div><div class="message__body description">@sereronnrot has joined the channel</div></div></div><div class="message event" id="message-1598249598.004100"><div class="content"><div class="summary"><div class="message__header user">kyaddress</div><div class="message__timestamp date"><a class="date" href="#message-1598249598.004100">2020-08-24&nbsp;15:13:18 +0900</a></div></div><div class="message__body description">@kyaddress has joined the channel</div></div></div><div class="message event" id="message-1598507424.005700"><div class="content"><div class="summary"><div class="message__header user">hexirp</div><div class="message__timestamp date"><a class="date" href="#message-1598507424.005700">2020-08-27&nbsp;14:50:24 +0900</a></div></div><div class="message__body description">Haskell で書いたプログラムをウェブページの上で動かしたいのですが、どうすればいいのでしょうか？　前から知っていた GHCJS は開発が停止してしまっているようです。</div></div></div><div class="message event" id="message-1598512144.005900"><div class="content"><div class="summary"><div class="message__header user">hexirp</div><div class="message__timestamp date"><a class="date" href="#message-1598512144.005900">2020-08-27&nbsp;16:09:04 +0900</a></div></div><div class="message__body description">状況を考えると質問をした後に思い出した Asterius しか選択肢がなさそうなので、それを試してみます。</div></div></div><div class="message event" id="message-1598806266.000200"><div class="content"><div class="summary"><div class="message__header user">arakur65536</div><div class="message__timestamp date"><a class="date" href="#message-1598806266.000200">2020-08-31&nbsp;01:51:06 +0900</a></div></div><div class="message__body description">@arakur65536 has joined the channel</div></div></div><div class="message event" id="message-1599094688.000300"><div class="content"><div class="summary"><div class="message__header user">kazu</div><div class="message__timestamp date"><a class="date" href="#message-1599094688.000300">2020-09-03&nbsp;09:58:08 +0900</a></div></div><div class="message__body description">class method を inline するにはどうすればいいでしょうか？<br/>調べた限り、instance 宣言の際に INLINE プラグマを書けばよさそうです。<br/>しかし、プロファイルを取ると、その method がボトルネックとして現れるので、inline できてないようです。<br/><br/>具体的には、以下の read8 を、具体的な型 ReadBuffer に対して呼び出しています。<br/><br/><a href='https://hackage.haskell.org/package/network-byte-order-0.1.5/docs/src/Network.ByteOrder.html#read8'>https://hackage.haskell.org/package/network-byte-order-0.1.5/docs/src/Network.ByteOrder.html#read8</a><br/><br/>関数定義をトップレベルに移してみたり、関係ないとは思いますが SPECIALIZE を書いたりしてみましたが、やはりうまく行きませんでした。</div></div></div><div class="message event" id="message-1599099489.000500"><div class="content"><div class="summary"><div class="message__header user">igrep</div><div class="message__timestamp date"><a class="date" href="#message-1599099489.000500">2020-09-03&nbsp;11:18:09 +0900</a></div></div><div class="message__body description"><code>read8</code> を使用している箇所が多相になっているためにコンパイル時に型が特定できてない、というケースだと思うので、`read8` を 実際に呼んでいる箇所を一つずつ検証することになりますね... 呼んでいる関数をインライン化するとか。<br/>（関連: <a href='https://blog.miz-ar.info/2016/06/writing-efficient-program-with-haskell/#2.specialization'>https://blog.miz-ar.info/2016/06/writing-efficient-program-with-haskell/#2.specialization</a> すでに読んでいる記事でしたらすみません）</div></div></div><div class="message event" id="message-1599099630.000800"><div class="content"><div class="summary"><div class="message__header user">kazu</div><div class="message__timestamp date"><a class="date" href="#message-1599099630.000800">2020-09-03&nbsp;11:20:30 +0900</a></div></div><div class="message__body description">「具体的な型」と書いたように、多相にはなっていません。</div></div></div><div class="message event" id="message-1599103396.001200"><div class="content"><div class="summary"><div class="message__header user">fumieval</div><div class="message__timestamp date"><a class="date" href="#message-1599103396.001200">2020-09-03&nbsp;12:23:16 +0900</a></div></div><div class="message__body description">INLINEプラグマを指定していれば、意図的に最適化を切ったりしないかぎりインライン化されるはずです。もしかしたらプロファイリングが影響しているかもしれません（トップレベルに絞ってみてはいかが）。また、無関係ですがread16などはインライン化がなく辞書渡しになるので、かなりパフォーマンスが落ちます</div></div></div><div class="message event" id="message-1599103587.001400"><div class="content"><div class="summary"><div class="message__header user">kazu</div><div class="message__timestamp date"><a class="date" href="#message-1599103587.001400">2020-09-03&nbsp;12:26:27 +0900</a></div></div><div class="message__body description">read16 に SPECIALIZE を書いた方がいいってことですね？</div></div></div><div class="message event" id="message-1599104176.001800"><div class="content"><div class="summary"><div class="message__header user">fumieval</div><div class="message__timestamp date"><a class="date" href="#message-1599104176.001800">2020-09-03&nbsp;12:36:16 +0900</a></div></div><div class="message__body description">ユーザーがReadableのインスタンスを追加できるので私ならINLINEをつけますが、それが想定した使い方でなければSPECIALISEでもいいと思います</div></div></div><div class="message event" id="message-1599105752.002300"><div class="content"><div class="summary"><div class="message__header user">kazu</div><div class="message__timestamp date"><a class="date" href="#message-1599105752.002300">2020-09-03&nbsp;13:02:32 +0900</a></div></div><div class="message__body description">ありがとうございます。INLINE を付けておきます。</div></div></div><div class="message event" id="message-1599237119.002800"><div class="content"><div class="summary"><div class="message__header user">s1170087</div><div class="message__timestamp date"><a class="date" href="#message-1599237119.002800">2020-09-05&nbsp;01:31:59 +0900</a></div></div><div class="message__body description">@s1170087 has joined the channel</div></div></div><div class="message event" id="message-1599310854.003600"><div class="content"><div class="summary"><div class="message__header user">igrep</div><div class="message__timestamp date"><a class="date" href="#message-1599310854.003600">2020-09-05&nbsp;22:00:54 +0900</a></div></div><div class="message__body description">この質問に答えようと思ったのですが、ちょっと自信がないのでツッコミをいただきたいです。いろいろ断言しちゃっていいか迷う...<br/>replyに回答案を書きます。<br/><a href='https://ja.stackoverflow.com/questions/70079/%E3%83%A2%E3%83%8A%E3%83%89%E5%89%87%E3%82%92%E5%B4%A9%E3%81%97%E3%81%A6%E3%81%97%E3%81%BE%E3%81%86%E4%BE%8B%E3%81%8C%E7%9F%A5%E3%82%8A%E3%81%9F%E3%81%84'>https://ja.stackoverflow.com/questions/70079/%E3%83%A2%E3%83%8A%E3%83%89%E5%89%87%E3%82%92%E5%B4%A9%E3%81%97%E3%81%A6%E3%81%97%E3%81%BE%E3%81%86%E4%BE%8B%E3%81%8C%E7%9F%A5%E3%82%8A%E3%81%9F%E3%81%84</a></div></div></div><div class="message event" id="message-1599310918.003800"><div class="content"><div class="summary"><div class="message__header user">igrep</div><div class="message__timestamp date"><a class="date" href="#message-1599310918.003800">2020-09-05&nbsp;22:01:58 +0900</a></div></div><div class="message__body description">------ 以下回答案 ------<br/>コメントにも回答にも明確に回答されてないとおぼしき部分について回答します。<br/><br/>&gt; つまりどこの部分にどのように注意してコードを書けばいいのかというようなことが気になっています。おそらく、instanceを実装しているときですよね？<br/>&gt;<br/>&gt; instanceの実装さえミスがなければ fやg はモナド則を満たさなくなってしまうことと関係ないと思っているのですがいかがでしょうか？<br/><br/>ご認識のとおりです。<br/>Monad則はあくまでも`&gt;&gt;=`や`return`についての規則であるため、`&gt;&gt;=`や`return`の**引数が**、つまり`f`や`g`がどうなっていようと関係ありません。<br/><br/>が、そもそもあなたが自分でMonadのインスタンスを定義する必要さえないでしょう。<br/>世の中には無数のMonadが存在するように見えるかも知れません（し、広い意味のモナドは実際そうなのでしょうが）、Haskellプログラミングにおいて役に立つMonadは、数えるほどしかありません。<br/>実際のところ[モナドの六つの系統[Functor x Functor] - モナドとわたしとコモナド](<http://fumieval.hatenablog.com/entry/2013/06/05/182316)という記事にあるものが概ねすべてです>（分類方法そのものは一般的ではないですが）。<br/><br/>世に広まるパッケージ見ていると、一見先ほどの記事にリストアップされていないMonadが見つかることがあります。<br/>ところがそれらはほぼ間違いなく、ここにリストアップされているMonadの単純なラッパーか、それらを組み合わせて別の名前を付けたり、何らかの用途に特殊化したものです。<br/>独自に定義しているものがあったとしたら、それは恐らく効率のためであって、実質的な役割は先ほどの記事にリストアップされたMonadのうち、どれかに当てはまるはずです。<br/><br/>もしリストアップされているものにどれにも当てはまらないものができれば、別途論文が書かれていると思います（というのも、実は「どれにも当てはまらない」のかどうか個人的にわからない[Select Monad](<http://hackage.haskell.org/package/transformers-0.5.6.2/docs/Control-Monad-Trans-Select.html)というのがあるからです>）。<br/>とにかく、「Haskellプログラミングに役に立つMonad型クラスのインスタンス」というのはそれぐらい貴重なのです。<br/>（もっと広い意味の、本来の圏論における「モナド」はいろいろあるかも知れませんが、私は圏論には詳しくないのでその点は突っ込まないでください！）<br/><br/>少し話がそれましたが、そうした事情があるため、「モナド則を守れているかどうか」というのを意識する必要があるのは、少なくともそうしたライブラリーを作るようになったら、であって、純粋にMonadのユーザーである限りその必要はありません。<br/>それはほとんどのHaskellプログラマーが経験しないことのはずです。<br/>仮に経験したとしても、多分にそれは（先ほど触れたような）既存のMonadを元に独自定義する場合であって、大抵はコピペと少しの修正で済むでしょう。<br/>DRY原則に従うなら、そんなことしたくないですよね？</div></div></div><div class="message event" id="message-1599317355.004400"><div class="content"><div class="summary"><div class="message__header user">kats.ando</div><div class="message__timestamp date"><a class="date" href="#message-1599317355.004400">2020-09-05&nbsp;23:49:15 +0900</a></div></div><div class="message__body description">@kats.ando has joined the channel</div></div></div><div class="message event" id="message-1599378431.005800"><div class="content"><div class="summary"><div class="message__header user">dex10619</div><div class="message__timestamp date"><a class="date" href="#message-1599378431.005800">2020-09-06&nbsp;16:47:11 +0900</a></div></div><div class="message__body description">高度な話題なので付いていけないですが、回答がついていなかったのでコメントさせて頂きます:bow:<br/><br/>&gt; &gt; つまりどこの部分にどのように注意してコードを書けばいいのかというようなことが気になっています。おそらく、instanceを実装しているときですよね？<br/>&gt; &gt;<br/>&gt; &gt; instanceの実装さえミスがなければ fやg はモナド則を満たさなくなってしまうことと関係ないと思っているのですがいかがでしょうか？<br/>&gt; <br/>&gt; ご認識のとおりです。<br/>&gt; Monad則はあくまでも`&gt;&gt;=`や`return`についての規則であるため、`&gt;&gt;=`や`return`の**引数が**、つまり`f`や`g`がどうなっていようと関係ありません。<br/>上記に関して、私も同様の理解です。<br/><br/>上記の記事の質問者さんはモナド則を崩せる方法を知りたがっているようですが、すでに回答があるようにモナド則を崩す実装は簡単にできると思います。<br/>プログラマがモナドを自作するときに気をつけるべきことは、モナド則を崩す実装について考えることではなく、モナド則を満たした実装になっているかに気をつけることかと思います。<br/>モナド則を満たさない実装はあらゆるパターンが考えられますし、モナド則を満たしていない時点で、それはモナドではないため、一般のプログラマがここを深く追求する価値があるとは（今の私のレベルでは）思えません。モナドに代わる新しい計算の概念を探そうとしている方には研究対象になるのかもしれませんが。<br/><br/>後半のモナドの分類の言及については私の手に余りますので、コメントは控えます。。<br/><br/>&gt; ご認識のとおりです。<br/>&gt; Monad則はあくまでも`&gt;&gt;=`や`return`についての規則であるため、`&gt;&gt;=`や`return`の**引数が**、つまり`f`や`g`がどうなっていようと関係ありません。<br/>ただ、上記の回答だけでも、質問者さんへの回答にはなっているかと思いました。</div></div></div></div><div class="pager ui pagination menu"><a href="../../html/C5666B6BB/88.html" class="pager__previous item">Previous</a><a href="../../" class="pager__top item">Top</a></div></div></body></html>