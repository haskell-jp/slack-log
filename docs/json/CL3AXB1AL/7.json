[
    {
        "type": "message",
        "user": "UL1HFJATE",
        "ts": "1680152962.225539",
        "text": "追加提案，というか皆さまの意見を聞きたいです:\n `strict`  (<https://hackage.haskell.org/package/strict>): 基本的なデータ型 ( `Either` ,  `Maybe` , and pair from `base`,  `These` from `these` )のfield-strict version と baseに入ってる lazy IO の strict version を実装します． 元々transitive dependency に入ってて， <https://haskell-jp.slack.com/archives/C014PGG641Z/p1678521681800639> = <https://haskell.jp/slack-log/html/C014PGG641Z/4.html#message-1678521681.800639> あたり見てもモチベーションはありそうな気がします．しかし，リンク先の会話の主題そのものはタプルなのですが，このパッケージの `Data.Strict.Tuple` はペア `Pair a b` しかサポートしてなくて，19項までのタプル( `T1` , `T2` , … , `T19` )をサポートしてる `strict-tuple`  (<https://hackage.haskell.org/package/strict-tuple>) はモジュール名が `Data.Tuple.Strict` でややこしい，というのがアレですね．"
    },
    {
        "type": "message",
        "user": "U4LGTMTMK",
        "ts": "1680155886.899719",
        "text": "話を複雑にするようで申し訳ないんですが、 <http://h2.jaguarpaw.co.uk/posts/nested-strict-data/> とかどうですか？\n多分 <https://hackage.haskell.org/package/strict-wrapper-0.0.0.0> がその実装のようです。"
    },
    {
        "type": "message",
        "user": "U4LGTMTMK",
        "ts": "1680155928.276409",
        "text": "引用頂いたスレッドの発言の時も本当はこれを挙げたかったんですけど、うまく探せなかったもので..."
    },
    {
        "type": "message",
        "user": "UL1HFJATE",
        "ts": "1680156325.696669",
        "text": "あー，頭のいい実装だ．4項までのタプルしか実装がないのは残念ではありますが，結構便利そう．"
    },
    {
        "type": "message",
        "user": "U4LGTMTMK",
        "ts": "1680156381.606969",
        "text": "あまり利用もメンテも熱心にされてなさそうなのが惜しいんですけどね。すごくいいアイディアなのに。"
    },
    {
        "type": "message",
        "user": "UL1HFJATE",
        "ts": "1680156426.323509",
        "text": "貫禄の Dependencies: `base &lt; 5`"
    },
    {
        "type": "message",
        "user": "UL1HFJATE",
        "ts": "1680156692.120609",
        "text": "こういうパッケージって「古く」はならなそうに見えるので入れるのにそんなにリスクはなさそうですが，無意味に入れると収拾がつかなくなりそうという理由だけで躊躇するところはあるんですよね…"
    },
    {
        "type": "message",
        "user": "UL1HFJATE",
        "ts": "1680156820.743719",
        "text": "でも Haskell の競プロ提出コードなんて bang がついてない変数を思い浮かべるのが難しいくらいですし，あったら結構嬉しそうなんだよな…"
    },
    {
        "type": "message",
        "user": "UL1HFJATE",
        "ts": "1680231036.259809",
        "text": "`strict-wrappers` については， unsafe な関数が注釈なしに含まれているので導入を見合わせようかなと思います．<https://haskell.jp/slack-log/html/C5666B6BB/103.html#message-1680184874.825459> = <https://haskell-jp.slack.com/archives/C5666B6BB/p1680184874825459> でのログをご確認くだされば幸いです．"
    },
    {
        "type": "message",
        "user": "UL5PAB0F9",
        "ts": "1680233986.982779",
        "text": "`strict` の `Data.Strict.Tuple` は `Pair a b` しかないですが `x :!: y :!: z` のようにできるのでそこまで不便ではないかもしれません。\nオンラインジャッジ的な対応としては `containers` にある `Utils.Containers.Internal.StrictPair` を使うという手もありますが `Show` にすらなっていなくて不便ですね"
    },
    {
        "type": "message",
        "user": "ULMGVGLP3",
        "ts": "1680237192.269909",
        "text": "<@ULMGVGLP3> has joined the channel"
    },
    {
        "type": "message",
        "user": "UL1HFJATE",
        "ts": "1680266406.952249",
        "text": "あー、とすると `strict` はだいぶ良さそうですか。メモリ上のレイアウトまで気にするなら `strict-tuple` を更に追加で入れるのも一応選択肢にはならないことは…ないのか？"
    },
    {
        "type": "message",
        "user": "UL1HFJATE",
        "ts": "1680272951.343829",
        "text": "あ，忘れてた．最適化をまともにperf取らずに神に祈るのが好きな私みたいな軟弱者には，`strict-containers`  (<https://hackage.haskell.org/package/strict-containers-0.2|https://hackage.haskell.org/package/strict-containers-0.2>) のデータ型のフィールドまでstrict flagがついた containers (+unordered-containers) 実装とか見せられるとちょっと気になってしまいます。\n\n```data X = X !Int !Double\ndata Y = Y Int Double```\nを考えたときに、 `case x_value of X !a !b -&gt; ...` は `a`, `b` が評価されているかを判定するコードが不要だが、\n`case y_value of Y !a !b -&gt; ...` において `y_value` のフィールドがあらゆる評価パスで評価済みだとしても、実行時に評価済みかどうかを判定するコードが消せない可能性がある、みたいなことを耳にするので…"
    },
    {
        "type": "message",
        "user": "UL1HFJATE",
        "ts": "1680690476.770539",
        "text": "Language Test Contestが2nd freeze (3/28)版に更新されました！\n\n期待通り，次のコードをコードテストに投げると `cabal.project.freeze` ファイルを取ってこれました:\n\n```import <http://System.IO|System.IO>\n\nmain :: IO ()\nmain = putStr =&lt;&lt; readFile \"/judge/submission/cabal.project.freeze\"```\n結果は <https://gist.github.com/gksato/b7d0b18e9ef8be5762fef8717737e27b#file-4-cabal-project-freeze> です．\n\nあと，全exposed modulesのインポート (<https://gist.github.com/gksato/b7d0b18e9ef8be5762fef8717737e27b#file-3-imports-hs>) を投げても実行が通ることも確認できました！\n\n今の所，次のfreezeの時には，\n• `extra` : 1.7.12 -&gt; 1.7.13\n• `strict` を追加\n• インストールコマンドとコンパイルコマンドにおいて，workdirの仕様が不明だったために必要だった余計なコマンド群を除去(参照: <https://docs.google.com/spreadsheets/d/1HXyOXt5bKwhKWXruzUvfMFHQtBxfZQ0047W7VVObnXI/edit#gid=1835616968&amp;range=H67:I68>)\nを確定で実施するつもりでおり，\n• `strict-tuple` の追加\n• `strict-containers` の追加\nについては保留中です．"
    },
    {
        "type": "message",
        "user": "UL5PAB0F9",
        "ts": "1680713459.208939",
        "text": "GHCについてくるライブラリ群で現環境では使えるが新環境では使えない状態のものがあるので対応しておきたいです\n```import Data.Binary () -- binary\nimport Data.Time () -- time\nimport System.Directory () -- directory\nimport System.FilePath () -- filepath\nimport System.Posix () -- unix\nimport System.Process () -- process\nimport Text.PrettyPrint () -- pretty\n\nmain=pure()```\n"
    },
    {
        "type": "message",
        "user": "UL1HFJATE",
        "ts": "1680736340.027829",
        "text": "あーそれ，（競プロに関係あるかわかんなくて）入れるか迷ってたんですよね．入れる側に一票入ったので入れることにしましょう！"
    },
    {
        "type": "message",
        "user": "UL1HFJATE",
        "ts": "1680744242.989739",
        "text": "あと， GHC-bundled library で現環境で使えるけど新環境では使えない，というと `ghc-boot`, `ghc-boot-th`,  `hpc`,  `integer-gmp`,  `terminfo`, `ghc-prim` あたりもそうなはずですね．ここら辺も入れた方がいいでしょうか？\n\n現環境は `cabal install --lib` を用いているので， GHC-bundled library (<https://gitlab.haskell.org/ghc/ghc/-/wikis/commentary/libraries/version-history> で確認できます)のうち，`cabal-install &lt;= 3.8.1.0` が <https://hackage.haskell.org/package/cabal-install-3.8.1.0/docs/src/Distribution.Client.CmdInstall.html#globalPackages|Distribution.Client.CmdInstall.globalPackages> 変数によって明示的に global package とみなしていたものは利用可能だったはずです．\n\nほかには，現環境では使用できない GHC-bundled package (一度も `cabal install --lib` を投げたことのない裸の `ghc` では使えるが，一度でも `cabal install --lib` を投げてしまうと top-level `ghc` から不可視になってしまうタイプのGHC-bundled package．`globalPackages` 変数に名前が挙がってないとそうなる)もありますが，そこら辺についてはどうしましょうか．"
    },
    {
        "type": "message",
        "user": "UL1HFJATE",
        "ts": "1680783614.872259",
        "text": "なるほど． Windows 環境下でないとビルドできない `Win32` を除き，\n• `Cabal`\n• `Cabal-syntax`\n• `binary`\n• `directory`\n• `filepath`\n• `ghc` \n• `ghc-boot` \n• `ghc-boot-th`\n• `ghc-compact`\n• `ghc-heap`\n• `ghc-prim`\n• `ghci`\n• `haskelline`\n• `hpc`\n• `integer-gmp`\n• `libiserv`\n• `pretty`\n• `process`\n• `stm`\n• `terminfo`\n• `time`\n• `unix`\n• `xhtml`\nを全て追加する，ということですか． `ghc-compact` をただ追加するのもアレなので，\n• `compact`\nを追加してもいいかもしれませんね．\n\nさしあたって気にすべき点は，特に `ghc-prim` などの `ghc*` 系が GHC のバージョン間で安定したAPIを提供しそうに見えない，ということでしょうか．\n\n細かい反論としては:\n• `ghc` とか `terminfo`  とか本当に要るの？  → 「本当に」要る要らないの線引きは難しいので，「GHC-bundled」という明確な線引きがあるのは良いこと\n• `ghc*` 系はHackageにアップロードされていないことが多い（ 「GHC-bundled version しか使えないからHackageからのダウンロードの需要がない以上，面倒だからいいよね〜」という理由なのかは知らない）ので，`cabal-plan license-report`  が自動でライセンスを拾ってこれないため，License report の Human-written caveat を手書きで追加執筆しなければならないのが面倒 → 頑張れ\nという点もありますが，ここら辺は簡単に再反論できるところですね．とくに「GHC-bundled」という明確な線引きがある，というのは結構な美点っぽいです．\n\nみなさんのご意見もお聞きしたいので，よろしくお願いします．"
    }
]