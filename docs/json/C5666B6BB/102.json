[
    {
        "text": "cabal.project.local に相当するような stack.yaml のやつってありますか？",
        "type": "message",
        "ts": "1661954651.345509",
        "user": "U4L0B71L1"
    },
    {
        "text": "いくつかのデータ型があらかじめ定義されており、それらはTLV(type length value)で統一的に符号化されるとします。\nこれに対する符号器/復号器の基本ライブラリを作りますが、データ型は将来追加されるかもしれないので、サードパーティライブラリで拡張可能としたいです。\n\nまず、符号化のために以下のようなクラスを定義します。\n\n```class Typeable a =&gt; T a where\n  typeT  :: Int\n  encode :: T -&gt; ByteString\n  decode :: ByteString -&gt; T\n  fromTLV :: TLV -&gt; Maybe a  -- TLVは後述\n  fromTLV (TLV x) = cast x\n  toTLS :: a -&gt; TLV\n  toTLS = TLV```\n既存のデータを表す型を A と B とすると、\n\n```data A = A ...\ndata B = B ...\n\ninstance A where\n  typeT = 0\n  encode = ...\n  decode = ...\n\ninstance B where\n  typeT = 1\n  encode = ...\n  decode = ...```\nこれらの型を同じように扱えるように、 `ExistentialQuantification` を用いて、以下の型を定義します。\n\n```data TLV = forall a. T a =&gt; TLV a```\n符号器で encode を使うのは、 `a` が与えられるので簡単です。\n\n```encodeTLV :: TLV -&gt; ByteString\nencodeTLV (TLV x) = encode x```\n問題は復号器です。TLVのTとLの部分は `ByteString` に符号化された整数なので、それをパースして V の部分の `ByteString` を切り出した後に、適切な `decode` を呼ぶだしたいのですが、どうすれば呼べるでしょうか？\n\nぱっと思いつくのは、 `Int -&gt; ByteString` の辞書を用意して、それを引くことです。拡張可能にするのは、この辞書を公開し、利用時に要素を追加可能にする必要がありそうです。\n\n基本的に reflaction に関係する問題だと思います。サードバーティが `data C` を定義したら、自動的にその `decode` も呼ばれるような魔法はあるのでしょうか？",
        "type": "message",
        "ts": "1662340285.680249",
        "user": "U56MBRKR9"
    },
    {
        "text": "Haskellそのものとは関係ない質問になるので恐縮ですがお聞かせ下さい\n\nプログラミング初心者やHaskellの周辺に全く触れたことない人向けに一時間程度Haskellについて話す機会を得たのですが、皆さんならどういった内容を話すと良いと思われますか？",
        "type": "message",
        "ts": "1662712288.672419",
        "user": "U02LD7MAQ00"
    },
    {
        "text": "ライブラリを書いており、テスト用にライブラリ内で定義した型の <https://hackage.haskell.org/package/QuickCheck-2.14.2/docs/Test-QuickCheck-Arbitrary.html#t:Arbitrary|QuickCheckの >`Arbitrary`<https://hackage.haskell.org/package/QuickCheck-2.14.2/docs/Test-QuickCheck-Arbitrary.html#t:Arbitrary| インスタンス>を作成しようと考えています。 `Arbitrary` インスタンスをどこに書くのが良いのかで悩んでいます。\nこのライブラリを他のプロジェクトから使った時にも `Arbitrary` インスタンスを使えるようにしたいので、テストコード側ではなくライブラリ側に書きたいと考えています。\nしかし、インスタンスを書く為に必要な <https://hackage.haskell.org/package/quickcheck-instances|quickcheck-instances>ライブラリがそれ自身を他のライブラリの依存パッケージとしないことを推奨しているため、「ライブラリ側に書く」のを躊躇しています。\n別のライブラリとして記述するという方法もあると思いますが、それだと後々整合性を持たせるのを忘れそうなのであまり使いたくないなぁと思っています。\n\nこの場合どこに書くのが適切なのでしょうか",
        "type": "message",
        "ts": "1662787201.859309",
        "user": "ULTBB86UC"
    },
    {
        "text": "<@U041V2FD49H> has joined the channel",
        "type": "message",
        "ts": "1662796961.406049",
        "user": "U041V2FD49H"
    },
    {
        "text": "<@U0427D94J5V> has joined the channel",
        "type": "message",
        "ts": "1663285388.992699",
        "user": "U0427D94J5V"
    },
    {
        "text": "<@U042R04R22H> has joined the channel",
        "type": "message",
        "ts": "1663391272.236539",
        "user": "U042R04R22H"
    },
    {
        "text": "はじめて質問させていただきます。\nHaskell学習中の者で、理解が進まない箇所があるのでお力添えいただきたく思います:man-bowing:\n（続く...）",
        "type": "message",
        "ts": "1663570888.297569",
        "user": "U02B9UAPCQ4"
    },
    {
        "text": "<@U043E4G2CRZ> has joined the channel",
        "type": "message",
        "ts": "1663811846.559439",
        "user": "U043E4G2CRZ"
    }
]