[
    {
        "ts": "1609711445.116800",
        "text": "<@U01J9M7LZB3> has joined the channel",
        "user": "U01J9M7LZB3",
        "type": "message"
    },
    {
        "ts": "1609766193.117000",
        "text": "<@U01HHDX3NQP> has joined the channel",
        "user": "U01HHDX3NQP",
        "type": "message"
    },
    {
        "ts": "1609975932.117200",
        "text": "<@U01J5HQ4ZH9> has joined the channel",
        "user": "U01J5HQ4ZH9",
        "type": "message"
    },
    {
        "ts": "1610182880.117400",
        "text": "<@U01HX0A6NT1> has joined the channel",
        "user": "U01HX0A6NT1",
        "type": "message"
    },
    {
        "ts": "1610248749.117600",
        "text": "<@U01JJHKV4PN> has joined the channel",
        "user": "U01JJHKV4PN",
        "type": "message"
    },
    {
        "ts": "1610466636.117800",
        "text": "<@UCM4G8PGW> has joined the channel",
        "user": "UCM4G8PGW",
        "type": "message"
    },
    {
        "ts": "1610765534.000200",
        "text": "<@U01JU5F0G13> has joined the channel",
        "user": "U01JU5F0G13",
        "type": "message"
    },
    {
        "ts": "1610880354.000400",
        "text": "<@U01JRMTAJ8N> has joined the channel",
        "user": "U01JRMTAJ8N",
        "type": "message"
    },
    {
        "ts": "1610927921.000600",
        "text": "<@U01K57PCEH2> has joined the channel",
        "user": "U01K57PCEH2",
        "type": "message"
    },
    {
        "ts": "1610987216.000800",
        "text": "<@U01KE6706CR> has joined the channel",
        "user": "U01KE6706CR",
        "type": "message"
    },
    {
        "ts": "1611106546.001000",
        "text": "<@U01K4FM2C93> has joined the channel",
        "user": "U01K4FM2C93",
        "type": "message"
    },
    {
        "ts": "1611155070.001300",
        "text": "<@U01KG21NNVA> has joined the channel",
        "user": "U01KG21NNVA",
        "type": "message"
    },
    {
        "ts": "1611469399.000200",
        "text": "<@UJBCU6PCH> has joined the channel",
        "user": "UJBCU6PCH",
        "type": "message"
    },
    {
        "ts": "1611579200.002500",
        "text": "まだ基本文法で感動してるような段階の初心者なんですが、どうしても経験者でないとわからないことをお聞きしたいです。GitHubでチラチラとHaskellで書かれたリポジトリを見てみたら、なんとなく全体的に確かに他の言語のものより短くプログラムが書かれている気がします。やはり、Haskellを使用すると他の一般的な言語よりも短いコード量になる、というのはあるのでしょうか？",
        "user": "U01K57PCEH2",
        "type": "message"
    },
    {
        "ts": "1611580274.002600",
        "text": "確かに比較的短く書くための機能はたくさんありますね。まぁ、そのあたりの機能を使いすぎると短すぎて逆に分かりづらい、みたいな状況に陥りがちなんで一概にいいとは言えませんが... :sweat_smile:",
        "user": "U4LGTMTMK",
        "type": "message"
    },
    {
        "ts": "1611580689.002800",
        "text": "なるほど。初心者の段階である程度学んでいった先にどんな感じの世界が待ってるのかがわかってたほうがやりやすいので、助かります！",
        "user": "U01K57PCEH2",
        "type": "message"
    },
    {
        "ts": "1611582399.003200",
        "text": "<@UPH4N6YBV> has joined the channel",
        "user": "UPH4N6YBV",
        "type": "message"
    },
    {
        "ts": "1611634239.003400",
        "text": "<@U01KE3E9SJK> has joined the channel",
        "user": "U01KE3E9SJK",
        "type": "message"
    },
    {
        "ts": "1612148405.003900",
        "text": "Reminder: \nbeginnersチャンネルは、新しい人がスムーズにHaskellに慣れるための質問を歓迎するチャンネルです。\nHaskell-Beginners ML や IRCの#haskell-beginners  や RedditのMonthly Hask Anythingのような位置づけを意図しています。\n\nbeginnersチャンネルでの回答側は、以下の左側のような応答を厳禁とする運用です。\n• それはくだらない質問だ → くだらない質問など無い\n• その質問は以前にもあった → 質問者はそんなこと知らない\n• Google検索せよ → 検索できないから質問している\nbeginnersチャンネルでは、例えば以下のレベルの質問から歓迎します。\n• `:` とは何のことですか。\n• タプルとは何ですか。\n",
        "user": "USLACKBOT",
        "type": "message"
    },
    {
        "ts": "1612186740.004100",
        "text": "<@U01LWT27BEV> has joined the channel",
        "user": "U01LWT27BEV",
        "type": "message"
    },
    {
        "ts": "1612319768.014700",
        "text": "入力処理で、1回の入力単位が1行であれば、hGetLine hdl でよいのですが、\n1回の入力単位が複数の改行を含み特定の文字列（たとえば\"\\n&gt;&gt;&gt; \"）が出現するまで、\nという場合どう書けばいいでしょうか。",
        "user": "U4KU9ABL0",
        "type": "message"
    },
    {
        "ts": "1612333836.015400",
        "text": "とりあえず1文字ずつ読むしかないかなぁ。",
        "user": "U4KU9ABL0",
        "type": "message"
    },
    {
        "ts": "1612357996.015600",
        "text": "こういうことですか\n\n```import           <http://System.IO|System.IO>\n\nhGetLineUntil :: Handle -&gt; String -&gt; IO String\nhGetLineUntil hdl marker = go \"\"\n where\n  go accum = do\n    line &lt;- hGetLine hdl\n    if line == marker\n      then return accum\n      else go $ accum ++ line ++ \"\\n\"\n\n\nmain :: IO ()\nmain =\n  print =&lt;&lt; hGetLineUntil stdin \"&gt;&gt;&gt;\"```",
        "user": "U4LGTMTMK",
        "type": "message"
    },
    {
        "ts": "1612364055.015800",
        "text": "ああ、説明不足でした、特定の文字列というのは或る種のプロンプトであることを想定していまして、\nプロンプトの後は一文字も来ていない時点で取得したいのです。\nプロンプトは来ていても、改行文字は来ないので、hGetLineではプロンプトが得られない状況です。",
        "user": "U4KU9ABL0",
        "type": "message"
    },
    {
        "ts": "1612365284.016200",
        "text": "とりあえず、書いてみたのですが、入出力が不得意すぎて、なんだかなコードのような気がしています。\n```hGetUntil :: Handle -&gt; String -&gt; IO String\nhGetUntil h str = do\n    { eof &lt;- hIsEOF h\n    ; if eof then return \"\"\n      else do\n          { c &lt;- hGetChar h\n          ; if c == head str then (c :) &lt;$&gt; getStr (tail str)\n            else (c :) &lt;$&gt; hGetUntil h str\n          }\n    }\n    where\n        getStr []     = return \"\"\n        getStr (c:cs) = do\n            { eof &lt;- hIsEOF h\n            ; if eof then return \"\"\n              else do\n                  { c' &lt;- hGetChar h\n                  ; if c == c' then (c' :) &lt;$&gt; getStr cs\n                    else (c' :) &lt;$&gt; hGetUntil h str\n                  }\n            }```\n",
        "user": "U4KU9ABL0",
        "type": "message"
    },
    {
        "ts": "1612383980.016400",
        "text": "やりたいことはこういうことだったりしますか？\n```{-# LANGUAGE OverloadedStrings #-}\n\nmodule Main where\n\nimport qualified <http://System.IO|System.IO>             as S\nimport qualified Data.ByteString.Char8 as BS\nimport           Data.IORef            (IORef, newIORef, readIORef, writeIORef)\nimport           System.IO.Unsafe      (unsafePerformIO)\n\nmkBuffer :: IO (IORef BS.ByteString)\nmkBuffer = newIORef \"\"\n\nhGetUntil :: S.Handle -&gt; IORef BS.ByteString -&gt; BS.ByteString -&gt; IO BS.ByteString\nhGetUntil h ref marker = do\n  prevRemain &lt;- readIORef ref\n  (item, remain) &lt;- go prevRemain\n  writeIORef ref remain\n  return item\n where\n  go prevRemain =\n    if BS.null bs2\n      then do\n        mBs &lt;- getBs prevRemain\n        case mBs of\n          Nothing     -&gt; return (prevRemain, \"\")\n          Just remain -&gt; go remain\n      else return (bs1, bs3)\n   where\n    (bs1, bs2) = BS.breakSubstring marker prevRemain\n    bs3        = BS.drop (BS.length marker) bs2\n  getBs :: BS.ByteString -&gt; IO (Maybe BS.ByteString)\n  getBs prev = do\n    isEOF &lt;- S.hIsEOF h\n    if isEOF\n      then return Nothing\n      else do\n        True &lt;- S.hWaitForInput h (-1)\n        Just . BS.append prev &lt;$&gt; BS.hGetNonBlocking h 1024\n\nmain :: IO ()\nmain = do\n  buf &lt;- mkBuffer\n  print =&lt;&lt; hGetUntil S.stdin buf \"\\n&gt;&gt;&gt;\"```\n（IORefは必須ではないですが、どこかに情報をためて受け渡したりする必要があります）",
        "user": "U4M5UPE4F",
        "type": "message"
    },
    {
        "ts": "1612395874.016700",
        "text": "REPLのラッパーを書こうとしいます。*ユーザーの入力(改行終端)ごと*にREPLからの出力(プロンプト文字列終端)を表示するものです。\n模式的には、以下の(1)〜(3)の要素を繋げてループにする(あるいはそれぞれをループにしてから繋げる)イメージです。\n\n```(1)  (stdin &amp; getLine         ) &gt;&gt;= (INPUT-FILTER  &gt;&gt;&gt; hPutStrLn oh1   )\n(2)  (ih1   &amp; hGetLine        ) &gt;&gt;= (REPL          &gt;&gt;&gt; hPutStr   oh2   )\n(3)  (ih2   &amp; hGetUntil prompt) &gt;&gt;= (OUTPUT-FILTER &gt;&gt;&gt; hputStr   stdout)```\n",
        "user": "U4KU9ABL0",
        "type": "message"
    },
    {
        "ts": "1612679205.017200",
        "text": "<@U01M91RMC1G> has joined the channel",
        "user": "U01M91RMC1G",
        "type": "message"
    },
    {
        "ts": "1612958227.017400",
        "text": "<@U01N0DE52HX> has joined the channel",
        "user": "U01N0DE52HX",
        "type": "message"
    },
    {
        "ts": "1613272635.018000",
        "text": "@channel\nすごいH本 第1版 p104で、\nstring2digits::String-&gt;[Int]\nstring2digits = map digitToInt .filter isDigit　…(1)\nとあり、\n\n*Main Data.Char&gt; filter isDigit \"4545-45345\"\n\"454545345\"\n\n*Main Data.Char&gt; map digitToInt \"454545454343\"\n[4,5,4,5,4,5,4,5,4,3,4,3]\n\nとなるまでは分かるのですが、なぜ(1)のように書けるか\n分からず、解説をお願いしたいです。\n(関数合成(.)を使うと、\"digitToInt .filter isDigit\"がひとまとめになって、mapした各要素に適用されるイメージのため)",
        "user": "U0137RHDV7S",
        "type": "message"
    },
    {
        "ts": "1613274366.019500",
        "text": "関数適用の優先度が最も高いので、\n```map digitToInt . filter isDigit```\nは分かりやすいように括弧を付けると\n```(map digitToInt) . (filter isDigit)```\nと評価されるからです!\n\n逆に\n&gt; “digitToInt .filter isDigit”がひとまとめになって、\nを実現したい時は\n```map (digitToInt . filter isDigit)```\nと明示的に書く必要があります:eyes:",
        "user": "U4KPPQW7K",
        "type": "message"
    },
    {
        "ts": "1613274402.019800",
        "text": "`map digitToInt . filter isDigit` は `(map digitToInt) . (filter isDigit)` と同じです。関数合成 `f . g` は加算 `m + n` と同じ二項演算子なので、そうなります。",
        "user": "U5LEE6C1J",
        "type": "message"
    },
    {
        "ts": "1613281731.020200",
        "text": "<@U01NRPX8ABA> has joined the channel",
        "user": "U01NRPX8ABA",
        "type": "message"
    },
    {
        "ts": "1613284312.020500",
        "text": "<@U4KPPQW7K> / <@U5LEE6C1J>\n ありがとうございます",
        "user": "U0137RHDV7S",
        "type": "message"
    },
    {
        "ts": "1613481197.020800",
        "text": "Haskellでヒアドキュメントを実現する一番良い方法は何でしょうか\nたとえば、\n1から100までの連番それぞれに対して、\nその番号を含んだ文書を、計100通り出力したいです。\nシェルスクリプトやPerlでもよくある処理なので難しいことではないと思っていたのですが、\nHaskellでしようとすると詰まってしまいました。\n\n *試したこと*\n\n• *String Gapを使う方法*\n⇒正しくできることもありましたが、下記のエラーがでて動かないこともありました。\n`lexical error in string/character literal at character '\\n'`\n\n改行の位置やインデントの問題なのかもしれませんが、どこを見れば正しいやり方が把握できるのかがわからなかったです。\n\n• *ライブラリを使う方法*\n⇒stackageでヒットしたheredocというライブラリ　heredoc\n<https://www.stackage.org/package/heredoc>\nでは、変数を埋め込むことが出来なさそうな感じでした。\nまた、変数を埋め込むことのできるライブラリ  heredocs\n<https://github.com/cutsea110/heredoc>\nはstackに載っておらず、stackで作成したプロジェクトへの導入の仕方がわからず敬遠している状況です。\n\nいいやり方をご存じの方、教えていただきたいです。",
        "user": "UKAS45C80",
        "type": "message"
    },
    {
        "ts": "1613484744.021000",
        "text": "僕はよく <https://hackage.haskell.org/package/here> を使います",
        "user": "U56L7EVNY",
        "type": "message"
    }
]