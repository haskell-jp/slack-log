[
    {
        "ts": "1564557369.063600",
        "text": "一応補足ですが，現在の GHC では full laziness が入るタイミングが調整されていて，\n```\nfactMemo :: Int -&gt; Integer\nfactMemo = (map fact' [0..] !!)\n  where\n    fact' 0 = 1\n    fact' n = fromIntegral n * factMemo (n - 1)\n\nfact :: Int -&gt; Integer\nfact x = map fact' [0..] !! x\n  where\n    fact' 0 = 1\n    fact' n = fromIntegral n * fact (n - 1)\n```\nはどちらも `fact'` は外に出されます．このため， `map fact' [0..]` も CAF として扱われます． GHCi のバイトコード出すパスでは， core 2 core のパスが少し簡略化されてるので， full laziness が真面目に入ってないだけだと思いますね．\n\nなので，スーパーコンビネータかどうかは指標の一つではありますが，実際にはどう最適化が入るかによって CAF になるかはかなり左右されます",
        "user": "U57D08Z9U",
        "type": "message"
    },
    {
        "ts": "1564577136.064100",
        "text": "<@ULXKBEPR6> has joined the channel",
        "user": "ULXKBEPR6",
        "type": "message"
    },
    {
        "ts": "1564580251.064400",
        "text": "<@ULZRSHT1C> has joined the channel",
        "user": "ULZRSHT1C",
        "type": "message"
    },
    {
        "ts": "1564587041.064600",
        "text": "Liquid Haskell について言えば、`{-@ @-}` は GHC にとっては単なるコメントなのでもっと早い段階で消えそう……な気がしますが根拠はないです。",
        "user": "U4M4XHKB8",
        "type": "message"
    },
    {
        "ts": "1564590486.066800",
        "text": "確かに あれはただのコメントでプラグまですらなかったですね:persevere: 雰囲気的に(?) 型が削除される以前に消されてそうですね…",
        "user": "U9XHWQX7Z",
        "type": "message"
    },
    {
        "ts": "1564617187.071600",
        "text": "はい、”外に出す”ということをコンパイラがやるかどうかはまた別ですもんね. &gt; 真面目に入ってない\nただ後者のfact’がxを巻き込まずに外に出せるとすると意味論的に変わっちゃわないのかなという疑問が湧いてきたんだけど…",
        "user": "U4MMHDSNT",
        "type": "message"
    },
    {
        "ts": "1564632506.072200",
        "text": "<@ULYJX1PU5> has joined the channel",
        "user": "ULYJX1PU5",
        "type": "message"
    },
    {
        "ts": "1564646022.072500",
        "text": "<@ULMAZ8XQB> has joined the channel",
        "user": "ULMAZ8XQB",
        "type": "message"
    },
    {
        "ts": "1564668616.072700",
        "text": "GHC の最適化は通常 equational reasoning に基づいて行われてるので，その意味で意味論が変わるものはあまりないと思いますね (Haskell はちゃんとした formal semantics はないので，ある程度簡略化したラムダ計算の体系の元でということにはなりますが)．\n\nCAF を static closure にして欲しくないという話であれば， <https://stackoverflow.com/questions/6090932/how-to-make-a-caf-not-a-caf-in-haskell/6091166#6091166> みたいな話があって，今回の場合 `map fact' [0..]` の部分を切り出して， `fact` の引数を受け取るようにして `NOINLINE` すればいいと思いますね．と，思ったんですが，\n```\nfact2 :: Int -&gt; Integer\nfact2 x = factMemo2 x fact' !! x\n  where\n    fact' 0 = 1\n    fact' n = fromIntegral n * fact' (n - 1)\n\nfactMemo2 :: Int -&gt; (Int -&gt; Integer) -&gt; [Integer]\nfactMemo2 _ f = map f [0..]\n{-# NOINLINE factMemo2 #-}\n```\nみたいなのだと， w/w が入って `factMemo2` の参照が worker の方に書き換えられてしまいますね… 一応次の形式にすると `-O` ならいい感じに CAF 化を妨害できるみたいです:\n```\nfact2 :: Int -&gt; Integer\nfact2 x = factMemo2 (x &lt; 0) fact' !! x\n  where\n    fact' 0 = 1\n    fact' n = fromIntegral n * fact' (n - 1)\n\nfactMemo2 :: Bool -&gt; (Int -&gt; Integer) -&gt; [Integer]\nfactMemo2 !_ f = map f [0..]\n{-# NOINLINE factMemo2 #-}\n```",
        "user": "U57D08Z9U",
        "type": "message"
    },
    {
        "ts": "1564848108.073200",
        "text": "<@UM0RQSUDS> has joined the channel",
        "user": "UM0RQSUDS",
        "type": "message"
    },
    {
        "ts": "1564990128.075100",
        "text": "みなさんHTMLを出力するときに、どんなテンプレートエンジンを使っていますか？\nこちらのissue <https://github.com/haskell-jp/slack-log/issues/20> に取り組む際の参考にしようと思います。",
        "user": "U4LGTMTMK",
        "type": "message"
    },
    {
        "ts": "1564990231.075500",
        "text": "楽なんで Mustache です :raising_hand: （型の活用はあんまりできないやつですが）\n<http://hackage.haskell.org/package/stache>",
        "user": "U4KPPQW7K",
        "type": "message"
    },
    {
        "ts": "1564990257.075900",
        "text": "blaze-htmlとか使うからテンプレートエンジン使いません！だと今回のケースはちょっとつらい。\nユーザーがカスタマイズできるように外部のテンプレートエンジンを使おう、という趣旨なので",
        "user": "U4LGTMTMK",
        "type": "message"
    },
    {
        "ts": "1564990349.076100",
        "text": "Mustacheやっぱ定番ですかね。\nユーザーがカスタマイズするという要件なので型が緩いのはこの際気にしません！ :muscle:\n起動時にテンプレートをコンパイルしてチェックする、みたいな考慮は必要でしょうね... mustacheならそれもできたはず。",
        "user": "U4LGTMTMK",
        "type": "message"
    },
    {
        "ts": "1564993898.076500",
        "text": "<@UM3TW6S5D> has joined the channel",
        "user": "UM3TW6S5D",
        "type": "message"
    },
    {
        "ts": "1564998373.076700",
        "text": "blaze-html はテンプレートエンジンとはまた違うか :tashikani:",
        "user": "U56L7EVNY",
        "type": "message"
    },
    {
        "ts": "1565050460.077000",
        "text": "関連議論を全部は追い切れていないのですが、再コンパイルが問題であるなら、現状の仕組みをrunghcで動かすのはどうでしょうか？",
        "user": "U570660KX",
        "type": "message"
    },
    {
        "ts": "1565051059.077200",
        "text": "Dhallもテンプレートエンジンとして使える事を謳っているのですが、現状パフォーマンスがすこぶる悪いのが難点です <http://www.haskellforall.com/2017/06/dhall-is-now-template-engine.html>",
        "user": "U570660KX",
        "type": "message"
    },
    {
        "ts": "1565054059.077800",
        "text": "我々だけでなく、ほかのSlack Workspaceの管理者も使えるように、実行ファイルのリリースも視野に入れているので、runghcだとちとつらいですね...\n<https://github.com/haskell-jp/slack-log/issues/22>",
        "user": "U4LGTMTMK",
        "type": "message"
    },
    {
        "ts": "1565083258.080300",
        "text": "<https://qiita.com/autotaker1984/items/5ec0bbd5a44e146dbada> を読んでいて気になったのですが、\nリストリテラル `[1, 2, 3]` が `build  (\\c n -&gt; c 1 (c 2 (c 3 n)))` に変換されるというルールはどこに載っているでしょうか？\nbaseパッケージのGHC.List moduleやGHC.Base moduleを探してみましたが見つかりませんでした。\nきっとコンパイラーのどこかの層に組み込まれているから、librariesの方を見てもわからないってことですよね...",
        "user": "U4LGTMTMK",
        "type": "message"
    },
    {
        "ts": "1565089371.080600",
        "text": "一応 <https://gitlab.haskell.org/ghc/ghc/blob/ghc-8.6.5-release/compiler/deSugar/DsExpr.hs#L837> の部分がそうです。リテラルは Haskell レベルだといじれないので通常は脱糖で扱われることになりますね",
        "user": "U57D08Z9U",
        "type": "message"
    },
    {
        "ts": "1565245599.082900",
        "text": "リスト、木、グラフみたいな基本的なデータ構造のうえでの、ソートとか探索とかの基本的なアルゴリズムについて Haskell でのコードをまとめたサイトとか本はなにかありますか？",
        "user": "UKYUFC94P",
        "type": "message"
    },
    {
        "ts": "1565245790.083100",
        "text": "ぱっと思いつくのは <https://scrapbox.io/haskell-shoen/%E3%83%AC%E3%82%B7%E3%83%94%E9%9B%86> と <https://wiki.haskell.jp/%E3%83%87%E3%83%BC%E3%82%BF%E6%A7%8B%E9%80%A0%E5%88%97%E4%BC%9D> ですが、前者は建設中っぽいし後者はデータ構造そのものの紹介で操作については言及してないしなぁ...",
        "user": "U4LGTMTMK",
        "type": "message"
    },
    {
        "ts": "1565246125.083500",
        "text": "ありがとうございます！",
        "user": "UKYUFC94P",
        "type": "message"
    },
    {
        "ts": "1565246591.083700",
        "text": "なかなかまとまってる資料が見当たらず、いまのところは Data.Tree とか Data.Graph とかのソースを読んでいます。",
        "user": "UKYUFC94P",
        "type": "message"
    }
]