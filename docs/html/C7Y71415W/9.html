<!DOCTYPE html><html><head><meta charset="utf-8"><title>haskell-jp / math #9</title><link rel="stylesheet" href="../../main.css" type="text/css" media="screen"></head><body><div class="ui container"><h1>haskell-jp / math #9</h1><div class="pager ui pagination menu"><a href="../../html/C7Y71415W/8.html" class="pager__previous item">Previous</a><a href="../../" class="pager__top item">Top</a></div><div class="message_list ui feed"><div class="message event" id="message-1585133863.001000"><div class="content"><div class="summary"><div class="message__header user">shin1hi</div><div class="message__timestamp date"><a class="date" href="#message-1585133863.001000">2020-03-25&nbsp;19:57:43 +0900</a></div></div><div class="message__body description">Coalgebra の方ってレンズとかライフゲームだっけ。</div></div></div><div class="message event" id="message-1585134017.003100"><div class="content"><div class="summary"><div class="message__header user">shin1hi</div><div class="message__timestamp date"><a class="date" href="#message-1585134017.003100">2020-03-25&nbsp;20:00:17 +0900</a></div></div><div class="message__body description">なんか、レンズの有用性とかあまり知らないので、ちゃんとやりたいな。</div></div></div><div class="message event" id="message-1585134447.005300"><div class="content"><div class="summary"><div class="message__header user">shin1hi</div><div class="message__timestamp date"><a class="date" href="#message-1585134447.005300">2020-03-25&nbsp;20:07:27 +0900</a></div></div><div class="message__body description">Traversable とは、横断検索ができる形のデータ型の型クラス？<br/>実用例としては、主にツリー型への適用だろうか。</div></div></div><div class="message event" id="message-1585135095.005400"><div class="content"><div class="summary"><div class="message__header user">shin1hi</div><div class="message__timestamp date"><a class="date" href="#message-1585135095.005400">2020-03-25&nbsp;20:18:15 +0900</a></div></div><div class="message__body description">Hom(BxC,D) == Hom(B,Hom(C,D))<br/><br/>これは、<br/>g (b,c) = curry g b c<br/>のカリー化を端的に表しているものだと思いましたが、<br/>(&gt;&gt;=) を用いて何をしようとしているのでしょうか。</div></div></div><div class="message event" id="message-1585215045.005700"><div class="content"><div class="summary"><div class="message__header user">shin1hi</div><div class="message__timestamp date"><a class="date" href="#message-1585215045.005700">2020-03-26&nbsp;18:30:45 +0900</a></div></div><div class="message__body description"><pre>f : A -&gt; B 
g : B -&gt; A -&gt; C 
に対して、

自然に考えられる　A -&gt; C の要素は、
λa. (g (f a) a) 
でしょうか。</pre></div></div></div><div class="message event" id="message-1585215974.006600"><div class="content"><div class="summary"><div class="message__header user">shin1hi</div><div class="message__timestamp date"><a class="date" href="#message-1585215974.006600">2020-03-26&nbsp;18:46:14 +0900</a></div></div><div class="message__body description">元記事をよんでみたが、<br/>class Category の定義に id でなく、idA があるのが謎すぎる（読むのをやめた）</div></div></div><div class="message event" id="message-1585216714.007000"><div class="content"><div class="summary"><div class="message__header user">shin1hi</div><div class="message__timestamp date"><a class="date" href="#message-1585216714.007000">2020-03-26&nbsp;18:58:34 +0900</a></div></div><div class="message__body description">なるほど、これを読めばいいのか。<br/><a href='https://blog.jle.im/entry/intro-to-machines-arrows-part-1-stream-and'>https://blog.jle.im/entry/intro-to-machines-arrows-part-1-stream-and</a></div></div></div><div class="message event" id="message-1585314795.012800"><div class="content"><div class="summary"><div class="message__header user">tkskzyk0925</div><div class="message__timestamp date"><a class="date" href="#message-1585314795.012800">2020-03-27&nbsp;22:13:15 +0900</a></div></div><div class="message__body description">そうであろうと思いながら、実際に例を見つけられていなくてモヤモヤしていることなのですが：<br/><br/>1. 圏 <code>C</code> と圏 <code>D</code> を用意<br/>2. 函手 <code>F: C → D</code> と函手 <code>G: C → D</code> を用意<br/>3. 任意に <code>F</code> と <code>G</code> を選んだとき、自然変換は必ずしも構成できない<br/>   (函手圏として捉えれば、任意の2対象間に必ずしも射が存在するとは限らない、の意)<br/><br/>これは自明だと思っているのですが、どうしても型と関数の圏に閉じる場合、<br/>適当な自然変換を構成できてしまうようにも思えてしまい… 何か身近な反例って無いでしょうか？ :thinking_face:<br/>(もしくは、CCCだと任意の2自己函手間に自然変換を構成できてしまう、などあったりするのか)</div></div></div><div class="message event" id="message-1585315331.013000"><div class="content"><div class="summary"><div class="message__header user">minorinoki_haskjp</div><div class="message__timestamp date"><a class="date" href="#message-1585315331.013000">2020-03-27&nbsp;22:22:11 +0900</a></div></div><div class="message__body description">CやDは一般の圏でもOKですか？（型と関数の圏にはこだわらない？）</div></div></div><div class="message event" id="message-1585315359.013200"><div class="content"><div class="summary"><div class="message__header user">tkskzyk0925</div><div class="message__timestamp date"><a class="date" href="#message-1585315359.013200">2020-03-27&nbsp;22:22:39 +0900</a></div></div><div class="message__body description">一般の圏でも良いです :slightly_smiling_face:</div></div></div><div class="message event" id="message-1585315763.013400"><div class="content"><div class="summary"><div class="message__header user">minorinoki_haskjp</div><div class="message__timestamp date"><a class="date" href="#message-1585315763.013400">2020-03-27&nbsp;22:29:23 +0900</a></div></div><div class="message__body description">Cを空でない適当な圏として、D={:smile:,:thinking_face:}を対象が2個の離散圏（射が恒等射しかない圏）とします。Fを、対象をすべて:smile:に送り、射もすべてid<i>:smile:に送る自明な関手とします。Gは対象をすべて:thinking_face:に送り、射をすべてid</i>:thinking_face:に送る自明な関手とします。FからGへの自然変換を作るにはCのそれぞれの対象（仮にaとします）について射Fa→Gaを用意しないといけませんが、Fa=:smile:とGa=:thinking_face:の間には射は存在しないのでそのような自然変換は存在しません。</div></div></div><div class="message event" id="message-1585315950.013600"><div class="content"><div class="summary"><div class="message__header user">tkskzyk0925</div><div class="message__timestamp date"><a class="date" href="#message-1585315950.013600">2020-03-27&nbsp;22:32:30 +0900</a></div></div><div class="message__body description">あー、それはめちゃわかりやすいですね！ありがとうございます :bow:</div></div></div><div class="message event" id="message-1585437682.014100"><div class="content"><div class="summary"><div class="message__header user">me1</div><div class="message__timestamp date"><a class="date" href="#message-1585437682.014100">2020-03-29&nbsp;08:21:22 +0900</a></div></div><div class="message__body description">@me1 has joined the channel</div></div></div><div class="message event" id="message-1585535672.014700"><div class="content"><div class="summary"><div class="message__header user">igrep</div><div class="message__timestamp date"><a class="date" href="#message-1585535672.014700">2020-03-30&nbsp;11:34:32 +0900</a></div></div><div class="message__body description">続くCoqでの証明はわからんけど、すごくおもしろい <a href='https://qiita.com/nekonibox/items/c1c7f4d1ad1695967e39'>https://qiita.com/nekonibox/items/c1c7f4d1ad1695967e39</a></div></div></div><div class="message event" id="message-1585537233.015700"><div class="content"><div class="summary"><div class="message__header user">hexirp</div><div class="message__timestamp date"><a class="date" href="#message-1585537233.015700">2020-03-30&nbsp;12:00:33 +0900</a></div></div><div class="message__body description">半順序でのソートってつまりトポロジカルソートなのでは（まだ記事を読んでいないけど）</div></div></div><div class="message event" id="message-1585537335.016700"><div class="content"><div class="summary"><div class="message__header user">igrep</div><div class="message__timestamp date"><a class="date" href="#message-1585537335.016700">2020-03-30&nbsp;12:02:15 +0900</a></div></div><div class="message__body description"><blockquote> そこで、O(n log n)の全順序におけるソートアルゴリズムが流用できないかを考察していきます。</blockquote>とあるとおり、既存のソートアルゴリズムを再利用できないか、という試みです。</div></div></div><div class="message event" id="message-1585537418.018700"><div class="content"><div class="summary"><div class="message__header user">hexirp</div><div class="message__timestamp date"><a class="date" href="#message-1585537418.018700">2020-03-30&nbsp;12:03:38 +0900</a></div></div><div class="message__body description">読みました。その通りですね。最悪計算量が O(n log n) であるアルゴリズムが全滅しているのは偶然なのかな？</div></div></div></div><div class="pager ui pagination menu"><a href="../../html/C7Y71415W/8.html" class="pager__previous item">Previous</a><a href="../../" class="pager__top item">Top</a></div></div></body></html>