[
    {
        "type": "message",
        "user": "U4LGTMTMK",
        "ts": "1685264725.412439",
        "text": "今日も今日とて脱線が多く、makeMistakesToLearnHaskellを進められただけで終わりました。cabal replの件はもうちょっと思い出しながら延長戦でちょっと進めます。\n<https://github.com/haskell-jp/makeMistakesToLearnHaskell/commit/10197f35f9a73aba781934a5c3c8f15a0e87dc08>"
    },
    {
        "type": "message",
        "user": "U4KNX0J3A",
        "ts": "1685265175.876119",
        "text": "• `TAlias ModuleName.Canonical Name [(Name, Type)] AliasType` からエイリアス右辺の型情報を省いた `TAliasElmi ModuleName.Canonical Name [(Name, Type)]`データコンストラクタを追加\n• 使用箇所にそれに合わせて枝を追加\n• Build.loadInterfaces関数とDetails.loadInterfaces関数で読み出し時に穴埋めに必要なaliasesを取れそうなのでここで穴埋めをやるとよさそうだとわかった\n• Build.loadiInterfaces内で右辺の型を埋めるfillInAliases関数を実装中\nめざせelm 0.19.2"
    },
    {
        "type": "message",
        "user": "U584T7GAH",
        "ts": "1685265336.791599",
        "text": "\"簡約!? λカ娘\" (#7)　読了　モナドを徹底的に圏論で考える記事と　Dependent Type Programming が面白い（難解だった）\nAtCoder 鉄則本 B68 - ALGO Express 悪戦苦闘中"
    },
    {
        "type": "message",
        "user": "U57CGDBMG",
        "ts": "1685534564.441479",
        "text": "その後コードを整理して短くなりました。成果報告。\na円 b円 1円 (a &gt; b &gt; 1) の3種類のコインを使った最小枚数での払い方。計算量 O(log(b))。\n```import Data.List (unfoldr)\n\n-- a/b の連分数展開と近似分数\ncf a b = unfoldr f (a,b,0,1,1,0) where\n  f (_,0,_,_,_,_) = Nothing\n  f (a,b,p1,q1,p2,q2) = Just((b,c,p2,q2), (b,a',p2,q2,p,q)) where\n    (c, a') = a `divMod` b\n    (p, q) = (p1 + c * p2, q1 + c * q2)\n\nchunk [] = []\nchunk [(r1,_,p1,q1)] = [(r1,p1,q1, 0,undefined,undefined, undefined)]\nchunk ((r1,_,p1,q1):(r2,c2,p2,q2):ds)\n  | c' &lt; c2 = [pair]\n  | otherwise = pair: chunk ds\n  where\n    (c, l) = (r1 - p1 + q1) `divMod` (r2 + p2 - q2)\n    c' = if c == c2 &amp;&amp; l == 0 then c-1 else c\n    pair = (r1,p1,q1, r2,p2,q2, c')\n\n-- n円を a円 b円 1円 (a &gt; b &gt; 1) の3種類のコインで払う。計算量 O(log(b))\ncmp a b n = (y'+x'+z',(y',x',z')) where\n  (y, x) = n `divMod` a\n  (y',x',z') = cmp' (chunk $ cf a b) (y,x,0)\n  cmp' [] yxz = yxz\n  cmp' ((r1,p1,q1, r2,p2,q2, c): ds) (y,x,z)\n    | i1 &lt; i = yxz1\n    | r2 == 0 = yxz1\n    | x1 &lt; r2 = cmp' ds yxz1\n    | j2 &lt;= c &amp;&amp; y2 &gt;= 0 = cmp' ds yxz2 \n    | otherwise = yxz1\n    where\n      i = x `div` r1\n      i1 = if y &lt; i * q1 then y `div` q1 else i\n      yxz1@(y1,x1,z1) = (y - i1 * q1, x - i1 * r1, z + i1 * p1)\n      (j,x2) = (x1 - r1) `divMod` r2\n      j2 = -j\n      yxz2@(y2,_,_) = (y1 - j2 * q2 - q1, x2, z1 + j2 * p2 + p1)```"
    }
]