<!DOCTYPE html><html><head><meta charset="utf-8"><title>haskell-jp / questions #41</title><link rel="stylesheet" href="/slack-log/messages.css" type="text/css" media="screen"></head><body><h1>haskell-jp / questions #41</h1><div class="pager"><a href="/slack-log/html/C5666B6BB/40.html" class="pager__previous">Previous</a><a href="/slack-log/" class="pager__top">Top</a><a href="/slack-log/html/C5666B6BB/42.html" class="pager__next">Next</a></div><div class="message_list"><div class="message" id="message-1548838831.405200"><div class="message__timestamp">2019-01-30<br/>18:00:31 +0900</div><div class="message__header">koyama</div><div class="message__body">OOP 脳に洗脳されていると、二項演算子の左と右が同じ型でないといけないっていうこと自体がびっくりだろうからそれを言おうとしてるのかなあ、と。</div></div><div class="message" id="message-1548838861.406200"><div class="message__timestamp">2019-01-30<br/>18:01:01 +0900</div><div class="message__header">fumieval</div><div class="message__body">うーん、文法的な理解に違いがあるように見えます…例えば「あなたにはプログラミングの才能がある」という言い方ができるからといって、「才能がある(という性質)とは、あなたのことである」と言うことはできないですよね。「あなた」を型、「才能がある」をインスタンス、「プログラミングの」を「ある型クラスの」と置き換えても同じことが言えます</div></div><div class="message" id="message-1548839013.408800"><div class="message__timestamp">2019-01-30<br/>18:03:33 +0900</div><div class="message__header">fumieval</div><div class="message__body">意地悪に捉えればそういう見方もありますね…ただ色々と成り立ってないので、私は忘れたほうがいいという結論になりました…</div></div><div class="message" id="message-1548839039.409300"><div class="message__timestamp">2019-01-30<br/>18:03:59 +0900</div><div class="message__header">koyama</div><div class="message__body">まあ、いじわるというか、この部分についても「まぎらわしい」ので、ぶっちゃけ読む価値がないなあ、と^^;</div></div><div class="message" id="message-1548839074.409700"><div class="message__timestamp">2019-01-30<br/>18:04:34 +0900</div><div class="message__header">kakkun61</div><div class="message__body">型クラスは <code>(種, 種, …, 型, 型, …)</code> という組で、インスタンスはそれに対応する <code>(型, 型, …, 値, 値, …)</code> という組というイメージ（ただし Haskell では、インスタンスは型の組合せの部分で一意にならないといけない）</div></div><div class="message" id="message-1548839376.410800"><div class="message__timestamp">2019-01-30<br/>18:09:36 +0900</div><div class="message__header">koyama</div><div class="message__body">それはそのとおりです。なので、その文法的な問題は「Eq のインスタンス」のところには当てはまらないんじゃないかな、と思いました。ぶっちゃけ言いたいことはそれだけです^^;</div></div><div class="message" id="message-1548839393.411000"><div class="message__timestamp">2019-01-30<br/>18:09:53 +0900</div><div class="message__header">notogawa</div><div class="message__body">こう <a href='https://gist.github.com/notogawa/c122fc1d75531c4f8db30e6d66832ffc'>https://gist.github.com/notogawa/c122fc1d75531c4f8db30e6d66832ffc</a></div></div><div class="message" id="message-1548839461.411200"><div class="message__timestamp">2019-01-30<br/>18:11:01 +0900</div><div class="message__header">fumieval</div><div class="message__body">「Eqのインスタンス」のように型クラスが明記されていれば、それは型に対する述語となるのでもちろん問題ないと思います。</div></div><div class="message" id="message-1548839663.415000"><div class="message__timestamp">2019-01-30<br/>18:14:23 +0900</div><div class="message__header">koyama</div><div class="message__body">要は例えば groupBy::(a-&gt;a-&gt;Bool)-&gt;[a]-&gt;[[a]] にいちいち最初の引数を渡すの面倒だから、この型なら必ずこの関数を使ってねっていうのを instance で決めておけば group :: Eq a=&gt;[a]-&gt;[[a]] が使えるよ、っていう話ですよね。で、逆にそれじゃ困る人は毎回 groupBy に何か渡すしかない、っていう。</div></div><div class="message" id="message-1548839699.415400"><div class="message__timestamp">2019-01-30<br/>18:14:59 +0900</div><div class="message__header">hexirp</div><div class="message__body">Scala や Coq の原理はこうなんですよね。まず、型を定義して、それを暗黙引数で型クラスとして使う方法。</div></div><div class="message" id="message-1548839731.415500"><div class="message__timestamp">2019-01-30<br/>18:15:31 +0900</div><div class="message__header">hexirp</div><div class="message__body">newtype も一応使えます</div></div><div class="message" id="message-1548839787.415800"><div class="message__timestamp">2019-01-30<br/>18:16:27 +0900</div><div class="message__header">koyama</div><div class="message__body">newtype するのは一つの手ではありますが、皮をかぶせたり外したりしないといけないので、 groupBy が必要な状況ではあまり向いてないかなあ、と思ってあえて groupBy を例に出しました^^;</div></div><div class="message" id="message-1548839894.416100"><div class="message__timestamp">2019-01-30<br/>18:18:14 +0900</div><div class="message__header">koyama</div><div class="message__body">まあ、そういう状況でも newtype でくるんで外した方がラクだよね、っていう発想をするのが真の Haskeller なのかもしれませんね…^^;;</div></div><div class="message" id="message-1548839954.416400"><div class="message__timestamp">2019-01-30<br/>18:19:14 +0900</div><div class="message__header">hexirp</div><div class="message__body">そうですね、横槍失礼しました :bow:</div></div><div class="message" id="message-1548839998.417100"><div class="message__timestamp">2019-01-30<br/>18:19:58 +0900</div><div class="message__header">koyama</div><div class="message__body">（foldl や foldr が中で、 Endo に包み込んで foldMap に扱わせてるのを見たりすると、たしかに包んで外す方がラクだという話はあるんだな、と思いました）</div></div><div class="message" id="message-1548840063.417900"><div class="message__timestamp">2019-01-30<br/>18:21:03 +0900</div><div class="message__header">hexirp</div><div class="message__body">あ、今は coerce でわざわざ外したりくるんだりしなくとも変換出来たり</div></div><div class="message" id="message-1548840106.418600"><div class="message__timestamp">2019-01-30<br/>18:21:46 +0900</div><div class="message__header">fumieval</div><div class="message__body">束縛・代入の話のときもそうでしたが、基本的な用語で意見が割れることがあり油断できない…</div></div><div class="message" id="message-1548840110.418700"><div class="message__timestamp">2019-01-30<br/>18:21:50 +0900</div><div class="message__header">koyama</div><div class="message__body">包むコンストラクタ・外すrunほげ のかわりに coerce / coerce を書くだけですよね^^;</div></div><div class="message" id="message-1548840235.419700"><div class="message__timestamp">2019-01-30<br/>18:23:55 +0900</div><div class="message__header">koyama</div><div class="message__body">少し前に <a href='https://haskell-jp.slack.com/archives/C5666B6BB/p1548483818293400'>https://haskell-jp.slack.com/archives/C5666B6BB/p1548483818293400</a> の話題がでましたけど、これなんかはまさに「型（コンストラクタ）に対して一個しかインスタンス宣言できない」がゆえの悩みだったりしますよね…</div></div><div class="message" id="message-1548841069.421700"><div class="message__timestamp">2019-01-30<br/>18:37:49 +0900</div><div class="message__header">koyama</div><div class="message__body">ところで <a href='#C5666B6BB'>questions</a> らしく質問ですけど、標準 Haskell だと「instance 宣言自体の export/import をするかしないか」は選べなくて必ず export しちゃうし必ず import しちゃうんですけど、 GHC 拡張だとそこらへんコントロールできたりするでしょうか？</div></div><div class="message" id="message-1548841235.422200"><div class="message__timestamp">2019-01-30<br/>18:40:35 +0900</div><div class="message__header">igrep</div><div class="message__body">さぁ... そんな拡張はちょっと聞いたことがないですね... あったとして使われたら結構混乱しそうな気がします... :fearful:</div></div><div class="message" id="message-1548841363.422400"><div class="message__timestamp">2019-01-30<br/>18:42:43 +0900</div><div class="message__header">koyama</div><div class="message__body">意味がどうなるかがわからないのが確かに混乱しそうですね。ただ、こう、自分のモジュールで「もともと Show インスタンスじゃないんだけど、自分のデバッグのためだけにこのモジュールではこういう形で表示させたいのでそのためだけに Show インスタンスに入れておきたい（けどヨソのモジュールでは使ってほしくないので export はしたくない）みたいな話って、ありそうな気がするんですよね…</div></div><div class="message" id="message-1548841480.422800"><div class="message__timestamp">2019-01-30<br/>18:44:40 +0900</div><div class="message__header">koyama</div><div class="message__body">あと、標準の Show インスタンスの定義がきにいらないので自分版を使いたい、とか^^;</div></div><div class="message" id="message-1548841542.423000"><div class="message__timestamp">2019-01-30<br/>18:45:42 +0900</div><div class="message__header">koyama</div><div class="message__body">まあ、いずれも show にこだわることなく自分で文字列化関数を作ってそれを使えという話ではあるんですが…。</div></div><div class="message" id="message-1548841712.423300"><div class="message__timestamp">2019-01-30<br/>18:48:32 +0900</div><div class="message__header">koyama</div><div class="message__body">自分版で「オーバーライド（？）」できてしまうと、別モジュールのライブラリの奥の方で print してるような関数ではたしてどっちの show が使われるのか、ワクワクしますねｗ</div></div><div class="message" id="message-1548841755.423600"><div class="message__timestamp">2019-01-30<br/>18:49:15 +0900</div><div class="message__header">koyama</div><div class="message__body">（おそらく最初の Show a=&gt;制約を見たときにセットされた辞書がたらいまわしにされると思うんですが…）</div></div><div class="message" id="message-1548841827.423900"><div class="message__timestamp">2019-01-30<br/>18:50:27 +0900</div><div class="message__header">igrep</div><div class="message__body">完全な自由を与えるわけではないんですが、特定の範囲でメソッド（が入った辞書）を差し替えることができる、という意味では去年のHaskell Symposiumで発表された <a href='https://icfp18.sigplan.org/event/haskellsymp-2018-papers-coherent-explicit-dictionary-application-for-haskell'>https://icfp18.sigplan.org/event/haskellsymp-2018-papers-coherent-explicit-dictionary-application-for-haskell</a> が近いような気がします。</div></div><div class="message" id="message-1548841953.424200"><div class="message__timestamp">2019-01-30<br/>18:52:33 +0900</div><div class="message__header">igrep</div><div class="message__body">あぁっ、以前は無料でPDFがダウンロードできたのに今はできない？ :disappointed:</div></div><div class="message" id="message-1548842276.424600"><div class="message__timestamp">2019-01-30<br/>18:57:56 +0900</div><div class="message__header">igrep</div><div class="message__body">実装だけ見ても難しいかとは思いますが、 <a href='https://github.com/mrBliss/ghc'>https://github.com/mrBliss/ghc</a> これがそのプロトタイプです。</div></div><div class="message" id="message-1548842943.424900"><div class="message__timestamp">2019-01-30<br/>19:09:03 +0900</div><div class="message__header">koyama</div><div class="message__body">Sample.hs を見ていました。 visible type application のような感じで、二重丸括弧で ((辞書用の型のデータ)) と書けば辞書が渡せる、っていう感じなんですかね。</div></div><div class="message" id="message-1548848027.425300"><div class="message__timestamp">2019-01-30<br/>20:33:47 +0900</div><div class="message__header">syocy</div><div class="message__body">自分で分かっていないことを言うのですが、 backpack で似たようなことはできないのでしょうか。</div></div><div class="message" id="message-1548849589.425500"><div class="message__timestamp">2019-01-30<br/>20:59:49 +0900</div><div class="message__header">igrep</div><div class="message__body">型や関数まとめるのにbackpackのsignatureを使っている場合であれば、「このunitではこのsignatureに該当するmoduleはこんなmoduleです」、と自由に宣言できるので、できると思います。</div></div><div class="message" id="message-1548853128.425800"><div class="message__timestamp">2019-01-30<br/>21:58:48 +0900</div><div class="message__header">koyama</div><div class="message__body">えーと、 backpack というものを知らないのでいまググった程度の知識ですが、それはつまり「型クラスを使うというコースを捨てて、 backpack のモジュール化機構を使いましょう」っていう解決策ですかね？</div></div><div class="message" id="message-1548853457.426000"><div class="message__timestamp">2019-01-30<br/>22:04:17 +0900</div><div class="message__header">koyama</div><div class="message__body">こう、結局「C でヘッダファイルだけ公開してコンパイルさせておいて、実際にリンクするライブラリは切り替え可能」って言ってるのに近い感じ（っていうかそのもの？）なので、 C ってしぶとく生き残る強さがあるよなーと思ってしまいます^^;</div></div><div class="message" id="message-1548854579.429200"><div class="message__timestamp">2019-01-30<br/>22:22:59 +0900</div><div class="message__header">koyama</div><div class="message__body">上記と関連するのですが、現状 instance 宣言は取捨選択できないので、二重定義を避けるために「どのモジュールに instance 宣言を置くべきか」というのが悩ましい気がしています。自分で便利な型クラスを作ったのでそれに Int, Double …などのインスタンスを書きたい場合、逆に自分で便利な型を作ったのでそれを Num, Show, Eq …などのインスタンスにしたい場合、その両方の場合がありうるので、「型クラスの定義があるモジュール側にインスタンスを書く」のも「型の定義があるモジュール側にインスタンスを書く」のもなんか違う気がしています。なんかベストプラクティスとかあるんでしょうかね？（既存ライブラリの組み合わせで実際に問題がおきたりはしていないのでしょうか？）</div></div><div class="message" id="message-1548857051.429400"><div class="message__timestamp">2019-01-30<br/>23:04:11 +0900</div><div class="message__header">matsubara0507</div><div class="message__body">インスタンス宣言の export/import する方法は現状ないはずです(少なくとも一般的な方法は)<br/>そして、おっしゃる通り backpack も型クラスとは別の機能であってます :ok_hand: </div></div><div class="message" id="message-1548890919.429600"><div class="message__timestamp">2019-01-31<br/>08:28:39 +0900</div><div class="message__header">igrep</div><div class="message__body">「自分で便利な型クラスを作ったのでそれに Int, Double …などのインスタンスを書きたい場合」「型クラスの定義があるモジュール側にインスタンスを書く」<br/>で、<br/>「自分で便利な型を作ったのでそれを Num, Show, Eq …などのインスタンスにしたい場合」「「型の定義があるモジュール側にインスタンスを書く」<br/>でよいのではないでしょうか。<br/>というか、そうじゃなければorphan-instanceの警告でますし...</div></div><div class="message" id="message-1548892212.430000"><div class="message__timestamp">2019-01-31<br/>08:50:12 +0900</div><div class="message__header">mizunashi-mana</div><div class="message__body">この辺は僕も悩んでて正解を知りたいのですが，標準的な答えとしては「型クラスの定義があるモジュールにインスタンス宣言がないということは実装がないということが標準(型クラス提供者が考えるデファクト)である」/「新たな型定義があるモジュールにインスタンス宣言がないということは，その型に実装がないことが標準(型提供者が考えるデファクト)である」ということだと思っています．なので，デファクトから外れる場合 <code>newtype</code> なりで自分自身の考えるインスタンスを追加するべきというのが現状のHaskellの主流ではないでしょうか？( orphan instance の警告が出るのがそれを示していると思います．この辺は shadowing も事情が似てる気がします)</div></div><div class="message" id="message-1548892912.430200"><div class="message__timestamp">2019-01-31<br/>09:01:52 +0900</div><div class="message__header">mizunashi-mana</div><div class="message__body">この思想自体は理解できますが，実際に使う場合インスタンスを柔軟に切り替えたいことはありますし，保守性の面で orphan instance を作らなければいけない場合はあります( base-orphans などが有名な例だと思います)．<br/>また， parsers ライブラリは orphan instance を避けるため attoparsec / parsec に依存してるわけですがおかげで megaparsec から批判が飛んでくるといった事態を引き起こしています．</div></div><div class="message" id="message-1548893275.430400"><div class="message__timestamp">2019-01-31<br/>09:07:55 +0900</div><div class="message__header">mizunashi-mana</div><div class="message__body">ただ， orphan instance はかなり注意深く管理しないと壊れる可能性も高い (instance宣言の明示的なexport/import はできないので，1つの orphan instance のせいでモジュール全てが使えなくなるといったことも起きる) ので，結構リスクが高いです．<br/>なので，よほどのことがない限り orphan instance を使わず <code>newtype</code> によって新しいインスタンス宣言は作っていくべき，ただ注意深く管理しリスクを許容するなら使うべき時はあるかもしれないというのが，個人的に知る限りのベストプラクティスだとは思いますね(ただあまり納得はできていないのですが)</div></div><div class="message" id="message-1548893391.430800"><div class="message__timestamp">2019-01-31<br/>09:09:51 +0900</div><div class="message__header">igrep</div><div class="message__body">多分、orphan instanceを提供する目的のライブラリーとアプリケーション以外はorphan instanceを作らず、個々のアプリケーションでのみそれらを使う（または自分でorphan instanceを定義する）が正解じゃないかと思っています。</div></div><div class="message" id="message-1548901289.431000"><div class="message__timestamp">2019-01-31<br/>11:21:29 +0900</div><div class="message__header">koyama</div><div class="message__body">ライブラリＡ（クラスＸを提供していて、既存の有名どころのデータ型のインスタンスは一通り提供している）と、<br/>ライブラリＢ（データ型Ｙを提供していて、既存の有名どころのクラスへのインスタンスは一通り提供している）があるとしたときに、<br/>ライブラリＡとＢを組み合わせた時のＹのＸへのインスタンス宣言はとりあえずその状態ではライブラリ利用者側で書くしかないわけですが、一方これらのライブラリの製作者側の立ち位置に立った時にお互い相手の存在を認知したときに自分（のライブラリの次期バージョン）でインスタンス宣言を書きたくならないのかなあ、というところが疑問のポイントでした。</div></div><div class="message" id="message-1548901428.431600"><div class="message__timestamp">2019-01-31<br/>11:23:48 +0900</div><div class="message__header">koyama</div><div class="message__body">第三のライブラリとして orphan instance のみを提供するライブラリが出現する、というのが流れなんですかねえ、この場合は。</div></div><div class="message" id="message-1548910075.432400"><div class="message__timestamp">2019-01-31<br/>13:47:55 +0900</div><div class="message__header">koyanagis</div><div class="message__body">@koyanagis has joined the channel</div></div><div class="message" id="message-1548910477.432600"><div class="message__timestamp">2019-01-31<br/>13:54:37 +0900</div><div class="message__header">hiroto.shioi</div><div class="message__body"><blockquote>一方これらのライブラリの製作者側の立ち位置に立った時にお互い相手の存在を認知したときに自分（のライブラリの次期バージョン）でインスタンス宣言を書きたくならないのかなあ、というところが疑問のポイントでした。</blockquote>よっぽどの需要がない限り書く必要がないと考えるんじゃないかな。。mizunashiさんがいうとおりYのデータ型をnewtypeでくるんで、そのくるんだ型でインスタンス定義すればいいだけだし。<br/>僕がXを提供しているライブラリの製作者ならそう考えるね。</div></div><div class="message" id="message-1548910546.432800"><div class="message__timestamp">2019-01-31<br/>13:55:46 +0900</div><div class="message__header">y_taka_23</div><div class="message__body">あかんやつや。しかし aws-lambda-haskell-runtime も相当やっつけ感があるし、これがマイナ言語の悲哀か。</div></div><div class="message" id="message-1548910697.433100"><div class="message__timestamp">2019-01-31<br/>13:58:17 +0900</div><div class="message__header">igrep</div><div class="message__body"><blockquote>第三のライブラリとして orphan instance のみを提供するライブラリが出現する、というのが流れなんですかねえ、この場合は。</blockquote>だと思いますよ。現にそういうライブラリーはたくさんありますし。</div></div><div class="message" id="message-1548919494.433500"><div class="message__timestamp">2019-01-31<br/>16:24:54 +0900</div><div class="message__header">hiroto.shioi</div><div class="message__body">Parsecに関する質問です。<br/>MarkdownのOrderedListのようなものをparsecを用いて解析しようとしています。<br/>Markdownでは - (ダッシュ）を用いてUnorderedListを表現しますが、今回は文章の前のwhitespaceの数がその代わりとなっています。<br/>例：Markdownでは<br/>- One<br/>- Two<br/>- Three<br/>と表現するところを<br/> One<br/> Two<br/> Three<br/>と表現します。（見えにくいと思うけど、各行にはそれぞれ最初スペースがあります。。）<br/>つまり文章の前にwhitespaceがあればリストであると判断することができます。<br/>またwhitespaceの数が増えた場合、新たなリストが始まったと判断し、解析を始める必要があります。<br/>問題はネスト化されたリストを解析する際に、それを正しく解析できていません。<br/><a href='https://gist.github.com/HirotoShioi/ddeaccf09b7545f64883019ea4b94c55'>https://gist.github.com/HirotoShioi/ddeaccf09b7545f64883019ea4b94c55</a><br/>parseList exampleList<br/>を実行すると (Right expecting)を返すようにしたいのですが、どこに問題があるのでしょうか。<br/>僕はbulletPointParserに問題があるんじゃないかと思っています。</div></div><div class="message" id="message-1548922789.434200"><div class="message__timestamp">2019-01-31<br/>17:19:49 +0900</div><div class="message__header">igrep</div><div class="message__body"><blockquote>それを正しく解析できていません。</blockquote>:thinking_face: どんな結果になるんでしょうか？<br/>ParserErrorが返ってくる？それとも無限ループにはまる？<br/>どちらにしてもできることとして、 <code>traceShowId</code>で怪しいところにデバッグコードを挟んでみるのもよいんじゃないかと</div></div><div class="message" id="message-1548923625.434400"><div class="message__timestamp">2019-01-31<br/>17:33:45 +0900</div><div class="message__header">mizunashi-mana</div><div class="message__body">具体的に，パーサに則ってパースしてみるといいと思います． <code>bulletPointParser</code> が間違っているというのはあっていて，具体的にはそれぞれの要素で <code>lookAhead</code> に入る前に空白を <code>replicateM_</code> で消費してる数に注目してみるのが良い気がします．</div></div></div><div class="pager"><a href="/slack-log/html/C5666B6BB/40.html" class="pager__previous">Previous</a><a href="/slack-log/" class="pager__top">Top</a><a href="/slack-log/html/C5666B6BB/42.html" class="pager__next">Next</a></div></body></html>