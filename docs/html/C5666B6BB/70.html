<!DOCTYPE html><html><head><meta charset="utf-8"><title>haskell-jp / questions #70</title><link rel="stylesheet" href="../../messages.css" type="text/css" media="screen"></head><body><h1>haskell-jp / questions #70</h1><div class="pager"><a href="../../html/C5666B6BB/69.html" class="pager__previous">Previous</a><a href="../../" class="pager__top">Top</a></div><div class="message_list"><div class="message" id="message-1567938986.050900"><div class="message__timestamp">2019-09-08<br/>19:36:26 +0900</div><div class="message__header">igrep</div><div class="message__body">確かに、言われてみればなんの区切りもなく匿名関数が始まっているようで、普通の式とどうやって見分けるんだろうという感じがしますね...</div></div><div class="message" id="message-1567939338.051200"><div class="message__timestamp">2019-09-08<br/>19:42:18 +0900</div><div class="message__header">9647142</div><div class="message__body">たしかに。<br/>括弧にくるんでるからって安心してましたけどたしかにexprASTも括弧にくるまれてるから安心できなかった</div></div><div class="message" id="message-1567943436.051800"><div class="message__timestamp">2019-09-08<br/>20:50:36 +0900</div><div class="message__header">mizunashi-mana</div><div class="message__body">なるほど，不思議な動作ですね… 確かに Strict の時のみ stack overflow になりました… ちょっとそれは想定してませんでしたね…</div></div><div class="message" id="message-1567945497.052100"><div class="message__timestamp">2019-09-08<br/>21:24:57 +0900</div><div class="message__header">mizunashi-mana</div><div class="message__body">あ，いいのか．過去の自分に追いつけてなかった．<br/>まず， Strict をつけようがつけまいが，<br/><pre>
foldl (\ z x -&gt; x : z) [] [1..n]
</pre><br/>は<br/><pre>
let k = \ z x -&gt; x : z in (([] `k` 1) ... `k` n)
</pre><br/>みたいなものを生成することになります．でそれぞれの括弧の中身はサンクのままヒープにのって評価されるのを待つことになります．<br/><br/><code>evaluate</code> でそれが WHNF まで評価されることになりますが，まず一番外側の評価<br/><pre>
(… `k` n) =&gt; n : ...
</pre><br/>が実行されることになります． Strict をつけない場合 <code>...</code> は評価されませんが， Strict をつける場合 <code>...</code> の部分が評価されることになり，さらにその評価のために <code>k (…) (n - 1)</code> の評価が走りという感じで，どんどんスタックに退避された値が積み上がっていきスタックオーバーフローになります．<br/><br/>なお，ちゃんと <code>foldl'</code> を使った場合，ヒープに積み上がるはずだったサンクが先に消化されながらループが回るため，どちらの場合もスタックオーバーフローは起きません</div></div><div class="message" id="message-1567945696.052800"><div class="message__timestamp">2019-09-08<br/>21:28:16 +0900</div><div class="message__header">mizunashi-mana</div><div class="message__body">あ，だから Strict 拡張のみで stack overflow する例なんですね．前のコメントは間違いですね．失礼しました</div></div><div class="message" id="message-1567955856.055000"><div class="message__timestamp">2019-09-09<br/>00:17:36 +0900</div><div class="message__header">kakkun61</div><div class="message__body">初めて template Haskell を書いたのですがビルド時に 10GB 以上消費されるようになってしまいました…… :cry:<br/>コードレビューしてほしいです<br/><a href='https://github.com/kakkun61/tuple/pull/1'>https://github.com/kakkun61/tuple/pull/1</a></div></div><div class="message" id="message-1567962365.055200"><div class="message__timestamp">2019-09-09<br/>02:06:05 +0900</div><div class="message__header">notogawa</div><div class="message__body">Ty*等構文木のコンストラクタを直で使うとバージョンアップで壊れやすいものができあがるので，可能な限りQuasi-quotationを使って書いておいたほうが幸せになると思います．</div></div><div class="message" id="message-1567963552.055400"><div class="message__timestamp">2019-09-09<br/>02:25:52 +0900</div><div class="message__header">kakkun61</div><div class="message__body">なるほど！</div></div><div class="message" id="message-1567976577.055600"><div class="message__timestamp">2019-09-09<br/>06:02:57 +0900</div><div class="message__header">mizunashi-mana</div><div class="message__body"><code>Q</code> モナドは， <code>runQ</code> を使えば <code>IO</code> の元で走らせることができるようになっているので，それでデバッグできます．大体のデータ型は <code>Show</code> が実装されているので，単純に表示してみると良いと思います．<br/><br/><pre>
&gt;&gt;&gt; runQ (consType 1) :: IO [Dec]
[TySynInstD Data.Tuple.List.Data.Cons (TySynEqn [VarT x_2,TupleT 0] (AppT (TupleT 1) (VarT x_2)))]
</pre><br/><br/>みたいな感じでそれぞれの関数の <code>Dec</code> を表示する <code>Main</code> モジュールを書いて，プロファイルを取ってみるといいと思いますね．<br/><br/>ついでにですが，無限リストの利用は計画的に行った方が良いと思いますね</div></div><div class="message" id="message-1567992697.056300"><div class="message__timestamp">2019-09-09<br/>10:31:37 +0900</div><div class="message__header">kakkun61</div><div class="message__body"><code>runQ</code> したのをわざわざコピーしてました……</div></div><div class="message" id="message-1568007206.056600"><div class="message__timestamp">2019-09-09<br/>14:33:26 +0900</div><div class="message__header">hiroto.shioi</div><div class="message__body">できないと思う。少なくとも僕が関わっているプロジェクトではstackでインストールしたパッケージをnixの環境では利用できなかった。<br/><br/><br/><blockquote>OSSでhydra使うにはどうしたらいいでしょうか。自分でたてるしかないですか？</blockquote>自分もよくわからないからきいてみます！</div></div><div class="message" id="message-1568079332.061100"><div class="message__timestamp">2019-09-10<br/>10:35:32 +0900</div><div class="message__header">junji.hashimoto</div><div class="message__body">お疲れ様です<br/>type levelの関数をpropertyテストするにはどうすればいいでしょうか？<br/>doctestでkinds!やtype-specで個別の値はテストできるのですが。<br/>あとはtemplate haskellつかうとか？</div></div><div class="message" id="message-1568081220.062100"><div class="message__timestamp">2019-09-10<br/>11:07:00 +0900</div><div class="message__header">igrep</div><div class="message__body"><a href='https://hackage.haskell.org/package/should-not-typecheck'>https://hackage.haskell.org/package/should-not-typecheck</a> をうまく使えば... と思ったけど型レベルで生成する必要があるわけですよね... :gununu:<br/><br/>確かにTemplate Haskellを使って頑張って書くしか思いつかないですね... （新しいパッケージを作るチャンス！</div></div><div class="message" id="message-1568120533.062600"><div class="message__timestamp">2019-09-10<br/>22:02:13 +0900</div><div class="message__header">igrep</div><div class="message__body">改めて試して、<br/><pre>
foldr (\x z -&gt; x : z) [] [1 .. size]
</pre><br/>と、 <code>foldr</code> にした場合、<br/><code>Strict</code> をつけた場合最適化を有効にしてもスタックがあふれますね。大体理屈は <code>foldl</code> の場合と同じ、ですよね？<br/><code>foldr</code> に渡した関数 <code>(\x z -&gt; x : z)</code> は実質的に両辺をWHNFまで評価する <code>:</code> ということでしょうから。</div></div><div class="message" id="message-1568135882.062900"><div class="message__timestamp">2019-09-11<br/>02:18:02 +0900</div><div class="message__header">mizunashi-mana</div><div class="message__body"><code>foldr</code> の場合 <code>foldl</code> の時と事情が少々異なっていて，まず strict な <code>foldr</code> 相当のものは通常リストを reverse するなどしない限り，固定スタックの再帰にできません．それは，リストの後ろの要素から得られる値が分からないと前の要素に対しての計算ができないからです． <code>foldr</code> の場合，<br/><pre>
let k = \ x z -&gt; x : z in (1 `k` foldr k [] [2 .. n])
</pre><br/>みたいなものが最初にヒープに乗ることになります．そして，このサンクを評価する時 <code>k</code> が strict なので， <code>foldr k [] [2 .. n]</code> 部分の評価が始まりこの時スタックに値が退避されます．同様の操作がされることによってスタックがどんどん積み上がっていくことになりますが，ヒープの消費量はサンクが nursery にいる間に処理されるため抑えられます．<br/><br/><code>foldr'</code> は <code>foldl</code> を使って実装されているため，スタックを消費しない代わりにヒープを消費する実装になっています (これは前回のやつの原理からですね．今回はリストを生成するため，そちらの方にもヒープが割かれて顕著な差がないですが， <code>\ x z -&gt; x</code> とかだと差が出ると思います) なので，基本的に Strict 拡張下では <code>foldr</code> 系統は使ってはいけません．代わりに <code>foldl'</code> を使ってなんとかするか， lazy にするか， mutable の使用を検討すべきです．<br/><br/> <code>foldl</code> の例は一見 strict にしたらいけそうに見えるけど，実は中身が正格消費になっていないので heap を辿りながらスタックオーバーフローしてしまう例になっていて， strict にするだけではダメで中身も正格消費なものを使わないといけないということになります．ここらへんは， (`foldl` は有名な例ですが) 遅延評価での罠を知っていないと判断できないですし，逆に strict 拡張はこういう遅延評価の罠から生まれたもので， BangPattern と strictness flag を書くのがめんどい人用の拡張なので，背景を抑えると strict 拡張がどういう動作をするのかは見えやすいのでは？ というのがあのコメントで言いたいことですね</div></div><div class="message" id="message-1568137511.063100"><div class="message__timestamp">2019-09-11<br/>02:45:11 +0900</div><div class="message__header">mizunashi-mana</div><div class="message__body">なので基本的には、<br/>* foldr 系統は strict 下では使ってはいけない<br/>* foldl 系統は (strict 下でなくても) 正格消費版を使うこと<br/>みたいな感じですね</div></div><div class="message" id="message-1568157804.063500"><div class="message__timestamp">2019-09-11<br/>08:23:24 +0900</div><div class="message__header">igrep</div><div class="message__body">詳しい解説ありがとうございます！</div></div></div><div class="pager"><a href="../../html/C5666B6BB/69.html" class="pager__previous">Previous</a><a href="../../" class="pager__top">Top</a></div></body></html>