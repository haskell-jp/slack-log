[
    {
        "ts": "1558658628.093400",
        "text": "こんにちは。型クラスについて質問です。\nInt64をラップしたMyNumberという型をつくりました。\nこの型について、以下のような操作を定義したいのですが、どうもうまくいきません。そもそもこのようなことが可能なのか、可能であればどうしたらよいのか、ぜひ教えてください。\n\nやりたいこと：\n- 許可：MyNumber 同士の 足し算、引き算\n- 許可：MyNumber の整数倍\n- 許可：MyNumber 同士の大小比較\n- 不許可： MyNumber と整数の足し算、引き算\n- 不許可：MyNumberと 整数の大小比較\n- 不許可：MyNumber同士の掛け算。\n\n不許可については、コンパイル時にエラーとなるのが理想です。\n\nこんな感じで書き進めてみたものの、なにか根本的に違うような気がしています。\n作戦として、MyNumberをNumやOrdのインスタンスにして、不許可の操作を実装しない、もしくは何らかの方法でコンパイルエラーにする、ということを考えました。\n\n```haskell\nmodule Main where\n\nimport qualified <http://GHC.Int|GHC.Int> as GI (Int64)\n\nnewtype MyNumber = MyNumber { getNumber::GI.Int64} deriving(Eq, Show)\ninstance Num MyNumber where\n    (+) (MyNumber x) (MyNumber y) = MyNumber $ x + y\n    -- (*) _ _ = undefined -- not sure how to achieve \"MyNumber 150 * 2\"\n    -- fromInteger x = undefined -- to avoid comparison against Num\n\ninstance Ord MyNumber where\n    (&lt;=) (MyNumber x) (MyNumber y) = x &lt;= y\n\nmain :: IO ()\nmain = do\n    putStrLn $ (++) \"Allow MyNumber + MyNumber : \" $ show $ MyNumber 100 + MyNumber 200 == MyNumber 300\n    putStrLn $ (++) \"Allow MyNumber &gt; MyNumber : \" $ show $ MyNumber 330 &gt; MyNumber 100 -- not detected by compiler\n    putStrLn $ (++) \"Allow MyNumber * Integer :\" $ show $ (MyNumber 150) * 2  -- show can I do this?\n    putStrLn $ (++) \"Don't allow MyNumber &gt; Integger : \" $ show $ (MyNumber 330) &gt; 100 -- not detected by compiler\n    putStrLn $ (++) \"Don't allow MyNumber * MyNumber : \" $ show $ (MyNumber 330) * (MyNumber 100) -- not detected by compiler?\n```",
        "user": "U7GSVRQ6S",
        "type": "message"
    },
    {
        "ts": "1558659783.093500",
        "text": "```\n1. 許可：MyNumber 同士の 足し算、引き算\n2. 許可：MyNumber の整数倍\n3. 許可：MyNumber 同士の大小比較\n4. 不許可： MyNumber と整数の足し算、引き算\n5. 不許可：MyNumberと 整数の大小比較\n6. 不許可：MyNumber同士の掛け算。\n```\n便宜上ナンバリング。\n`Num a` 型クラスは型 `a` 同士の足し算 `(+)` と掛け算 `(*)` を両方定義する必要があるので、その方針( `Num` のインスタンスにする)で 1 と 6 を実現することはできないです。",
        "user": "U56L7EVNY",
        "type": "message"
    },
    {
        "ts": "1558659954.093700",
        "text": "まぁ方法としては\n(1) 足し算だけの型クラス `Add a` なんかを独自で定義する\n(2) 足し算を `Monoid a` 型クラスかなんかで定義する(演算子が `(&lt;&gt;)` に変わってしまうが)\n\nがあるかなぁ。。。",
        "user": "U56L7EVNY",
        "type": "message"
    },
    {
        "ts": "1558664779.094100",
        "text": "演算子の見かけにこだわりたいのであれば、カスタムPreludeを作って(+)や(-)を上書きすればいいでしょうね。\n（やり過ぎ感は否めませんが…）\n<https://haskell.e-bigmoon.com/posts/2018/05-23-extended-prelude.html>",
        "user": "U4LGTMTMK",
        "type": "message"
    },
    {
        "ts": "1558666437.094500",
        "text": "<http://hackage.haskell.org/package/vector-space> 演算子は変わりますがvector-space を使ってみてはどうでしょうか？まさに加算とスカラー倍のためのインターフェイスです",
        "user": "U4KUNQF9N",
        "type": "message"
    },
    {
        "ts": "1558693882.000400",
        "text": "Numに全部ぶちこんだのはHaskellの初期設計過ち四天王に入りそうで入らなさそう",
        "user": "U57CUMWQ6",
        "type": "message"
    },
    {
        "ts": "1558758303.000700",
        "text": "Numeric Prelude ってどうなんですか？",
        "user": "U6JPU2DD2",
        "type": "message"
    },
    {
        "ts": "1558963421.001100",
        "text": "<@UJPKD2R2P> has joined the channel",
        "user": "UJPKD2R2P",
        "type": "message"
    },
    {
        "ts": "1559009020.001400",
        "text": "<@UJQ0WEJG2> has joined the channel",
        "user": "UJQ0WEJG2",
        "type": "message"
    },
    {
        "ts": "1559011117.003200",
        "text": "Haskellで｢送られてきたメールアドレスの少なくともドメインがメールサーバとして成立しているかどうか(DNSでMXもしくはAもしくはAAAAを持つか)｣どうか調べる必要があって,汎用性があるからOSSにしようかと思ってるのですが既出なら教えてください\n後DNS周りで楽に取れるやつが欲しい…パフォーマンス気にしなければ <http://hackage.haskell.org/package/resolv-0.1.1.2/docs/Network-DNS.html> で良いんですが…いや別に気にしなくても良いのか",
        "user": "U57CUMWQ6",
        "type": "message"
    },
    {
        "ts": "1559011160.003300",
        "text": "いやパフォーマンスの問題ではなく使い勝手の問題ですねこれは",
        "user": "U57CUMWQ6",
        "type": "message"
    },
    {
        "ts": "1559017840.006300",
        "text": "&gt; which is why we recommend using `try` rather than `catch` for ordinary exception recovery.\n&gt; <https://www.stackage.org/haddock/lts-13.23/base-4.12.0.0/Control-Exception.html#g:3>\nとあるので `try` の方を使うかという気持ちなんですが、複数の型の例外を捕捉したいとき何かイディオムあるんですかね？\nつまり `catch` ならこう ↓ なるケース（ `catches` を使ってもいい）\n```\nprint $ (head []) `div` (0 :: Int)\n  `catch` (\\e -&gt; putStrLn $ \"arith \" &lt;&gt; displayException (e :: ArithException))\n  `catch` (\\e -&gt; putStrLn $ \"some \" &lt;&gt; displayException (e :: SomeException))\n```\n`try` でベタで書くとこうなる\n```\ndo\n  v &lt;- try $ do\n    v &lt;- try $ print $ (head []) `div` (0 :: Int)\n    case v of\n      Right _ -&gt; pure ()\n      Left e -&gt; putStrLn $ \"arith \" &lt;&gt; displayException (e :: ArithException)\n  case v of\n    Right _ -&gt; pure ()\n    Left e -&gt; putStrLn $ \"some \" &lt;&gt; displayException (e :: SomeException)\n```\n<https://wandbox.org/permlink/FSlRioZ1EPWcWXjf>",
        "user": "U4L0B71L1",
        "type": "message"
    },
    {
        "ts": "1559018427.006500",
        "text": "dns: DNS library in Haskell - <http://hackage.haskell.org/package/dns> もありますが、使い勝手は似たようなものっぽいですね",
        "user": "U7155GPR9",
        "type": "message"
    },
    {
        "ts": "1559019191.006800",
        "text": "口頭での議論のとおりですが、簡潔に書くなら諦めて `catches` するしかなさそうな気がします。\n\n&gt; which is why we recommend using `try` rather than `catch` for ordinary exception recovery.\n\nの部分ですが、例外処理が十分に軽い処理（非同期例外がmaskされてもすぐに終わる）であれば問題ないでしょうし。",
        "user": "U4LGTMTMK",
        "type": "message"
    },
    {
        "ts": "1559021399.007000",
        "text": "1つのアプリーケーション内なら、直和型を宣言して適宜ラップするとか",
        "user": "U56L7EVNY",
        "type": "message"
    },
    {
        "ts": "1559024673.007300",
        "text": "実際に `try` 関数が `catch` を使ってやっているように、直和型でラップするだけ、というのが正解なんでしょうね\n参考: <https://hackage.haskell.org/package/base-4.12.0.0/docs/src/Control.Exception.Base.html#try>",
        "user": "U4LGTMTMK",
        "type": "message"
    },
    {
        "ts": "1559024850.007500",
        "text": "こんなのはどうでしょう？\n<https://gist.github.com/mizunashi-mana/c2d6b87206e9c1f43046f84b135fd445>\n\nやってることは大体 `catches` と同じです",
        "user": "U57D08Z9U",
        "type": "message"
    },
    {
        "ts": "1559026004.007900",
        "text": "なるほでぃうす",
        "user": "U4L0B71L1",
        "type": "message"
    },
    {
        "ts": "1559118620.008400",
        "text": "<@UJRDL35U3> has joined the channel",
        "user": "UJRDL35U3",
        "type": "message"
    },
    {
        "ts": "1559198752.000200",
        "text": "みなさんありがとうございました。vector-spaceは良さげですね！直接は大小比較をサポートしていない（ベクトルだから当たり前ですが）ので、その部分を手当してあげる必要はありそうです。",
        "user": "U7GSVRQ6S",
        "type": "message"
    }
]