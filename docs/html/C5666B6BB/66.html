<!DOCTYPE html><html><head><meta charset="utf-8"><title>haskell-jp / questions #66</title><link rel="stylesheet" href="../../messages.css" type="text/css" media="screen"></head><body><h1>haskell-jp / questions #66</h1><div class="pager"><a href="../../html/C5666B6BB/65.html" class="pager__previous">Previous</a><a href="../../" class="pager__top">Top</a></div><div class="message_list"><div class="message" id="message-1564031792.030700"><div class="message__timestamp">2019-07-25<br/>14:16:32 +0900</div><div class="message__header">notogawa</div><div class="message__body">型の上で計算するだけで終わりにしていいのならそのように大概のことはできるんですが，今やろうとしているのは証明であり，値レベルで云々する(≒singletonsとかでゴニョゴニョする)必要があります．たとえば，<br/><pre>
sNatToNat' :: Sing n -&gt; Sing (ConvertNat n)
sNat'ToNat :: Sing (ConvertNat n) -&gt; Sing n
</pre><br/>みたいな部品が必要になると思いますが，コレを定義してやろうとすると正攻法では詰むと思います．</div></div><div class="message" id="message-1564183015.031300"><div class="message__timestamp">2019-07-27<br/>08:16:55 +0900</div><div class="message__header">shunkichi.sato</div><div class="message__body">@shunkichi.sato has joined the channel</div></div><div class="message" id="message-1564196017.031600"><div class="message__timestamp">2019-07-27<br/>11:53:37 +0900</div><div class="message__header">woodsondelhia88</div><div class="message__body">@woodsondelhia88 has joined the channel</div></div><div class="message" id="message-1564202852.031900"><div class="message__timestamp">2019-07-27<br/>13:47:32 +0900</div><div class="message__header">ogahiro0720</div><div class="message__body">@ogahiro0720 has joined the channel</div></div><div class="message" id="message-1564202948.032200"><div class="message__timestamp">2019-07-27<br/>13:49:08 +0900</div><div class="message__header">yama_aoi</div><div class="message__body">@yama_aoi has joined the channel</div></div><div class="message" id="message-1564202962.032500"><div class="message__timestamp">2019-07-27<br/>13:49:22 +0900</div><div class="message__header">cj.bc-sd</div><div class="message__body">@cj.bc-sd has joined the channel</div></div><div class="message" id="message-1564203079.032800"><div class="message__timestamp">2019-07-27<br/>13:51:19 +0900</div><div class="message__header">wuthering1118</div><div class="message__body">@wuthering1118 has joined the channel</div></div><div class="message" id="message-1564207277.033100"><div class="message__timestamp">2019-07-27<br/>15:01:17 +0900</div><div class="message__header">k.kent8192</div><div class="message__body">@k.kent8192 has joined the channel</div></div><div class="message" id="message-1564208415.033400"><div class="message__timestamp">2019-07-27<br/>15:20:15 +0900</div><div class="message__header">drmaruyama</div><div class="message__body">@drmaruyama has joined the channel</div></div><div class="message" id="message-1564213476.035800"><div class="message__timestamp">2019-07-27<br/>16:44:36 +0900</div><div class="message__header">lotz</div><div class="message__body">質問です :raising_hand:<br/>cassavaを使ってCSV をパースした結果をextensibleのRecordにしようとしてるのですが<br/><pre>
readCSV :: WrapForall Csv.FromField Vector xs =&gt; FilePath -&gt; IO (RecordOf Vector xs)
readCSV filepath = do
    csvBs &lt;- BL.readFile filepath
    case Csv.decode Csv.HasHeader csvBs :: Either String (Vector (Record xs)) of
        Left reason -&gt; error reason
        Right vs -&gt; undefined
</pre><br/>以下のような感じでカインドが合わないと怒られてしまいます…<br/><pre>
....hs:36:82: error:
    • Expected kind '[membership-0:Type.Membership.Internal.Assoc
                        k0 *]',
        but 'xs' has kind '[*]'
    • In the second argument of 'RecordOf', namely 'xs'
      In the first argument of 'IO', namely '(RecordOf Vector xs)'
      In the type signature:
        readCSV :: WrapForall Csv.FromField Vector xs =&gt;
                   FilePath -&gt; IO (RecordOf Vector xs)
   |
36 | readCSV :: WrapForall Csv.FromField Vector xs =&gt; FilePath -&gt; IO (RecordOf Vector xs)
   |   
</pre><br/>どなたか対処方法を教えていただけませんでしょうか :bow:</div></div><div class="message" id="message-1564213875.036200"><div class="message__timestamp">2019-07-27<br/>16:51:15 +0900</div><div class="message__header">lotz</div><div class="message__body">@igrep<br/><pre>
{-# LANGUAGE PolyKinds #-}
</pre><br/>試したけどできず…</div></div><div class="message" id="message-1564213935.036400"><div class="message__timestamp">2019-07-27<br/>16:52:15 +0900</div><div class="message__header">fumieval</div><div class="message__body"><code>WrapForall Csv.FromField Vector</code>がxsの種を <code>[*]</code> に固定する原因となっています。 <code>Forall (KeyValue KnownSymbol (Instance1 Csv.FromField Vector)) xs</code>としてはどうでしょう</div></div><div class="message" id="message-1564214375.037100"><div class="message__timestamp">2019-07-27<br/>16:59:35 +0900</div><div class="message__header">lotz</div><div class="message__body">@fumieval ありがとうございます！今度は以下のようなエラーメッセージになりました:bow:<br/><pre>
....hs:30:125: error:
    • Expected kind '[membership-0:Type.Membership.Internal.Assoc
                        * *]',
        but 'xs' has kind '[membership-0:Type.Membership.Internal.Assoc
                              ghc-prim-0.5.3:GHC.Types.Symbol *]'
    • In the first argument of 'DataFrame', namely 'xs'
      In the first argument of 'IO', namely '(DataFrame xs)'
      In the type signature:
        readCSV :: Forall (KeyValue KnownSymbol (Instance1 Csv.FromField Vector)) xs =&gt;
                   FilePath -&gt; IO (DataFrame xs)
</pre></div></div><div class="message" id="message-1564214540.037300"><div class="message__timestamp">2019-07-27<br/>17:02:20 +0900</div><div class="message__header">fumieval</div><div class="message__body">今度こそPolyKinds事案に見えますね… :thinking_face:</div></div><div class="message" id="message-1564215334.037500"><div class="message__timestamp">2019-07-27<br/>17:15:34 +0900</div><div class="message__header">lotz</div><div class="message__body">PolyKindsを入れたらエラーが変わりました…！ :pray:<br/><pre>
readCSV :: Forall (KeyValue KnownSymbol (Instance1 Csv.FromField Vector)) xs =&gt; FilePath -&gt; IO (RecordOf Vector xs)
readCSV filepath = do
    csvBs &lt;- BL.readFile filepath
    case Csv.decode Csv.HasHeader csvBs :: Either String (Vector (Record xs)) of
        Left reason -&gt; error reason
        Right vs -&gt; undefined
</pre><br/><br/><pre>
...hs:52:10: error:
    • Could not deduce (Forall
                          (Instance1 Csv.FromField (Field Identity)) xs1)
        arising from a use of 'Csv.decode'
      from the context: Forall
                          (KeyValue KnownSymbol (Instance1 Csv.FromField Vector)) xs
        bound by the type signature for:
                   readCSV :: forall (xs :: [membership-0:Type.Membership.Internal.Assoc
                                               ghc-prim-0.5.3:GHC.Types.Symbol *]).
                              Forall
                                (KeyValue KnownSymbol (Instance1 Csv.FromField Vector)) xs =&gt;
                              FilePath -&gt; IO (RecordOf Vector xs)
        at src/Data/Frame/Reader.hs:49:1-115
    • In the expression:
          Csv.decode Csv.HasHeader csvBs ::
            Either String (Vector (Record xs))
      In a stmt of a 'do' block:
        case  Csv.decode Csv.HasHeader csvBs ::
                Either String (Vector (Record xs))
        of
          Left reason -&gt; error reason
          Right vs -&gt; undefined
      In the expression:
        do csvBs &lt;- BL.readFile filepath
           case  Csv.decode Csv.HasHeader csvBs ::
                   Either String (Vector (Record xs))
           of
             Left reason -&gt; error reason
             Right vs -&gt; undefined
   |
52 |     case Csv.decode Csv.HasHeader csvBs :: Either String (Vector (Record xs)) of
   |          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
</pre></div></div><div class="message" id="message-1564215360.037700"><div class="message__timestamp">2019-07-27<br/>17:16:00 +0900</div><div class="message__header">lotz</div><div class="message__body">インスタンスの導出が出来てない… :thinking_face:</div></div><div class="message" id="message-1564215435.037900"><div class="message__timestamp">2019-07-27<br/>17:17:15 +0900</div><div class="message__header">fumieval</div><div class="message__body">ScopedTypeVariablesとRankNTypesでxsを束縛していないような雰囲気…？</div></div><div class="message" id="message-1564215645.038100"><div class="message__timestamp">2019-07-27<br/>17:20:45 +0900</div><div class="message__header">lotz</div><div class="message__body">あ、LANGUAGEも含めて貼りますね :bow:</div></div><div class="message" id="message-1564215690.038300"><div class="message__timestamp">2019-07-27<br/>17:21:30 +0900</div><div class="message__header">lotz</div><div class="message__body"><pre>
{-# LANGUAGE DataKinds #-}
{-# LANGUAGE FlexibleContexts #-}
{-# LANGUAGE PolyKinds #-}
{-# LANGUAGE RankNTypes #-}
{-# LANGUAGE ScopedTypeVariables #-}
{-# LANGUAGE TypeOperators #-}

module Data.Frame.Reader where

import qualified Data.ByteString.Lazy as BL

import qualified Data.Csv as Csv
import Data.Extensible 
import Data.Vector (Vector)

readCSV :: forall xs. Forall (KeyValue KnownSymbol (Instance1 Csv.FromField Vector)) xs =&gt; FilePath -&gt; IO (RecordOf Vector xs)
readCSV filepath = do
    csvBs &lt;- BL.readFile filepath
    case Csv.decode Csv.HasHeader csvBs :: Either String (Vector (Record xs)) of
        Left reason -&gt; error reason
        Right vs -&gt; undefined
</pre><br/><br/><pre>
.hs:19:10: error:
    • Could not deduce (Forall
                          (Instance1 Csv.FromField (Field Identity)) xs)
        arising from a use of 'Csv.decode'
      from the context: Forall
                          (KeyValue KnownSymbol (Instance1 Csv.FromField Vector)) xs
        bound by the type signature for:
                   readCSV :: forall (xs :: [Assoc
                                               ghc-prim-0.5.3:GHC.Types.Symbol *]).
                              Forall
                                (KeyValue KnownSymbol (Instance1 Csv.FromField Vector)) xs =&gt;
                              FilePath -&gt; IO (RecordOf Vector xs)
        at src/Data/Frame/Reader.hs:16:1-126
    • In the expression:
          Csv.decode Csv.HasHeader csvBs ::
            Either String (Vector (Record xs))
      In a stmt of a 'do' block:
        case  Csv.decode Csv.HasHeader csvBs ::
                Either String (Vector (Record xs))
        of
          Left reason -&gt; error reason
          Right vs -&gt; undefined
      In the expression:
        do csvBs &lt;- BL.readFile filepath
           case  Csv.decode Csv.HasHeader csvBs ::
                   Either String (Vector (Record xs))
           of
             Left reason -&gt; error reason
             Right vs -&gt; undefined
</pre></div></div><div class="message" id="message-1564215718.038500"><div class="message__timestamp">2019-07-27<br/>17:21:58 +0900</div><div class="message__header">lotz</div><div class="message__body">現状このような感じです！</div></div><div class="message" id="message-1564216168.038700"><div class="message__timestamp">2019-07-27<br/>17:29:28 +0900</div><div class="message__header">fumieval</div><div class="message__body">ああ、無名のレコードと互換性がないと言うだけのことでした！こんな感じにすると通ります <pre>
readCSV :: forall xs. Forall (KeyValue KnownSymbol (Instance1 Csv.FromField Identity)) xs =&gt; FilePath -&gt; IO (RecordOf Vector xs)
readCSV filepath = do
    csvBs &lt;- BL.readFile filepath
    case Csv.decodeByName csvBs :: Either String (Csv.Header, Vector (Record xs)) of
        Left reason -&gt; error reason
        Right vs -&gt; undefined
</pre></div></div><div class="message" id="message-1564216303.038900"><div class="message__timestamp">2019-07-27<br/>17:31:43 +0900</div><div class="message__header">lotz</div><div class="message__body">通りました!!<br/>そうか、インスタンスにするべきは Vector じゃなくて Identity とだったんですね。<br/>いただいたコードを参考にしながら勉強します :pray:<br/>ありがとうございました :bow:</div></div><div class="message" id="message-1564216854.039100"><div class="message__timestamp">2019-07-27<br/>17:40:54 +0900</div><div class="message__header">lotz</div><div class="message__body">なるほど！<br/>FromRecord と FromNamedRecord の差ですか…！<br/><a href='https://gyazo.com/59a3a33419ebec83181cf24c6d42c972'>https://gyazo.com/59a3a33419ebec83181cf24c6d42c972</a><br/><br/>今パースしたいCSV、ヘッダーついてないんですよね… :sweat_smile:</div></div><div class="message" id="message-1564216965.039400"><div class="message__timestamp">2019-07-27<br/>17:42:45 +0900</div><div class="message__header">lotz</div><div class="message__body">CSVのByteStringの頭に無理やりヘッダー行追加するか :thinking_face:</div></div><div class="message" id="message-1564218058.039600"><div class="message__timestamp">2019-07-27<br/>18:00:58 +0900</div><div class="message__header">fumieval</div><div class="message__body">なるほど…その場合こんな感じですかね　```readCSV :: forall xs. (Forall (Instance1 Csv.FromField (Field Identity)) xs) =&gt; FilePath -&gt; IO (RecordOf Vector xs)<br/>readCSV filepath = do<br/>    csvBs &lt;- BL.readFile filepath<br/>    case Csv.decode Csv.HasHeader csvBs :: Either String (Vector (Record xs)) of<br/>        Left reason -&gt; error reason<br/>        Right vs -&gt; undefined<br/>```</div></div><div class="message" id="message-1564218142.039800"><div class="message__timestamp">2019-07-27<br/>18:02:22 +0900</div><div class="message__header">lotz</div><div class="message__body">すごい！！出来るんですね！！<br/>型クラス制約の定義読んで勉強します :sob: :arigatougozaimasu:</div></div><div class="message" id="message-1564218159.040000"><div class="message__timestamp">2019-07-27<br/>18:02:39 +0900</div><div class="message__header">lotz</div><div class="message__body">（手元でもコンパイル通りました!! :bow: ）</div></div><div class="message" id="message-1564218172.040300"><div class="message__timestamp">2019-07-27<br/>18:02:52 +0900</div><div class="message__header">gan13027830</div><div class="message__body">@gan13027830 has joined the channel</div></div><div class="message" id="message-1564274912.041100"><div class="message__timestamp">2019-07-28<br/>09:48:32 +0900</div><div class="message__header">nnhixi</div><div class="message__body">@nnhixi has joined the channel</div></div><div class="message" id="message-1564303895.041500"><div class="message__timestamp">2019-07-28<br/>17:51:35 +0900</div><div class="message__header">alliswellthatendswell</div><div class="message__body">@alliswellthatendswell has joined the channel</div></div><div class="message" id="message-1564340963.043600"><div class="message__timestamp">2019-07-29<br/>04:09:23 +0900</div><div class="message__header">kakkun61</div><div class="message__body">定作用形についてブログ書くかと書いてたら分からなくなってきました<br/><pre>
fact3 :: Int -&gt; Integer
fact3 = (map fact' [0..] !!)
  where
    fact' 0 = 1
    fact' n = fromIntegral n * fact' (n-1)
</pre><br/><code>fact3</code> はなんで CAF なんでしょう？ <code>map</code> は定数でもなければコンビネーターでもない変数なような……<br/><a href='https://kakkun61.hatenablog.com/entry/2019/07/29/%E9%96%A2%E6%95%B0%E3%81%AE%E3%83%A1%E3%83%A2%E5%8C%96'>https://kakkun61.hatenablog.com/entry/2019/07/29/%E9%96%A2%E6%95%B0%E3%81%AE%E3%83%A1%E3%83%A2%E5%8C%96</a></div></div><div class="message" id="message-1564380382.044200"><div class="message__timestamp">2019-07-29<br/>15:06:22 +0900</div><div class="message__header">dusty.trombone</div><div class="message__body">@dusty.trombone has joined the channel</div></div><div class="message" id="message-1564381544.044400"><div class="message__timestamp">2019-07-29<br/>15:25:44 +0900</div><div class="message__header">igrep</div><div class="message__body">CAFかどうかと関係あるかわからない、かつ自信がないので元記事のコメントではなくここで。<br/>ちょうど途中まで読んでたこの話 <a href='https://treszkai.github.io/2019/07/13/haskell-eval'>https://treszkai.github.io/2019/07/13/haskell-eval</a> がすごく関係ありそうな気がします。</div></div><div class="message" id="message-1564385022.044700"><div class="message__timestamp">2019-07-29<br/>16:23:42 +0900</div><div class="message__header">mizunashi-mana</div><div class="message__body">スーパーコンビネータは，一般の文脈では確かにコンビネータで部分項がスーパーコンビネータであるものを指しますが， CAF の文脈では，<br/>• ラムダ式でない<br/>• ローカル関数が全てグローバルに出しても問題ない定義になっている<br/>だと思うのが良いと思います．厳密には，<br/><a href='https://gitlab.haskell.org/ghc/ghc/wikis/commentary/rts/storage/gc/CAFs'>https://gitlab.haskell.org/ghc/ghc/wikis/commentary/rts/storage/gc/CAFs</a><br/>に書いてある通り，要はサンクとなる static closure のことを指しています．<br/><br/>ところでメモ化の要因は，確かに <code>fact3</code> が CAF であることもありますが，一番の要因として， Core では関数適用の引数は let を通して変数に束縛されることになるので，実際にはこのプログラムは<br/><pre>
fact3 = (!!) fact3'
   where
       fact3' = map fact' l
       l = [0..]
       fact' 0 = 1
       fact' n = ...
</pre><br/>みたいなものと等価になります (厳密にはこれも怪しいですが) ．で， fact3' が CAF となるからというのが大きいですね (なお実際 GHC 8.6.5 では fact3' が floating out されていて， fact3 自体は最終的に eta expand されて <code>fact3 = \x -&gt; (!!) fact3' x</code> という形になっていました)</div></div><div class="message" id="message-1564412515.047300"><div class="message__timestamp">2019-07-30<br/>00:01:55 +0900</div><div class="message__header">yharuhi39</div><div class="message__body">はっきりと質問というわけでもないですがrandomよりは質問よりなのでこちらで。  ghc でアノテーション(カスタムアノテーションも含む)が削除されるタイミングっていつなんですかね？ Cmmの段階まで保持されるんですかね？</div></div><div class="message" id="message-1564414903.047400"><div class="message__timestamp">2019-07-30<br/>00:41:43 +0900</div><div class="message__header">yharuhi39</div><div class="message__body">あ、これ色々質問が間違ってるや。 そもそも アノテーションではなくプラグマだし。 一般のプラグマに関しては言及不可なやつでしたね。。。すみません。 質問の意図としては。 たとえばLiquid Haskell を用いて ある評価木の一部（またはすべて）の範囲で値が一定の範囲収まるといった情報を知った上でレジスタの配置とかそういった最適化（？）みたいなのができるのかなと思い質問しました。</div></div><div class="message" id="message-1564453083.047800"><div class="message__timestamp">2019-07-30<br/>11:18:03 +0900</div><div class="message__header">igrep</div><div class="message__body">これをめっちゃざっくりJSで例えてみました。<br/><a href='https://gist.github.com/igrep/afcf4789d88da3b3995308e2e12c59df'>https://gist.github.com/igrep/afcf4789d88da3b3995308e2e12c59df</a><br/>要するに、メモ化に使うリストをラムダ式の中で定義するか、外で定義してキャッシュするか、という違いですよね？</div></div><div class="message" id="message-1564453085.048000"><div class="message__timestamp">2019-07-30<br/>11:18:05 +0900</div><div class="message__header">igrep</div><div class="message__body"></div></div><div class="message" id="message-1564453849.049000"><div class="message__timestamp">2019-07-30<br/>11:30:49 +0900</div><div class="message__header">igrep</div><div class="message__body">:point_up: スレッドへの返信でGistを張っただけなのにこっちにも出てくるのか... 驚かせてたらすみません。 :bow:</div></div><div class="message" id="message-1564458305.049200"><div class="message__timestamp">2019-07-30<br/>12:45:05 +0900</div><div class="message__header">kakkun61</div><div class="message__body">違うような<br/>（意味論上は同じにもかかわらず）中で定義しても、形によってキャッシュされたりされなかったりという違いかと<br/>理論上は参照透過だから一度計算したものは全部保存してもいいんだけど、現実はメモリーの制約があるから基本的には捨てていて、ただ CAF の形式のときは保存している、という話だと認識している</div></div><div class="message" id="message-1564458874.049400"><div class="message__timestamp">2019-07-30<br/>12:54:34 +0900</div><div class="message__header">igrep</div><div class="message__body">すみません、付け加えた言葉がまずかった。「JavaScriptで強引に例えるならあたかも外で定義してキャッシュするかのように振る舞う（Haskellの場合実際には、最初に呼ばれたときにキャッシュされる）」みたいなことを言いたかった。</div></div><div class="message" id="message-1564459211.049600"><div class="message__timestamp">2019-07-30<br/>13:00:11 +0900</div><div class="message__header">igrep</div><div class="message__body">外で定義して、っていうか <code>fact3</code> を定義したときに、というべきか。</div></div><div class="message" id="message-1564459462.049800"><div class="message__timestamp">2019-07-30<br/>13:04:22 +0900</div><div class="message__header">igrep</div><div class="message__body">少し修正して実態に近づけてみた</div></div><div class="message" id="message-1564460182.050100"><div class="message__timestamp">2019-07-30<br/>13:16:22 +0900</div><div class="message__header">kakkun61</div><div class="message__body">13章が読むリスト積まれた <a href='https://www.microsoft.com/en-us/research/publication/the-implementation-of-functional-programming-languages/'>https://www.microsoft.com/en-us/research/publication/the-implementation-of-functional-programming-languages/</a></div></div><div class="message" id="message-1564492113.050600"><div class="message__timestamp">2019-07-30<br/>22:08:33 +0900</div><div class="message__header">ULW9GKNQ0</div><div class="message__body">@ULW9GKNQ0 has joined the channel</div></div><div class="message" id="message-1564495379.050800"><div class="message__timestamp">2019-07-30<br/>23:02:59 +0900</div><div class="message__header">cutsea110</div><div class="message__body">この辺の分かりやすい説明はHaskell High Perfomance Programmingのchaper 1に書いてあります.<br/>blog記事にも出てたので持っている前提で書きますがp8です.<br/><br/>fib_memとfib_mem_argとを比較して<br/>「map fib [0..]は引数に依存せずメモ化することが可能だけれど関数に引数を適用すると暗黙のうちに以前の関数適用からの式へのポインタを持つことができない新しい式を作ってしまうからです」<br/>つまりwhereで定義しているローカル関数fibはfib_memにぶら下がっているのに対してfib_mem_argの方はfib_mem_arg n(というnに適用した式)に対してローカル関数fibがぶらさがっている.つまりnが適用される都度別のfibになるとみなすとよい(のかな).<br/>結果としてmap fib [0..]のfibは毎度違ってしまう.</div></div><div class="message" id="message-1564496016.051100"><div class="message__timestamp">2019-07-30<br/>23:13:36 +0900</div><div class="message__header">cutsea110</div><div class="message__body">CAFsがポイントになるのは結局トップレベルにリフトできるからで,トップレベルから掴んでいられるから評価が進めばサンクが潰れて値に置き換わって再利用できるということで,fib_mem_argのようにトップレベルに着地できうに宙に浮いてしまってたら一度評価したものも失われるのでメモ化されない.<br/>逆に言えばメモリを解放する手段がないわけだからメモリリーク(と言っていいのかどうかいまだに私は迷うのだけど)している.<br/>なので速度は出るけどメモリは食い続ける一方でGCできないはず.<br/>というわけで,やっぱりtabulationするのが一番いいんじゃないかと思うけどそれはまた別の話か.</div></div></div><div class="pager"><a href="../../html/C5666B6BB/65.html" class="pager__previous">Previous</a><a href="../../" class="pager__top">Top</a></div></body></html>