[
    {
        "ts": "1564557369.063600",
        "text": "一応補足ですが，現在の GHC では full laziness が入るタイミングが調整されていて，\n```\nfactMemo :: Int -&gt; Integer\nfactMemo = (map fact' [0..] !!)\n  where\n    fact' 0 = 1\n    fact' n = fromIntegral n * factMemo (n - 1)\n\nfact :: Int -&gt; Integer\nfact x = map fact' [0..] !! x\n  where\n    fact' 0 = 1\n    fact' n = fromIntegral n * fact (n - 1)\n```\nはどちらも `fact'` は外に出されます．このため， `map fact' [0..]` も CAF として扱われます． GHCi のバイトコード出すパスでは， core 2 core のパスが少し簡略化されてるので， full laziness が真面目に入ってないだけだと思いますね．\n\nなので，スーパーコンビネータかどうかは指標の一つではありますが，実際にはどう最適化が入るかによって CAF になるかはかなり左右されます",
        "user": "U57D08Z9U",
        "type": "message"
    },
    {
        "ts": "1564577136.064100",
        "text": "<@ULXKBEPR6> has joined the channel",
        "user": "ULXKBEPR6",
        "type": "message"
    },
    {
        "ts": "1564580251.064400",
        "text": "<@ULZRSHT1C> has joined the channel",
        "user": "ULZRSHT1C",
        "type": "message"
    },
    {
        "ts": "1564587041.064600",
        "text": "Liquid Haskell について言えば、`{-@ @-}` は GHC にとっては単なるコメントなのでもっと早い段階で消えそう……な気がしますが根拠はないです。",
        "user": "U4M4XHKB8",
        "type": "message"
    },
    {
        "ts": "1564590486.066800",
        "text": "確かに あれはただのコメントでプラグまですらなかったですね:persevere: 雰囲気的に(?) 型が削除される以前に消されてそうですね…",
        "user": "U9XHWQX7Z",
        "type": "message"
    },
    {
        "ts": "1564617187.071600",
        "text": "はい、”外に出す”ということをコンパイラがやるかどうかはまた別ですもんね. &gt; 真面目に入ってない\nただ後者のfact’がxを巻き込まずに外に出せるとすると意味論的に変わっちゃわないのかなという疑問が湧いてきたんだけど…",
        "user": "U4MMHDSNT",
        "type": "message"
    },
    {
        "ts": "1564632506.072200",
        "text": "<@ULYJX1PU5> has joined the channel",
        "user": "ULYJX1PU5",
        "type": "message"
    },
    {
        "ts": "1564646022.072500",
        "text": "<@ULMAZ8XQB> has joined the channel",
        "user": "ULMAZ8XQB",
        "type": "message"
    },
    {
        "ts": "1564668616.072700",
        "text": "GHC の最適化は通常 equational reasoning に基づいて行われてるので，その意味で意味論が変わるものはあまりないと思いますね (Haskell はちゃんとした formal semantics はないので，ある程度簡略化したラムダ計算の体系の元でということにはなりますが)．\n\nCAF を static closure にして欲しくないという話であれば， <https://stackoverflow.com/questions/6090932/how-to-make-a-caf-not-a-caf-in-haskell/6091166#6091166> みたいな話があって，今回の場合 `map fact' [0..]` の部分を切り出して， `fact` の引数を受け取るようにして `NOINLINE` すればいいと思いますね．と，思ったんですが，\n```\nfact2 :: Int -&gt; Integer\nfact2 x = factMemo2 x fact' !! x\n  where\n    fact' 0 = 1\n    fact' n = fromIntegral n * fact' (n - 1)\n\nfactMemo2 :: Int -&gt; (Int -&gt; Integer) -&gt; [Integer]\nfactMemo2 _ f = map f [0..]\n{-# NOINLINE factMemo2 #-}\n```\nみたいなのだと， w/w が入って `factMemo2` の参照が worker の方に書き換えられてしまいますね… 一応次の形式にすると `-O` ならいい感じに CAF 化を妨害できるみたいです:\n```\nfact2 :: Int -&gt; Integer\nfact2 x = factMemo2 (x &lt; 0) fact' !! x\n  where\n    fact' 0 = 1\n    fact' n = fromIntegral n * fact' (n - 1)\n\nfactMemo2 :: Bool -&gt; (Int -&gt; Integer) -&gt; [Integer]\nfactMemo2 !_ f = map f [0..]\n{-# NOINLINE factMemo2 #-}\n```",
        "user": "U57D08Z9U",
        "type": "message"
    }
]