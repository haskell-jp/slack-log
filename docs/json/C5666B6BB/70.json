[
    {
        "ts": "1567938986.050900",
        "text": "確かに、言われてみればなんの区切りもなく匿名関数が始まっているようで、普通の式とどうやって見分けるんだろうという感じがしますね...",
        "user": "U4LGTMTMK",
        "type": "message"
    },
    {
        "ts": "1567939338.051200",
        "text": "たしかに。\n括弧にくるんでるからって安心してましたけどたしかにexprASTも括弧にくるまれてるから安心できなかった",
        "user": "UMKGDJ2RZ",
        "type": "message"
    },
    {
        "ts": "1567943436.051800",
        "text": "なるほど，不思議な動作ですね… 確かに Strict の時のみ stack overflow になりました… ちょっとそれは想定してませんでしたね…",
        "user": "U57D08Z9U",
        "type": "message"
    },
    {
        "ts": "1567945497.052100",
        "text": "あ，いいのか．過去の自分に追いつけてなかった．\nまず， Strict をつけようがつけまいが，\n```\nfoldl (\\ z x -&gt; x : z) [] [1..n]\n```\nは\n```\nlet k = \\ z x -&gt; x : z in (([] `k` 1) ... `k` n)\n```\nみたいなものを生成することになります．でそれぞれの括弧の中身はサンクのままヒープにのって評価されるのを待つことになります．\n\n`evaluate` でそれが WHNF まで評価されることになりますが，まず一番外側の評価\n```\n(… `k` n) =&gt; n : ...\n```\nが実行されることになります． Strict をつけない場合 `...` は評価されませんが， Strict をつける場合 `...` の部分が評価されることになり，さらにその評価のために `k (…) (n - 1)` の評価が走りという感じで，どんどんスタックに退避された値が積み上がっていきスタックオーバーフローになります．\n\nなお，ちゃんと `foldl'` を使った場合，ヒープに積み上がるはずだったサンクが先に消化されながらループが回るため，どちらの場合もスタックオーバーフローは起きません",
        "user": "U57D08Z9U",
        "type": "message"
    },
    {
        "ts": "1567945696.052800",
        "text": "あ，だから Strict 拡張のみで stack overflow する例なんですね．前のコメントは間違いですね．失礼しました",
        "user": "U57D08Z9U",
        "type": "message"
    },
    {
        "ts": "1567955856.055000",
        "text": "初めて template Haskell を書いたのですがビルド時に 10GB 以上消費されるようになってしまいました…… :cry:\nコードレビューしてほしいです\n<https://github.com/kakkun61/tuple/pull/1>",
        "user": "U4L0B71L1",
        "type": "message"
    },
    {
        "ts": "1567962365.055200",
        "text": "Ty*等構文木のコンストラクタを直で使うとバージョンアップで壊れやすいものができあがるので，可能な限りQuasi-quotationを使って書いておいたほうが幸せになると思います．",
        "user": "U5G2BCVBN",
        "type": "message"
    },
    {
        "ts": "1567963552.055400",
        "text": "なるほど！",
        "user": "U4L0B71L1",
        "type": "message"
    },
    {
        "ts": "1567976577.055600",
        "text": "`Q` モナドは， `runQ` を使えば `IO` の元で走らせることができるようになっているので，それでデバッグできます．大体のデータ型は `Show` が実装されているので，単純に表示してみると良いと思います．\n\n```\n&gt;&gt;&gt; runQ (consType 1) :: IO [Dec]\n[TySynInstD Data.Tuple.List.Data.Cons (TySynEqn [VarT x_2,TupleT 0] (AppT (TupleT 1) (VarT x_2)))]\n```\n\nみたいな感じでそれぞれの関数の `Dec` を表示する `Main` モジュールを書いて，プロファイルを取ってみるといいと思いますね．\n\nついでにですが，無限リストの利用は計画的に行った方が良いと思いますね",
        "user": "U57D08Z9U",
        "type": "message"
    },
    {
        "ts": "1567992697.056300",
        "text": "`runQ` したのをわざわざコピーしてました……",
        "user": "U4L0B71L1",
        "type": "message"
    },
    {
        "ts": "1568007206.056600",
        "text": "できないと思う。少なくとも僕が関わっているプロジェクトではstackでインストールしたパッケージをnixの環境では利用できなかった。\n\n\n&gt; OSSでhydra使うにはどうしたらいいでしょうか。自分でたてるしかないですか？\n自分もよくわからないからきいてみます！",
        "user": "U7Z4F723Z",
        "type": "message"
    },
    {
        "ts": "1568079332.061100",
        "text": "お疲れ様です\ntype levelの関数をpropertyテストするにはどうすればいいでしょうか？\ndoctestでkinds!やtype-specで個別の値はテストできるのですが。\nあとはtemplate haskellつかうとか？",
        "user": "U74KTAG0N",
        "type": "message"
    },
    {
        "ts": "1568081220.062100",
        "text": "<https://hackage.haskell.org/package/should-not-typecheck> をうまく使えば... と思ったけど型レベルで生成する必要があるわけですよね... :gununu:\n\n確かにTemplate Haskellを使って頑張って書くしか思いつかないですね... （新しいパッケージを作るチャンス！",
        "user": "U4LGTMTMK",
        "type": "message"
    },
    {
        "ts": "1568120533.062600",
        "text": "改めて試して、\n```\nfoldr (\\x z -&gt; x : z) [] [1 .. size]\n```\nと、 `foldr` にした場合、\n`Strict` をつけた場合最適化を有効にしてもスタックがあふれますね。大体理屈は `foldl` の場合と同じ、ですよね？\n`foldr` に渡した関数 `(\\x z -&gt; x : z)` は実質的に両辺をWHNFまで評価する `:` ということでしょうから。",
        "user": "U4LGTMTMK",
        "type": "message"
    },
    {
        "ts": "1568135882.062900",
        "text": "`foldr` の場合 `foldl` の時と事情が少々異なっていて，まず strict な `foldr` 相当のものは通常リストを reverse するなどしない限り，固定スタックの再帰にできません．それは，リストの後ろの要素から得られる値が分からないと前の要素に対しての計算ができないからです． `foldr` の場合，\n```\nlet k = \\ x z -&gt; x : z in (1 `k` foldr k [] [2 .. n])\n```\nみたいなものが最初にヒープに乗ることになります．そして，このサンクを評価する時 `k` が strict なので， `foldr k [] [2 .. n]` 部分の評価が始まりこの時スタックに値が退避されます．同様の操作がされることによってスタックがどんどん積み上がっていくことになりますが，ヒープの消費量はサンクが nursery にいる間に処理されるため抑えられます．\n\n`foldr'` は `foldl` を使って実装されているため，スタックを消費しない代わりにヒープを消費する実装になっています (これは前回のやつの原理からですね．今回はリストを生成するため，そちらの方にもヒープが割かれて顕著な差がないですが， `\\ x z -&gt; x` とかだと差が出ると思います) なので，基本的に Strict 拡張下では `foldr` 系統は使ってはいけません．代わりに `foldl'` を使ってなんとかするか， lazy にするか， mutable の使用を検討すべきです．\n\n `foldl` の例は一見 strict にしたらいけそうに見えるけど，実は中身が正格消費になっていないので heap を辿りながらスタックオーバーフローしてしまう例になっていて， strict にするだけではダメで中身も正格消費なものを使わないといけないということになります．ここらへんは， (`foldl` は有名な例ですが) 遅延評価での罠を知っていないと判断できないですし，逆に strict 拡張はこういう遅延評価の罠から生まれたもので， BangPattern と strictness flag を書くのがめんどい人用の拡張なので，背景を抑えると strict 拡張がどういう動作をするのかは見えやすいのでは？ というのがあのコメントで言いたいことですね",
        "user": "U57D08Z9U",
        "type": "message"
    },
    {
        "ts": "1568137511.063100",
        "text": "なので基本的には、\n* foldr 系統は strict 下では使ってはいけない\n* foldl 系統は (strict 下でなくても) 正格消費版を使うこと\nみたいな感じですね",
        "user": "U57D08Z9U",
        "type": "message"
    },
    {
        "ts": "1568157804.063500",
        "text": "詳しい解説ありがとうございます！",
        "user": "U4LGTMTMK",
        "type": "message"
    },
    {
        "ts": "1568158296.063800",
        "text": "<@UN9L2JYPR> has joined the channel",
        "user": "UN9L2JYPR",
        "type": "message"
    },
    {
        "ts": "1568171614.064000",
        "text": "こんにちは！OSSでHydraを使うならこれを参考にするといいよっていわれました。\n<https://nixos.org/hydra/manual/#chap-installation>",
        "user": "U7Z4F723Z",
        "type": "message"
    },
    {
        "ts": "1568192880.065800",
        "text": "ありがとうございます。",
        "user": "U74KTAG0N",
        "type": "message"
    }
]