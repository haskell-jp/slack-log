[
    {
        "ts": "1548838831.405200",
        "text": "OOP 脳に洗脳されていると、二項演算子の左と右が同じ型でないといけないっていうこと自体がびっくりだろうからそれを言おうとしてるのかなあ、と。",
        "user": "UF8SE896V",
        "type": "message"
    },
    {
        "ts": "1548838861.406200",
        "text": "うーん、文法的な理解に違いがあるように見えます…例えば「あなたにはプログラミングの才能がある」という言い方ができるからといって、「才能がある(という性質)とは、あなたのことである」と言うことはできないですよね。「あなた」を型、「才能がある」をインスタンス、「プログラミングの」を「ある型クラスの」と置き換えても同じことが言えます",
        "user": "U4KUNQF9N",
        "type": "message"
    },
    {
        "ts": "1548839013.408800",
        "text": "意地悪に捉えればそういう見方もありますね…ただ色々と成り立ってないので、私は忘れたほうがいいという結論になりました…",
        "user": "U4KUNQF9N",
        "type": "message"
    },
    {
        "ts": "1548839039.409300",
        "text": "まあ、いじわるというか、この部分についても「まぎらわしい」ので、ぶっちゃけ読む価値がないなあ、と^^;",
        "user": "UF8SE896V",
        "type": "message"
    },
    {
        "ts": "1548839074.409700",
        "text": "型クラスは `(種, 種, …, 型, 型, …)` という組で、インスタンスはそれに対応する `(型, 型, …, 値, 値, …)` という組というイメージ（ただし Haskell では、インスタンスは型の組合せの部分で一意にならないといけない）",
        "user": "U4L0B71L1",
        "type": "message"
    },
    {
        "ts": "1548839376.410800",
        "text": "それはそのとおりです。なので、その文法的な問題は「Eq のインスタンス」のところには当てはまらないんじゃないかな、と思いました。ぶっちゃけ言いたいことはそれだけです^^;",
        "user": "UF8SE896V",
        "type": "message"
    },
    {
        "ts": "1548839393.411000",
        "text": "こう <https://gist.github.com/notogawa/c122fc1d75531c4f8db30e6d66832ffc>",
        "user": "U5G2BCVBN",
        "type": "message"
    },
    {
        "ts": "1548839461.411200",
        "text": "「Eqのインスタンス」のように型クラスが明記されていれば、それは型に対する述語となるのでもちろん問題ないと思います。",
        "user": "U4KUNQF9N",
        "type": "message"
    },
    {
        "ts": "1548839663.415000",
        "text": "要は例えば groupBy::(a-&gt;a-&gt;Bool)-&gt;[a]-&gt;[[a]] にいちいち最初の引数を渡すの面倒だから、この型なら必ずこの関数を使ってねっていうのを instance で決めておけば group :: Eq a=&gt;[a]-&gt;[[a]] が使えるよ、っていう話ですよね。で、逆にそれじゃ困る人は毎回 groupBy に何か渡すしかない、っていう。",
        "user": "UF8SE896V",
        "type": "message"
    },
    {
        "ts": "1548839699.415400",
        "text": "Scala や Coq の原理はこうなんですよね。まず、型を定義して、それを暗黙引数で型クラスとして使う方法。",
        "user": "U5LEE6C1J",
        "type": "message"
    },
    {
        "ts": "1548839731.415500",
        "text": "newtype も一応使えます",
        "user": "U5LEE6C1J",
        "type": "message"
    },
    {
        "ts": "1548839787.415800",
        "text": "newtype するのは一つの手ではありますが、皮をかぶせたり外したりしないといけないので、 groupBy が必要な状況ではあまり向いてないかなあ、と思ってあえて groupBy を例に出しました^^;",
        "user": "UF8SE896V",
        "type": "message"
    },
    {
        "ts": "1548839894.416100",
        "text": "まあ、そういう状況でも newtype でくるんで外した方がラクだよね、っていう発想をするのが真の Haskeller なのかもしれませんね…^^;;",
        "user": "UF8SE896V",
        "type": "message"
    },
    {
        "ts": "1548839954.416400",
        "text": "そうですね、横槍失礼しました :bow:",
        "user": "U5LEE6C1J",
        "type": "message"
    },
    {
        "ts": "1548839998.417100",
        "text": "（foldl や foldr が中で、 Endo に包み込んで foldMap に扱わせてるのを見たりすると、たしかに包んで外す方がラクだという話はあるんだな、と思いました）",
        "user": "UF8SE896V",
        "type": "message"
    },
    {
        "ts": "1548840063.417900",
        "text": "あ、今は coerce でわざわざ外したりくるんだりしなくとも変換出来たり",
        "user": "U5LEE6C1J",
        "type": "message"
    },
    {
        "ts": "1548840106.418600",
        "text": "束縛・代入の話のときもそうでしたが、基本的な用語で意見が割れることがあり油断できない…",
        "user": "U4KUNQF9N",
        "type": "message"
    },
    {
        "ts": "1548840110.418700",
        "text": "包むコンストラクタ・外すrunほげ のかわりに coerce / coerce を書くだけですよね^^;",
        "user": "UF8SE896V",
        "type": "message"
    },
    {
        "ts": "1548840235.419700",
        "text": "少し前に <https://haskell-jp.slack.com/archives/C5666B6BB/p1548483818293400> の話題がでましたけど、これなんかはまさに「型（コンストラクタ）に対して一個しかインスタンス宣言できない」がゆえの悩みだったりしますよね…",
        "user": "UF8SE896V",
        "type": "message"
    },
    {
        "ts": "1548841069.421700",
        "text": "ところで <#C5666B6BB|questions> らしく質問ですけど、標準 Haskell だと「instance 宣言自体の export/import をするかしないか」は選べなくて必ず export しちゃうし必ず import しちゃうんですけど、 GHC 拡張だとそこらへんコントロールできたりするでしょうか？",
        "user": "UF8SE896V",
        "type": "message"
    },
    {
        "ts": "1548841235.422200",
        "text": "さぁ... そんな拡張はちょっと聞いたことがないですね... あったとして使われたら結構混乱しそうな気がします... :fearful:",
        "user": "U4LGTMTMK",
        "type": "message"
    },
    {
        "ts": "1548841363.422400",
        "text": "意味がどうなるかがわからないのが確かに混乱しそうですね。ただ、こう、自分のモジュールで「もともと Show インスタンスじゃないんだけど、自分のデバッグのためだけにこのモジュールではこういう形で表示させたいのでそのためだけに Show インスタンスに入れておきたい（けどヨソのモジュールでは使ってほしくないので export はしたくない）みたいな話って、ありそうな気がするんですよね…",
        "user": "UF8SE896V",
        "type": "message"
    },
    {
        "ts": "1548841480.422800",
        "text": "あと、標準の Show インスタンスの定義がきにいらないので自分版を使いたい、とか^^;",
        "user": "UF8SE896V",
        "type": "message"
    },
    {
        "ts": "1548841542.423000",
        "text": "まあ、いずれも show にこだわることなく自分で文字列化関数を作ってそれを使えという話ではあるんですが…。",
        "user": "UF8SE896V",
        "type": "message"
    },
    {
        "ts": "1548841712.423300",
        "text": "自分版で「オーバーライド（？）」できてしまうと、別モジュールのライブラリの奥の方で print してるような関数ではたしてどっちの show が使われるのか、ワクワクしますねｗ",
        "user": "UF8SE896V",
        "type": "message"
    },
    {
        "ts": "1548841755.423600",
        "text": "（おそらく最初の Show a=&gt;制約を見たときにセットされた辞書がたらいまわしにされると思うんですが…）",
        "user": "UF8SE896V",
        "type": "message"
    },
    {
        "ts": "1548841827.423900",
        "text": "完全な自由を与えるわけではないんですが、特定の範囲でメソッド（が入った辞書）を差し替えることができる、という意味では去年のHaskell Symposiumで発表された <https://icfp18.sigplan.org/event/haskellsymp-2018-papers-coherent-explicit-dictionary-application-for-haskell> が近いような気がします。",
        "user": "U4LGTMTMK",
        "type": "message"
    },
    {
        "ts": "1548841953.424200",
        "text": "あぁっ、以前は無料でPDFがダウンロードできたのに今はできない？ :disappointed:",
        "user": "U4LGTMTMK",
        "type": "message"
    },
    {
        "ts": "1548842276.424600",
        "text": "実装だけ見ても難しいかとは思いますが、 <https://github.com/mrBliss/ghc> これがそのプロトタイプです。",
        "user": "U4LGTMTMK",
        "type": "message"
    },
    {
        "ts": "1548842943.424900",
        "text": "Sample.hs を見ていました。 visible type application のような感じで、二重丸括弧で ((辞書用の型のデータ)) と書けば辞書が渡せる、っていう感じなんですかね。",
        "user": "UF8SE896V",
        "type": "message"
    }
]