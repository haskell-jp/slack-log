[
    {
        "ts": "1620365648.083900",
        "text": "前に質問させて頂いたように、このようなデータ構造を定義してしているのですが、\n流石にフィールド名が長い(MWBTreeぐらいには省略しても良いかもしれない)ので、\nmakeFieldsでlensを適用したいのですが、\nlensを使わなくても素直にアクセス出来るようにしたいので、\nフィールド名をアンダースコアで始めたくありません。\n古典的なプレフィクス付きのフィールド名を維持しながらlensのコードを生成する素直な方法はありますか?",
        "user": "U57CUMWQ6",
        "type": "message"
    },
    {
        "ts": "1620107152.083800",
        "text": "<@U020TCX5859> has joined the channel",
        "user": "U020TCX5859",
        "type": "message"
    },
    {
        "ts": "1620365648.083900",
        "text": "前に質問させて頂いたように、このようなデータ構造を定義してしているのですが、\n流石にフィールド名が長い(MWBTreeぐらいには省略しても良いかもしれない)ので、\nmakeFieldsでlensを適用したいのですが、\nlensを使わなくても素直にアクセス出来るようにしたいので、\nフィールド名をアンダースコアで始めたくありません。\n古典的なプレフィクス付きのフィールド名を維持しながらlensのコードを生成する素直な方法はありますか?",
        "user": "U57CUMWQ6",
        "type": "message"
    },
    {
        "ts": "1620523899.085100",
        "text": "<@U0214FHSR54> has joined the channel",
        "user": "U0214FHSR54",
        "type": "message"
    },
    {
        "ts": "1620667561.085300",
        "text": "<@U021C4RT2G5> has joined the channel",
        "user": "U021C4RT2G5",
        "type": "message"
    },
    {
        "ts": "1620880384.089100",
        "text": "<https://www.stackage.org/haddock/lts-17.11/exceptions-0.10.4/Control-Monad-Catch.html|exceptions>パッケージで`MonadCatch`クラスに`ContT` インスタンスが提供されていないのは何か理由があるのでしょうか？\n具体的には実装として以下のものを考えられると思うのですがまずい部分があるのでしょうか？\n```instance MonadCatch m =&gt; MonadCatch (ContT r m) where\n  catch m f = ContT $ \\k -&gt; catch (runContT m k) (flip runContT k . f)```",
        "user": "UP6J2B1LL",
        "type": "message"
    },
    {
        "ts": "1621091479.091000",
        "text": "<@U021XMH7NDT> has joined the channel",
        "user": "U021XMH7NDT",
        "type": "message"
    },
    {
        "ts": "1621162561.092000",
        "text": "はじめまして。\n<https://www.haskell.org/onlinereport/haskell2010/|Haskell 2010 Language Report> および <https://github.com/haskell/haskell-report|そのリポジトリ> を読んでいるのですが、文書の内容に（些細な）問題を見つけたり、ビルドスクリプトに問題が見つかった場合は、どこに提案すればよいのでしょうか？",
        "user": "U021XMH7NDT",
        "type": "message"
    },
    {
        "ts": "1621326587.003000",
        "text": "お疲れ様です。\nlensのライブラリがいくつかあります。（generic-lensはいいなと思いつつ）\nどれも同じ定義をつかっているようですが、\nパワフルな機能は必要なくてLens, Prism, Traversal, Isoとか基本的なものが含まれていればよいケースでは\nどれを使うのがおすすめでしょうか。\nそろそろbaseのライブラリに入ってほしいですね。\n逆につかわないほうがいいものはありますか？\nとりあえず、これを使うべきですかね。\n<https://hackage.haskell.org/package/lens>",
        "user": "U74KTAG0N",
        "type": "message"
    },
    {
        "ts": "1621346667.004200",
        "text": "<@U02291FDK6F> has joined the channel",
        "user": "U02291FDK6F",
        "type": "message"
    },
    {
        "ts": "1621412510.004400",
        "text": "<@U022QRU5FHP> has joined the channel",
        "user": "U022QRU5FHP",
        "type": "message"
    },
    {
        "ts": "1621603872.004600",
        "text": "<@U022FV4RUQ6> has joined the channel",
        "user": "U022FV4RUQ6",
        "type": "message"
    },
    {
        "ts": "1621723678.004800",
        "text": "<@U022NP2FUMB> has joined the channel",
        "user": "U022NP2FUMB",
        "type": "message"
    },
    {
        "ts": "1621946967.005000",
        "text": "<@U0234TBC9J8> has joined the channel",
        "user": "U0234TBC9J8",
        "type": "message"
    },
    {
        "ts": "1622027544.005200",
        "text": "<@U023980QWR2> has joined the channel",
        "user": "U023980QWR2",
        "type": "message"
    },
    {
        "ts": "1622093256.005400",
        "text": "<@U02371BTELB> has joined the channel",
        "user": "U02371BTELB",
        "type": "message"
    },
    {
        "ts": "1622361142.005600",
        "text": "非標準ライブラリーを import すると VS Code がエラーと言う　例えば `Could not find module 'Data.Vector'\\nPerhaps you meant Data.Functor (from base-4.14.1.0)`  実際はビルドも実行も問題がないコードですが　VS Code の Extension に HSLに入れて以来この問題が発生しています　環境は　VS Code + WSL2: Ubuntu-20.0.4 Remote + Extension: Haskell 1.4.0 (Haskell Language Server), stack version 2.5.1,  ghc version 8.10.4　です　どなたか解決策をお持ちですか",
        "user": "U584T7GAH",
        "type": "message"
    },
    {
        "ts": "1622521093.005900",
        "text": "<@U0249USCRHN> has joined the channel",
        "user": "U0249USCRHN",
        "type": "message"
    },
    {
        "ts": "1622534738.009000",
        "text": "Windows 10 に stack をインストールして Haskellプログラミングの環境を作成しようとしたら、%USERPROFILE% にnon-ASCII文字があるとNG という地雷を踏んでしまいました。\nユーザー名に日本語が含まれていたためです。ユーザー名にnonASCII文字を含まないローカルアカウントを作成し、そちらのアカウントでやれば回避できるのですが、\n日本語を含むユーザー名のままで、この問題を回避する方法はありますでしょうか。特殊な事情があり、WSLは使えません。",
        "user": "U4KU9ABL0",
        "type": "message"
    },
    {
        "ts": "1622560579.012400",
        "text": "<#C4M4TT8JJ|random> な気もしますが、とりあえずこちらで。\n\nGHCのgitlabのページ（<https://gitlab.haskell.org/ghc/ghc>）で、CodeやWikiに対するsearchが動いてないようです。元からこうでしたっけ？ちょっと前まではきちんと動いていたような記憶があります。そもそも手元の問題かも、と思ってiPhoneで試してみましたが、やはりsearchできないようです。",
        "user": "U7907NMGF",
        "type": "message"
    },
    {
        "ts": "1622601548.013200",
        "text": "<@U023WQ97M9A> has joined the channel",
        "user": "U023WQ97M9A",
        "type": "message"
    },
    {
        "ts": "1622702815.013800",
        "text": "<@U023VRF8LP4> has joined the channel",
        "user": "U023VRF8LP4",
        "type": "message"
    },
    {
        "ts": "1622881060.014000",
        "text": "<@U024143QTA9> has joined the channel",
        "user": "U024143QTA9",
        "type": "message"
    },
    {
        "ts": "1623111994.019500",
        "text": "servantについて質問です。\n\nTutorialのfirst exampleのstartAppを1つの関数にまとめたらどうなるのかやってみようとして失敗しました。\nTutorialのプログラムの `startApp` は `UserAPI1` 型に依存するはずですが、`myStartApp` にはこの型の変数を引数に取ることがないので、代わりに型変数 `apiType` を取るようにするためにforallを使ってみたのですが、\n`Illegal symbol forall in type`\nというエラーが出てうまくいきません。\nどのように記述すればいいでしょうか？",
        "user": "U01R1UNMVT5",
        "type": "message"
    },
    {
        "ts": "1623144623.020400",
        "text": "<@U0251CSBE5N> has joined the channel",
        "user": "U0251CSBE5N",
        "type": "message"
    },
    {
        "ts": "1623205147.020600",
        "text": "<@U024U0DCJ3T> has joined the channel",
        "user": "U024U0DCJ3T",
        "type": "message"
    },
    {
        "ts": "1623512883.032000",
        "text": "`IntSet` みたいな~trie木~Patricia木を車輪の再開発しなければならなくなったのですが、型の御加護を受けつつ余計なreference indirectionを避けるために\n\n```\ndata Patricia (inhabited :: Bool) :: Type where\n  Branch :: {-# UNPACK #-} !Word -&gt; !(Patricia True) -&gt; !(Patricia True) -&gt; Patricia True\n  Tip :: {-# UNPACK #-} !Word -&gt; Patricia True\n  Nil :: Patricia False\n\nnewtype Patricia' = forall b. Patricia' (Patricia b)```\nみたいなことを考えたのですが、existential type って newtypeでは使えないようで、効率が悪そうというよりはただただ気持ち悪いです。empty と non-emptyを型で分離した上で、それらを統合するwrapperがheap中にもう一個できるのを回避するのは不可能でしょうか…。",
        "user": "UL1HFJATE",
        "type": "message"
    },
    {
        "ts": "1623515683.032900",
        "text": "empty と non-emptyを型で分離した上で、という話じゃなくなってしまうのですが。\n\nGADT による制限で `Nil` は `Branch` にも `Tip` にも持たれないので、空の `Patricia` を表現するときだけに使われると思っていいですよね。もしそうなら、`Patricia` が必ず1つ以上の要素をもつ (`Semigroup` みたいに) としてしまえば `Nil` がなくなって `inhabited` を区別しなくてよくなり、existential type もいらなくなると思ったのですが、そういうのってありなんでしょうか。empty がなくなると不便ですかね。",
        "user": "U578W9676",
        "type": "message"
    },
    {
        "ts": "1623664209.046500",
        "text": "<@U025AGT283T> has joined the channel",
        "user": "U025AGT283T",
        "type": "message"
    },
    {
        "ts": "1623738094.046700",
        "text": "<@U02580P7H5J> has joined the channel",
        "user": "U02580P7H5J",
        "type": "message"
    }
]