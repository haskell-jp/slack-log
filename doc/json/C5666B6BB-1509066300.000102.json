[
    {
        "ts": "1509066300.000102",
        "text": "補足ですが．それこそViewPatternsでも使わない限りPatternSynonymsはその名の通りただのシノニムなので，パターンマッチで可能なこと以上のことができるようにはなりません．つまり，コンストラクタをかぶせていく(=マッチして取り出したい値を別の値に変質させずそのまま持たせる)だけで値を作れるルートがある場合にしか，コンストラクトの逆操作であるパターンマッチ(によるデストラクト，中身の取り出し)は定義できません．今回定義しようとしているシノニムに対してあてはめると，(パターンマッチにより分解して出そうとしている，パターンに現れる1，2番目の)CallowSExprをそのまま使って，つまり「その中身を一旦取り出す(grouup)」というコンストラクタをかぶせる以外の操作を挟まずには(パターンに現れる3番目の)CallowSExprをコンストラクトできるルートが無いので，パターンマッチによってCallowSExprを分解してCallowSExprを取り出すことはできないということになります．このことは定義したいなと思ったパターンの型を考えた際に，いろいろとその実現方法について試行錯誤せずとも，それらに現れる型のコンストラクタの情報からできそう/できなさそうについては判断可能かと思います．",
        "user": "U5G2BCVBN",
        "type": "message"
    },
    {
        "ts": "1509067743.000088",
        "text": "ありがとうございます！！",
        "user": "U5LV76EJH",
        "type": "message"
    },
    {
        "ts": "1509075365.000217",
        "text": "ViewPatternsを除けば、PatternSynonymsは有限なパターンマッチで表現可能なもののみ定義できるって感じですかね？ &gt; <@U5G2BCVBN>",
        "user": "U5LV76EJH",
        "type": "message"
    },
    {
        "ts": "1509075419.000121",
        "text": "うおおできた！！ ありがとうございます！！ &gt; <@U560KD6DN>",
        "user": "U5LV76EJH",
        "type": "message"
    },
    {
        "ts": "1509088544.000378",
        "text": "今のケースって、CallowSExpr型のtermをAtomの場合とConsの場合でそれぞれパターンマッチできるようにしたいってことだと思うんですが、newtypeで作った型をコンストラクト・デストラクトする方法は常に1通りしかないのでこういうpatternが記述できてもいいんじゃないかという気はした(ぼやき)",
        "user": "U560KD6DN",
        "type": "message"
    },
    {
        "ts": "1509088704.000184",
        "text": "newtypeがdataの特殊な場合だと思うと(つまり一般にdataに対しては)こういうのは当然記述できないわけですが、newtypeは1つのコンストラクタのみからなる型と思えばそのコンストラクタに対するパターンは常にbidirectionalに作れるでしょみたいな",
        "user": "U560KD6DN",
        "type": "message"
    },
    {
        "ts": "1509111253.000364",
        "text": "わかる～！\n\nこのような解決方法が存在していてよかった。",
        "user": "U5LV76EJH",
        "type": "message"
    },
    {
        "ts": "1509419581.000222",
        "text": "久々に <https://www.slideshare.net/pfi/ss-9780450> を読んでいて気になったのですが、Haskellにconcurrent revisionsの実装はあるんでしょうか？",
        "user": "U4LGTMTMK",
        "type": "message"
    },
    {
        "ts": "1509434917.000062",
        "text": "参考: Purely Functional Concurrent Revisions <https://www.microsoft.com/en-us/research/publication/prettier-concurrency-purely-functional-concurrent-revisions/>",
        "user": "U61BA2X0U",
        "type": "message"
    },
    {
        "ts": "1509678432.000160",
        "text": "`Database.Relational.Type` が relational-query 0.9.5.0 の GitHub の cabal ファイルの exposed-modules にはあるのに Stackage LTS-9.11 見るとないのなんでなんでしょう？\n• GitHub <https://github.com/khibino/haskell-relational-record/blob/502ff25dcb0b8bd430951192d6deb31657d1ea04/relational-query/relational-query.cabal>\n• Stackage <https://www.stackage.org/lts-9.11/package/relational-query-0.9.5.0>",
        "user": "U4L0B71L1",
        "type": "message"
    },
    {
        "ts": "1509678903.000038",
        "text": "<https://github.com/khibino/haskell-relational-record/blob/release-relational-query-0_9_5_0/relational-query/relational-query.cabal> にも\n<https://hackage.haskell.org/package/relational-query-0.9.5.0>\nにもないということは、\nリリース時のミスっぽい感じがしますね。。。 :cold_sweat:",
        "user": "U4LGTMTMK",
        "type": "message"
    },
    {
        "ts": "1509678949.000184",
        "text": "Issueとして送った方が良さそうな気が強います。",
        "user": "U4LGTMTMK",
        "type": "message"
    },
    {
        "ts": "1509679053.000175",
        "text": "いや違うわ。\n<https://github.com/khibino/haskell-relational-record/blob/release-relational-query-0_9_5_0/relational-query/relational-query.cabal>\nにもなかったので、参照しているGitHubのコミットがおかしい気がします。",
        "user": "U4LGTMTMK",
        "type": "message"
    },
    {
        "ts": "1509679107.000061",
        "text": "lts-9 のブランチにはあるんで、単純に見てるコミットが 0.9.5 と 0.10.0 の間のコミットなだけだと思いますよ\n<https://github.com/khibino/haskell-relational-record/blob/lts-9/relational-query/relational-query.cabal>",
        "user": "U56L7EVNY",
        "type": "message"
    },
    {
        "ts": "1509679154.000197",
        "text": "なるほど、バージョン番号上げる前の作業途中のリビジョンを見っちゃったのか",
        "user": "U4L0B71L1",
        "type": "message"
    },
    {
        "ts": "1509679249.000088",
        "text": "GitHub の検索欄から雑に検索して探してたのでちゃんと clone してブランチ指定して目的のもの探してみます\nありがとうございました",
        "user": "U4L0B71L1",
        "type": "message"
    },
    {
        "ts": "1509926603.000088",
        "text": "<@U7VAVLWQL> has joined the channel",
        "user": "U7VAVLWQL",
        "type": "message"
    },
    {
        "ts": "1510066861.000505",
        "text": ".cabal ファイルに書いてあるけど使っていないパッケージを調べる方法……は packageunused というパッケージを使えば良さそうでした（自己解決） <https://hackage.haskell.org/package/packunused>",
        "user": "U4M598NHM",
        "type": "message"
    },
    {
        "ts": "1510093633.000314",
        "text": "<https://hackage.haskell.org/package/weeder> の方が簡単そうですよ！",
        "user": "U4LGTMTMK",
        "type": "message"
    },
    {
        "ts": "1510217044.000027",
        "text": "<@U7XC5U1RR> has joined the channel",
        "user": "U7XC5U1RR",
        "type": "message"
    },
    {
        "ts": "1510278772.000141",
        "text": "<@U7Z4F723Z> has joined the channel",
        "user": "U7Z4F723Z",
        "type": "message"
    },
    {
        "ts": "1510333224.000566",
        "text": "weeder 試しているのですが色々報告してくれていいですね！",
        "user": "U4M598NHM",
        "type": "message"
    },
    {
        "ts": "1510365916.000084",
        "text": "package.yaml には使えないですよね…",
        "user": "U56L7EVNY",
        "type": "message"
    },
    {
        "ts": "1510380019.000012",
        "text": "引数の命名規則的なのHaskellにありますか?",
        "user": "U5FTM76CA",
        "type": "message"
    },
    {
        "ts": "1510382253.000032",
        "text": "うーん、型や変数については <https://wiki.haskell.org/Programming_guidelines#Naming_Conventions> がありますが、引数についてはあまり聞かないですね。。。\nもしかして何か具体的に悩んでいたりしますか？",
        "user": "U4LGTMTMK",
        "type": "message"
    },
    {
        "ts": "1510399756.000058",
        "text": "Maybeモナドを引数に取ってJustとNothingで場合分けする関数を作っていて、Maybeモナドの引数名を悩みました。細かいことなのですが…",
        "user": "U5FTM76CA",
        "type": "message"
    },
    {
        "ts": "1510406228.000091",
        "text": "長く書くのであればmaybeFooみたいにmaybeを頭に着けるか、短くするのであればmbっていうプレフィックスをつけますね。\nというか、Maybeを引数にとるのであれば\n```\nf (Just x) = ...\nf Nothing = ...\n```\nという書き方ができるので、そうすればMaybeを意識しなくて済むのでは？",
        "user": "U4LGTMTMK",
        "type": "message"
    },
    {
        "ts": "1510408779.000016",
        "text": "そもそも、関数の型は推論ができても書くっていう慣習があるので、引数の型によって引数名を考える必要は無さそう(関数の型定義を見ろ)。",
        "user": "U56L7EVNY",
        "type": "message"
    },
    {
        "ts": "1510409061.000055",
        "text": "<@U4LGTMTMK> ぼくも結局そう書いてました:sweat_drops:\n<@U56L7EVNY> C++畑出身なので名前がどうしても気になって…",
        "user": "U5FTM76CA",
        "type": "message"
    },
    {
        "ts": "1510412909.000001",
        "text": "必要というより、型から引数名考えた方が楽じゃないっすか。だから決してそのアプローチは悪くないと思います。",
        "user": "U4LGTMTMK",
        "type": "message"
    },
    {
        "ts": "1510423487.000017",
        "text": "<@U55UMF3L0> has joined the channel",
        "user": "U55UMF3L0",
        "type": "message"
    },
    {
        "ts": "1510465927.000009",
        "text": "Foldable型クラスの foldMap は満たすべき\u0008 Foldable則はないんでしたっけ。ないとしたら型引数を1個持つすべての型コンストラクタは ```foldMap _ _ = memtpy``` で Foldable にできますか（役には立たなそうですが）。",
        "user": "U57CGDBMG",
        "type": "message"
    },
    {
        "ts": "1510467005.000048",
        "text": "<https://hackage.haskell.org/package/base-4.10.0.0/docs/Data-Foldable.html>\n曰く\n```\nfoldr f z t = appEndo (foldMap (Endo . f) t ) z\nfoldl f z t = appEndo (getDual (foldMap (Dual . Endo . flip f) t)) z\nfold = foldMap id\n```\nを満たせ、とありますね。\n更にFunctorのインスタンスでもある場合は、\n```\nfoldMap f = fold . fmap f\n```\nも満たせ、と。",
        "user": "U4LGTMTMK",
        "type": "message"
    },
    {
        "ts": "1510467157.000027",
        "text": "`Endo` というのは関数の `(.)` を `mappend` として扱うための、関数に対する newtype で、 `Dual` というのは任意のMonoidの`mappend`を `flip` するための newtype だそうです。\nつまり最初の2つを要約すると、\nfoldrもfoldlも、 `foldMap` で合成した関数によって作られなければならないってことのようですね。",
        "user": "U4LGTMTMK",
        "type": "message"
    },
    {
        "ts": "1510467305.000008",
        "text": "foldMap 以外のメソッドは foldMap を使ったデフォルト実装にするとすれば上記のメソッド間の関係は自動的に満たされますね（多分）。foldMap 単独で満たすべき則はないんでしょうか。",
        "user": "U57CGDBMG",
        "type": "message"
    },
    {
        "ts": "1510468829.000023",
        "text": "foldMap _ _ = memptyの場合，Const m関手と同じFoldableを持つのでそれもFoldableといっていいものだと思います",
        "user": "U57D08Z9U",
        "type": "message"
    },
    {
        "ts": "1510468890.000011",
        "text": "mempty のケースは結構一貫性が感じられますね。例えば、リストを要素に持つ木の fold は普通要素を左から並べて concat したものを想像しますが木ごとに「この木の fold結果は好きに選んだこのリストとする」のように対応を勝手に決めてしまっても Foldable と言ってよいでしょうか。",
        "user": "U57CGDBMG",
        "type": "message"
    },
    {
        "ts": "1510469197.000051",
        "text": "foldの満たすべき性質の本質は，おそらくfold . fmap f = f . foldだと思います",
        "user": "U57D08Z9U",
        "type": "message"
    },
    {
        "ts": "1510469373.000022",
        "text": "ただ，これはfoldがどんなmに対しても定義できる多相関数である以上，その他のFoldableの法則が満たされれば，満たされるものだと思います．",
        "user": "U57D08Z9U",
        "type": "message"
    },
    {
        "ts": "1510469561.000048",
        "text": "「この木の fold結果は好きに選んだこのリストとする」\nこれは結局木の形に言及したものになるのでそれも一つのfoldの仕方と言えるのではないでしょうか？（今，ちょっと文献を探してます）",
        "user": "U57D08Z9U",
        "type": "message"
    },
    {
        "ts": "1510469713.000032",
        "text": "「この木」と書きましたが木の形だけでなく同じ木の形でも要素の値ごとに一貫性なく値を割り当てることも考えてました。",
        "user": "U57CGDBMG",
        "type": "message"
    },
    {
        "ts": "1510469831.000009",
        "text": "要素の値というのは， `fold :: Monoid m =&gt; t m -&gt; m` での， `m` の型に言及するというのことでしょうか？",
        "user": "U57D08Z9U",
        "type": "message"
    },
    {
        "ts": "1510469856.000012",
        "text": "型にも具体的な値ごとにも。 `fold (Leaf [1]) = [3,5]; fold (Leaf [2]) = []; ...`",
        "user": "U57CGDBMG",
        "type": "message"
    },
    {
        "ts": "1510470054.000057",
        "text": "型に言及するには，制約が `Monoid` しかないので，情報が足りないのではないでしょうか？",
        "user": "U57D08Z9U",
        "type": "message"
    },
    {
        "ts": "1510470161.000004",
        "text": "多相関数というのは割と結構強い制約で，例えばFunctor則は `fmap` が多相関数なのでどちらかの則があれば自動的にもう一方を満たします(<https://www.schoolofhaskell.com/user/edwardk/snippets/fmap>)",
        "user": "U57D08Z9U",
        "type": "message"
    },
    {
        "ts": "1510470210.000039",
        "text": "なので， Foldableも多相関数を利用してる場合その時点で割と実装が限られて来ます (もっとも，ボトムを定義中に使われると色々と壊れるのですが)",
        "user": "U57D08Z9U",
        "type": "message"
    },
    {
        "ts": "1510470466.000002",
        "text": "そういう意味では、多相関数を使ってなくて Functor であってもなくてもよく（Functor でもなおかつという方が面白いですが）いかにも不自然な感じのする Foldable の例があるかという質問と思ってください。",
        "user": "U57CGDBMG",
        "type": "message"
    },
    {
        "ts": "1510470608.000024",
        "text": "それはあり得ると思いますが，多相関数でない以上FoldableではないのでそれはfoldやfoldMapの型を特殊化したものと型が一致したただの別の関数ということになってしまうのではないでしょうか？",
        "user": "U57D08Z9U",
        "type": "message"
    },
    {
        "ts": "1510470730.000054",
        "text": "なお， Foldableをもう少し弱めたものならば <https://hackage.haskell.org/package/recursion-schemes-5.0.2/docs/Data-Functor-Foldable.html#t:Recursive> などがあります",
        "user": "U57D08Z9U",
        "type": "message"
    },
    {
        "ts": "1510471096.000003",
        "text": "うむむむ、リストとリスト以外のモノイドで実装を分けて書けないので多相的な実装しか書けないですね。確かに。",
        "user": "U57CGDBMG",
        "type": "message"
    },
    {
        "ts": "1510471145.000029",
        "text": "これがfoldのチュートリアルみたいです．これを読んでみると疑問が解決するかもしれません？（ちょっと僕も読んでみます）\n<http://www.cs.nott.ac.uk/~pszgmh/fold.pdf>",
        "user": "U57D08Z9U",
        "type": "message"
    },
    {
        "ts": "1510471478.000017",
        "text": "では、木の形だけで判断するとして好きに選んだいくつかのある木のときだけは mempty にしてそれ以外では concat した値にするとしたら整合性や不自然さはどうでしょう。",
        "user": "U57CGDBMG",
        "type": "message"
    },
    {
        "ts": "1510471674.000018",
        "text": "多分それも代数的には意味のある構造なのだと思います．それを木という代数的構造で考えると不自然なのですが，別の代数と考えるとそのfoldを考えてるようなものなのだと思います",
        "user": "U57D08Z9U",
        "type": "message"
    },
    {
        "ts": "1510471721.000041",
        "text": "なので，Foldable的にはおかしくないのだと思うのですが(ちょっとFoldableの背景には明るくないので，明確には言えないです)",
        "user": "U57D08Z9U",
        "type": "message"
    },
    {
        "ts": "1510472257.000025",
        "text": "そもそもこのことを考え始めたきっかけは「Haskell 教養としての関数型プログラミング」に 「Foldable は並べられるという性質」とあって「並べられる」っぽっくない Foldable の例はないだろうかと考え始めたのでした。",
        "user": "U57CGDBMG",
        "type": "message"
    },
    {
        "ts": "1510472334.000066",
        "text": "なるほど．並べられるというより並べ方を定義するの方が分かりやすいかもしれません",
        "user": "U57D08Z9U",
        "type": "message"
    },
    {
        "ts": "1510472424.000018",
        "text": "foldMapを定義すれば基本的にtoListが定義できるので",
        "user": "U57D08Z9U",
        "type": "message"
    },
    {
        "ts": "1510472550.000014",
        "text": "まあ「並べる」とはどういう意味かということに帰着されて `toList t = build (\\ c n -&gt; foldr c n t)` を「並べる」ということだ言ってしまえばその通りかもしれませんが普通の直感とは多分違うような気が。",
        "user": "U57CGDBMG",
        "type": "message"
    },
    {
        "ts": "1510472730.000004",
        "text": "まあ確かに普通の直感とは異なるかもしれません．ただ，普通の直感の並べ方をもっと形式的に表せないかというのがfoldMapのアイデアの元になってて,",
        "user": "U57D08Z9U",
        "type": "message"
    },
    {
        "ts": "1510472843.000090",
        "text": "リストに対してのfoldMapが出来てそれでtoListがちゃんと表せて，木もフラットにする方法がやっぱり同じ方法で出来て，じゃあFoldableにまとめたら他の代数でも同じように並べ方が定義できるようになったという感じだと思います．",
        "user": "U57D08Z9U",
        "type": "message"
    },
    {
        "ts": "1510473084.000007",
        "text": "なので直感的な感覚から始まって，色々な並べるをうまく表せるFoldableを一つの並べるの定義方法だと思えば，非直感的な並べ方に対しても同じようなことができてその並べ方に沿って並べるをアルゴリズムの一部として使うようなものが一般的に書けるという点では，Foldableも並べられるという性質を持っているといって問題ないのではないでしょうか？",
        "user": "U57D08Z9U",
        "type": "message"
    },
    {
        "ts": "1510473916.000008",
        "text": "うーん、そうですね。上に書いたときどき mempty になる例も列に並ぶのをさぼるグループがいると考えれば「並べる」と言える気がしてきました。自分のコピーを作って複数人分潜り込ませて並ぶというのもありかな。",
        "user": "U57CGDBMG",
        "type": "message"
    },
    {
        "ts": "1510474985.000053",
        "text": "```\nnewtype Square a = Square a\n```\nとかだったら意味論的にはありだと思いますね",
        "user": "U57D08Z9U",
        "type": "message"
    },
    {
        "ts": "1510481874.000020",
        "text": "リストも（標準のリストFoldableとは違いますが）\n```\nfold [] = mempty\nfold [m1] = m1 &lt;&gt; m1\nfold [m1, m2] = m2\nfold [m1, m2, m3] = m1 &lt;&gt; m3 &lt;&gt; m2 &lt;&gt; m3\nfold [m1, m2, m3, m4] = mempty\n...\n```\nのように要素と &lt;&gt;  と memtpy だけを組み合わせているかぎりどのように定義しても Foldable になりそうですね。",
        "user": "U57CGDBMG",
        "type": "message"
    },
    {
        "ts": "1510504726.000031",
        "text": "あれ、toList の話に自分で build を出しましたが build は cata, ana を想定してない一般には定義されてないですよね。toList は fold からどう定義できるんでしたっけ。Foldableパッケージには toList = elems と書いてあるだけでその elems はどう定義するのでしょう。上の例では\n```\nelems [m1] = [m1,m1]\nelems [m1,m2] = [m2]\n...\n```\nと定義するという堂々巡りしているだけ？",
        "user": "U57CGDBMG",
        "type": "message"
    },
    {
        "ts": "1510512428.000022",
        "text": "どの `Foldable` を見てるかはよく分かりませんが，現状のbase( <https://hackage.haskell.org/package/base-4.10.0.0/docs/src/Data.Foldable.html#line-230> )では， `toList = build (\\ c n -&gt; foldr c n t)` がデフォルトになっています． `build` は <https://hackage.haskell.org/package/base-4.10.0.0/docs/src/GHC.Base.html#line-871> ですね．リストを作るためのビルダーになっていて， foldr/build変換なども適用されるようになります",
        "user": "U57D08Z9U",
        "type": "message"
    },
    {
        "ts": "1510555268.000089",
        "text": "一回stack buildでcabalファイルを生成してから使えばpackage.yamlにも使えるのでは?手で編集できないほど依存ライブラリの数が多ければわかりませんが…",
        "user": "U57CUMWQ6",
        "type": "message"
    },
    {
        "ts": "1510561822.000162",
        "text": "ううう、build はそうでした。上で書いた fold の例だと `toList [m1] = m1:m1:[] = [m1,m1]` ですね。\nelems と書いてあったのは `instance Foldable (Array i)` の中のところでした。\n`'toList = '` で検索したのが失敗だった orz。",
        "user": "U57CGDBMG",
        "type": "message"
    },
    {
        "ts": "1510715994.000101",
        "text": "\u0008前に書いていた `fold . fmap f = f . fold` は f はモノイド準同型を前提してということですか。",
        "user": "U57CGDBMG",
        "type": "message"
    },
    {
        "ts": "1510726603.000115",
        "text": "あ，そうですね． `f` がモノイド準同型であることが必要です",
        "user": "U57D08Z9U",
        "type": "message"
    },
    {
        "ts": "1510731561.000247",
        "text": "初歩的な質問なのですが\n`import qualified Data.Text as T`とすると\n`T.Text`と型にもTが付くんですか?",
        "user": "U5FTM76CA",
        "type": "message"
    },
    {
        "ts": "1510731628.000105",
        "text": "はい。",
        "user": "U4LGTMTMK",
        "type": "message"
    },
    {
        "ts": "1510731645.000081",
        "text": "ありがとうございます。",
        "user": "U5FTM76CA",
        "type": "message"
    },
    {
        "ts": "1510733750.000262",
        "text": "型を `T.Text` にしたくない場合はこんな感じで定義されてることが多いですね！\n\n```\nimport Data.Text (Text)\nimport qualified Data.Text as T\n```\n\n`Data.Map` を `import` する際にも良くみかけます:grinning:",
        "user": "U5B3EGEFQ",
        "type": "message"
    },
    {
        "ts": "1510734420.000172",
        "text": "wado さんの提示してるやり方よくしますね",
        "user": "U4L0B71L1",
        "type": "message"
    },
    {
        "ts": "1510735436.000187",
        "text": "括弧付きimportのほうが優先順位が高いんですね",
        "user": "U5FTM76CA",
        "type": "message"
    },
    {
        "ts": "1510735901.000080",
        "text": "モジュールの括弧は優先順位とは全く無関係です。括弧によってモジュールから `import` するもの (関数や型など) を明示的に列挙できます。\n\n```\nimport Data.Text (Text)\n```\n\n上記は `Text` 型のみを `import` します。その際、 `qualified ... as` 形式ではないため `Text` という表記で利用できます。\n\n```\nimport qualified Data.Text as T\n```\n\n上記は `Text` モジュールで `export` されているもの全てが `import` されます。(`T.Text`, `T.null`, etc...)。こちらは `qualified ... as` 形式なので全て `T.` という修飾詞つきの表記で利用できます。( `Prelude` や他のモジュールで定義されている関数 (や型) の名前と被る場合に使います。)\n具体例:\n - [Text.null](<https://www.stackage.org/haddock/lts-9.13/text-1.2.2.2/Data-Text.html#v:null>)\n - [Prelude.null](<https://www.stackage.org/haddock/lts-9.13/base-4.9.1.0/Prelude.html#v:null>)。\n\nなので上記ように `import` を2つ書いた場合は `Text` 型は `Text` と `T.Text` の両方の形式で利用できるという理解が正しいです。\n\nただ両方利用できても、 `T.Text` って書くの面倒なので `Text` しか使わないという感じです。\n\n`T.Text` を `import` しないようにするためには `hiding` キーワードを使って明示的に `import` しないものを指定します。(`hiding` は暗黙的に `Prelude` から `import` されているものを隠したい場合によく利用します。 `import Prelude hiding (div)`)\n\n```\nimport Data.Text (Text)\nimport qualified Data.Text as T hiding (Text)\n```\n\n長くなりましたが、だいたいこんな感じだと思います。",
        "user": "U5B3EGEFQ",
        "type": "message"
    },
    {
        "ts": "1510744302.000321",
        "text": "なるほど。\nありがとうございます:musical_note:",
        "user": "U5FTM76CA",
        "type": "message"
    },
    {
        "ts": "1510790576.000058",
        "text": "Stackを使った開発でのghc-modの利用について質問させてください．Stackage LTS-8.xにはghc-modがあったので問題なくインストールできましたが，LTS-9.xからは外されて(?)しまい，cabal-installで別途導入しようとしても途中でエラーになってしまいます．LTS-9.xでghc-modを利用できている方はどのようにやっていらっしゃるのでしょうか．",
        "user": "U56LT20RJ",
        "type": "message"
    },
    {
        "ts": "1510791571.000276",
        "text": "ghc-modは、もう僕の手を離れているので、よく分かりません。",
        "user": "U56MBRKR9",
        "type": "message"
    },
    {
        "ts": "1510791592.000054",
        "text": "GHC 8.0.2では使えますし、僕も stack なしで使っています。",
        "user": "U56MBRKR9",
        "type": "message"
    },
    {
        "ts": "1510791612.000091",
        "text": "なお、ghc-modは、まだ GHC 8.2.x には対応していません。",
        "user": "U56MBRKR9",
        "type": "message"
    },
    {
        "ts": "1510792155.000150",
        "text": "`lts-9` 系でも `stack install ghc-mod` でインストールできたような気がします。",
        "user": "U5B3EGEFQ",
        "type": "message"
    },
    {
        "ts": "1510792785.000086",
        "text": "試しにやってみたらインストールできたようです（macOS 10.13.1, Stack LTS-9.13）．LTS-9.x になって以来パッケージリストに ghc-mod が含まれていないので stack install ではできないものと思って試していませんでした．ありがとうございます．",
        "user": "U56LT20RJ",
        "type": "message"
    },
    {
        "ts": "1510792839.000180",
        "text": "便乗ですが、今だとEmacsでhaskellのコードを書く場合は `haskell-mode` を使っておくのがいいんでしょうか。(というかそれ以外に選択肢がない？)",
        "user": "U61BA2X0U",
        "type": "message"
    },
    {
        "ts": "1510794752.000033",
        "text": "はい。elpaに上がっているhaskell-modeが最新だと思います。",
        "user": "U56MBRKR9",
        "type": "message"
    },
    {
        "ts": "1510798655.000193",
        "text": "単にsyntax highlightくらいできればいいならhaskell-modeでいいと思います\nもっとIDE的な機能が欲しければinteroっていうプラグインがありますね",
        "user": "U560KD6DN",
        "type": "message"
    },
    {
        "ts": "1510879403.000061",
        "text": "ある typeclass の instance を reexport する方法って、Haskellにはないんでしたっけ？",
        "user": "U56MBRKR9",
        "type": "message"
    },
    {
        "ts": "1510882435.000032",
        "text": "普通に <https://github.com/tfausak/autoexporter> などでやるように module ごと reexport すればできたように思います。\nちょっと記憶が怪しい（しかもTHによる例）ので恐縮ですが、\n<https://github.com/igrep/typesafe-precure/blob/5dc0800ae8f8f4e002ee3d32d92ae6450b86d653/src/ACME/PreCure/Textbook/KirakiraALaMode/Instances.hs> の時点のtypesafe-precureは\n`ACME.PreCure.Textbook.KirakiraALaMode.Instances` でインスタンスしか定義していない module を export して、\n更に src/ACME/PreCure/Textbook/KirakiraALaMode.hs などでreexport していました。",
        "user": "U4LGTMTMK",
        "type": "message"
    },
    {
        "ts": "1510890461.000059",
        "text": "” All instances defined in a module A are imported automatically when importing A, or importing any module that imports A, directly or indirectly.”  <https://wiki.haskell.org/Orphan_instance> だそうで、有無を言わさず自動的に再エクスポートされるみたいです",
        "user": "U570660KX",
        "type": "message"
    },
    {
        "ts": "1510994045.000043",
        "text": "誰かText.EDEに詳しい人いませんか",
        "user": "U5FTM76CA",
        "type": "message"
    },
    {
        "ts": "1510994928.000036",
        "text": "`env = fromPairs [\"list\" .=[\"AA\",\"BB\",\"CC\"]]`",
        "user": "U5FTM76CA",
        "type": "message"
    },
    {
        "ts": "1510994949.000038",
        "text": "こうしてもうまくレンダリングできません",
        "user": "U5FTM76CA",
        "type": "message"
    },
    {
        "ts": "1511000732.000092",
        "text": "それはコンパイルエラーになるということでしょうか？それとも，例外が出るということでしょうか？テンプレートが思った通りに表示できないということでしょうか？",
        "user": "U57D08Z9U",
        "type": "message"
    },
    {
        "ts": "1511151257.000115",
        "text": "<@U826HT001> has joined the channel",
        "user": "U826HT001",
        "type": "message"
    },
    {
        "ts": "1511154969.000087",
        "text": "import A() して export しても、instance が re-export されることを確かめました。",
        "user": "U56MBRKR9",
        "type": "message"
    },
    {
        "ts": "1511154974.000031",
        "text": "ありがとうございました。",
        "user": "U56MBRKR9",
        "type": "message"
    },
    {
        "ts": "1511155002.000140",
        "text": "`{-# OPTIONS_GHC -fno-warn-dodgy-exports #-}` と併用すると、警告がなくなるようです。",
        "user": "U56MBRKR9",
        "type": "message"
    },
    {
        "ts": "1511158251.000010",
        "text": "失礼しました。コンパイルエラーが出たので、\nenv = fromPairs [\"list\".= toJSON [\"aa\",\"bb\",\"cc\"]] としても[String]がToJSONのinstanceになっていない?などのコンパイルエラーがでました",
        "user": "U5FTM76CA",
        "type": "message"
    },
    {
        "ts": "1511165032.000025",
        "text": "edeは，大雑把にはテンプレートをJSONデータをパラメータにしてレンダリングするライブラリです．で，HaskellではJSONを扱うライブラリの金字塔として， aeson というライブラリ(<https://www.stackage.org/package/aeson>)があり ede でもそれを使用しています．(.=)はaesonの関数です．aesonは，Valueという型 (<https://hackage.haskell.org/package/aeson-1.1.0.0/docs/Data-Aeson-Types.html#t:Value>) でJSONデータを表現しています．`fromPairs` は[(Text, Value)] というものから Value型の値を作る関数ですが，この関数はキーとその中身のJSONデータから新たなるJSONデータを作る関数 (イメージとしては， `[(\"ab\", { \"a\": \"b\" }), (\"cd\", { \"c\": \"d\" })] =&gt; { \"ab\": { \"a\": \"b\" }, \"cd\": { \"c\": \"d\" } }` というような変換を行う関数)です．\n\nまず一つ目ですが，aesonではToJSONという型クラスを用意しており，この型クラスには名前の通りJSONのデータへ変換できる型がインスタンスとして登録されています． (.=) は `&lt;キーとなるテキスト&gt; .= &lt;JSONになれる型の値(ToJSONのインスタンス)&gt;` という感じで使い，右の値は自動的にJSONデータに変換してくれます．なので， `fromPairs [ \"list\" .= toJSON [\"aa\", \"bb\", \"cc\" ]` は `fromPairs [ \"list\" .= [ \"aa\", \"bb\", \"cc\" ] ]` と同値です．JSONデータとしての表現は， aeson と bytestring というライブラリをロードしてghci上で\n```\n&gt;&gt;&gt; import Data.Aeson\n&gt;&gt;&gt; toJSON [ \"aa\", \"bb\", \"cc\" ] — Haskell上での表現が表示される\n```\nまたは\n```\n&gt;&gt;&gt; import qualified Data.ByteString.Lazy.Char8 as BS\n&gt;&gt;&gt; BS.putStrLn $ encode [ \"aa\", \"bb\", \"cc\" ] — JSONデータが表示される\n```\nとすれば見ることができます\n\nで，ここからは推測になるのですが，Haskell事情として文字列を表すデータ型にString型は扱いにくく(特に速度を求めるものでは) text というパッケージ(<https://www.stackage.org/package/text>) を代わりに使用されることが多くあります． aeson でも例に漏れずこのパッケージを使用しており， JSONのキーとしてString型ではなくText型というものを使います． なので `fromPairs [ (\"list\" :: String) .= [ \"aa\", \"bb\", \"cc\" ] ]` というのはコンパイルエラーを起こします． 正しい型は `fromPairs [ (Data.Text.pack \"list\" :: Data.Text.Text) .= [ \"aa\", \"bb\", \"cc\" ] ]` というのが正しい表記なのですがこのような書き方は良くするので， `OverloadedStrings` という拡張がよく使用されます．この拡張を有効にすると `fromPairs [ (\"list\" :: Data.Text.Text) .= [ \"aa\", \"bb\", \"cc\" ] ]` という表記が可能になります．",
        "user": "U57D08Z9U",
        "type": "message"
    },
    {
        "ts": "1511165623.000082",
        "text": "この `OverloadedStrings` はよく使う拡張なので， edeのドキュメントには書かれていないのですが， それを有効にしていないままドキュメントのサンプルを動かそうとするとエラーが出るはずです．この拡張を有効にしていなかったりしないでしょうか？",
        "user": "U57D08Z9U",
        "type": "message"
    },
    {
        "ts": "1511177091.000057",
        "text": "Thread Scope で Raw Events をテキスト検索（Ctrll+f）することはできないでしょうか？ traceEvent で起こしたユーザイベントがどこにあるか探したいのですが。",
        "user": "U4M598NHM",
        "type": "message"
    },
    {
        "ts": "1511183116.000180",
        "text": "現状では出来ないと思います。おそらく簡単に機能追加できると思うのでPR歓迎です。",
        "user": "U4M9NJ7QE",
        "type": "message"
    },
    {
        "ts": "1511183721.000048",
        "text": "OverloadedStringsは有効にしてあるのですがここでのData.Text.TextはData.Text.Lazy.Textの方ですか?",
        "user": "U5FTM76CA",
        "type": "message"
    },
    {
        "ts": "1511185225.000029",
        "text": "いいえ、strictのですね。うーん、OverloadedStringsが有効になってるなら、逆に `fromPairs [\"list\" .= ([\"aa\",\"bb\",\"cc\"] :: [String])]` と書かなきゃいけない方ですかね？",
        "user": "U57D08Z9U",
        "type": "message"
    },
    {
        "ts": "1511186718.000555",
        "text": "`:: [Data.Text.Text]`で型指定してみます",
        "user": "U5FTM76CA",
        "type": "message"
    },
    {
        "ts": "1511188624.000417",
        "text": "あ、後説明の都合上Data.Text.Textと書きましたが、 import Data.Text (Text) してモジュール名指定無しで使用することを想定しているのでその辺は都度読み替えていただけるとって感じです :pray: ",
        "user": "U57D08Z9U",
        "type": "message"
    },
    {
        "ts": "1511189777.000469",
        "text": "なるほど分かりました。ありがとうございます。PRは、余裕があればやってみたいと思います。",
        "user": "U4M598NHM",
        "type": "message"
    },
    {
        "ts": "1511250257.000071",
        "text": "Textで型付けしましたが、実行してアクセスすると、eitherRenderにレンダリング不能と出力されました。\n丸投げをお許しください:sweat_drops:（スレッドでソース作れません）\n```\n&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n    &lt;head&gt;\n        &lt;title&gt;{{ title }}&lt;/title&gt;\n    &lt;/head&gt;\n    &lt;body&gt;\n        &lt;h1&gt;{{ title }}&lt;/h1&gt;\n        &lt;ol&gt;\n            {% for food in foods %}\n            &lt;li&gt;{{ food }}&lt;/li&gt;\n            {% endfor %}\n        &lt;/ol&gt;\n    &lt;/body&gt;\n&lt;/html&gt;\n```\n\n```\n{-# LANGUAGE OverloadedStrings #-}\n\nimport Web.Scotty\nimport Text.EDE\nimport Data.Aeson\nimport Data.Text(Text)\n\nmain :: IO()\n\nmain = do\n\n  path &lt;- eitherParseFile \"./html/index.html\"\n\n  let env = fromPairs [(\"title\" :: Text) .= (\"LIST\" :: Text)\n                      ,(\"foods\" :: Text) .= ([\"AA\",\"BB\",\"CC\"] :: [Text])]\n\n  let txt = either error id $ path &gt;&gt;= (`eitherRender` env)\n\n  scotty 3000 $ do\n    get \"/\" $ html txt\n```",
        "user": "U5FTM76CA",
        "type": "message"
    },
    {
        "ts": "1511259666.000281",
        "text": "ちょっと今試せる環境がないのですが、for文のとこは `{% for food in foods %} &lt;li&gt;{{ food.value }}&lt;/li&gt; {% endfor %}` な気がします",
        "user": "U57D08Z9U",
        "type": "message"
    },
    {
        "ts": "1511265202.000345",
        "text": "あ…それですね。",
        "user": "U5FTM76CA",
        "type": "message"
    },
    {
        "ts": "1511353884.000016",
        "text": "出来ました!ありがとうございます",
        "user": "U5FTM76CA",
        "type": "message"
    },
    {
        "ts": "1511427155.000206",
        "text": "<@U84LW224U> has joined the channel",
        "user": "U84LW224U",
        "type": "message"
    },
    {
        "ts": "1511427539.000122",
        "text": "<@U84LW224U> has left the channel",
        "user": "U84LW224U",
        "type": "message"
    },
    {
        "ts": "1511673555.000013",
        "text": "<@U85FBE23C> has joined the channel",
        "user": "U85FBE23C",
        "type": "message"
    },
    {
        "ts": "1511708585.000012",
        "text": "<@U5GP4SCMD> has joined the channel",
        "user": "U5GP4SCMD",
        "type": "message"
    },
    {
        "ts": "1511831458.000006",
        "text": "slack 初心者なんですが、`curl -sSL <https://get.haskellstack.org/> | sh` すると、slack はどこに入りますか？",
        "user": "U56MBRKR9",
        "type": "message"
    },
    {
        "ts": "1511831527.000139",
        "text": "TLS 1.3 に対応した TLS パッケージをHaskellerじゃない人が使いたいそうで、ビルドする方法を書かないといけないの。。。",
        "user": "U56MBRKR9",
        "type": "message"
    },
    {
        "ts": "1511831541.000195",
        "text": "$ curl -sSL <https://get.haskellstack.org/> | grep DEFAULT_DEST\nDEFAULT_DEST=“/usr/local/bin/stack”\n    [ “$DEST” != “” ] || DEST=“$DEFAULT_DEST”",
        "user": "U5G2BCVBN",
        "type": "message"
    },
    {
        "ts": "1511831655.000188",
        "text": "ありがたや。",
        "user": "U56MBRKR9",
        "type": "message"
    },
    {
        "ts": "1511832362.000097",
        "text": "(めちゃくちゃどうでもいいんですけど、slack と stack を typo してますよ(笑))",
        "user": "U56L7EVNY",
        "type": "message"
    },
    {
        "ts": "1511832385.000024",
        "text": "わー。",
        "user": "U56MBRKR9",
        "type": "message"
    },
    {
        "ts": "1511834421.000129",
        "text": "`cabal clean; cabal build` の代わりは `stack clean; stack build` ですか？",
        "user": "U56MBRKR9",
        "type": "message"
    },
    {
        "ts": "1511834467.000108",
        "text": "そうですね",
        "user": "U5G2BCVBN",
        "type": "message"
    },
    {
        "ts": "1511834809.000193",
        "text": "ありがとうございます。",
        "user": "U56MBRKR9",
        "type": "message"
    },
    {
        "ts": "1511836048.000048",
        "text": "<https://github.com/vincenthz/hs-tls/issues/167#issuecomment-263763622>",
        "user": "U56MBRKR9",
        "type": "message"
    },
    {
        "ts": "1511836084.000195",
        "text": "もしお時間があれば、これにパッと目を通していただいて、おかしなところがあれば、ご指摘いただけると嬉しいです。",
        "user": "U56MBRKR9",
        "type": "message"
    },
    {
        "ts": "1511837424.000062",
        "text": "以下コマンド列にて動作を確認しました．\n$ docker run -it --rm debian /bin/bash\n# apt-get update\n# apt-get install -y curl sudo git\n# useradd -m -G users,sudo -s /bin/bash test\n# passwd test\n# su test\n$ cd\n$ curl -sSL <https://get.haskellstack.org/> | sh\n$ which stack\n/usr/local/bin/stack\n$ stack setup\n$ stack ghci\n$ git clone <https://github.com/kazu-yamamoto/hs-tls.git>\n$ cd hs-tls\n$ git checkout -t origin/tls13\n$ stack build\n$ stack exec tls-simpleclient -- --no-valid --http1.1 <http://www.mew.org|www.mew.org> 13443",
        "user": "U5G2BCVBN",
        "type": "message"
    },
    {
        "ts": "1511839022.000114",
        "text": "stackについて、またまた質問です。あるパッケージを stack build するとします。依存しているライブラリは、githubの最新のものをとって来ないといけません。この依存って、どうやって指定するんでしょうか？",
        "user": "U56MBRKR9",
        "type": "message"
    },
    {
        "ts": "1511839078.000227",
        "text": "mighttpd2をビルドする際に、tlsとwarp-tlsの `tls13` ブランチを使わせないといけないのです。",
        "user": "U56MBRKR9",
        "type": "message"
    },
    {
        "ts": "1511839299.000031",
        "text": "<https://qiita.com/tanakh/items/6866d0f570d0547df026#stackyaml%E3%82%92%E7%B7%A8%E9%9B%86%E3%81%99%E3%82%8B>\nにあるとおり、\n```\npackages:\n- some-directory\n- <https://example.com/foo/bar/baz-0.0.2.tar.gz>\n- location:\n    git: git@github.com:commercialhaskell/stack\n    commit: 6a86ee32e5b869a877151f74064572225e1a0398\n```\nのように書いたりできます。",
        "user": "U4LGTMTMK",
        "type": "message"
    },
    {
        "ts": "1511839332.000038",
        "text": "公式ドキュメントはこのあたり <https://docs.haskellstack.org/en/stable/yaml_configuration/#complex-package-locations-location>",
        "user": "U4L0B71L1",
        "type": "message"
    },
    {
        "ts": "1511839478.000174",
        "text": "補足すると、本件の場合 `extra-dep: true` を明記しないと多分ダメですね。\n例\n```\n- location:\n    git: git@github.com:commercialhaskell/stack\n    commit: 6a86ee32e5b869a877151f74064572225e1a0398\n    extra-dep: true\n```\n:sweat: .oO(経験上、外部のリポジトリーを使う場合ほぼ間違いなく `extra-dep: true` するし、デフォルトでそうしてもいい気もしますが。)",
        "user": "U4LGTMTMK",
        "type": "message"
    },
    {
        "ts": "1511839848.000213",
        "text": "`stack 1.6.0` からもう少し簡単になりますよ。",
        "user": "U5B3EGEFQ",
        "type": "message"
    },
    {
        "ts": "1511840091.000088",
        "text": "<https://github.com/commercialhaskell/stack/blob/master/doc/custom_snapshot.md>\n<https://www.fpcomplete.com/blog/2017/07/stacks-new-extensible-snapshots>\n\nこの辺の話です:grinning:",
        "user": "U5B3EGEFQ",
        "type": "message"
    },
    {
        "ts": "1511840212.000246",
        "text": "`extra-deps` の指定はこっちでした。\n<https://github.com/commercialhaskell/stack/blob/master/doc/yaml_configuration.md#packages-and-extra-deps>",
        "user": "U5B3EGEFQ",
        "type": "message"
    },
    {
        "ts": "1511840368.000002",
        "text": "Custom snapshots, 自前で作った新しいバージョンのパッケージの利用とか、GHCの新しいバージョンの利用とかが楽になりますね！ :smile:",
        "user": "U4LGTMTMK",
        "type": "message"
    },
    {
        "ts": "1511840479.000091",
        "text": "git は commit 書かないとダメなんですか？ branch の先頭を使って欲しいんです。",
        "user": "U56MBRKR9",
        "type": "message"
    },
    {
        "ts": "1511840516.000098",
        "text": "強いて言えば `stack clean` 恐らく大抵不要だとは思いますけどね！ :stuck_out_tongue_closed_eyes:",
        "user": "U4LGTMTMK",
        "type": "message"
    },
    {
        "ts": "1511840667.000218",
        "text": "&gt; Note: it is highly recommended that you only use SHA1 values for a Git or Mercurial commit. Other values may work, but they are not officially supported, and may result in unexpected behavior (namely, stack will not automatically pull to update to new versions)\n\n先ほどの公式ドキュメント曰く、だそうです。",
        "user": "U4LGTMTMK",
        "type": "message"
    },
    {
        "ts": "1511841150.000161",
        "text": "tarballのURLでもいいみたいなんで、 <https://github.com/kazu-yamamoto/hs-tls/archive/tls13.tar.gz> みたいなURLを参照させるのはいかがでしょうか？",
        "user": "U4LGTMTMK",
        "type": "message"
    },
    {
        "ts": "1511841215.000053",
        "text": "<https://github.com/kazu-yamamoto/hs-tls/tree/tls13> にある、「Clone or download」というボタンをクリックすると出てくる、「Download ZIP」と書かれたリンクのURLをtar.gzに置き換えたものです。",
        "user": "U4LGTMTMK",
        "type": "message"
    },
    {
        "ts": "1511841321.000091",
        "text": "後は、相対パスを決め打ちしちゃって、都度 `git pull` なりしてもらう、ぐらいですかね。。。",
        "user": "U4LGTMTMK",
        "type": "message"
    },
    {
        "ts": "1511842590.000264",
        "text": "tar.gzを書くと、extra-depsの設定がないとか言われちゃいますね。",
        "user": "U56MBRKR9",
        "type": "message"
    },
    {
        "ts": "1511843064.000049",
        "text": "stack.yamlですが、ターゲットのパッケージのフラグはどのように記述するのでしょうか？ 依存パッケージのフラグは書けるようですが。。。",
        "user": "U56MBRKR9",
        "type": "message"
    },
    {
        "ts": "1511844449.000100",
        "text": "こういう感じのフラグですか？\n<https://github.com/haskell/haskell-ide-engine/blob/master/stack.yaml>",
        "user": "U5B3EGEFQ",
        "type": "message"
    },
    {
        "ts": "1511845343.000183",
        "text": "それですが、stack.yamlを置いてあるパッケージ自体のフラグをどうやって書けばいいのか分かりません。",
        "user": "U56MBRKR9",
        "type": "message"
    },
    {
        "ts": "1511845389.000100",
        "text": "とりあえず、こんな感じになりました。",
        "user": "U56MBRKR9",
        "type": "message"
    },
    {
        "ts": "1511845390.000178",
        "text": "<https://github.com/vincenthz/hs-tls/issues/167#issuecomment-261823286>",
        "user": "U56MBRKR9",
        "type": "message"
    },
    {
        "ts": "1511845482.000096",
        "text": "<@U5G2BCVBN> わざわざありがとうございます！",
        "user": "U56MBRKR9",
        "type": "message"
    },
    {
        "ts": "1511845829.000146",
        "text": "ターゲットのパッケージのフラグを定義するってことですよね\ncabal ファイルがそのまま使えますよ\nstack.yaml はあくまでも依存パッケージなどのバージョンや場所を記述してるだけです(正確にはもっとイロンナことがかけますが…)",
        "user": "U56L7EVNY",
        "type": "message"
    },
    {
        "ts": "1511846321.000091",
        "text": "`stack.yaml` にパッケージ名と好きなフラグを定義して、各パッケージの `.cabal` でそのフラグを使って処理すると思います。\n\n具体的にはこんな感じですか。\n\n```\nflags:\n  tls:\n    compat: true\n    network: true\n  tls-debug:\n    xxxx: true\n```",
        "user": "U5B3EGEFQ",
        "type": "message"
    },
    {
        "ts": "1511846540.000145",
        "text": "<https://github.com/kazu-yamamoto/mighttpd2/blob/tls13/stack.yaml> のことですかね？\nいずれにしてもできたのであればよかったです！",
        "user": "U4LGTMTMK",
        "type": "message"
    },
    {
        "ts": "1511847160.000079",
        "text": "ありがとうございました。",
        "user": "U56MBRKR9",
        "type": "message"
    },
    {
        "ts": "1511847233.000079",
        "text": "<@U56L7EVNY>  cabal ファイルのデフォルトを書き換えることで対応しました。トピックブランチだから、まぁいいやって感じで。",
        "user": "U56MBRKR9",
        "type": "message"
    },
    {
        "ts": "1511851807.000198",
        "text": "<@U4KNU6N48> HRRの質問です。\nRelation型のプレースホルダーはなんのために…あるんですか？\nあと、ドキュメントにある `$(defineTable \"example.db\" \"account\") `の構文を教えてください。",
        "user": "U5FTM76CA",
        "type": "message"
    },
    {
        "ts": "1511863878.000041",
        "text": "個人的には、使いたいリポジトリをプロジェクト直下にsubmodule addしてpackagesに追加しちゃう事が多いですね",
        "user": "U570660KX",
        "type": "message"
    },
    {
        "ts": "1511918366.000197",
        "text": "代わりに知っている範囲で答えちゃいます。\n&gt; Relation型のプレースホルダーはなんのために…あるんですか？\n\nSQLのPrepared Statementsを作るためのものだったかと思います。\n\n&gt; あと、ドキュメントにある `$(defineTable \"example.db\" \"account\") `の構文を教えてください。\n\nTemplate Haskellを使った、型定義の自動生成です、というので答えになってますかね？",
        "user": "U4LGTMTMK",
        "type": "message"
    },
    {
        "ts": "1511936222.000034",
        "text": "Prepared Statements?ですか。\nTemplateHaskellの構文なんですか経験がないのでわかりませんでした。\nありがとうございます:musical_note:",
        "user": "U5FTM76CA",
        "type": "message"
    },
    {
        "ts": "1511947030.000123",
        "text": "プレースホルダについては、SQLそのものに関わる機構なので、まずはSQLについて調べるのがよいかと思います。参考: <https://qiita.com/Morinikiz/items/dfdb33f25df4df0f672c>",
        "user": "U61BA2X0U",
        "type": "message"
    },
    {
        "ts": "1511999996.000326",
        "text": "<@U87FHPYS0> has joined the channel",
        "user": "U87FHPYS0",
        "type": "message"
    },
    {
        "ts": "1512016590.000086",
        "text": "Hakyllの質問です。pygmentizeを走らせたりするためにSystem.ProcessのreadCreateProcessを使ってIO StringをHakyll.Core.CompilerのunsafeCompilerでCompiler Stringに変換して使っていました。Hakyll.Core.UnixFilterのことを知ってそちらの方を使うように書き換えた所、`hGetContents: invalid argument (invalid byte sequence)`と出て上手く使えません。<https://jaspervdj.be/hakyll/tutorials/faq.html> にあるようにE.setLocaleEncoding E.utf8を使おうにも、IOとCompilerでは型が合いません。unixFilterを使うにはどうすればよいでしょうか？",
        "user": "U55UJK1B2",
        "type": "message"
    },
    {
        "ts": "1512019116.000120",
        "text": "FAQにもあるとおり、\n`hakyll` に渡した `do` ブロックじゃなくて `main` 関数の中でやるのはダメなんですかね？\nそれがダメなら、 `compilerUnsafeIO` というのがあるみたいです。 <https://hackage.haskell.org/package/hakyll-4.9.8.0/docs/Hakyll-Core-Compiler-Internal.html#v:compilerUnsafeIO>\nあるいは、 `unixFilterLBS` を使って、 `ByteString` として読んでみてはいかがでしょうか？\n<https://hackage.haskell.org/package/hakyll-4.9.8.0/docs/Hakyll-Core-UnixFilter.html#v:unixFilterLBS>",
        "user": "U4LGTMTMK",
        "type": "message"
    },
    {
        "ts": "1512019205.000089",
        "text": "あ、あと、FAQでは触れてないみたいですが、Windowsであれば `chcp 65001` と言うコマンドを実行すれば回避できます。\nLinuxと違って端末を立ち上げる都度実行しないといけないのが悩ましいですが。。。",
        "user": "U4LGTMTMK",
        "type": "message"
    },
    {
        "ts": "1512020684.000021",
        "text": "返信ありがとうございます！ `unsafeCompiler = compilerUnsafeIO` となっていますね、 `unsafeCompiler (E.setLocaleEncoding E.utf8) &gt;&gt; unixFilter ...` みたいな感じで使うということでしょうか？ `unixFilterLBS` を使うのは確かに手ですね、両方試してみます。",
        "user": "U55UJK1B2",
        "type": "message"
    },
    {
        "ts": "1512035534.000154",
        "text": "お願いしますー",
        "user": "U4L0B71L1",
        "type": "message"
    },
    {
        "ts": "1512035595.000274",
        "text": "ちょっと今試す余裕ないんで自信ないんですが、 ScopedTypeVariablesでなんとかなる？",
        "user": "U4LGTMTMK",
        "type": "message"
    },
    {
        "ts": "1512035629.000139",
        "text": "<@U86V3B4PJ> has joined the channel",
        "user": "U86V3B4PJ",
        "type": "message"
    },
    {
        "ts": "1512036008.000409",
        "text": "`runST` 後の `do` 式の型を明示して `forall s.` して、それを中で使う形ですかね？",
        "user": "U4L0B71L1",
        "type": "message"
    },
    {
        "ts": "1512036062.000571",
        "text": "恐らく。",
        "user": "U4LGTMTMK",
        "type": "message"
    },
    {
        "ts": "1512036284.000208",
        "text": "ホントだすごい\n```\n{-# LANGUAGE ScopedTypeVariables #-}\n\nmodule Main where\n\nimport <http://Control.Monad.ST|Control.Monad.ST>\nimport <http://Data.Array.ST|Data.Array.ST>\n\nmain :: IO ()\nmain = print $ runST st\n\nst :: forall s . ST s Int\nst = do\n  array &lt;- newArray (0, 1) 0 :: ST s (STArray s Int Int)\n  let\n      go :: Int -&gt; ST s Int\n      go = readArray array\n  writeArray array 1 1\n  go 1\n  -- go array 1\n```",
        "user": "U56L7EVNY",
        "type": "message"
    },
    {
        "ts": "1512036320.000041",
        "text": "<@U56L7EVNY> 手柄は譲った！ :bow:",
        "user": "U4LGTMTMK",
        "type": "message"
    },
    {
        "ts": "1512036746.000480",
        "text": "<@U4L0B71L1> さんが質問したのか(笑)\nこんがらがった(笑)\nじゃぁ向こうにも書いておきます",
        "user": "U56L7EVNY",
        "type": "message"
    },
    {
        "ts": "1512037069.000474",
        "text": "DONE",
        "user": "U56L7EVNY",
        "type": "message"
    },
    {
        "ts": "1512040586.000169",
        "text": "<@U56L7EVNY>あ、ですです 分かりにくくてすみません",
        "user": "U4L0B71L1",
        "type": "message"
    },
    {
        "ts": "1512040727.000042",
        "text": "<@U4LGTMTMK> <@U56L7EVNY>ありがとうございました",
        "user": "U4L0B71L1",
        "type": "message"
    },
    {
        "ts": "1512040941.000209",
        "text": "実際に問題になってたコードはもうちょっと複雑だったんですがそちらも同様に解決しました",
        "user": "U4L0B71L1",
        "type": "message"
    },
    {
        "ts": "1512055697.000264",
        "text": "<@U87QYA152> has joined the channel",
        "user": "U87QYA152",
        "type": "message"
    },
    {
        "ts": "1512090076.000238",
        "text": "お騒がせしているstackですが、少し理解できました。依存パッケージだけ見えて、ターゲットのパッケージが見えないのは、\n\n```\npackages:\n- location: .\n```\n\nを書いてないからでした。これは、.cabal ファイルへのパスだと思えばよいのですね。パス状にある .cabal ファイル全ての一覧を取得し、ファイル名をパッケージ名として扱うようです。",
        "user": "U56MBRKR9",
        "type": "message"
    },
    {
        "ts": "1512090496.000312",
        "text": "そうです！ `stack init` とか `stack new` していれば自動でその部分はやってくれるはずですが、一から書いてしまいましたか。。。 :sweat_smile:",
        "user": "U4LGTMTMK",
        "type": "message"
    },
    {
        "ts": "1512090724.000009",
        "text": "試しに`stack.yaml`を決して、`stack init`してみたけど、`stack.yaml`は作られません。",
        "user": "U56MBRKR9",
        "type": "message"
    },
    {
        "ts": "1512091317.000227",
        "text": "フラグの件ですが、`location: .` を加えたら、ターゲットのフラグも指定できるようになったようです。",
        "user": "U56MBRKR9",
        "type": "message"
    },
    {
        "ts": "1512091411.000080",
        "text": "`stack exec foo` で起動される `foo`がどこにあるか調べる方法はないですか？ `stack which foo` とかできればいいのですが。。。",
        "user": "U56MBRKR9",
        "type": "message"
    },
    {
        "ts": "1512091557.000232",
        "text": "うーん、直接調べる方法ではありませんが、\n`stack path --bin-path` して出てくるパスから調べることになりますかね。。。\nあ、 `stack exec which foo` ならいかがでしょうか？",
        "user": "U4LGTMTMK",
        "type": "message"
    },
    {
        "ts": "1512091618.000200",
        "text": "`find .stack-work -name foo` でうまくいかないかなぁ(笑)",
        "user": "U56L7EVNY",
        "type": "message"
    },
    {
        "ts": "1512091696.000004",
        "text": "`stack exec which foo` がよさそう。ありがとうございます。",
        "user": "U56MBRKR9",
        "type": "message"
    },
    {
        "ts": "1512091725.000049",
        "text": "`find` だと、`.stack-work`以外にあるコマンドが起動されていた場合に探せないのです。",
        "user": "U56MBRKR9",
        "type": "message"
    },
    {
        "ts": "1512099810.000091",
        "text": "Prelude の `(^)` の定義が多相になっているため、 `phi^7` などと書くと「Integer に defaulting したよ！」っていう警告が出てしまうんですが `phi^(7 :: Int)` と書く以外に何か回避策ってあるでしょうか？",
        "user": "U61BA2X0U",
        "type": "message"
    },
    {
        "ts": "1512102148.000056",
        "text": "ただ警告を出さないだけなら `-fno-warn-type-defaults` というオプションがあります。ほかに試してみたところでは、 default 宣言を使って `default(Int)` としても警告は出てしまうようです。",
        "user": "U578W9676",
        "type": "message"
    },
    {
        "ts": "1512103037.000013",
        "text": "とりあえず\n`import Prelude hiding ( (^) )`\n`import qualified Prelude as Pre ( (^) )`\n`(^) :: (Num a) =&gt; a -&gt; Int -&gt; a`\n`x ^ y = x Pre.^ y`\nと再定義して回避しました。",
        "user": "U61BA2X0U",
        "type": "message"
    },
    {
        "ts": "1512287930.000010",
        "text": "<@U4M598NHM> 敢えてRedditのスレにしてみたんですが、 <https://www.reddit.com/r/haskell_jp/comments/7h89ey/a_tour_of_go_in_haskell%E3%82%92%E4%BD%9C%E3%81%A3%E3%81%9F%E3%81%AE%E3%81%A8go%E3%81%A8haskell%E3%81%AE%E6%AF%94%E8%BC%83_syocys/> どうなんでしょ？",
        "user": "U4LGTMTMK",
        "type": "message"
    },
    {
        "ts": "1512288609.000031",
        "text": ":naruhodo:",
        "user": "U4M598NHM",
        "type": "message"
    },
    {
        "ts": "1512735206.000045",
        "text": "<@U8CJWHF0E> has joined the channel",
        "user": "U8CJWHF0E",
        "type": "message"
    },
    {
        "ts": "1513162443.000255",
        "text": "<@U8DDVPNGZ> has joined the channel",
        "user": "U8DDVPNGZ",
        "type": "message"
    },
    {
        "ts": "1513232451.000110",
        "text": "Windowsユーザのみなさん、networkパッケージのメインテナーとしての質問です。\ncygwinってもうサポートしなくていいですかね？\nMSYSしかサポートしてないと宣言してもよいですか？",
        "user": "U56MBRKR9",
        "type": "message"
    },
    {
        "ts": "1513232934.000149",
        "text": "私はGHC 7.8ぐらい（stackがサポートしている最も古いGHC）からWindowsで使い始めたので、それより前をサポートしないのであればいいと思います。\nstackは必ずMSYS版GHCを自動でインストールするので。",
        "user": "U4LGTMTMK",
        "type": "message"
    },
    {
        "ts": "1513233510.000076",
        "text": "情報ありがとう！",
        "user": "U56MBRKR9",
        "type": "message"
    },
    {
        "ts": "1513304413.000032",
        "text": "<@U580LD4G7> has joined the channel",
        "user": "U580LD4G7",
        "type": "message"
    },
    {
        "ts": "1513309250.000122",
        "text": "Windowsで、`__OpenBSD__`というCのマクロをチェックしたら、エラーになってしまうんですけど、どうしてなんでしょうか？\n\n<https://ci.appveyor.com/project/eborden/network/build/1.0.182/job/g8lchejtxp4eg120>",
        "user": "U56MBRKR9",
        "type": "message"
    },
    {
        "ts": "1513311185.000116",
        "text": "355行目のディレクティブ，elseifじゃなくてelifじゃないですか？",
        "user": "U5G2BCVBN",
        "type": "message"
    },
    {
        "ts": "1513312046.000053",
        "text": "Bingo!",
        "user": "U56MBRKR9",
        "type": "message"
    },
    {
        "ts": "1513312047.000046",
        "text": "<https://ci.appveyor.com/project/eborden/network/build/1.0.183/job/l39qvaovwb3gf7ch>",
        "user": "U56MBRKR9",
        "type": "message"
    },
    {
        "ts": "1513312063.000013",
        "text": "やったぜ",
        "user": "U5G2BCVBN",
        "type": "message"
    },
    {
        "ts": "1513312071.000099",
        "text": "ありがとうございます！\nありがとうございます！！\nありがとうございます！！！",
        "user": "U56MBRKR9",
        "type": "message"
    },
    {
        "ts": "1513480246.000028",
        "text": "Emacsを使われてる方、教えて下さい。 （急ぎではありません。 かつ返信は遅くなります:bow:）\nEmacsでは、Haskellコードのsyntax highlightに、主に、どういうツールが使われていますか？\n（syntax highlightを修正しようとしています。）",
        "user": "U55V441FS",
        "type": "message"
    },
    {
        "ts": "1513520824.000018",
        "text": "stack初心者の質問です。stackのバージョンを1.5.1から1.6.1にアップグレードしようとすると以下のメッセージが表示されます。\n```\nWARNING: The \"stack\" executable found on the PATH environment variable is /usr/local/bin/stack, and not the version that was just installed.\nThis means that \"stack\" calls on the command line will not use this version.\nNew stack executable available at /Users/shioihiroto/.local/bin/stack\n```\nこれの解決方法はありますか。",
        "user": "U7Z4F723Z",
        "type": "message"
    },
    {
        "ts": "1513521084.000028",
        "text": "たぶん `curl` でインストールする方法だと思いますが、最近その警告が出るようになりました。\n\n古い `stack` が `/usr/local/bin`  に残っていると出たような気がしますが、どうでしょうか？",
        "user": "U5B3EGEFQ",
        "type": "message"
    },
    {
        "ts": "1513521165.000077",
        "text": "`stack upgrade` は `/Users/shioihiroto/.local/bin/stack` に新しいバージョンの `stack` をインストールしたけど、パスは `/usr/local/bin/stack` に通ってるんだけどいいの？\nって感じだから、 `/Users/shioihiroto/.local/bin/stack` のパスを `/usr/local/bin/stack` より優先度上げればいいんじゃない？",
        "user": "U56L7EVNY",
        "type": "message"
    },
    {
        "ts": "1513523529.000003",
        "text": "<@U5B3EGEFQ> /usr/local/binにあったstackファイルを削除したら直りました！\n<@U56L7EVNY> パスの優先度の上げ方がわかりませんでした。。！",
        "user": "U7Z4F723Z",
        "type": "message"
    },
    {
        "ts": "1513523800.000060",
        "text": "`stack` のバージョンが古すぎると `stack upgrade` した時にバイナリが落ちてこない (最新の `stack` をソースコードからコンパイルしだす) ので `/usr/local/bin/stack` を削除します。\n\n逆に新しめの `stack` であれば `stack upgrade` してしまって `export PATH=~/.local/bin:$PATH` を `.bashrc` などに追記しておくと良いと思います。\n\n逆に `export PATH=$PATH:~/.local/bin` にすると常にシステムの `stack` を参照するのではまります。\n\n最新の `stack` の `changelog` を見ると、この問題に対処したように思うのですが、試してないので良くわかってないです。",
        "user": "U5B3EGEFQ",
        "type": "message"
    },
    {
        "ts": "1513523975.000060",
        "text": "昔、インデントをカスタマイズできないかと思ってhaskell-modeの中を見てみたのですが、かなりモノリシックなelispで変えるの無理やんって思った覚えがあります（役に立てず申し訳ない）",
        "user": "U570660KX",
        "type": "message"
    },
    {
        "ts": "1513572069.000086",
        "text": "もう1つ質問です。haskell-jpにて求人募集を出すことはできますか。出す場合にはどのチャンネルが適切でしょうか。（仕事はもちろんhaskellを用いた開発です）。",
        "user": "U7Z4F723Z",
        "type": "message"
    },
    {
        "ts": "1513573852.000111",
        "text": "前例がなく、現状数が増える見込みもないので、\n<https://www.reddit.com/r/haskell_jp/> か <#C4M4TT8JJ|random> か、Haskell-jp Blog <https://haskell.jp/blog/> に投稿するという形でいかがでしょうか。 \n頻度が高くなるようであれば、（Slackにこだわらず）別のチャンネルを検討します。",
        "user": "U4LGTMTMK",
        "type": "message"
    },
    {
        "ts": "1513574646.000210",
        "text": "了解です！ありがとうございます！",
        "user": "U7Z4F723Z",
        "type": "message"
    },
    {
        "ts": "1513582716.000309",
        "text": "<@U8G3R30J0> has joined the channel",
        "user": "U8G3R30J0",
        "type": "message"
    },
    {
        "ts": "1513587850.000329",
        "text": "<@U8G16FA59> has joined the channel",
        "user": "U8G16FA59",
        "type": "message"
    },
    {
        "ts": "1513600533.000013",
        "text": "haskell-mode が、emacsでのsyntax highlightに使われているものなのですね、有難うございます！ \n助かりました、この中を見ていきます:+1:",
        "user": "U55V441FS",
        "type": "message"
    },
    {
        "ts": "1513605910.000075",
        "text": "<https://hackage.haskell.org/package/base-4.10.1.0/docs/Data-Type-Equality.html> の `:~:` って何に使うのでしょうか?どうやって使うのでしょうか?¿ :sob::innocent::sob::oden:",
        "user": "U8G16FA59",
        "type": "message"
    },
    {
        "ts": "1513607081.000289",
        "text": "通常のHaskellプログラミングの範囲ではあまり使用する用途はないと思います．この定義自体はとても単純なので `GADTs` が分かっていれば <https://hackage.haskell.org/package/base-4.10.1.0/docs/Data-Type-Equality.html#t::-126->: の定義そのままの意味を持ちます(つまり， `Refl :: a ~ b =&gt; a :~: b` という唯一のコンストラクタを持ちます)． 単純に考えると， `a :~: b` という型を持つ値があるならば(ボトムを考えなければ) `a ~ b` という命題が真にになります．",
        "user": "U57D08Z9U",
        "type": "message"
    },
    {
        "ts": "1513607398.000346",
        "text": "2つの型が等しいという情報から何らかの実行時リフレクションをしたい場合や型レベルのプログラミングをしたい場合などに役に立ちます(等しいかどうかという情報は非常に重要なので標準の範囲に用意されていますが，型制約についてより汎用的なリフレクションを行いたいなら <https://hackage.haskell.org/package/constraints-0.9.1/docs/Data-Constraint.html#t:Dict> などもあるのでそれを使うと良いと思います． `a :~: b` は `Dict (a ~ b)` と同じです)",
        "user": "U57D08Z9U",
        "type": "message"
    },
    {
        "ts": "1513607551.000539",
        "text": "なお，1つの主な用途としては，下の方にある <https://hackage.haskell.org/package/base-4.10.1.0/docs/Data-Type-Equality.html#t:TestEquality> があり，実行時表現の同値性を使用したリフレクションなどがあります(2つの値があった場合に同じ表現(型)として扱っていいかを実行時に判断する)",
        "user": "U57D08Z9U",
        "type": "message"
    },
    {
        "ts": "1513609365.000637",
        "text": "ついでに，GHCの内部よりの話としての詳細は <https://github.com/ghc/ghc/blob/fe6848f544c2a14086bcef388c46f4070c22d287/compiler/prelude/TysPrim.hs#L581>\nに載っているので，もしリフレクションなどの応用的な話ではなく，GHCの内部的な話に興味があるのでしたら，こちらを読んでみるのがいいと思います．",
        "user": "U57D08Z9U",
        "type": "message"
    },
    {
        "ts": "1513612041.000819",
        "text": "そのものではないのですが、同じ形の型 `Is` がmachinesパッケージで定義されていて、ストリームの入力を指定する手段として使用されています <https://hackage.haskell.org/package/machines-0.6.3/docs/Data-Machine-Process.html>",
        "user": "U570660KX",
        "type": "message"
    },
    {
        "ts": "1513669138.000252",
        "text": "ありがとうございます:sob::sob:\nまだあまりよくわかっていないのですが、GHCiで `:t Refl` とやると `Refl :: a :~: a` と出てくるのですが、 `Refl :: a ~ b =&gt; a :~: b` はどうしてわかるのでしょうか?:scream_cat:",
        "user": "U8G16FA59",
        "type": "message"
    },
    {
        "ts": "1513671215.000201",
        "text": "FFI を Haskell 2010 で使うときは ForeignFunctionInterface プラグマを指定する必要はなくなったんでしたっけ？",
        "user": "U56MBRKR9",
        "type": "message"
    },
    {
        "ts": "1513671253.000051",
        "text": "Haskell 98 には FFI の話はなく、Haskell 2010 では FFI が記載されてますね。",
        "user": "U56MBRKR9",
        "type": "message"
    },
    {
        "ts": "1513671305.000235",
        "text": "ちなみに、Haskell 2010のサポートはGHC 7.0.1から。",
        "user": "U56MBRKR9",
        "type": "message"
    },
    {
        "ts": "1513671995.000009",
        "text": "あ!GADTsが全くわかってませんでした:sob::scream_cat:\n勉強してみます:sob::writing_hand:",
        "user": "U8G16FA59",
        "type": "message"
    },
    {
        "ts": "1513675928.000219",
        "text": "GADTsに関しては、 <http://dev.stephendiehl.com/hask/#gadts-1> が良い導入になっていると思います",
        "user": "U57D08Z9U",
        "type": "message"
    },
    {
        "ts": "1513676234.000072",
        "text": "とりあえずGHCは 7.2.1 から ForeignFunctionInterface が enabled by default になっているようです <https://downloads.haskell.org/~ghc/7.2.1/docs/html/users_guide/ffi.html>",
        "user": "U61BA2X0U",
        "type": "message"
    },
    {
        "ts": "1513695974.000693",
        "text": "おおーありがとうございます:heart_eyes::sob:",
        "user": "U8G16FA59",
        "type": "message"
    },
    {
        "ts": "1513761620.000026",
        "text": "Refl は reflexivity の略ですか?symやtrans はどのように使うの関数なのでしょうか?:oden:",
        "user": "U8G16FA59",
        "type": "message"
    },
    {
        "ts": "1513786759.000076",
        "text": "これですね\n<https://ja.wikipedia.org/wiki/%E5%90%8C%E5%80%A4%E9%96%A2%E4%BF%82#.E5.AE.9A.E7.BE.A9>\nそれぞれ Refl(反射律/reflexivity)，sym(対称律/symmetric)，trans(推移律/transitive)を表しています．つまり，同値関係の基本的な公理となる関数ですね．",
        "user": "U57D08Z9U",
        "type": "message"
    },
    {
        "ts": "1513788568.000754",
        "text": "<@U8HK4CEVB> has joined the channel",
        "user": "U8HK4CEVB",
        "type": "message"
    },
    {
        "ts": "1513788569.000134",
        "text": "Hello. I am slacknowledge bot.\nWhen a thread is added a :memo: (memo) reaction, I will save it.\nEveryone can view the saved thread at <https://slacknowledge.pig-brewing.com> .",
        "user": "U8HK4CEVB",
        "type": "message"
    },
    {
        "ts": "1513789565.000144",
        "text": "質問です :raising_hand: \n[0, 1, 1, 0, 0, 1, 0, … みたいな0と1のリスト（もしくは Array Word32 Word8 とか） があった時にこれをビット列とみなしてByteStringに変換する簡単な方法 or 便利な関数ってありませんか？\n8個ずつchunksして\u00082のn乗を掛けて足してWord8にしてpackするのは思いついたんですが…",
        "user": "U4KPPQW7K",
        "type": "message"
    },
    {
        "ts": "1513790463.000041",
        "text": "このチャンネルでの知見を漁るのが結構大変だなと思い、slack上で行われたQ&amp;Aを保存して検索しやすくするためのbotを作ってみました。\n:memo: が付けられたスレッドを保存します。\nもしよければ使ってみて下さい:grinning:\n\nこのbotに関する問題などあれば私に教えて下さい:bow:",
        "user": "U59TQ3MJ9",
        "type": "message"
    },
    {
        "ts": "1513807811.000452",
        "text": "おー、ありがとうございます。",
        "user": "U56MBRKR9",
        "type": "message"
    },
    {
        "ts": "1513807924.000304",
        "text": "Bool の Array って、ワードでなく、ちゃんとビットで表現されてませんでしたっけ？",
        "user": "U56MBRKR9",
        "type": "message"
    },
    {
        "ts": "1513807967.000061",
        "text": "Windowsの質問ですが、Cのヘッダで32ビットか64ビットか判断する方法はありませんか？",
        "user": "U56MBRKR9",
        "type": "message"
    },
    {
        "ts": "1513816444.000164",
        "text": "`_WIN64`とか `_WIN32`とかのcompiler predefinedマクロに頼らずにってことですか？",
        "user": "U5G2BCVBN",
        "type": "message"
    },
    {
        "ts": "1513816531.000068",
        "text": "あ、`_WIN64` ってあるんですね。やってみます。",
        "user": "U56MBRKR9",
        "type": "message"
    },
    {
        "ts": "1513817093.000132",
        "text": "うぉー。できた。ありがとうございます！",
        "user": "U56MBRKR9",
        "type": "message"
    },
    {
        "ts": "1513817155.000033",
        "text": ":+1:",
        "user": "U5G2BCVBN",
        "type": "message"
    },
    {
        "ts": "1513817550.000040",
        "text": "`mingw32_HOST_OS` が定義されていたら、 `winsock2.h` は存在すると仮定してもいいですか？ (network パッケージ、過去の遺産が降り積もっていて、泣きそうです。)",
        "user": "U56MBRKR9",
        "type": "message"
    },
    {
        "ts": "1513818723.000140",
        "text": "networkパッケージてC部分のコンパイル時にconfigureしてませんでしたっけ？ヘッダ(や，その他ライブラリ等)の存在確認がしたいならAC_CHECK_HEADERSとか使えば実際にconfigure時に確認してマクロをdefineできるんじゃないですか？",
        "user": "U5G2BCVBN",
        "type": "message"
    },
    {
        "ts": "1513819036.000019",
        "text": "Array# …でしょうか。\n<https://hackage.haskell.org/package/ghc-prim-0.5.1.0/docs/GHC-Prim.html#t:Array-35->\nどうやってByteStringに変換したら良いのかわからなくて詰まってしまいましたorz",
        "user": "U4KPPQW7K",
        "type": "message"
    },
    {
        "ts": "1513825837.000022",
        "text": "FFI には\n- UNIX 用の ccall\n- Win32 用の stdcall\nが定義してあるんですが、Win64用にはないんですよ。\nで、GHC はWin64上では ccall/stdcallどちらを指定しても、Win64用のABIを使うようです。しかし、stdcallを指定しいると、警告が出てうるさいです。\nなので、Win32だとstdcall、Win64だとccallにしたかったのでした。",
        "user": "U56MBRKR9",
        "type": "message"
    },
    {
        "ts": "1513825882.000128",
        "text": "警告はたったこれだけになった。\n<https://ci.appveyor.com/project/eborden/network/build/1.0.240/job/apgyl5iycnn3ab54>",
        "user": "U56MBRKR9",
        "type": "message"
    },
    {
        "ts": "1513825915.000060",
        "text": "一つ、stdcallの警告が残っているけど、それは取れます。あとは、Haskell的な警告をなくすだけ。",
        "user": "U56MBRKR9",
        "type": "message"
    },
    {
        "ts": "1513826001.000051",
        "text": "現在、どちらのマクロも使えるんですが、使い分けの基準が分かりません。同じ意味なら、どちらかに統一したいのです。",
        "user": "U56MBRKR9",
        "type": "message"
    },
    {
        "ts": "1513827706.000049",
        "text": "どちらのって何と何ですか？",
        "user": "U5G2BCVBN",
        "type": "message"
    },
    {
        "ts": "1513828960.000022",
        "text": "`mingw32_HOST_OS` と `winsock2.h` が存在するときに定義される `HAVE_WINSOCK2_H` です。",
        "user": "U56MBRKR9",
        "type": "message"
    },
    {
        "ts": "1513831275.000177",
        "text": "`mingw32_HOST_OS` であっても，includeパスがおかしいとかでconfigure時に見えてないような事態も考えられるので `winsock2.h` のincludeでは `HAVE_WINSOCK2_H` も見るようにしたほうがいいです．どちらかに統一というか `#ifdef mingw32_HOST_OS` → `#ifdef HAVE_WINSOCK2_H` → `#include &lt;winsock2.h&gt;`のように包含関係になるような感じじゃないかと",
        "user": "U5G2BCVBN",
        "type": "message"
    },
    {
        "ts": "1513831283.000005",
        "text": "`Data.Array.Base` を読み込むと `UArray Int Bool` に対して `ByteArray#` を取り出せるので、後はなんとかなりませんかね？",
        "user": "U56MBRKR9",
        "type": "message"
    },
    {
        "ts": "1513831625.000041",
        "text": "ありがとうございます！\n`ByteArray#` について調べてる途中で UArray がByteArrayAccessのインスタンスになってることに気づいて convert を使えば思ってたことができそうです :bow: 詳しい実装もコードを読んで勉強してみます :pray: \n<https://hackage.haskell.org/package/memory-0.14.10/docs/Data-ByteArray.html#v:convert>",
        "user": "U4KPPQW7K",
        "type": "message"
    },
    {
        "ts": "1513831888.000206",
        "text": "Windows で `winsock2.h` が見えないときは、どのみちエラーにすべきなので、`mingw32_HOST_OS` だけでよくないですかね？",
        "user": "U56MBRKR9",
        "type": "message"
    },
    {
        "ts": "1513831989.000149",
        "text": "ああ、`convert` 使ってもいいなら、それが便利ですね。",
        "user": "U56MBRKR9",
        "type": "message"
    },
    {
        "ts": "1513832019.000032",
        "text": "UArray Int Bool が、本当にビット列をパックしているかは、確かめてください。",
        "user": "U56MBRKR9",
        "type": "message"
    },
    {
        "ts": "1513833496.000094",
        "text": "エラーの発報の観点から話をするなら，理想的には判明時点で早々に発報すべきです．その最速判明タイミングとはconfigure時点であり， `AC_CHECK_HEADERS` の `action-if-not-found` ケースでエラーにすることもできます．",
        "user": "U5G2BCVBN",
        "type": "message"
    },
    {
        "ts": "1513836299.000022",
        "text": "なるほど。",
        "user": "U56MBRKR9",
        "type": "message"
    },
    {
        "ts": "1513836323.000090",
        "text": "早期発見の努力はするとして、コードの方は、どっちかに統一してもいいですよね？",
        "user": "U56MBRKR9",
        "type": "message"
    },
    {
        "ts": "1513836725.000113",
        "text": "そちらは統一していない意図がわからないの恐らく…としか言えないですね．",
        "user": "U5G2BCVBN",
        "type": "message"
    },
    {
        "ts": "1513836861.000037",
        "text": "ええ、デッドコードです。今まで誰も手につけられなかったのです。僕がやらなければ、今後誰もやらないでしょう。",
        "user": "U56MBRKR9",
        "type": "message"
    },
    {
        "ts": "1513848486.000059",
        "text": "<@U4LGTMTMK> set the channel topic: お悩み相談専用チャンネル。回答は原則スレッド機能でやりましょう。複数の質問を同時に投稿しやすくするための配慮です。過去の質問は <https://slacknowledge.pig-brewing.com/> から。",
        "user": "U4LGTMTMK",
        "type": "message"
    },
    {
        "ts": "1513848500.000255",
        "text": "<@U4LGTMTMK> set the channel topic: お悩み相談専用チャンネル。回答は原則スレッド機能でやりましょう。複数の質問を同時に投稿しやすくするための配慮です。過去に :memo: された質問は <https://slacknowledge.pig-brewing.com/> から。",
        "user": "U4LGTMTMK",
        "type": "message"
    },
    {
        "ts": "1514091345.000040",
        "text": "Lazy I/O の readFile について resource exhausted (Too many open files) という例外を再現しようとして，\n\n```\nmain = readFile \"file_list.txt\" &gt;&gt;= mapM_ (readFile &gt;=&gt; print . length) . lines\n```\n\nというプログラムを書いて ghc-8.2.2 でコンパイルし実行してみたのですが，再現できませんでした．file_list.txt には10万個のファイル名が書いてあり，カレントディレクトリにその10万個のファイルがあります．どうすれば再現できるのでしょうか？．なにか勘違いしている可能性があります．指摘していただければ幸いです．",
        "user": "U4KU9ABL0",
        "type": "message"
    },
    {
        "ts": "1514091572.000010",
        "text": "推測ですが、 `length` だと全部読んで（そして自動で閉めて）しまいそうですし、 `take 1` とかしてみるのはいかがでしょうか？",
        "user": "U4LGTMTMK",
        "type": "message"
    },
    {
        "ts": "1514091725.000047",
        "text": "take 1 でも問題なく実行できるようです。",
        "user": "U4KU9ABL0",
        "type": "message"
    },
    {
        "ts": "1514091977.000007",
        "text": "`ulimit` でファイルディスクリプタ数の限界( `-n` オプション)を小さく設定した上で， `take 1` で実行してみてください．",
        "user": "U5G2BCVBN",
        "type": "message"
    },
    {
        "ts": "1514092181.000052",
        "text": "なるほど、ulimit -n 32 とすると再現できました。ありがとうございます。",
        "user": "U4KU9ABL0",
        "type": "message"
    },
    {
        "ts": "1514092389.000061",
        "text": "デフォルトではファイルディスクリプタの上限が 1048576 になっていました。",
        "user": "U4KU9ABL0",
        "type": "message"
    },
    {
        "ts": "1514167677.000069",
        "text": "昔(Linuxカーネルが2.4とかの頃)はファイルディスクリプタの変化を待つシステムコールがselectしかなかったので、上限も自ずと1024くらいの小さい値だったのが、今はepollとかがあるので大量のファイルディスクリプタが扱えるということですかね",
        "user": "U61BA2X0U",
        "type": "message"
    },
    {
        "ts": "1514183838.000052",
        "text": "<@U8JGMG1QT> has joined the channel",
        "user": "U8JGMG1QT",
        "type": "message"
    },
    {
        "ts": "1514188382.000068",
        "text": "pollも思い出してあげて下さい。\n上限を引き上げたのはこの子です。",
        "user": "U56MBRKR9",
        "type": "message"
    },
    {
        "ts": "1514269396.000072",
        "text": "また、教えて君です :slightly_smiling_face:\n型シノニムを使用するとき、宣言時のアリティを満さなければならないのですが、そうなっている理由について、いまだに、よくわからないでいます。\nそのような制限がないとどのようなことが起こるのでしょうか。",
        "user": "U4KU9ABL0",
        "type": "message"
    },
    {
        "ts": "1514272657.000123",
        "text": "これのことでしょうか？\n<https://stackoverflow.com/questions/4922560/why-doesnt-typesynonyminstances-allow-partially-applied-type-synonyms-to-be-use>\n\npartial applyのことなら，type checkがundecidableになるので，Haskellの派生系でも許可してるものは見かけないですね",
        "user": "U57D08Z9U",
        "type": "message"
    },
    {
        "ts": "1514273931.000060",
        "text": "type check が undecidable になるというところが、良くわからないのです。",
        "user": "U4KU9ABL0",
        "type": "message"
    },
    {
        "ts": "1514274715.000097",
        "text": "type synonymは一種の型関数ですから， `type A a = B a a` という型関数において，型クラス `C :: * -&gt; *` のインスタンスとして `instance C A where` という定義があった時に，最終的にインスタンスを決める時に `(\\a -&gt; B a a) ~ A` をどうやって判定するかという問題になります．このような問題は，一般に実際に全ての値に対して返り値が一致しているかという方法で判断しますが，これをチェックするのは通常難しいですね．\n\n例に出したものだと単純なので決定的にできるかもしれませんが，上のstack overflowの例でこの問題を考えてみた場合，納得がいくと思います",
        "user": "U57D08Z9U",
        "type": "message"
    },
    {
        "ts": "1514275183.000011",
        "text": "すみません。「最終的にインスタンスを決める時に `(\\a a -&gt; B a a) ~ A` をどうやって判定するかという問題になります」の部分がよく判からないでいます。",
        "user": "U4KU9ABL0",
        "type": "message"
    },
    {
        "ts": "1514275561.000194",
        "text": "例えば， `type A2 a = B a a` というのがあった時に， `A2 ~ A` なので `C A2` という制約は `instance C A` から成り立つはずです．これをどう判定するかということですね",
        "user": "U57D08Z9U",
        "type": "message"
    },
    {
        "ts": "1514275625.000158",
        "text": "s/ `\\a a -&gt; B a a` / `\\a -&gt; B a a` / でした",
        "user": "U57D08Z9U",
        "type": "message"
    },
    {
        "ts": "1514275776.000042",
        "text": "A2 ~ A が判定できないということですか？",
        "user": "U4KU9ABL0",
        "type": "message"
    },
    {
        "ts": "1514276358.000064",
        "text": "まあ一般にはその判定( `forall a :: *. A2 a ~ A a` が成り立つかどうか)が undecidable だということですね．この例の場合はdecidableにするアルゴリズムがあるかもしれません(なので，今回の場合はできるかもしれません)が，これを一般の場合で考えた場合(例えば，ブール論理を埋め込んだstack overflowの例の場合)，それを判定する決定的なアルゴリズムを構築するのが困難だということです",
        "user": "U57D08Z9U",
        "type": "message"
    },
    {
        "ts": "1514276696.000110",
        "text": "stack overflow の例でいうと、Not True ~ False を示すのが困難ということになりますか。",
        "user": "U4KU9ABL0",
        "type": "message"
    },
    {
        "ts": "1514276775.000030",
        "text": "そうです",
        "user": "U57D08Z9U",
        "type": "message"
    },
    {
        "ts": "1514279927.000109",
        "text": "ううむ。外延的に決定するしかないとすれば、そうなのかな。",
        "user": "U4KU9ABL0",
        "type": "message"
    },
    {
        "ts": "1514281265.000202",
        "text": "あまりパッといい文献を出せませんが，もし気になるならeta expansion problemsなどで調べてみると，いいかもしれません",
        "user": "U57D08Z9U",
        "type": "message"
    },
    {
        "ts": "1514283115.000038",
        "text": "ありがとうございます。",
        "user": "U4KU9ABL0",
        "type": "message"
    },
    {
        "ts": "1514323843.000124",
        "text": "<@U5GP4SCMD> uploaded a file: <https://haskell-jp.slack.com/files/U5GP4SCMD/F8JPH5R5W/____________________________2017-12-27_06.04.08.png|nix で slack をインストールしようとしてコケました> and commented: nix-env -iA nixpkgs.stack とすると図のように、\n\nVariable not in scope:\n       hSetBuffering :: Handle -&gt; BufferMode -&gt; IO a0\n\nと出てしまいます。",
        "user": "U5GP4SCMD",
        "type": "message"
    },
    {
        "ts": "1514324720.000182",
        "text": "結局 slack は他の手段で （nix 使わないで）インストールしてしまったのですが、上記はどうしたものかなぁと",
        "user": "U5GP4SCMD",
        "type": "message"
    },
    {
        "ts": "1514327658.000028",
        "text": "話をちゃんと理解してませんが、シノニムの部分適用を許すと実質的に型レベルのラムダを許すことになり、高階単一化の決定不能性が問題になる、という話ではないかな、多分。",
        "user": "U4MA78F6X",
        "type": "message"
    },
    {
        "ts": "1514333197.000059",
        "text": "<@U4L0B71L1> commented on <@U5GP4SCMD>’s file <https://haskell-jp.slack.com/files/U5GP4SCMD/F8JPH5R5W/____________________________2017-12-27_06.04.08.png|nix で slack をインストールしようとしてコケました>: stack? slack?",
        "user": null,
        "type": "message"
    },
    {
        "ts": "1514333272.000006",
        "text": "「ラムダ抽象の高階単一化の決定不能性」について調べてみます。なにかお勧めの文献ありますか？",
        "user": "U4KU9ABL0",
        "type": "message"
    },
    {
        "ts": "1514334128.000079",
        "text": "ああ、Agdaの実装になんかあった気がする。",
        "user": "U4KU9ABL0",
        "type": "message"
    },
    {
        "ts": "1514334681.000010",
        "text": "<@U5GP4SCMD> commented on <@U5GP4SCMD>’s file <https://haskell-jp.slack.com/files/U5GP4SCMD/F8JPH5R5W/____________________________2017-12-27_06.04.08.png|nix で slack をインストールしようとしてコケました>: stackでした :sweat_smile:",
        "user": null,
        "type": "message"
    },
    {
        "ts": "1514340938.000037",
        "text": "昔同じようなことを書いた記憶があると思ったら……\n<http://chaton.practical-scheme.net/haskell-ja/a/2011/12/02>\n<http://chaton.practical-scheme.net/haskell-ja/a/2011/12/07>\n<http://chaton.practical-scheme.net/haskell-ja/a/2011/12/08>\n<http://chaton.practical-scheme.net/haskell-ja/a/2011/12/09>\n<http://chaton.practical-scheme.net/haskell-ja/a/2011/12/10>\n<http://chaton.practical-scheme.net/haskell-ja/a/2011/12/11>\n<http://chaton.practical-scheme.net/haskell-ja/a/2011/12/13>",
        "user": "U4MA78F6X",
        "type": "message"
    },
    {
        "ts": "1514342043.000013",
        "text": "うへぇ。私6年間まったく進歩してない（どころか退化している）ことが晒されたぁ。orz\n勉強しなおしだ。",
        "user": "U4KU9ABL0",
        "type": "message"
    },
    {
        "ts": "1514344934.000032",
        "text": "なんか壊れたバージョンを間違ってビルドしてしまったんですかね。。。\nそれにしても不思議ですね。。。そもそもなんでわざわざソースからインストールしてるんだろう。。。 \n:thinking_face:",
        "user": "U4LGTMTMK",
        "type": "message"
    },
    {
        "ts": "1514346236.000098",
        "text": "<@U4MA78F6X> すいません，ラムダの等価性判定でeta expansionがうまくできない場合があるって話を聞いたことがあって勘違いしてましたが，injectivityの問題なんですね．これってつまり，Injectivityがうまく追跡できれば，f a ~ f b =&gt; a ~ bの展開が(安全に)できるってことなんですよね．",
        "user": "U57D08Z9U",
        "type": "message"
    },
    {
        "ts": "1514346407.000002",
        "text": "injectivityが辿れれば，ラムダのunifyはうまくいくということなんですかね？",
        "user": "U57D08Z9U",
        "type": "message"
    },
    {
        "ts": "1514347190.000017",
        "text": "Oh…12/2のしか見てませんでした．すいません忘れてください",
        "user": "U57D08Z9U",
        "type": "message"
    },
    {
        "ts": "1514382702.000119",
        "text": "同じような `issue` 立ちましたね。\n<https://github.com/commercialhaskell/stack/issues/3713>",
        "user": "U5B3EGEFQ",
        "type": "message"
    },
    {
        "ts": "1514439802.000020",
        "text": ":point_up: のissue、もうcloseされましたね。言及している方のissueももう解決したみたいですし、今ならいいのかも。",
        "user": "U4LGTMTMK",
        "type": "message"
    },
    {
        "ts": "1514447700.000194",
        "text": "<@U8EJKMNVA> has joined the channel",
        "user": "U8EJKMNVA",
        "type": "message"
    },
    {
        "ts": "1514449383.000238",
        "text": "<@U4LGTMTMK> pinned a message to this channel.",
        "user": "U4LGTMTMK",
        "type": "message"
    },
    {
        "ts": "1514450354.000056",
        "text": "<#C8KBGEBR7|code-review> で少し触れたのですが、\nテストフレームワークはみなさん何がおすすめですかね？個人的にはHSpecをずっと使っていて、この間HUnitを使わざるを得ない状況になったので使ってみたら、HSpecに慣れすぎていたせいか、ものすごく書きにくかったように覚えていまして。。。",
        "user": "U4LGTMTMK",
        "type": "message"
    },
    {
        "ts": "1514451124.000116",
        "text": "過去のコードを読んでいたら ` \\u -&gt; return(u,u) ` というのを見つけたんですが、こういうのってArrowで書くべきなんですかね",
        "user": "U8EJKMNVA",
        "type": "message"
    },
    {
        "ts": "1514451244.000229",
        "text": "そのあたりは劇的にコードを短くしたりわかりやすくしたりするものでもないので、覚えていたら、程度でいいと思いますよ。",
        "user": "U4LGTMTMK",
        "type": "message"
    },
    {
        "ts": "1514771614.000027",
        "text": "いつもtasty-hspecとdoctestを使ってます！",
        "user": "U5LV76EJH",
        "type": "message"
    },
    {
        "ts": "1514967685.000066",
        "text": "<@U8LLBJ59Q> has joined the channel",
        "user": "U8LLBJ59Q",
        "type": "message"
    },
    {
        "ts": "1514981592.000140",
        "text": "これって現状， `RecordWildCards` に対応してないって認識でいいんですかね？なんか対応してない理由とかあるんすかね？(field punsは対応してそうなんですよね)\n<https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#record-pattern-synonyms>",
        "user": "U57D08Z9U",
        "type": "message"
    },
    {
        "ts": "1514981811.000257",
        "text": "いちよ，使えるんですかね？ `name-shadowing` 警告が出るけど…",
        "user": "U57D08Z9U",
        "type": "message"
    },
    {
        "ts": "1515146591.000078",
        "text": "ExcelのRATE関数相当品が、どこかに転がっていないですかね・・・\n<http://www.excel-list.com/rate.html>",
        "user": "U87QYA152",
        "type": "message"
    },
    {
        "ts": "1515228730.000034",
        "text": "超遅レスですが、名前はequality constraintsですね。\n<https://downloads.haskell.org/~ghc/8.2.1/docs/html/users_guide/glasgow_exts.html#equality-constraints>",
        "user": "U59TQ3MJ9",
        "type": "message"
    },
    {
        "ts": "1515309334.000036",
        "text": "<@U88NRUX26> has joined the channel",
        "user": "U88NRUX26",
        "type": "message"
    },
    {
        "ts": "1515446598.000160",
        "text": "「チャンス」なんてリアクションがあるんですね。結局自前で実装しました。\nと言ってもJavaでの実装を見つけたので、それをHaskellに移植しただけですが。",
        "user": "U87QYA152",
        "type": "message"
    },
    {
        "ts": "1515447187.000513",
        "text": "Excel/Java/Haskellそれぞれで微妙に結果が異なるのですが、原因が分からず・・・まあ誤差と言ってもいい程度の差異ではあるのですが。",
        "user": "U87QYA152",
        "type": "message"
    },
    {
        "ts": "1515482874.000074",
        "text": "このために作りましたw :commit: :chance: \n<https://emoji.pine.moe/#!/> を使っています。",
        "user": "U4LGTMTMK",
        "type": "message"
    },
    {
        "ts": "1515486530.000175",
        "text": "JavaScript で Prettier というフォーマッターを最近使っているのですが、これ保存時に自動的かつ強制的にコードのフォーマットを統一してくるんですね。細かいこだわりとかが無視されてしまうものの、フォーマットを気にしなくて良くなるというユーザ体験はかなり良かったので Haskell 開発でも同じようなことをやってみたいと思っています。\n\nおそらくエディタの保存フックで hfmt や brittany などを走らせればいいと思うのですが、そのようなことをやっている人はいますか？ 設定を伺いたいです(できれば Spacemacs か Emacs)。",
        "user": "U4M598NHM",
        "type": "message"
    },
    {
        "ts": "1515488335.000011",
        "text": "Elm はフォーマットがかっちり決まってるのもあって 、VS Code 使ってましたが、保存時フォーマットの設定ありましたね（自分は JetBrains 製品に慣れてて VS Code でも自動保存してるせいで、手動フォーマット適用にしてましたが）\nフォーマットを気にしなくていいというのが楽というのは同意です",
        "user": "U4L0B71L1",
        "type": "message"
    },
    {
        "ts": "1515489556.000516",
        "text": "HIE にいちおう brittany を呼び出す仕組みがあるっぽいけど\n<https://github.com/haskell/haskell-ide-engine/blob/master/README.md#features>",
        "user": "U56L7EVNY",
        "type": "message"
    },
    {
        "ts": "1515508805.000825",
        "text": "haskell-ide-engineは未調査でした。近々 Emacs で使いやすくなりそう！ <https://github.com/haskell/haskell-ide-engine/issues/338>",
        "user": "U4M598NHM",
        "type": "message"
    },
    {
        "ts": "1515556200.000112",
        "text": "hfmtを試してみましたが、#ifdef とか .hsc には対応してないんですね。残念すぎる。",
        "user": "U56MBRKR9",
        "type": "message"
    },
    {
        "ts": "1515572728.000158",
        "text": "私はCloudFunctionsを用いたイベント駆動型のサーバーレス設計が好きです。Haskellにそのようなサービスはありますか？",
        "user": "U6M886B2M",
        "type": "message"
    },
    {
        "ts": "1515572828.000051",
        "text": "求めているものかどうか確信が持てませんが、ちょうど今日こんなパッケージを見つけました <https://github.com/seek-oss/serverless-haskell>",
        "user": "U4LGTMTMK",
        "type": "message"
    },
    {
        "ts": "1515574154.000258",
        "text": "Lambdaの方はこういったことができるんですね、ありがとうございます。",
        "user": "U6M886B2M",
        "type": "message"
    },
    {
        "ts": "1515594395.000305",
        "text": "私も山下さんと会うたびにこの話をしている気がするのですが、KindSignature を明示させるようにすれば、決定不能を避けることができたりはしないのでしょうか。\nそれでうまくいくのなら、GHC に拡張を提案するのが良いのではないかと思っています。",
        "user": "U4KNU6N48",
        "type": "message"
    },
    {
        "ts": "1515601419.000154",
        "text": "<@U6JPU2DD2> has joined the channel",
        "user": "U6JPU2DD2",
        "type": "message"
    },
    {
        "ts": "1515715777.000138",
        "text": "これはよさそうですね。早速試してみたいと思います。",
        "user": "U87QYA152",
        "type": "message"
    },
    {
        "ts": "1515716339.000214",
        "text": "mtlパッケージのReaderTに、 `k` という見慣れない型パラメーターがあるのを見つけたんですが、これは一体何のためのパラメーターで、使用する際型宣言ではどう書けばいいのでしょうか？\n<https://hackage.haskell.org/package/mtl-2.2.1/docs/Control-Monad-Reader.html#t:ReaderT> \nまぁ、 kindの宣言を見る限り継続っぽい何かであることは察せられるんですが。。。",
        "user": "U4LGTMTMK",
        "type": "message"
    },
    {
        "ts": "1515723567.000161",
        "text": "Haddock のバージョンが上がったのか詳細は知らないんですが `newtype` でのカインドが明示されるようになったみたいですね",
        "user": "U4L0B71L1",
        "type": "message"
    },
    {
        "ts": "1515726275.000014",
        "text": "ソース読んでみたらControl.Monad.Trans.Readerからreexportしていて、reexport元のControl.Monad.Trans.Readerではそうなってなかったので、何か使っている拡張が関係している気がしてきました。\n<https://hackage.haskell.org/package/transformers-0.5.5.0/docs/Control-Monad-Trans-Reader.html>",
        "user": "U4LGTMTMK",
        "type": "message"
    },
    {
        "ts": "1515726340.000008",
        "text": "ReaderTの定義が\n\n```\nnewtype ReaderT r m a = ReaderT (r -&gt; m a)\n```\n\nなので、実は `m a` が `*` でさえあれば `m :: * -&gt; *` と `a :: *` 以外でも値を作れますよ、っていう話ですね。\nなので　 `m :: k -&gt; *` と `a :: k` に一般化されていると。\n\n<https://haskell.jp/blog/posts/2017/10-about-kind-system-part1.html> の「種多相」節に書いてある。",
        "user": "U570660KX",
        "type": "message"
    },
    {
        "ts": "1515726435.000003",
        "text": "とはいえ、MonadをはじめとするReaderTのインスタンスはk=*の場合しか定義されないので、一般化されたReaderTを何に使うのかは良く分からないです",
        "user": "U570660KX",
        "type": "message"
    },
    {
        "ts": "1515726494.000061",
        "text": "transformersのChangelogによると、0.5からPolyKinded対応したとの事なので、ここで各クラスがまとめて種多相になったっぽい？",
        "user": "U570660KX",
        "type": "message"
    },
    {
        "ts": "1515727203.000090",
        "text": "続けて済みません、 :point_up: の質問に関連してtransformersのドキュメントを読んでいたんですが、\nSelectT と AccumT というこれまた見慣れないMonad Transformersができているのに気づきました。\n<https://hackage.haskell.org/package/transformers-0.5.5.0/docs/Control-Monad-Trans-Select.html>\n<https://hackage.haskell.org/package/transformers-0.5.5.0/docs/Control-Monad-Trans-Accum.html>\nそれぞれ何のためのものかご存じでしょうか？\n特にぱっとソースを読んでみた感じ、AccumTはLazy WriterTと何が違うねん、という感じでした。。。 :cold_sweat:",
        "user": "U4LGTMTMK",
        "type": "message"
    },
    {
        "ts": "1515727300.000075",
        "text": "あ、ごめんなさい `AccumT` については自己解決しました。\n\n```\nThis monad transformer is similar to both state and writer monad transformers. Thus it can be seen as\n\na restricted append-only version of a state monad transformer or\na writer monad transformer with the extra ability to read all previous output.\n```\nと書いてあるとおりですね！",
        "user": "U4LGTMTMK",
        "type": "message"
    },
    {
        "ts": "1515727448.000053",
        "text": "まぁ、 `SelectT` については張ってある論文読めって感じですかね。。。",
        "user": "U4LGTMTMK",
        "type": "message"
    },
    {
        "ts": "1515727773.000243",
        "text": " set up a reminder “https://haskell-jp.slack.com/archives/C5666B6BB/p1513788569000134” in this channel at 10AM every Friday, Japan Standard Time.",
        "user": "U4LGTMTMK",
        "type": "message"
    },
    {
        "ts": "1515727944.000009",
        "text": "有用そうな質問は積極的に :memo: していきたいですが、ついつい忘れてしまうので取り急ぎ <https://haskell-jp.slack.com/archives/C5666B6BB/p1513788569000134> のメッセージを定期リマインダーに追加しました。\nとりあえず毎週金曜日で。",
        "user": "U4LGTMTMK",
        "type": "message"
    },
    {
        "ts": "1515731534.000002",
        "text": "Win32 な環境で、FFI に stdcall ではなく ccall と書くと何が起きますか？\nときどき ccall を使っているコードを見かけるのですが、大丈夫なのでしょうか？\nちなみに、Win64だとccallと書くと適切なABIを使うようです。\nstdcallと書いても適切なABIを使いますが、無意味に警告が出ます。",
        "user": "U56MBRKR9",
        "type": "message"
    },
    {
        "ts": "1515738921.000036",
        "text": "`stack.yaml` で指定してるsolver以外のdb情報などを `.stack-work` から消してくれる `stack` のサブコマンドってあったりしますかね？",
        "user": "U57D08Z9U",
        "type": "message"
    },
    {
        "ts": "1515739828.000083",
        "text": "`stack clean` では不足ってことですよね。。。",
        "user": "U4LGTMTMK",
        "type": "message"
    },
    {
        "ts": "1515744001.000315",
        "text": "`clean` だと全部消しちゃいませんか？",
        "user": "U57D08Z9U",
        "type": "message"
    },
    {
        "ts": "1515744188.000265",
        "text": "正確に把握してませんが、 `stack clean --help` 曰く\n`local package` だけなので自分で作った（cabalファイルに書いた）パッケージだけではないかと認識しています。\nあとは `extra-dependencies` としてビルドしたものぐらい？",
        "user": "U4LGTMTMK",
        "type": "message"
    },
    {
        "ts": "1515744240.000048",
        "text": "おう，そもそも `clean` はビルド生成物だけを消すコマンドなんですね．ビルド生成物を消したいわけじゃなくて，hoogle dbとか各ltsごとに保持しているパッケージ情報を消したいです",
        "user": "U57D08Z9U",
        "type": "message"
    },
    {
        "ts": "1515744750.000012",
        "text": "もしかして、 `.stack-work` 以下に各resolverのコンパイル済みパッケージが入ると勘違いしてませんか...?\n実際には `~/.stack/` 以下のはずです。\nその辺はcabal sandboxから改善されているはずなので。。。",
        "user": "U4LGTMTMK",
        "type": "message"
    },
    {
        "ts": "1515744827.000054",
        "text": "うーんでも， 200M ぐらいあるので…",
        "user": "U57D08Z9U",
        "type": "message"
    },
    {
        "ts": "1515744997.000266",
        "text": "そういえば、と思って自分も手元のプロジェクトを見てみたら、334MBもあったw\nそして `du -hs` で掘ってみた感じ、どうも自分のパッケージをビルドしてできる\n`.stack-work/dist/x86_64-linux` 以下が主にとっているみたいですね。。。",
        "user": "U4LGTMTMK",
        "type": "message"
    },
    {
        "ts": "1515745069.000050",
        "text": "あ、と思ったら `.stack-work/install` 以下も結構とってるな。。。",
        "user": "U4LGTMTMK",
        "type": "message"
    },
    {
        "ts": "1515745160.000166",
        "text": "主に消したいのは `.stack-work/install` 以下の使わないlts分のものですね",
        "user": "U57D08Z9U",
        "type": "message"
    },
    {
        "ts": "1515745193.000006",
        "text": "あってもおかしく無いと思ったんですけど，まあ無いなら普通に消します",
        "user": "U57D08Z9U",
        "type": "message"
    },
    {
        "ts": "1515745257.000392",
        "text": "なるほど。そっちも掘ってみましたが、やっぱり入っているのは自前のパッケージっぽいですね。\nだから思い切って消しちゃってもいいかも。\nそして `stack clean` しても消えない模様。。。 :disappointed:",
        "user": "U4LGTMTMK",
        "type": "message"
    },
    {
        "ts": "1515745360.000318",
        "text": "結論、resolver毎にビルド結果を残してしまうstackの仕様に加え、GHCがビルドしたものがそもそも大きすぎるのが問題な気がしました :sweat_smile:",
        "user": "U4LGTMTMK",
        "type": "message"
    },
    {
        "ts": "1515774272.000915",
        "text": "<https://twitter.com/hsjoihs/status/951851803531816960>\nfreeモナドとかoperationalとかcontとかを学ぶ際に最初に読むべきもの、なんかオススメありますかね（英語可）（現状の理解度：StateTぐらいなら分かる、圏論の背景知識は不足している、LispとかSchemeとかcall/ccとかは全く理解していない）",
        "user": "U8EJKMNVA",
        "type": "message"
    },
    {
        "ts": "1515775218.000594",
        "text": "freeモナドについては\n<https://apfelmus.nfshost.com/articles/operational-monad.html> などを見ながら，ひとまずこのパッケージで何か作って見るのがいい気がします．\n<https://hackage.haskell.org/package/MonadPrompt>\nオススメはIOモナドですかね？(ファイルの読み取りや書き込みなどを自分のDSLで書けるようにする，より良いIOのための小さなフレームワークを作るなど)",
        "user": "U57D08Z9U",
        "type": "message"
    },
    {
        "ts": "1515776535.000410",
        "text": "継続(continuation/cont monad)については，話題が結構多岐にわたるんですが，基礎的な話についてはあまり良い資料を見つけられませんでした．\n<https://github.com/lotz84/haskell/blob/master/docs/continuation.md>\nとかで幾つか資料を見て見るのがいいんですかね？(誰か強い人にお任せ)",
        "user": "U57D08Z9U",
        "type": "message"
    },
    {
        "ts": "1515788627.000330",
        "text": "僕もWindowsの挙動は詳しくないのですがstack corruptionが起きるそうです。<https://github.com/haskell/ThreadScope/commit/299546b7aef4155849437d327d34059589a82643#commitcomment-23352756>\nコメントの通りwindows_cconv.hを使うのがおすすめだそうです。",
        "user": "U4M9NJ7QE",
        "type": "message"
    },
    {
        "ts": "1515800573.000056",
        "text": "Qiitaの僕の記事です。<https://qiita.com/YoshikuniJujo/items/c71644b5af1f5195cbf3>\nFreeモナドとOperationalモナドについての説明もありますので、もしよろしければ。ご参考までに。",
        "user": "U4M78PX5K",
        "type": "message"
    },
    {
        "ts": "1515814588.000002",
        "text": "入門向けではないですが私のお薦めは “FUNCTIONAL PEARL Data types a la carte” です。  <http://www.cs.ru.nl/~W.Swierstra/Publications/DataTypesALaCarte.pdf>",
        "user": "U57CGDBMG",
        "type": "message"
    },
    {
        "ts": "1515831056.000020",
        "text": "data types a la carteのfree monadに関しての洞察は，代数的な側面が強いので，あまりモナドに設置させるという感じでは無いかもしれないですね．freeモナドの方を重点的に解説してる記事としては\n<http://www.haskellforall.com/2012/06/you-could-have-invented-free-monads.html>\nとかもありますね",
        "user": "U57D08Z9U",
        "type": "message"
    },
    {
        "ts": "1515831207.000010",
        "text": "ただ，data types a la carteの手法自体は，free monadとは独立に知っておくと面白いと思います(理論面でも技術面でもfreeモナドとつながりが深いですし)",
        "user": "U57D08Z9U",
        "type": "message"
    },
    {
        "ts": "1515988462.000070",
        "text": "枝が Map k で分岐している木\n```\ndata X k a = Leaf a | Node (Map k (X k a))\n```\nに特別な名前が付いていますか。二分木とかトライ木のような。\nトライ木と呼んでもいいのかな。（キーが文字列でないだけで）",
        "user": "U57CGDBMG",
        "type": "message"
    },
    {
        "ts": "1515988727.000080",
        "text": "Map に Node が入り得るんですか？",
        "user": "U56MBRKR9",
        "type": "message"
    },
    {
        "ts": "1515988739.000129",
        "text": "例示したコードと若干異なりますが、\nRose treeの `Map` 版、ぐらいですかね。。。",
        "user": "U4LGTMTMK",
        "type": "message"
    },
    {
        "ts": "1515988833.000052",
        "text": "Freeモナドについては、私はfumievalさんやちゅーんさんのブログで勉強しました",
        "user": "U570660KX",
        "type": "message"
    },
    {
        "ts": "1515988844.000102",
        "text": "<http://d.hatena.ne.jp/its_out_of_tune/20121111/1352632815>",
        "user": "U570660KX",
        "type": "message"
    },
    {
        "ts": "1515988858.000084",
        "text": "<http://d.hatena.ne.jp/fumiexcel/20121111/1352614885>",
        "user": "U570660KX",
        "type": "message"
    },
    {
        "ts": "1515988897.000196",
        "text": "`Cofree` はrose treeを一般化したものなので、 `Cofree f a` の `f` を `Map k` としたバージョンともいえそうです。\n<https://www.stackage.org/haddock/lts-10.3/free-4.12.4/Control-Comonad-Cofree.html#t:Cofree>",
        "user": "U4LGTMTMK",
        "type": "message"
    },
    {
        "ts": "1515988953.000241",
        "text": "あー、rose tree (多分木)ですね。",
        "user": "U56MBRKR9",
        "type": "message"
    },
    {
        "ts": "1515989008.000049",
        "text": "Free (Map k) のつもりだったのですが\u0008、Cofree の方ですか？",
        "user": "U57CGDBMG",
        "type": "message"
    },
    {
        "ts": "1515989053.000150",
        "text": "ああー、例示したコードだとその方が近そうですね。。。",
        "user": "U4LGTMTMK",
        "type": "message"
    },
    {
        "ts": "1515989311.000160",
        "text": "多分木は Free [] ですよね。多分。",
        "user": "U57CGDBMG",
        "type": "message"
    },
    {
        "ts": "1515989402.000233",
        "text": "そうか。私が想定していたrose treeの場合、木の各階層に値が入ると思っていたんですが、提案されたものの場合葉にしか値が入らないのか。",
        "user": "U4LGTMTMK",
        "type": "message"
    },
    {
        "ts": "1515989465.000036",
        "text": "枝に値が入るかどうかで名前が変わりそうですね。",
        "user": "U57CGDBMG",
        "type": "message"
    },
    {
        "ts": "1515989538.000077",
        "text": "Leaf に値が入る木って、Haskell だとあまり見ないですね。。。",
        "user": "U56MBRKR9",
        "type": "message"
    },
    {
        "ts": "1515989639.000079",
        "text": "トライ木は枝に値が付くのか。",
        "user": "U57CGDBMG",
        "type": "message"
    },
    {
        "ts": "1515989763.000036",
        "text": "葉に値が付く木で、僕が Haskell で使ったことがあるのは、Huffuman 符号の木ぐらいですねぇ。",
        "user": "U56MBRKR9",
        "type": "message"
    },
    {
        "ts": "1515990220.000156",
        "text": "入門本ではどういう例で載せているか見たら「H本」はNodeにだけ持ち、「関数プログラミング入門」ではLeafにだけ持ってました。",
        "user": "U57CGDBMG",
        "type": "message"
    },
    {
        "ts": "1515990401.000040",
        "text": "そもそもは Free ((-&gt;) k) の例で名前がついているデータ型にどういうのがあるかなと思っての質問でした。\n例えば Bool -&gt; a の Free は（Leaf にだけ値を持つ）2分木、とか。",
        "user": "U57CGDBMG",
        "type": "message"
    },
    {
        "ts": "1515994235.000077",
        "text": "話のついでで、これも入門向けではなくて圏論的な解説ですが読みやすく F代数の勉強にもなったので。\n“Free monads in category theory (part 1)” <https://www.paolocapriotti.com/blog/2013/11/20/free-monads-part-1/>\npart 3 まであります。",
        "user": "U57CGDBMG",
        "type": "message"
    },
    {
        "ts": "1516002128.000134",
        "text": "もう決着がついてるのかわからないのですが，Free ((-&gt;) k)は多分木の一種だと思いますね． k = Bool なら2分木ですし， Ix k =&gt; ならFree []と同じです．多分木は通常Cofree ((-&gt;) k)だと思いますが，Free ((-&gt;) k)はそれの葉にだけ値を持つようなもの Cofree ((-&gt;) k) (Maybe a)のインスタンスのような感じだと思いますね",
        "user": "U57D08Z9U",
        "type": "message"
    },
    {
        "ts": "1516002285.000281",
        "text": "通常アルゴリズム界隈だと，木の種類というよりは実益がある木かどうかでデータ構造を分類する風潮があるので，あまり抽象化したものに名前をつけるという感じでは無いと思います（まあ，あまり詳しく無いのでもしかしたら名前がついてるかもですが）",
        "user": "U57D08Z9U",
        "type": "message"
    },
    {
        "ts": "1516002398.000199",
        "text": "トライ木なんかも構造に注目した名前じゃなくて主な機能であるRetrievalの「trie」から来た名前ですもんね。",
        "user": "U4LGTMTMK",
        "type": "message"
    },
    {
        "ts": "1516002850.000170",
        "text": "ありがとうござます。\n答えているのは、最近networkのメンテナーになった人ですね。",
        "user": "U56MBRKR9",
        "type": "message"
    },
    {
        "ts": "1516004063.000230",
        "text": "Freeモナドはよく <https://hackage.haskell.org/package/free-4.12.4/docs/Control-Monad-Free.html> が題材に出されているのですが，個人的には Functorからmonadが抽出可能とか，圏論的な意味でのfree objectの代数的な性質の話というよりも(こちらも分かれば面白いのですが，分かる最短ルートは圏論を勉強することだと思っています)，Haskellプログラミングにおいての入門としては <https://hackage.haskell.org/package/MonadPrompt-1.0.0.5/docs/Control-Monad-Prompt.html> にあるように，\n&gt; 1. Prompt is pure; it is only through the observation function runPromptC that you can cause effects.\n&gt; 2. You don’t have to worry about the monad laws; they are correct by construction and you cannot break them.\n&gt; 3. You can implement several observation functions for the same type.\nとなるような抽象データであることが，一番重要だと思っています．その点で結構MonadPromptは良いチュートリアルになっていると思いますね．\noperationalもfreeも出回ってる実装は結構奇怪で，それの理解を行うためには圏論の知識を多少身につけておいたほうがいいのですが，どちらも一番の強みは中身の実装を気にしなくても(実際多くのパッケージは，中身は公開してないと思いますね)なぜかモナドに設置できることなので，中身のメカニズムを知るのはHaskellプログラミングにおいてそのアドバンテージが分かってからでもいいと思いますね",
        "user": "U57D08Z9U",
        "type": "message"
    },
    {
        "ts": "1516022500.000358",
        "text": "返信遅くなってしまいすみません:bow: \nなるほど!どうもありがとうございます:pray:",
        "user": "U8G16FA59",
        "type": "message"
    },
    {
        "ts": "1516047402.000215",
        "text": "あ，それから continuation については，この記事が非常にわかりやすいと思います．3本立てです\n<https://genkami.github.io/2018/01/14/01-haskell-continuation.html>",
        "user": "U57D08Z9U",
        "type": "message"
    },
    {
        "ts": "1516061013.000020",
        "text": "<@U7V6G63LJ> has joined the channel",
        "user": "U7V6G63LJ",
        "type": "message"
    },
    {
        "ts": "1516338183.000196",
        "text": "(Numではなく)任意の型クラスのデフォルトの型を指定する方法ってありましたっけ？",
        "user": "U56MBRKR9",
        "type": "message"
    },
    {
        "ts": "1516338397.000082",
        "text": "ないはず",
        "user": "U5G2BCVBN",
        "type": "message"
    },
    {
        "ts": "1516338603.000083",
        "text": "`default` キーワードでできた気がしましたが現状 Prelude の数値クラスに限定されているみたいですね。 <https://prime.haskell.org/wiki/Defaulting>",
        "user": "U4M598NHM",
        "type": "message"
    },
    {
        "ts": "1516338818.000123",
        "text": "わーん。",
        "user": "U56MBRKR9",
        "type": "message"
    },
    {
        "ts": "1516338971.000115",
        "text": "```\naccept :: Socket -&gt; IO (Socket, SockAddr)\n```\nの `SockAddr` をユーザが拡張できるように\n```\naccept :: SocketAddress sa =&gt; Socket -&gt; IO (Socket, sa)\n```\nとしたかったんですが、型が決まらないので、\n```\naccept :: Socket -&gt; IO (Socket, SockAddr)\naccept' :: SocketAddress sa =&gt; Socket -&gt; IO (Socket, sa)\n```\nとしてるんですが、かっこ悪いですねぇ。",
        "user": "U56MBRKR9",
        "type": "message"
    },
    {
        "ts": "1516373715.000645",
        "text": "使ったことないのでわからないんですがExtendedDefaultRulesでこういうことが出来たりしないですかね？\n<https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/ghci.html?highlight=extendeddefaultrules#ghc-flag--XExtendedDefaultRules>",
        "user": "U560KD6DN",
        "type": "message"
    },
    {
        "ts": "1516375614.000802",
        "text": "`ExtendedDefaultRules` は，ここにあるクラスしか，適用できない感がありますね\n<https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/ghci.html#interactive-classes>\n\n`TypeApplication` を使って， `accept @SockAddr` とする前提でAPIを設計する(いちよシグネチャを明示的に書けば， `TypeApplication` を使わなくても良い)感じはダメなんですかね？",
        "user": "U57D08Z9U",
        "type": "message"
    },
    {
        "ts": "1516417192.000137",
        "text": "あと `OverloadedString` 拡張を有効にした時は `IsString` にも指定できるんだそうです。 <https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#overloaded-string-literals>",
        "user": "U570660KX",
        "type": "message"
    },
    {
        "ts": "1516451823.000112",
        "text": "<@U8WGPUHK9> has joined the channel",
        "user": "U8WGPUHK9",
        "type": "message"
    },
    {
        "ts": "1516532864.000032",
        "text": "<@U8P5W7YP6> has joined the channel",
        "user": "U8P5W7YP6",
        "type": "message"
    },
    {
        "ts": "1516556572.000116",
        "text": "<@U7XGESRSQ> has joined the channel",
        "user": "U7XGESRSQ",
        "type": "message"
    },
    {
        "ts": "1516590817.000228",
        "text": "どうもうまい方法はなさそうなので、Network.Socket は SockAddr 固定とし、generic な API は別モジュールで提供することにします。",
        "user": "U56MBRKR9",
        "type": "message"
    },
    {
        "ts": "1516590833.000221",
        "text": "みなさん、いろいろありがとうございました。勉強になりました。",
        "user": "U56MBRKR9",
        "type": "message"
    },
    {
        "ts": "1516762993.000127",
        "text": "<@U8X01G6FJ> has joined the channel",
        "user": "U8X01G6FJ",
        "type": "message"
    },
    {
        "ts": "1516784893.000214",
        "text": "<@U8XGRJ3DZ> has joined the channel",
        "user": "U8XGRJ3DZ",
        "type": "message"
    },
    {
        "ts": "1516877283.000417",
        "text": "<@U8YBE1TTM> has joined the channel",
        "user": "U8YBE1TTM",
        "type": "message"
    },
    {
        "ts": "1517071460.000046",
        "text": "`Generic2` クラスがない理由ってなんか技術的な理由だったりするんでしょうか？",
        "user": "U57D08Z9U",
        "type": "message"
    },
    {
        "ts": "1517175539.000040",
        "text": "<@U8ZBMSPPB> has joined the channel",
        "user": "U8ZBMSPPB",
        "type": "message"
    },
    {
        "ts": "1517195904.000180",
        "text": "<@U90FHSDFG> has joined the channel",
        "user": "U90FHSDFG",
        "type": "message"
    },
    {
        "ts": "1517213080.000038",
        "text": "Queue のライブラリってありますか？\n「Haskell queue」でググると出てくる↓は Stackage には無いから枯れちゃってるのかなぁと思いますし、何がデファクトなんでしょうか？\n<https://hackage.haskell.org/package/queue>",
        "user": "U56L7EVNY",
        "type": "message"
    },
    {
        "ts": "1517214067.000209",
        "text": "「Deprecated」って書いてありますもんね。 :disappointed: \nほしいのは並行計算で使う方じゃないキューですよね？\nであれば、\n<https://wiki.haskell.jp/データ構造列伝> でも触れているSeqか、確か銀行家キューを実装したパッケージもあったよな。。。 :thinking_face:",
        "user": "U4LGTMTMK",
        "type": "message"
    },
    {
        "ts": "1517214280.000316",
        "text": "ふつーの FIFO なデータ構造ですね\ndeque とか優先度つきのキューなら何種類かあるんですけど、それはそれでどれを使えばいいのやら。\nこんぐらいは自前で実装するのが当たり前なんですかね :thinking_face: ",
        "user": "U56L7EVNY",
        "type": "message"
    },
    {
        "ts": "1517215021.000092",
        "text": "<https://hackage.haskell.org/package/dequeue-0.1.12/docs/Data-Dequeue.html>\nこれか。\n<http://www.kmonos.net/pub/Presen/PFDS.pdf> とか  <http://fumieval.hatenablog.com/entry/2015/02/05/174342> で解説されている。",
        "user": "U4LGTMTMK",
        "type": "message"
    },
    {
        "ts": "1517215104.000104",
        "text": "なるほど",
        "user": "U56L7EVNY",
        "type": "message"
    },
    {
        "ts": "1517215462.000546",
        "text": "あでも、これも stackage にはない....",
        "user": "U56L7EVNY",
        "type": "message"
    },
    {
        "ts": "1517215506.000432",
        "text": "まぁstackageに置いているかどうかは作った人の裁量しだいなんで、的確な基準ではないんじゃないかな、と思います。",
        "user": "U4LGTMTMK",
        "type": "message"
    },
    {
        "ts": "1517215772.000146",
        "text": "まぁそうですね",
        "user": "U56L7EVNY",
        "type": "message"
    },
    {
        "ts": "1517220133.000223",
        "text": "```\n$ stack new blog hakyll-template\n$ cd blog\n# stack.yaml の resolver を nightly-2018-01-29 に\n$ stack build\n```\nすると ↓ のようなエラーが出るのですが解決方法が分かりません。\nObjective-C のコードを gcc が理解できてないんだろうなぐらいは分かるのですが。\n• OS X El Capitan 10.11.6\n• stack 1.6.3",
        "user": "U4L0B71L1",
        "type": "message"
    },
    {
        "ts": "1517220193.000245",
        "text": "<@U4L0B71L1> uploaded a file: <https://haskell-jp.slack.com/files/U4L0B71L1/F9031NU0L/building_hakyll_on_os_x.txt|building hakyll on OS X>",
        "user": "U4L0B71L1",
        "type": "message"
    },
    {
        "ts": "1517220603.000159",
        "text": "恐らく別件ですが類似の問題:\n<https://github.com/luite/hfsevents/issues/9>\n報告した方がいいかもですね。。。\n\nちなみに、念のため言うと、GCCはObjective-Cもちゃんとサポートしています。",
        "user": "U4LGTMTMK",
        "type": "message"
    },
    {
        "ts": "1517223395.000242",
        "text": "あ、まさに hfsevents のビルドでこけてるのでこれっぽい",
        "user": "U4L0B71L1",
        "type": "message"
    },
    {
        "ts": "1517225648.000137",
        "text": "コミュニティに与えた損害の埋め合わせのために、明日は仕事を休み、Haskell-jpに貢献できるようなことに費やします。Trelloにあったコーディング規約について、Wikiに投稿しようと考えています。他にも、何か案があればご教示を願いたいです",
        "user": "U4KUNQF9N",
        "type": "message"
    },
    {
        "ts": "1517225769.000015",
        "text": "そのイシューに Apple's Clang/LLVM 使えとあって Free Software Foundation GCC へのパスを消したら通りました\nstack の --with-gcc をオプションや stack.yaml ファイルに書いたりして GCC/Clang と FSF GCC と試したんだけどなぁ",
        "user": "U4L0B71L1",
        "type": "message"
    },
    {
        "ts": "1517225824.000368",
        "text": "GCC/Clang と書いているのはバックエンドが Clang だけど GCC 互換インターフェースをそなえている Apple の GCC です",
        "user": "U4L0B71L1",
        "type": "message"
    },
    {
        "ts": "1517233777.000416",
        "text": "これはダメなんでしょうか？使ったことないんですけど\n<https://hackage.haskell.org/package/heaps-0.3.6>",
        "user": "U57D08Z9U",
        "type": "message"
    },
    {
        "ts": "1517234352.000109",
        "text": "Oh… FIFOなのが欲しいんですね．",
        "user": "U57D08Z9U",
        "type": "message"
    },
    {
        "ts": "1517234501.000015",
        "text": "double-endedなのは， <https://hackage.haskell.org/package/deque-0.2/docs/Deque.html> もあるっぽいですが，どっちもあんまメンテされてなさそうですね… :sweat_smile:",
        "user": "U57D08Z9U",
        "type": "message"
    },
    {
        "ts": "1517234818.000018",
        "text": "<@U90881C13> has joined the channel",
        "user": "U90881C13",
        "type": "message"
    },
    {
        "ts": "1517234955.000385",
        "text": "kazu さんが昔記事にかいてるみたいに、需要がそもそも無いんですかね :sweat_smile: \n<http://d.hatena.ne.jp/kazu-yamamoto/touch/20121107/1352259739>\n\n効率が要るという訳でもないですし、おとなしく containers の Seq を使っておきます…\nありがとうございました。",
        "user": "U56L7EVNY",
        "type": "message"
    },
    {
        "ts": "1517274454.000281",
        "text": "<#C563RLDA4|haskell-jp-status> に移します。",
        "user": "U4LGTMTMK",
        "type": "message"
    },
    {
        "ts": "1517301958.000283",
        "text": "Haskell の歴史 :kininaru: \n<https://twitter.com/EzoeRyou/status/958258650505625603>",
        "user": "U56L7EVNY",
        "type": "message"
    },
    {
        "ts": "1517304309.000199",
        "text": "今更なんですけど、実はほしかったのはdlistだったりしない？\n<https://hackage.haskell.org/package/dlist-0.8.0.4/docs/Data-DList.html>\n後ろに追加していって最後にまとめて先頭から処理する、みたいな用途だと十分いけるのかな、と思うのですがいかがでしょう？",
        "user": "U4LGTMTMK",
        "type": "message"
    },
    {
        "ts": "1517317165.000053",
        "text": "Applicativeも含めた型の俯瞰図の、歴史のスナップショットの２点はこういうのもありますね。\n\nTypeclasspedia の昔の版（ApplicativeとMonadが切れてるころ）の日本語訳\n<http://snak.tdiary.net/20091020.html>\n\nTypeclasspedia のAMPとFTPの各プロポーザル反映後の最新版\n<https://byorgey.wordpress.com/2017/06/07/the-typeclassopedia-is-now-up-to-date/>\n<https://wiki.haskell.org/Typeclassopedia>",
        "user": "U55V441FS",
        "type": "message"
    },
    {
        "ts": "1517318564.000518",
        "text": "DList は良く分からないですけど、ぼくが欲しかったのは、本当に一般的な FIFO キューですので違うかなぁ。",
        "user": "U56L7EVNY",
        "type": "message"
    },
    {
        "ts": "1517805452.000096",
        "text": "教えてください。\n\n```\nclass Foo a where\n    toFoo  :: Int -&gt; a\n    fromFoo :: a -&gt; Int\n```\n\nという型クラスがあったとして、\n\n```\nintToInt :: Int -&gt; Int\nintToInt = fromFoo . toFoo\n```\n\nというコードを書きたいとき、中間の Foo a =&gt; a が一致することを要求するよう要求し、型検査を通す方法ってありますか？",
        "user": "U56MBRKR9",
        "type": "message"
    },
    {
        "ts": "1517808271.000167",
        "text": "ぱっと思いつくのは `TypeApplication` ですね。\n<https://kseo.github.io/posts/2017-01-08-visible-type-application-ghc8.html>",
        "user": "U4LGTMTMK",
        "type": "message"
    },
    {
        "ts": "1517809245.000109",
        "text": "どの `Foo` のインスタンスを使うかで `intToInt` の実装は変わってしまうので、 `a` からは逃げられない気がしますよね・・・。\n```\n{-# LANGUAGE TypeApplications #-}\n{-# LANGUAGE ScopedTypeVariables #-}\n{-# LANGUAGE AllowAmbiguousTypes #-}\n\nclass Foo a where\n    toFoo  :: Int -&gt; a\n    fromFoo :: a -&gt; Int\n\nintToInt :: forall a. Foo a =&gt; Int -&gt; Int\nintToInt = fromFoo . toFoo @a\n```",
        "user": "U4MAYDV9C",
        "type": "message"
    },
    {
        "ts": "1517810528.000040",
        "text": "具体的な Foo のインスタンスを宣言してそれを使うようにするというのはどうですか？\n\n```\n{-# LANGUAGE TypeApplications #-}\n{-# LANGUAGE ScopedTypeVariables #-}\n{-# LANGUAGE GADTs #-}\n\nclass Foo a where\n  toFoo :: Int -&gt; a\n  fromFoo :: a -&gt; Int\n\ninstance Foo Integer where\n  toFoo = toInteger\n  fromFoo = fromInteger\n\nintToInt :: forall a. (Foo a, a ~ Integer) =&gt; Int -&gt; Int\nintToInt = fromFoo . toFoo @a\n```",
        "user": "U4KU9ABL0",
        "type": "message"
    },
    {
        "ts": "1517810968.000148",
        "text": "ありがとうございます。\nTypeApplications でできることは確かめました。\nしかし、networkライブラリのメインテナとしては、GHC 7も救わないといけません。。。",
        "user": "U56MBRKR9",
        "type": "message"
    },
    {
        "ts": "1517811045.000054",
        "text": "forall単独で変数を導入できるのは8.2からなので、Proxyを引数に加えてScopedTypeVariableを利用する必要があると思います。",
        "user": "U4KUNQF9N",
        "type": "message"
    },
    {
        "ts": "1517812400.000103",
        "text": "ExplicitForAll を書かなくても、GHC *8.0* では forall が使えちゃうなぁ。",
        "user": "U56MBRKR9",
        "type": "message"
    },
    {
        "ts": "1517814369.000197",
        "text": "ScopedTypeVariablesを有効にすると ExplicitForAll が有効になります。これはたぶん、7.10 でも同じだった気がします",
        "user": "U4KU9ABL0",
        "type": "message"
    },
    {
        "ts": "1517938152.000785",
        "text": "明後日Philip Wadler氏の授業を受けるのですが、何か質問とか聞いてみたいことはありますか？（どんどん質問してこいと言われてます）\nちなみに今日の講義内容はProposition as Types, Session type、Process calculusに関するものでした。",
        "user": "U7Z4F723Z",
        "type": "message"
    },
    {
        "ts": "1517959897.000229",
        "text": "ExplicitForAll の方が ScopedTypeVariables よりも導入が後だった気がする。",
        "user": "U4MA78F6X",
        "type": "message"
    },
    {
        "ts": "1518090183.000347",
        "text": "appveyorで、バイナリを作りたいのですが、できあがったバイナリがどこにあるのか分かりません。どなたか、どう記述すればいいか、ご存知ありませんか？",
        "user": "U56MBRKR9",
        "type": "message"
    },
    {
        "ts": "1518090186.000016",
        "text": "<https://ci.appveyor.com/project/kazu-yamamoto/hs-tls>\n<https://ci.appveyor.com/project/kazu-yamamoto/hs-tls/build/artifacts>\n<https://github.com/kazu-yamamoto/hs-tls/blob/tls13/appveyor.yml>",
        "user": "U56MBRKR9",
        "type": "message"
    },
    {
        "ts": "1518146867.000099",
        "text": "github からとってきたソースは C:\\projects\\&lt;packagename&gt; にあって、stack はここで実行される。",
        "user": "U56MBRKR9",
        "type": "message"
    },
    {
        "ts": "1518146906.000223",
        "text": "stack が作業に使うのは、stack_root にしていしたディレクトリ。",
        "user": "U56MBRKR9",
        "type": "message"
    },
    {
        "ts": "1518146959.000230",
        "text": "artifacts は、前者内での相対パスしか使えないので、バイナリが見えない。",
        "user": "U56MBRKR9",
        "type": "message"
    },
    {
        "ts": "1518147011.000250",
        "text": "`stack --local-bin-path . install &lt;package_name&gt;` すると、作業ディレクトリから後者へバイナリをコピーしてくれる。",
        "user": "U56MBRKR9",
        "type": "message"
    },
    {
        "ts": "1518147023.000241",
        "text": "やった！ &lt;- 今ココ",
        "user": "U56MBRKR9",
        "type": "message"
    },
    {
        "ts": "1518147260.000045",
        "text": "う、スレッドになってなかった。ごめんなさい。",
        "user": "U56MBRKR9",
        "type": "message"
    },
    {
        "ts": "1518147692.000048",
        "text": "```\nCopying from C:\\projects\\hs-tls\\.stack-work\\install\\1e01afab\\bin\\tls-simpleclient.exe to C:\\projects\\hs-tls\\tls-simpleclient.exe\n```\nきたー！",
        "user": "U56MBRKR9",
        "type": "message"
    },
    {
        "ts": "1518158706.000018",
        "text": "ちょっとHaskellと外れた質問かな、と思いきや、なるほどAppVeyorではなくstackの使用についての質問でしたか。。。すみません、察せなくて。",
        "user": "U4LGTMTMK",
        "type": "message"
    },
    {
        "ts": "1518327591.000032",
        "text": "実行時の数値からNat種の型を作る(?)には `GHC.TypeLits` の `someNatVal` 関数などを使えばできるとおもうのですが、この時作られる型を自作の型クラスのインスタンスに限定するにはどのようにすればいいのでしょうか?:sob::sob::innocent:",
        "user": "U8G16FA59",
        "type": "message"
    },
    {
        "ts": "1518329567.000024",
        "text": "補足します:man-bowing::writing_hand:\nZ/nZ を表す型として `IntResidueClass` というデータ型と、有限体を表す型クラスとして `FiniteField` 型クラスを作りました。\nn が素数のときにZ/nZが有限体になることを次のようにしてプログラムにしました:writing_hand::scream_cat:\n\n```\nclass FiniteField k where\n  hoge :: k -&gt; String\n\nnewtype IntResidueClass (n :: Nat) = MkIntResidueClass Integer deriving (Show)\n\ninstance (IsPrime p) =&gt; FiniteField (IntResidueClass p) where\n  hoge _ = \"hogehoge\"\n```\n\n`IsPrime` は以下のように型族として定義しました。Natの型が素数になってるかどうかコンパイル時に判定させることができました:exploding_head:\n\n```\ntype family (x :: Nat) % (y :: Nat) :: Nat  where\n  x % y = Mod' x y (y &lt;=? x)\n\ntype family Mod' (x :: Nat) (y :: Nat) (xGeqY :: Bool) :: Nat where\n  Mod' x y 'True  = Mod' (x - y) y (y &lt;=? (x - y))\n  Mod' x y 'False = x\n\ntype IsPrime p = IsPrimeB p ~ 'True\n  \ntype family IsPrimeB (p :: Nat) :: Bool where\n  IsPrimeB 0 = 'False\n  IsPrimeB 1 = 'False\n  IsPrimeB 2 = 'True\n  IsPrimeB p = IsPrimeB' p 3 (p % 2 == 0) (Not (3 ^ 2 &lt;=? p))\n\ntype family IsPrimeB' (p :: Nat) (i :: Nat) (hasFactor :: Bool) (searchEnd :: Bool) where\n  IsPrimeB' _ _ 'True _ = 'False\n  IsPrimeB' _ _ _ 'True = 'True\n  IsPrimeB' p i _ _     = IsPrimeB' p (i + 2) (p % i == 0) (Not ((i + 2) ^ 2 &lt;=? p))\n```\n\nさらに、実行時のユーザの入力によって n を決めて `IntResidueClass n` 型の値を作り出すことは、以下のようにしてできました:oden:\n\n```\nmain :: IO ()\nmain = do\n  s &lt;- getLine\n  let i = read s :: Integer\n  let sn = fromJust $ someNatVal i\n  case sn of\n    SomeNat p -&gt; do\n      let irc = mkIntResidueClassFromProxy p 0\n      print irc \n```\n\nこのとき、 `print $ hoge irc` とするなどの、`FiniteField`クラスのメソッドを使うことができません:sob:\n `FiniteField` クラスのインスタンスである `IntResidueClass` を実行時に作るにはどうすれば良いのでしょうか:sob::man-bowing:",
        "user": "U8G16FA59",
        "type": "message"
    },
    {
        "ts": "1518332550.000008",
        "text": "<@U8ZN25NE7> has joined the channel",
        "user": "U8ZN25NE7",
        "type": "message"
    },
    {
        "ts": "1518334587.000034",
        "text": "KnownNat n からIntegerはいつでも変換できますが、どうしても値レベルの素数判定は使いたくないということですか？仮に型レベルの素数判定を使ったとしても、この場合結局実行時に評価することになって、性能はむしろ悪くなりそうですが",
        "user": "U8ZN25NE7",
        "type": "message"
    },
    {
        "ts": "1518335266.000018",
        "text": "どういう状況なのかは分かりませんが，基本的なアイデアとしては， `SomeNat` と同じようにまず `FiniteField` の制約を持つ存在型で包んであげて， `FiniteField` のリフレクションでインスタンスを導出してあげれば良いです．ただ，Haskellはこの辺があまり柔軟にはできていないので，リフレクションに多少工夫が必要です．",
        "user": "U57D08Z9U",
        "type": "message"
    },
    {
        "ts": "1518335452.000051",
        "text": "そうですね。あとはGADTで型レベルのパターンマッチをするのもあると思います。GHCの型だけで数学を表現するのは大変で、たくさんの人が挫折してますね・・",
        "user": "U8ZN25NE7",
        "type": "message"
    },
    {
        "ts": "1518336071.000046",
        "text": "どの道どのリフレクションを使うにしろ，何らかのユーザー保証は入ってくる(素数判定の結果がIsPrimeを満たすことを，GHCではなくユーザーが保証する． ~型族の実装からの実行時動作を導出することは個人的には無理だと思っていますが，できるかもしれません~ できそうかもです．アイデアだけ次のコメントに書いておきました．)と思いますが，リフレクションの方法としては\n1. `IsPrime` が1つのメソッドしか持たないなら <https://www.schoolofhaskell.com/user/thoughtpolice/using-reflection> という方法があります．\n2. もう一つは， `Typeable` (<https://www.stackage.org/haddock/lts-10.5/base-4.10.1.0/Type-Reflection.html#t:Typeable>) を利用して `someNat` で持ち上げた `Nat` の型情報を持ってくる方法があります\n他にもいろいろありますが，代表的なのはこの辺ですかね？",
        "user": "U57D08Z9U",
        "type": "message"
    },
    {
        "ts": "1518339576.000019",
        "text": "あまり頭のいいことをしようと考えなければ，結構簡単にいけそうですね．とりあえず思いついた方法を書いてみました．参考にどうぞ\n<https://gist.github.com/mizunashi-mana/30bccdd729e1a069580ac17e9d0853f2>\n後，型族からの実装の抽出は，IsPrimeBが構造的帰納法などで停止することを証明して，KnownNat n =&gt; IsPrimeB n ~ ’True \\/ IsPrimeB n ~ ’False であることを証明すれば，後はその証明を使って型レベルの’True/’Falseを値レベルのTrue/Falseに落としてTrueかどうか判定することでできそうな気がしました．まあ，ちょっとめんどそうなので，そっちの方は試してないです",
        "user": "U57D08Z9U",
        "type": "message"
    },
    {
        "ts": "1518345282.000085",
        "text": "singletonsとconstraintsを使いましょう．\n<https://gist.github.com/notogawa/83324a70e35049cd1ddccc005ea1a278>",
        "user": "U5G2BCVBN",
        "type": "message"
    },
    {
        "ts": "1518345900.000038",
        "text": "今回は書き下してますが， `<http://Data.Singletons.TH|Data.Singletons.TH>` とか使うともっとラクに書けるんじゃないかなと思います．",
        "user": "U5G2BCVBN",
        "type": "message"
    },
    {
        "ts": "1518367636.000053",
        "text": "おお:heart_eyes:どうもありがとうございます:pray:\nプログラムまで書いて頂いてものすごく参考になりそうです:man-bowing:\nまだ全部理解できていないのですが、わからないことがあったらまた質問するかもしれないです:sweat_drops:",
        "user": "U8G16FA59",
        "type": "message"
    },
    {
        "ts": "1518500384.000177",
        "text": "haskellの数値演算では型合わせが必須で、少しまともに書き始めると色々躓きまして、あちこち調べて整理しています。その中で過去の９８のクラス階層図<https://www.haskell.org/onlinereport/basic.htmlと、ここにある>　<https://en.wikibooks.org/wiki/Haskell/Classes_and_types#Standard_classes> おそらく最新と思われるものの間で違いがあります。具体的にはNumについていたEqやshowの型制約が外れているようなのですが、これは何故なのでしょう？",
        "user": "U55UN00G0",
        "type": "message"
    },
    {
        "ts": "1518501074.000102",
        "text": "結構前に、 Num クラスに Eq, Show 制約は不要だからなくなったと記憶しています。 xuwei さんのブログ記事がありました: <http://xuwei-k.hatenablog.com/entry/20120123/1327325922>",
        "user": "U578W9676",
        "type": "message"
    },
    {
        "ts": "1518501190.000143",
        "text": "<http://downloads.haskell.org/~ghc/latest/docs/html/users_guide/bugs.html#numbers-basic-types-and-built-in-classes> にも同じ話がありましたが、 ~やっぱり詳しい背景までは載ってませんね~ すみません、 :point_up: の記事でも軽く触れてますね。\n推測ですが、単純に `Eq` であることと `Show` であることとは `Num` に本質的でないと判断したんではないでしょうか。",
        "user": "U4LGTMTMK",
        "type": "message"
    },
    {
        "ts": "1518502923.000016",
        "text": "ありがとうございます。公式に外されたものなのですね。図の中で制約が外れた後も「All except～」とあるので、暗黙的に制約される何がしかの仕組みがあるのかと勘繰っていました。提案の中に書かれているように”意味がない”ということなのですね",
        "user": "U55UN00G0",
        "type": "message"
    },
    {
        "ts": "1518578885.000146",
        "text": "引き続き、数値演算時の型変換の質問です。",
        "user": "U55UN00G0",
        "type": "message"
    },
    {
        "ts": "1518578911.000041",
        "text": "<@U55UN00G0> uploaded a file: <https://haskell-jp.slack.com/files/U55UN00G0/F98PFFPMG/image.png|RWHに、このような図があります（レイアウト等一部アレンジしています）　>",
        "user": "U55UN00G0",
        "type": "message"
    },
    {
        "ts": "1518578945.000043",
        "text": "これを見ながら色々考えていたのですが、`realToFrac`の使いどころが分からなくなりました。",
        "user": "U55UN00G0",
        "type": "message"
    },
    {
        "ts": "1518579128.000135",
        "text": "整数型からの変換は`fromIntegral`一択。`Rational`へ・からの変換はそれぞれ専用関数があり、`Fractional`からの整数型への変換は何らかの切り捨て関数となると、`realToFrac`は`Fractional`間の変換時の使用に見えます。",
        "user": "U55UN00G0",
        "type": "message"
    },
    {
        "ts": "1518579194.000124",
        "text": "ただ、<https://wiki.haskell.org/Converting_numbers>　では、浮動小数点型の変換に`realToFrac`を使うのは問題があるので、専用関数を使え、とあります。（上表にはRWHの記述にくわえて、相互変換関数を追記してあります）",
        "user": "U55UN00G0",
        "type": "message"
    },
    {
        "ts": "1518579301.000020",
        "text": "となると、`realToFrac`の使いどころがわからなくなりました。ネット等にあるサンプルは比較的単純で`realToFrac`を使わずとも他の関数で書いても同じ結果になりました。もしかしてcomplexあたりとの演算？？分かれば単純なことな気がしていますが、思いつかなかったのでご教授いただけると嬉しいです",
        "user": "U55UN00G0",
        "type": "message"
    },
    {
        "ts": "1518580106.000082",
        "text": "<https://www.stackage.org/haddock/lts-10.5/base-4.10.1.0/Prelude.html#t:Fractional> を見る限り、\nお察しの通りComplexはRealじゃないかつFractionalである場合があるみたいですね。\nただ、実際のところ\n```\nrealToFrac = fromRational . toRational\n```\nで定義される程度の、ユースケースの割にはシンプルな関数です（個人の感想です）。\n歴史の闇の中でいろいろ仕様変更しているうちに要らないものができちゃった、なんてことは普通にあり得ますが。。。 :cold_sweat:",
        "user": "U4LGTMTMK",
        "type": "message"
    },
    {
        "ts": "1518580242.000126",
        "text": "早々のお返事ありがとうございます。RWHには実際にはrealToFracではなく、fromRational.toRationalで書かれていますね。",
        "user": "U55UN00G0",
        "type": "message"
    },
    {
        "ts": "1518580311.000206",
        "text": "いわゆる入門系の書籍やネットの記事等も比較的古めの情報が多いため、今ソースコードをみたときに事情が異なっているものが多いなあというのは昨日の例も含め、すごく感じています",
        "user": "U55UN00G0",
        "type": "message"
    },
    {
        "ts": "1518580402.000100",
        "text": ":thinking_face: `realToFrac` を deprecate にした方がいいか議論した方がいいのだろうか。。。",
        "user": "U4LGTMTMK",
        "type": "message"
    },
    {
        "ts": "1518580451.000125",
        "text": "今 RWH 読むならこちらも参考にどうぞ <http://d.hatena.ne.jp/kazu-yamamoto/20140206/1391666962>",
        "user": "U4L0B71L1",
        "type": "message"
    },
    {
        "ts": "1518583762.000165",
        "text": "質問です。\n以下のコードはDataKinds+PolyKindsではコンパイルが通らず、TypeInTypeを有効にすると通ります。\n\n```\n{-# LANGUAGE TypeFamilies, DataKinds, PolyKinds #-}\n\nimport GHC.TypeLits\n\ntype S = Symbol\n\ntype family T :: Symbol -- OK\ntype family T2 :: Maybe Symbol -- OK\ntype family T3 :: Maybe S -- Error!\n```\n\nエラー内容\n\n```\nkind.hs:8:25: error:\n    ? Type constructor ‘S’ cannot be used here\n        (Perhaps you intended to use TypeInType)\n    ? In the first argument of ‘Maybe’, namely ‘S’\n      In the kind ‘Maybe S’\n```\n\nTypeInTypeの意味は「*のカインドを*とし、型と同様に扱えるようにする」との事ですが、上記のコードが通る事がそれとどのように関係しているのか理解できていません。\nDataKinds+PolyKindsで上記のコードが通らないのはどのような制約によるもので、なぜTypeInTypeを指定するとそれが外れるのでしょうか。",
        "user": "U570660KX",
        "type": "message"
    },
    {
        "ts": "1518585483.000201",
        "text": "(ぜんぜん詳しく無いですけど)\nそもそも type alias の型では kind に昇格できないのではないですか？\n```\ntype family T4 :: S -- Error!\n```",
        "user": "U56L7EVNY",
        "type": "message"
    },
    {
        "ts": "1518585685.000140",
        "text": "最後の方に `TypeInType` について書いてありますね\n<https://haskell.jp/blog/posts/2017/13-about-kind-system-part2.html>",
        "user": "U56L7EVNY",
        "type": "message"
    },
    {
        "ts": "1518586501.000069",
        "text": "僕も全然詳しくないですが，それは一重にDataKindsの型システムではtype aliasのpromotionが許可されていないけど，TypeInTypeの型システムでは許可されているからだと思いますね．GHCの現状のTypeInTypeの実装がどういう風になっているかはあまり知らないのですが，「*のカインドを*とする」のはinfiniteなtype hierarchyを許可することのように聞こえます",
        "user": "U57D08Z9U",
        "type": "message"
    },
    {
        "ts": "1518587237.000214",
        "text": "TypeInTypeの原論文のIntroductionがいちよ解になってる気がします．\n<http://www.seas.upenn.edu/~sweirich/papers/fckinds.pdf>\n型の同値判定を種の同値判定に昇格するのが難しいと言ってますね．おそらくですが，この辺の兼ね合いでtype aliasを含めた型の同値判定を，既存の型システムで種レベルに昇格するのが難しかったのではないでしょうか？",
        "user": "U57D08Z9U",
        "type": "message"
    },
    {
        "ts": "1518587449.000089",
        "text": "数値の型について、もうひとつ。\n\n皆さんは`Fracitonal‘ってどんな日本語をあてられますか？（日本語になんかしないよ、という意見は置いておいて）。\n直訳は「分数」で手元にある虎本でも思い切り「分数」と訳されていますが、クラス間の関係から考えると「非整数」あたりが一番正確なのかな、と思っています。\n「分数」だとサブクラスに√やpiや複素数があることと整合しない気がしまして・・\n\nこの流れでいうと`RealFrac`は非整数のうち実数のもの、`RealFloat`は浮動小数点の実数（`Floating`は複素数も含む）という理解で正しいでしょうか？",
        "user": "U55UN00G0",
        "type": "message"
    },
    {
        "ts": "1518587804.000117",
        "text": "pi = pi / 1 \nだし、分数でもいいのでは？\npi や √ があるとおかしいのは有理数じゃない？",
        "user": "U56L7EVNY",
        "type": "message"
    },
    {
        "ts": "1518587975.000027",
        "text": "Oh…\n&gt; Languages such as Coq and Agda avoid the *:* axiom because it introduces inconsistency, but that is not an issue here. The FC type language is already inconsistent in the sense that all kinds are inhabited.\nなんですね，知りませんでした… 本当に文面通り*のカインドを*にするんですね…",
        "user": "U57D08Z9U",
        "type": "message"
    },
    {
        "ts": "1518588106.000009",
        "text": "無理数とは分数で表現できない数値（分子分母ともに整数である分数＝有理数、以外の値）で、代表は２の平方根や円周率だと教わりました。分数で表現できないのが無理数なのに分数クラスっていうのはと思ったのですが、なるほどpi/1という捉え方も確かにありますね・・",
        "user": "U55UN00G0",
        "type": "message"
    },
    {
        "ts": "1518588248.000013",
        "text": "無理数は 有理数 (分母と分子が整数の分数)で表現できない数だと思うよ\nぼくも専門ではないけど、分数はもっと一般化された概念なんじゃない？",
        "user": "U56L7EVNY",
        "type": "message"
    },
    {
        "ts": "1518588604.000108",
        "text": "上の記述、おかしいですね。分子分母ともに整数である分数＝有理数で、それ以外が無理数。なので、よく「無理数は分数で表現できない数」といった説明がされています（ちょっと書き方直しました）",
        "user": "U55UN00G0",
        "type": "message"
    },
    {
        "ts": "1518588857.000113",
        "text": "さらに`Rational`が`Ratio Integer`で（分母分子整数による分数）あることを考えると、やっぱり分数という日本語には個人的には違和感がありました",
        "user": "U55UN00G0",
        "type": "message"
    },
    {
        "ts": "1518589631.000178",
        "text": "数学の話ですが、rational を有理数と訳したのは、誤りとだったと言われています。",
        "user": "U56MBRKR9",
        "type": "message"
    },
    {
        "ts": "1518589672.000099",
        "text": "rational には、確かに「理にかなった」という意味もありますが、数学では比で表せるという意味です。",
        "user": "U56MBRKR9",
        "type": "message"
    },
    {
        "ts": "1518589697.000239",
        "text": "比数と訳せばよかったのにね、とよく言われます。",
        "user": "U56MBRKR9",
        "type": "message"
    },
    {
        "ts": "1518589754.000117",
        "text": "無理数(irrational)は、比で表せない数という意味です。",
        "user": "U56MBRKR9",
        "type": "message"
    },
    {
        "ts": "1518589824.000003",
        "text": "しかし、非比数は、訳語としてちょっとくるしいかも。:-)",
        "user": "U56MBRKR9",
        "type": "message"
    },
    {
        "ts": "1518589939.000122",
        "text": "比に整数で表せるみたいな意味が注入されるみたいでなんかそれも違和感ありません？",
        "user": "U5G2BCVBN",
        "type": "message"
    },
    {
        "ts": "1518589977.000200",
        "text": "「それ」とは何のことですか？",
        "user": "U56MBRKR9",
        "type": "message"
    },
    {
        "ts": "1518590112.000143",
        "text": "1:e みたいなのも比じゃないかということです．",
        "user": "U5G2BCVBN",
        "type": "message"
    },
    {
        "ts": "1518590168.000033",
        "text": "困ったときのwikipediaさんにも「分数は正の整数だけではなく、整数全体や実数、複素数等を用いても定義される」とありますので、Ratio Integerではないものを分数と違ったものと感じるのは間違いかもしれませんね",
        "user": "U55UN00G0",
        "type": "message"
    },
    {
        "ts": "1518590184.000038",
        "text": "この辺りは、数の発見の歴史と関係がありまして、ピタゴラスでググると分かると思います。",
        "user": "U56MBRKR9",
        "type": "message"
    },
    {
        "ts": "1518590232.000124",
        "text": "ピタゴラスは、万物は整数の比で表すことができるという宗教を唱えておりまして、ルート2が発見された時にひた隠しにしました。",
        "user": "U56MBRKR9",
        "type": "message"
    },
    {
        "ts": "1518590252.000172",
        "text": "宗教(笑)",
        "user": "U56L7EVNY",
        "type": "message"
    },
    {
        "ts": "1518590254.000113",
        "text": "ルート2の存在を外に漏らした弟子は、殺されたと言われています。",
        "user": "U56MBRKR9",
        "type": "message"
    },
    {
        "ts": "1518590290.000056",
        "text": "「君のような勘のいいガキは嫌いだよ」案件だ",
        "user": "U5G2BCVBN",
        "type": "message"
    },
    {
        "ts": "1518590302.000219",
        "text": "RWH では integral + fractional = real なんですよね？",
        "user": "U56MBRKR9",
        "type": "message"
    },
    {
        "ts": "1518590312.000221",
        "text": "訳し方の話から始まって随分と興味深い話になって勉強になります",
        "user": "U55UN00G0",
        "type": "message"
    },
    {
        "ts": "1518590370.000099",
        "text": "実数から整数を取り除いたら、整数以外の有理数と無理数になるから、なんかおかしいな。",
        "user": "U56MBRKR9",
        "type": "message"
    },
    {
        "ts": "1518590455.000164",
        "text": "ちなみに、ピタゴラス派のシンボルである星型にもルートが隠されておりまして、もう大変だったようです。",
        "user": "U56MBRKR9",
        "type": "message"
    },
    {
        "ts": "1518590459.000038",
        "text": "整数と(整数に対して)端(の出る)数というニュアンスですよね",
        "user": "U5G2BCVBN",
        "type": "message"
    },
    {
        "ts": "1518590474.000046",
        "text": "Num = Real + Fractional",
        "user": "U55UN00G0",
        "type": "message"
    },
    {
        "ts": "1518590511.000139",
        "text": "Real - Integral = RealFrac",
        "user": "U55UN00G0",
        "type": "message"
    },
    {
        "ts": "1518590515.000068",
        "text": "ですかね",
        "user": "U55UN00G0",
        "type": "message"
    },
    {
        "ts": "1518590542.000040",
        "text": "整数 &lt; 有理数 &lt; 実数 &lt; 虚数",
        "user": "U56MBRKR9",
        "type": "message"
    },
    {
        "ts": "1518590543.000208",
        "text": "です。",
        "user": "U56MBRKR9",
        "type": "message"
    },
    {
        "ts": "1518590553.000002",
        "text": "整数は integral",
        "user": "U56MBRKR9",
        "type": "message"
    },
    {
        "ts": "1518590562.000058",
        "text": "有理数は fractional",
        "user": "U56MBRKR9",
        "type": "message"
    },
    {
        "ts": "1518590585.000046",
        "text": "実数は real",
        "user": "U56MBRKR9",
        "type": "message"
    },
    {
        "ts": "1518590587.000157",
        "text": "有理数と対応するのはRationalでは？",
        "user": "U55UN00G0",
        "type": "message"
    },
    {
        "ts": "1518590609.000105",
        "text": "あー、すいません。そうです。",
        "user": "U56MBRKR9",
        "type": "message"
    },
    {
        "ts": "1518590618.000041",
        "text": "FractionalはComplexも含む、ですよね",
        "user": "U55UN00G0",
        "type": "message"
    },
    {
        "ts": "1518590646.000195",
        "text": "実数と虚数が包含関係なのもオカシイのでは？",
        "user": "U55UN00G0",
        "type": "message"
    },
    {
        "ts": "1518590657.000086",
        "text": "実数＜複素数？",
        "user": "U55UN00G0",
        "type": "message"
    },
    {
        "ts": "1518590661.000129",
        "text": "僕が書いたのは、数学用語でして、Haskell だとどう対応しているのかよくわかりません。",
        "user": "U56MBRKR9",
        "type": "message"
    },
    {
        "ts": "1518590669.000162",
        "text": "複素数＝実数＋虚数なのでは？",
        "user": "U55UN00G0",
        "type": "message"
    },
    {
        "ts": "1518590696.000084",
        "text": "すいません。s/虚数/複素数/ としてください。",
        "user": "U56MBRKR9",
        "type": "message"
    },
    {
        "ts": "1518590715.000181",
        "text": "僕の中には、虚数(i)だけの世界はないので。。。",
        "user": "U56MBRKR9",
        "type": "message"
    },
    {
        "ts": "1518590766.000111",
        "text": "数学用語と Haskell 用語の対応関係はよくわからないので、どなたかまとめて blog を書いて〜。",
        "user": "U56MBRKR9",
        "type": "message"
    },
    {
        "ts": "1518590804.000089",
        "text": "手元でそれをやっていて、わからなくなってきたので質問させていただいています",
        "user": "U55UN00G0",
        "type": "message"
    },
    {
        "ts": "1518590841.000176",
        "text": "もう少しはっきりしたら、皆さんに確認いただきたい",
        "user": "U55UN00G0",
        "type": "message"
    },
    {
        "ts": "1518590878.000045",
        "text": "ぜんぜん関係ないけど <https://github.com/haskell-jp/blog> に「こういう記事を書いてほしい」って Issue ? があってもいいのかなぁと今思った。",
        "user": "U56L7EVNY",
        "type": "message"
    },
    {
        "ts": "1518590898.000151",
        "text": "クラス階層から解き明かす方がいいかも。",
        "user": "U56MBRKR9",
        "type": "message"
    },
    {
        "ts": "1518590899.000224",
        "text": "<http://www.sampou.org/haskell/report-revised-j/basic.html>",
        "user": "U56MBRKR9",
        "type": "message"
    },
    {
        "ts": "1518590991.000230",
        "text": "RealFracが、実数から整数を除いたものに見える。。。",
        "user": "U56MBRKR9",
        "type": "message"
    },
    {
        "ts": "1518591024.000035",
        "text": "どうぞどうぞ <https://haskell-jp.slack.com/archives/C5666B6BB/p1518590878000045?thread_ts=1518587449.000089&amp;cid=C5666B6BB>",
        "user": "U4LGTMTMK",
        "type": "message"
    },
    {
        "ts": "1518591073.000239",
        "text": "クラス階層をみながらこんな絵をかいてます・・とお見せしようとおもったらスレッドには画像は貼れないのですね",
        "user": "U55UN00G0",
        "type": "message"
    },
    {
        "ts": "1518591145.000142",
        "text": "私の整理ではスレッドの元に書いた通り、RealFracは非整数の実数です",
        "user": "U55UN00G0",
        "type": "message"
    },
    {
        "ts": "1518591172.000122",
        "text": "演算がある集合(整数や実数)で閉じているか、が数値演算系の型クラスみたいですね(当たり前ですけど)",
        "user": "U56L7EVNY",
        "type": "message"
    },
    {
        "ts": "1518592378.000270",
        "text": "<@U55UN00G0> uploaded a file: <https://haskell-jp.slack.com/files/U55UN00G0/F98UJJ11T/image.png|image.png> and commented: スレッドにイメージを貼れなかったので恥をしのんでコチラに。クラス階層から追って作ったメモです。役に立ちますかね　",
        "user": "U55UN00G0",
        "type": "message"
    },
    {
        "ts": "1518597941.000303",
        "text": "`Post Request` って感じのラベルと、それ用の Issue template を作りません？\n(multi template で <https://github.com/blog/2495-multiple-issue-and-pull-request-templates> )",
        "user": "U56L7EVNY",
        "type": "message"
    },
    {
        "ts": "1518598084.000174",
        "text": "ラベルの方は権限が無いのでお願いします :pray:\ntemplate の方は PR でも出します。",
        "user": "U56L7EVNY",
        "type": "message"
    },
    {
        "ts": "1518598085.000264",
        "text": "OK, たたき台を作っていただけると助かります！\nせめて <https://github.com/haskell-jp/blog/issues> への登録を！\nちなみにラベルの名前は `Topic Request` でいかがでしょうか？",
        "user": "U4LGTMTMK",
        "type": "message"
    },
    {
        "ts": "1518598106.000295",
        "text": "Topic Request で OK です",
        "user": "U56L7EVNY",
        "type": "message"
    },
    {
        "ts": "1518598108.000413",
        "text": "あれ、なかったっけ。了解です。",
        "user": "U4LGTMTMK",
        "type": "message"
    },
    {
        "ts": "1518598194.000087",
        "text": "ありがとうございます。ブログについては見落としてました。この記事の3つの拡張ポイントが * のカインドとどう関係しているか、については、時間があるときに原論文を呼んでみたいです。",
        "user": "U570660KX",
        "type": "message"
    },
    {
        "ts": "1518753371.000096",
        "text": "こんな感じで型レべルリストに対する `(:)` 演算子みたいなものを作りたいのですが、どこかのパッケージで定義されていたりしないでしょうか。\n\n```\nclass KList (f :: k -&gt; *) (g :: [k] -&gt; *)\n  where\n    (&lt;:&lt;) :: f x -&gt; g xs -&gt; g (x ': xs)\n\n-- 利用例 (実際にはSingではなく情報のある型を使いたい)\ninstance KList Sing Sing\n  where\n   x &lt;:&lt; y = SCons x y\n\nmain =\n  do\n    let s = (sing :: Sing \"orange\") &lt;:&lt; (sing :: Sing '[\"apple\", \"grape\"])\n    print $ fromSing s\n```\n\n自分の作る型に対して専用の演算子を作ってもいいのですが、演算子をいたずらに増やしたくないので既存のものがあったら使いたいと思った次第です。",
        "user": "U570660KX",
        "type": "message"
    },
    {
        "ts": "1518761689.000127",
        "text": "Fractionalのインスタンスに必要なのって `(/)` と `fromRational` なので、「可除数」とかじゃダメですか。",
        "user": "U61BA2X0U",
        "type": "message"
    },
    {
        "ts": "1518761772.000176",
        "text": "有限体もFractionalなので。",
        "user": "U61BA2X0U",
        "type": "message"
    },
    {
        "ts": "1518836506.000071",
        "text": "自分で定義するにしても(:)演算子に限定せずに、singletonパッケージのTyFunに対して付随する値レベルの演算をインスタンス宣言できるように、型クラスを定義するのがベターかなと思いました",
        "user": "U570660KX",
        "type": "message"
    },
    {
        "ts": "1518881181.000021",
        "text": "<@U979PBETG> has joined the channel",
        "user": "U979PBETG",
        "type": "message"
    },
    {
        "ts": "1518928474.000055",
        "text": "分数という訳語は、さんざん思案した結果採用したものです。:thinking_face:感覚的には可除数というのもありかなと思います。",
        "user": "U4KU9ABL0",
        "type": "message"
    },
    {
        "ts": "1518941236.000052",
        "text": "shelarcy 著「本物のプログラマはHaskellを使う」は2013年の良記事 <http://tech.nikkeibp.co.jp/it/article/COLUMN/20060915/248215/?ST=develop> ですが 最新の Haskell に合わせた改訂版はありますか？\nまたこのような詳しいレベルの日本語解説記事が他にもあれば教えて下さい。",
        "user": "U584T7GAH",
        "type": "message"
    },
    {
        "ts": "1518945319.000016",
        "text": "著者が音信不通だそうです…… <https://haskell-jp.slack.com/archives/C4M4TT8JJ/p1511314597000198>",
        "user": "U4L0B71L1",
        "type": "message"
    },
    {
        "ts": "1519012478.000013",
        "text": "虎本の訳者である <@U4KU9ABL0> さんから直接コメントいただけるとは感激です。訳者の皆さんが単語一つ一つに適切な訳語を選ぶために大変なご苦労されていることは存じ上げております。今回の皆さんのご指摘で、自身の分数のイメージが有理数側に偏っていたのが分かり大変勉強になりました。今後も宜しくお願いいたします。",
        "user": "U55UN00G0",
        "type": "message"
    },
    {
        "ts": "1519021953.000202",
        "text": "これ、別に左辺が `f x` の形をしている必要はない事に気づいたので、APIを工夫して左辺が `g xs -&gt; g (x:xs)` になるようにして、ユーザーには `$` 演算子で適用してもらう事にしました。",
        "user": "U570660KX",
        "type": "message"
    },
    {
        "ts": "1519026745.000218",
        "text": "<@U9C56J90X> has joined the channel",
        "user": "U9C56J90X",
        "type": "message"
    },
    {
        "ts": "1519047298.000208",
        "text": "初学者です。「すごいHaskellたのしく学ぼう」の以下の記載(p121)、\n&gt;具体型とは、型引数を１つも取らない型か、あるいは、型引数を取るけれどもそれが全て埋まっている型のことを指します。\nこれについて、\n1. 「埋められていない型引数がある型」というのは `hoge :: [a] -&gt; b` の `[a]` などを想像していいものでしょうか？またはこの時の `b` も？\n2. 「埋められていない型引数がある型」というのは「抽象型」と呼んでいいのでしょうか？それともまた別の用語がありますか？\n\nまとめ\n1. どちらも具体型。 `(-&gt;)` や `([a] -&gt;)` がそれに該当し、型コンストラクタではあるが具体型ではない。また「型」という語には具体型のみを指す場合と、それ以外のものも含む場合があり、文脈に気を付けること( `Maybe a` でなく `Maybe` を型と呼ぶ場合がある、という話)\n2. 呼ばない。",
        "user": "U9C56J90X",
        "type": "message"
    },
    {
        "ts": "1519047428.000324",
        "text": "1つめの質問だと `(-&gt;)` や `([a] -&gt;)` が「埋められていない型引数がある型」ですね",
        "user": "U4L0B71L1",
        "type": "message"
    },
    {
        "ts": "1519048239.000018",
        "text": "ありがとうございます、 `(-&gt;)` って型コンストラクタなんですか…？と思ったらすごいH本のp231にその旨の記載がありますね…その周辺をざっと読んだ限りFunctorまで読めばこの疑問は解決しそうな気がしてきました。",
        "user": "U9C56J90X",
        "type": "message"
    },
    {
        "ts": "1519049360.000579",
        "text": "2つめの質問の回答になってるか分からないですが、『型システム入門』では、例えば `id` の型は `a -&gt; a` ですが、拡張を使えば `forall a. a -&gt; a` と書けて `forall a. T` のような型を全称型といいます。\nまたそのような型を持つ項を型抽象といいます。\n（誰かに合ってるかチェックしてもらいたい",
        "user": "U4L0B71L1",
        "type": "message"
    },
    {
        "ts": "1519122303.000222",
        "text": "「具象型」と呼ばれているのは `Int` `Maybe Int` `Maybe a` など、そうではない型コンストラクタは `Maybe` のことですね。混乱したらカインドを考えて、カインドが `*` のものが「具象型」と思うのがわかりやすい気がします。\n「具象型」ではない型コンストラクタのいい呼び方は、私は知りません。単に型コンストラクタと言ってしまうことも多いような・・・。",
        "user": "U4MAYDV9C",
        "type": "message"
    },
    {
        "ts": "1519264826.000066",
        "text": "どなたか、GHCのTracなどについて知見のある方お願いします！\n<https://www.reddit.com/r/haskell_jp/comments/7zb7ao/ghc%E3%81%AE%E7%89%B9%E5%AE%9A%E3%81%AE%E6%A9%9F%E8%83%BD%E3%81%AE%E9%96%8B%E7%99%BA%E7%8A%B6%E6%B3%81%E3%81%AB%E3%81%A4%E3%81%84%E3%81%A6/>",
        "user": "U4LGTMTMK",
        "type": "message"
    },
    {
        "ts": "1519293501.000050",
        "text": "Data.Array.IOで謎の挙動を踏んでしまって困っているのですが誰か助けてください…\n配列の要素の1つ目には値を代入していないのに変化してしまうのですが…\n<https://wandbox.org/permlink/cDzxFPMREeY0JSAE>",
        "user": "U56G77VM1",
        "type": "message"
    },
    {
        "ts": "1519294610.000129",
        "text": "17行目 `print =&lt;&lt; readArray arr n` で `n` じゃなくて `i` じゃね？",
        "user": "U56L7EVNY",
        "type": "message"
    },
    {
        "ts": "1519295049.000030",
        "text": "あっ……",
        "user": "U56G77VM1",
        "type": "message"
    },
    {
        "ts": "1519395474.000077",
        "text": "すごいH本にカインドの記述が見られなかったので調べてきました、がそれなりに難しそうですね…Wikipedia の記載ですが、カインドが `*` を「零項の型コンストラクタ」というのは気に入りました、１以上の項の型コンストラクタを指す特別な用語がない、というのも何となく納得です。",
        "user": "U9C56J90X",
        "type": "message"
    },
    {
        "ts": "1519460691.000086",
        "text": "&gt; すごいH本にカインドの記述が見られなかったので\nFunctorを説明しているあたりにあるはずですよ！",
        "user": "U4LGTMTMK",
        "type": "message"
    },
    {
        "ts": "1519471730.000002",
        "text": "うおおおー、7.11(p155)にありますね！\nあと今見たら「種類」としては索引にありますね、「種(しゅ)」を探せば見つけられたのか…「kind」と「種(たね)」しか探してませんでした、ありがとうございます！",
        "user": "U9C56J90X",
        "type": "message"
    },
    {
        "ts": "1519538775.000007",
        "text": "Haskell 入門の p87 の注釈欄 *13 の下記の記載を見て何となく理解しました。\n&gt; IO や Maybe はカインドが * ではないので正確には型ではありませんが、(略)\n私の当初の疑問は\n&gt; 具体型とは、型引数を１つも取らない型か、あるいは、型引数を取るけれどもそれが全て埋まっている型\nという文から、型の中に具体型とそうでないものがある、という想像をしたのですが、実際には型と具体型は同じもので、型コンストラクタのうち特殊なものを型と呼ぶ、という理解になりました（間違ってたら誰かご指摘ください…）",
        "user": "U9C56J90X",
        "type": "message"
    },
    {
        "ts": "1519543044.000075",
        "text": "大丈夫なように思います。一点、「型」という語は具体型のみを指す場合と、それ以外のものも含む場合と両方あるので、読むときはそこに注意が必要ですね。",
        "user": "U4L0B71L1",
        "type": "message"
    },
    {
        "ts": "1519561237.000055",
        "text": "英語で質問する場所ってどこがいいです？Haskell Cafe思ったより人がいなくてもうメジャーじゃないのかな",
        "user": "U7V6G63LJ",
        "type": "message"
    },
    {
        "ts": "1519561495.000082",
        "text": "あとHaskellのメーリングリストにホスティングサイトの脆弱性っぽいの投げたけど他の場所だったら投げなおします",
        "user": "U7V6G63LJ",
        "type": "message"
    },
    {
        "ts": "1519564064.000022",
        "text": "英語だと Stackoverflow は Haskell の質問は結構投稿されていますね。ディスカッション寄りのことがしたいのであれば別の場所があるかもしれないですが、ちょっと私は分からないです。",
        "user": "U4M598NHM",
        "type": "message"
    },
    {
        "ts": "1519565681.000086",
        "text": "Stackoverflowは功徳を積んでなくて投稿できないので今回は無理そうです。ここの皆さんは功徳を積んで投稿されてるんですかね",
        "user": "U7V6G63LJ",
        "type": "message"
    },
    {
        "ts": "1519566403.000009",
        "text": "いや今見たら投稿できるっぽいな…今度そっちも試してみます",
        "user": "U7V6G63LJ",
        "type": "message"
    },
    {
        "ts": "1519574116.000074",
        "text": "Haskellでマイナー気味なDBを使おうとするとドライバがなくてRustに流れそうなんですがこれはもうあきらめるところでしょうか…",
        "user": "U7V6G63LJ",
        "type": "message"
    },
    {
        "ts": "1519604201.000036",
        "text": "Redditですかね後は。\n<https://www.reddit.com/r/haskell/>\n<https://www.reddit.com/r/haskellquestions/> というのもありました",
        "user": "U4LGTMTMK",
        "type": "message"
    },
    {
        "ts": "1519604225.000099",
        "text": "どのMLのことですか？",
        "user": "U4LGTMTMK",
        "type": "message"
    },
    {
        "ts": "1519605969.000023",
        "text": "haskell@haskell.orgです",
        "user": "U7V6G63LJ",
        "type": "message"
    },
    {
        "ts": "1519619322.000036",
        "text": "僕もRocksDB使ってみたいなーとか思いますね",
        "user": "U5P0CRDSP",
        "type": "message"
    },
    {
        "ts": "1519619981.000018",
        "text": "cardano-sl で使われてるやつですね！",
        "user": "U5B3EGEFQ",
        "type": "message"
    },
    {
        "ts": "1519620322.000121",
        "text": "NoSQLはRest APIがあるようなのでそっちで頑張れるか試す予定",
        "user": "U7V6G63LJ",
        "type": "message"
    },
    {
        "ts": "1519623171.000116",
        "text": "バインディングとしてchrisdoneが作ったrocksdb-haskell-ngが使われているんですね。情報ありがとうございます。\n<https://github.com/chrisdone/rocksdb-haskell-ng>",
        "user": "U5P0CRDSP",
        "type": "message"
    },
    {
        "ts": "1519625894.000198",
        "text": "メーリスでもRCリリースの告知ありましたがRedditのほうが食いつきいいですね",
        "user": "U7V6G63LJ",
        "type": "message"
    },
    {
        "ts": "1519634463.000455",
        "text": "コピペ\n\nI become aware of the problem that\n<https://mail.haskell.org/mailman/listinfo/haskell> send a password to\n<http://mail.haskell.org/cgi-bin/mailman/subscribe/haskell>. Probably it\nmeans this page will send a password without encryption. Could you use\nhttps instead of http, or remove this duplicate page? I had used\n<https://mail.haskell.org/cgi-bin/mailman/listinfo/haskell> instead.",
        "user": "U7V6G63LJ",
        "type": "message"
    },
    {
        "ts": "1519645994.000037",
        "text": "なるほど。その程度でしたらわざわざセキュリティー専用のチャンネルを探す間でもないですね:cold_sweat::cold_sweat::cold_sweat:",
        "user": "U4LGTMTMK",
        "type": "message"
    },
    {
        "ts": "1519647371.000381",
        "text": "うっかりパスワード丸見えで送るとこだったので早く直してほしい",
        "user": "U7V6G63LJ",
        "type": "message"
    },
    {
        "ts": "1519661197.000402",
        "text": "Text 型で String のようなパターンマッチはできませんか？\n正規表現は使いたくないんですが、そうするとParsec使うしかないのでしょうか？",
        "user": "U4LEB9UP4",
        "type": "message"
    },
    {
        "ts": "1519664863.000700",
        "text": "正規表現を使うほど複雑な処理はわかりませんが、 `ViewPatterns` , `OverloadedStrings` を使えば先頭からxxxとかのマッチはできると思います。",
        "user": "U5CSEFF7H",
        "type": "message"
    },
    {
        "ts": "1519694477.000137",
        "text": "私も OverloadedStrings と文字列リテラル ( \"...\" ) のパターンを ByteString 等で良く使います。",
        "user": "U4KNU6N48",
        "type": "message"
    },
    {
        "ts": "1519697229.000286",
        "text": "AtomのHIEでStylish Haskellはどう適用するんでしたっけ？以前できたはずなのに思い出せない",
        "user": "U7V6G63LJ",
        "type": "message"
    },
    {
        "ts": "1519703539.000082",
        "text": "なるほど。 `ViewPatterns` 覚えないと。\nありがとうございます！",
        "user": "U4LEB9UP4",
        "type": "message"
    },
    {
        "ts": "1519704472.000230",
        "text": "何故正規表現を使いたく無いかよく分かって無いですが，ワイドルカードや許容文字が複数ある場合などは， `regex-applicative-text` や `regex-tdfa` などをよく使います",
        "user": "U57D08Z9U",
        "type": "message"
    },
    {
        "ts": "1519707158.000035",
        "text": "そういえば，ややこしそうなのであまり追ってなかったんですが，現状 `Typeable` のインスタンス解決が破綻してる件ってどうなってるんでしょうか？ `DeriveDataTypeable` はお亡くなりになる感じなのか，それともderiving自体は現状でも書いておくべきなんでしょうか？",
        "user": "U57D08Z9U",
        "type": "message"
    },
    {
        "ts": "1519708242.000016",
        "text": "GHC Wiki(<https://ghc.haskell.org/trac/ghc/wiki/Typeable#Long-termsolution>)によれば，まだ結局Long-term solutionが見つかってなくて， everything is `Typeable` でderivingされたものは無視するという方針でいく感じですかね？ そうなると現状， `AutoDeriveTypeable` が有効になってる前提で書くのがいいのか， `DeriveDataTypeable` でいちよderivingを書いていくのがいいのかどっちなんですかね？",
        "user": "U57D08Z9U",
        "type": "message"
    },
    {
        "ts": "1519720508.000136",
        "text": "System.Process.procにShift_JISで引数を渡す方法はありますか?\nとあるELFバイナリがShfit_JISで文字列引数を受け取るのでShfit_JISで文字列引数を渡して起動する必要があります\nIConv.convert \"UTF-8\" \"SHIFT-JIS\"でStringをShift_JISのByteString文字列にすることは出来たのですが\nprocが受け取るのはUCS-4の集まりであるStringなので詰みました\nとりあえずData.ByteString.Lazy.Char8.unpackでStringにしてみたのですが普通に文字化けしました\nsetForeignEncodingしてみれば良いのではという助言を貰って\n<https://twitter.com/mod_poppo/status/968397772301873152>\nlatin1やchar8を設定してみたのですが文字化けするのは変わりません\nprocにはShift_JISの文字列引数を渡すことは出来ないのでしょうか?",
        "user": "U57CUMWQ6",
        "type": "message"
    },
    {
        "ts": "1519721210.000125",
        "text": "Shift_JISを使うにはSystem.Posix.Process.ByteStringを使うしか無かったりするんでしょうか",
        "user": "U57CUMWQ6",
        "type": "message"
    },
    {
        "ts": "1519748214.000344",
        "text": "sortがうまくいかず困っています。\n<https://github.com/wat-aro/hs-issues/issues/2>\n\nプログラミングElixirにあったGitHubからIssueを取ってきてテーブル表示するコマンドラインツールをHaskellで作ろうとしているんですが、取得したデータのリストをソートしようとして、なぜか一番上に来るはずの要素が一番下に来てしまいます。そのデータ以外は期待した並び順になっていてよくわかりません。\nこれなにがおかしくてこうなってしまうのでしょうか？\n<https://github.com/wat-aro/hs-issues/blob/master/app/Main.hs>",
        "user": "U4LEB9UP4",
        "type": "message"
    },
    {
        "ts": "1519749181.000687",
        "text": "自己解決しました。foldrで出力するときに先頭の要素を最後に持ってきていた。",
        "user": "U4LEB9UP4",
        "type": "message"
    },
    {
        "ts": "1519783069.000052",
        "text": "多分そうだと思います。\n:confused: .oO(typed-processを勧めようかと思ったけど、結局同じ問題があるな… 提案してみようかしら…)",
        "user": "U4LGTMTMK",
        "type": "message"
    },
    {
        "ts": "1519819462.000492",
        "text": "ググったらRustをFFIするサンプルコードが結構でてきてホクホクしてきた\nこれ使おう",
        "user": "U7V6G63LJ",
        "type": "message"
    },
    {
        "ts": "1519819797.000178",
        "text": "よく考えたらコネクション保持しないといけないからそのままじゃだめだった",
        "user": "U7V6G63LJ",
        "type": "message"
    },
    {
        "ts": "1519957857.000079",
        "text": "<@U98QDF5EJ> has joined the channel",
        "user": "U98QDF5EJ",
        "type": "message"
    },
    {
        "ts": "1519972493.000138",
        "text": "<@U7PL7ACDU> has joined the channel",
        "user": "U7PL7ACDU",
        "type": "message"
    },
    {
        "ts": "1519986091.000188",
        "text": "<@U74KTAG0N> has joined the channel",
        "user": "U74KTAG0N",
        "type": "message"
    },
    {
        "ts": "1520006388.000108",
        "text": "<@U7V6G63LJ> has left the channel",
        "user": "U7V6G63LJ",
        "type": "message"
    },
    {
        "ts": "1520042790.000038",
        "text": "QuickCheckを使ってライブラリのテストを書く時、 `instance Arbitrary` ってライブラリ側に書くのとテスト側に orphan instance として書くの、どちらがいいんでしょう。",
        "user": "U98QDF5EJ",
        "type": "message"
    },
    {
        "ts": "1520043481.000036",
        "text": "公開して有用ならライブラリ側に書き、公開するつもりがないならテスト側に書けばいいでしょう。",
        "user": "U56MBRKR9",
        "type": "message"
    },
    {
        "ts": "1520043499.000141",
        "text": "テスト側に書いたら `{-# OPTIONS_GHC -fno-warn-orphans #-}` を書いておきます。",
        "user": "U56MBRKR9",
        "type": "message"
    },
    {
        "ts": "1520223577.000029",
        "text": "`imperative-edsl` の `System.IO.Fake` モジュールで定義されている `fakeIO` 関数を使ってこんな感じのテストを書いてみたんですが、他の方法って何かあります？\n\n```\nmodule Main where\n\nimport System.IO.Fake (fakeIO)\nimport Test.Hspec (hspec, describe, it)\nimport Test.Hspec.Expectations (shouldReturn)\n\nmain =  hspec $\n  describe \"Prelude.head\" $\n    it \"returns the first element of a list\" $\n      fakeIO act \"Haskell\" `shouldReturn` \"('H','a')\\n\"\n\nact :: IO ()\nact = do\n  x &lt;- getChar\n  getChar\n  y &lt;- getChar\n  print (x, y)\n```\n\n```\nFailures:\n\n  Main.hs:10:\n  1) Prelude.head returns the first element of a list\n       expected: \"('H','a')\\n\"\n        but got: \"('H','s')\\n\"\n```\n\n<https://github.com/emilaxelsson/imperative-edsl/blob/master/src/System/IO/Fake.hs>",
        "user": "U5B3EGEFQ",
        "type": "message"
    },
    {
        "ts": "1520242771.000492",
        "text": "それは IO をテストする他の方法という意味ですか？それともfakeIOの他の使い方という意味でしょうか？",
        "user": "U4LGTMTMK",
        "type": "message"
    },
    {
        "ts": "1520243251.000439",
        "text": "`IO ()` をテストする他の方法という意味ですー。",
        "user": "U5B3EGEFQ",
        "type": "message"
    },
    {
        "ts": "1520289597.000085",
        "text": "fakeIO がどういう仕組みでやっているのかは存じませんが（もしかしたら実質同じパターンかも）、 `IO` している関数に手を入れることができるなら、 :point_down: こういうちょっとした依存性注入パターンを使いますね。\n\n```\ndata Env m =\n  Env { print :: String -&gt; m (), read :: m String }\nuseIo :: Monad m =&gt; Env m -&gt; m ()\nuseIo e = do\n  s &lt;- read e\n  print s\n```\n\nこうすることで、実際に `IO` するかどうかを `Env` の中身に委ねつつ、 `useIo` を実質純粋な関数として維持できます。\nあとは `Env` を `ReaderT` を経由して渡すようにすれば、見かけとしてもバッチリになるでしょう。\n合わせて読みたい: <https://www.fpcomplete.com/blog/2017/07/the-rio-monad>\n\nあと、標準出力にしか対応していなくて悩ましいですが、全く違うアプローチとして、\n\n<http://syocy.hatenablog.com/entry/haskell-library-2016#%E3%83%86%E3%82%B9%E3%83%88>\n\nで触れている、 `silently` パッケージというのもあります。\nこちらは `stdout` を再オープンして書き換える、という大胆不敵なやり方をとっています。",
        "user": "U4LGTMTMK",
        "type": "message"
    },
    {
        "ts": "1520333709.000043",
        "text": "C++で書かれたライブラリのバインディングを作る際のオススメの方法ってありますか？\n今 <https://github.com/wavewave/fficxx> が少し気になっているのですが、使ったことある人がいたら、感想を知りたいです。",
        "user": "U4MA78F6X",
        "type": "message"
    },
    {
        "ts": "1520337228.000012",
        "text": "「テスト可能な形で入出力を切り離す」という目的ならば、Conduitを使うのもありかな、と思います\n\n```\nmodule Main where\n\nimport Data.Conduit (ConduitM, await, yield, runConduit, runConduitPure, (.|))\nimport qualified Data.Conduit.List as CL\nimport Conduit (stdinC, stdoutC)\nimport Data.ByteString.Char8 (pack, unpack)\nimport Test.Hspec (hspec, describe, it)\nimport Test.Hspec.Expectations (shouldBe)\n\nmain = hspec $\n  describe \"Prelude.head\" $\n    it \"returns the first element of a list\" $\n      runConduitPure (CL.sourceList \"Haskell\" .| act .| await) `shouldBe` Just ('H','a')\n\nact :: Monad m =&gt; ConduitM Char (Char, Char) m ()\nact = do\n  Just x &lt;- await\n  await\n  Just y &lt;- await\n  yield (x, y)\n\nactIO :: IO ()\nactIO = runConduit $\n  stdinC .|\n  CL.concatMap unpack .|\n  act .|\n  CL.map (pack . show) .|\n  stdoutC\n```",
        "user": "U570660KX",
        "type": "message"
    },
    {
        "ts": "1520338644.000084",
        "text": "<@U7JEMP5SR> has joined the channel",
        "user": "U7JEMP5SR",
        "type": "message"
    },
    {
        "ts": "1520389859.000178",
        "text": "CPP GHC拡張の `MIN_VERSION_*` で4桁を指定する方法ってないですよね？\n具体的には `hoge-1.2.3.4` と `hoge-1.2.3.5` で振る舞いを分ける方法って無いですよね？",
        "user": "U56L7EVNY",
        "type": "message"
    },
    {
        "ts": "1520390185.000200",
        "text": "そのマクロは3桁までしか扱わないので、できないと思います。PVP compliantならば最後の桁の違いによってユーザから見えるAPIの違いはないはずという考えだと思います。",
        "user": "U4M9NJ7QE",
        "type": "message"
    },
    {
        "ts": "1520390618.000239",
        "text": "やっぱそうですよね....",
        "user": "U56L7EVNY",
        "type": "message"
    },
    {
        "ts": "1520397995.000020",
        "text": "<@U4LGTMTMK> ありがとうございます。\n`fakeIO` の実装は `silently` にインスパイアされたものなので、仕組み自体は `silently` に近いです。\n\n`Env` を使った依存性注入パターンでは、例えば通常 `putStrLn` を使って出力している箇所を `Env` の `print` に差し替える必要がありそうですね。\n\nこのやり方に近い感じですか？\n<https://lexi-lambda.github.io/blog/2017/06/29/unit-testing-effectful-haskell-with-monad-mock/>\n\n標準入出力だけしか考えてなかったので、参考になりました。ありがとうございます。",
        "user": "U5B3EGEFQ",
        "type": "message"
    },
    {
        "ts": "1520398337.000012",
        "text": "&gt; このやり方に近い感じですか？\n&gt; <https://lexi-lambda.github.io/blog/2017/06/29/unit-testing-effectful-haskell-with-monad-mock/>\n\n型クラスはimplicit parameterなわけですから、 `Env` を implicit に渡していると考えれば近いかと思います。\n個人的には `Env` は直接渡した方が、型クラスより柔軟でお勧めです。",
        "user": "U4LGTMTMK",
        "type": "message"
    },
    {
        "ts": "1520398525.000053",
        "text": "<@U570660KX> 今回の目的は `テスト可能な形で入出力を切り離す` というよりは、既存のコードをできるだけ変更せずにテストするためにはどうしたら良いのかな？という感じでした。 (ちゃんと明示してなくてすみません。)\n\n`Conduit` あまり詳しく無いのですが、こういうこともできるんですね。勉強になりました。ありがとうございます。",
        "user": "U5B3EGEFQ",
        "type": "message"
    },
    {
        "ts": "1520399627.000215",
        "text": "一応、.cabalで `hoge &lt;=1.2.3.4` に依存するか `hoge &gt;=1.2.3.5` に依存するかのフラグを定義して、それに応じて `CPP-Options:` を設定する、という手はありますが。",
        "user": "U4MA78F6X",
        "type": "message"
    },
    {
        "ts": "1520399686.000153",
        "text": "ちょうど同じようなこと書こうとしてましたw \n参考までに。\n\npatchlevel より下の桁で試してないので勘で物を言っていますが、cabal の flags ソルバで cpp-options を切り替える方法はどうでしょうか？\nbuild-depends の条件が満たされない場合は、cabal のソルバが manual ではない flag の値を反転して条件が満たされるまで試すので、cpp-options で適当なマクロを define しておけば CPP マクロで参照できる気がします。\n\n```\nflag hogefuga-new-version\n  default: True\n  manual: False\n\nlibrary\n  ... (snip)\n  \n  if flag(hogefuga-new-version)\n    build-depends:\n      hogefuga &gt;= 1.2.3.5\n    cpp-options: -DHOGEFUGA_NEW_VERSION\n  else\n    build-depends:\n      hogefuga &gt;= 1 &amp;&amp; &lt; 1.2.3.5\n```",
        "user": "U4KNX1LQ0",
        "type": "message"
    },
    {
        "ts": "1520399722.000196",
        "text": "いいアイデアですね",
        "user": "U4M9NJ7QE",
        "type": "message"
    },
    {
        "ts": "1520400347.000076",
        "text": "この方法って、  `hogefuga-new-version` フラグを cabal build のときに渡して切り替える感じですか？",
        "user": "U56L7EVNY",
        "type": "message"
    },
    {
        "ts": "1520400391.000071",
        "text": "manual: Falseだとcabalが勝手にon/offを切り替えてくれます",
        "user": "U4M9NJ7QE",
        "type": "message"
    },
    {
        "ts": "1520400609.000129",
        "text": "おぉ、ダメだったら勝手に切り替えてくれるんですね。\nありがとうございます、試してみます。\n<https://www.haskell.org/cabal/users-guide/developing-packages.html#pkg-field-flag-manual>",
        "user": "U56L7EVNY",
        "type": "message"
    },
    {
        "ts": "1520402940.000119",
        "text": "どうやら、stack ではこの方法が出来無いようです(できなかった...)\n<https://github.com/commercialhaskell/stack/issues/2197>",
        "user": "U56L7EVNY",
        "type": "message"
    },
    {
        "ts": "1520405585.000021",
        "text": "stack 使うのであれば、stack.yaml の resolver と extra-deps から hoge のバージョンが一意に定まるはずなので、stack.yaml の flags にどちらかを明示しておけば良い気がします。",
        "user": "U4KNX1LQ0",
        "type": "message"
    },
    {
        "ts": "1520594742.000168",
        "text": "`replicate 100 False` で作成したリストに対して、\n```\nmkcs :: Int -&gt; [Bool] \nmkcs n = [if (x`mod`n==0)then True else False|x&lt;-[1..100]]\n```\nを`n&lt;-[1.100]`でandを取りたいときのコードを以下のように書いてみたのですが、これよりスッキリとした書き方はないでしょうか？\n```\nturn :: ([Bool],Int) -&gt; ([Bool],Int)\nturn (cs.n)\n    | n == 100  = (nxt,100)\n    | otherwise = turn (nxt,(n+1))\n    where \n        nxt = zipWith xor cs (mkcs n)\n        xor a b = ((not a)&amp;&amp;b) || (a&amp;&amp;(not b))\n\nmain = do\n    let c = replicate 100 False\n    print turn (c, 2) \n```",
        "user": "U86V3B4PJ",
        "type": "message"
    },
    {
        "ts": "1520595984.000097",
        "text": "`mkcs` の定義自体は `mkcs n = [x `mod` n == 0 | x &lt;- [1..100]]` でも良いですよね",
        "user": "U98QDF5EJ",
        "type": "message"
    },
    {
        "ts": "1520597258.000295",
        "text": "`ands` じゃなくて `turn` ??",
        "user": "U56L7EVNY",
        "type": "message"
    },
    {
        "ts": "1520597532.000398",
        "text": "`nxt = zipWith and cs (mkcs n)` も ` nxt = zipWith (&amp;&amp;) cs (mkcs n)` かな？",
        "user": "U56L7EVNY",
        "type": "message"
    },
    {
        "ts": "1520598003.000214",
        "text": "スタート `False` だと何べん `(&amp;&amp;)` しても `False` だからなにしたいコードかよくわからないですね...",
        "user": "U56L7EVNY",
        "type": "message"
    },
    {
        "ts": "1520600268.000038",
        "text": "説明を簡略化しようとして，いろいろミスっていました\nands -&gt; turn \nand -&gt; xor とします．",
        "user": "U86V3B4PJ",
        "type": "message"
    },
    {
        "ts": "1520600472.000027",
        "text": "あー xor か",
        "user": "U56L7EVNY",
        "type": "message"
    },
    {
        "ts": "1520600587.000367",
        "text": "ちなみに、Haskell に xor あるよ\n<http://hackage.haskell.org/package/base-4.10.1.0/docs/Data-Bits.html#v:xor>",
        "user": "U56L7EVNY",
        "type": "message"
    },
    {
        "ts": "1520601088.000382",
        "text": "うーん、すっきりかどうかは分からないけど\n```\nturn :: ([Bool], Int) -&gt; ([Bool], Int)\nturn = until ((&gt; 100) . snd) (\\(cs, n) -&gt; (zipWith xor cs (mkcs n), n + 1))\n```",
        "user": "U56L7EVNY",
        "type": "message"
    },
    {
        "ts": "1520601395.000278",
        "text": "欲しいのは `[Bool]` だけだったら普通に畳み込みでいいのか\n```\nimport Data.Bits\n\nmain = print $ turn [2..100] (replicate 100 False)\n\nturn :: [Int] -&gt; [Bool] -&gt; [Bool]\nturn ns cs = foldl (\\cs' n -&gt; zipWith xor cs' (mkcs n)) cs ns\n\nmkcs :: Int -&gt; [Bool] \nmkcs n = [x `mod` n == 0 | x &lt;- [1..100]]\n```",
        "user": "U56L7EVNY",
        "type": "message"
    },
    {
        "ts": "1520604135.000611",
        "text": "助言ありがとうございます\n畳み込みがまだ慣れてないのが，ネックになってそうなので，勉強がんばります",
        "user": "U86V3B4PJ",
        "type": "message"
    },
    {
        "ts": "1520700707.000019",
        "text": "もともとの問題を解くだけなら、100 という1つの整数からリストの構成を1回だけにするようなコードも書けるには書けますね。\n\n```\nmodule Main where\n\nimport Control.Arrow ((***))\nimport Data.Bool (bool)\n\nmain :: IO ()\nmain = print (fromEnum &lt;$&gt; mkes 100)\n\nmkes :: Int -&gt; [Bool]\nmkes b = hylo ((:) . mke b) [] phi b\n  where\n    phi 0 = Nothing\n    phi n = Just (succ (b - n), pred n)\n\nmke :: Int -&gt; Int -&gt; Bool\nmke b m = hylo xor False phi b\n  where\n    phi 0 = Nothing\n    phi n = Just (m `mod` succ (b - n) == 0, pred n)\n\nhylo :: (a -&gt; b -&gt; b) -&gt; b -&gt; (c -&gt; Maybe (a, c)) -&gt; c -&gt; b\nhylo f e phi x = maybe e (uncurry ($) . (f *** hylo f e phi)) (phi x)\n\nxor :: Bool -&gt; Bool -&gt; Bool\nxor p q = bool p (not p) q\n```",
        "user": "U4KU9ABL0",
        "type": "message"
    },
    {
        "ts": "1520860256.000049",
        "text": "<@U9NUV224E> has joined the channel",
        "user": "U9NUV224E",
        "type": "message"
    },
    {
        "ts": "1520997879.000079",
        "text": "`machinecell` について質問です。\n<https://hackage.haskell.org/package/machinecell>\n\n複数のストリームが同時に流れることがあると思うのですが、その場合、複数スレッドで並行（？）処理されるような機能はありますでしょうか？\nreadme に parallel という文字が見えるのですが、それがどういう意味なのかいまいちつかめず・・・",
        "user": "U4LNDESN8",
        "type": "message"
    },
    {
        "ts": "1520998870.000153",
        "text": "どうもです。そこのparallelという単語は、単にArrowの `(***)` 演算子が平行に射を合成するよ、という意味で使っているもので、並列演算の意味ではないんですね。パッケージの標準機能としては、マルチスレッド的なものは提供していません。",
        "user": "U570660KX",
        "type": "message"
    },
    {
        "ts": "1520999077.000090",
        "text": "並行処理対応としては、Pipes.Concurrentのspawnに相当する機能を試験実装していたりします(今作っているアプリのコードにこっそり入っている)。 <https://github.com/as-capabl/armageddon/blob/53004f980f17eea5c6ea38a8c5ea53d2ead264e9/machinecell-extra/src/Control/Arrow/Machine/World.hs#L487>",
        "user": "U570660KX",
        "type": "message"
    },
    {
        "ts": "1521002869.000002",
        "text": "あ、作者さんだ！\n回答ありがとうございます！",
        "user": "U4LNDESN8",
        "type": "message"
    },
    {
        "ts": "1521002955.000157",
        "text": "マルチスレッド的な事情については了解しました。",
        "user": "U4LNDESN8",
        "type": "message"
    },
    {
        "ts": "1521002967.000186",
        "text": "試験実装の方、おもしろそうですね！",
        "user": "U4LNDESN8",
        "type": "message"
    },
    {
        "ts": "1521022633.000006",
        "text": "とりあえずコンパイルが通るコードが無いと何をしたいのかわからない\n引数を([Bool], Int) -&gt; xにするぐらいなら[Bool] -&gt; Int -&gt; xにした方が良さそうですが\nそもそもこの[Bool]必要なのか疑問",
        "user": "U57CUMWQ6",
        "type": "message"
    },
    {
        "ts": "1521197380.000419",
        "text": "Slack上の「Haskell入門 関数型プログラミング言語の基礎と実践」読書会で\n「transformersパッケージと mtlパッケージの違いはなんだろう」\nという疑問が出てました。\n<https://umekitahs.slack.com/>",
        "user": "U57CGDBMG",
        "type": "message"
    },
    {
        "ts": "1521209862.000265",
        "text": "transformers と mtl の歴史的なことは <https://wiki.haskell.org/Monad_Transformer_Library> にまとまっているようです。これは私のブログ (<http://syocy.hatenablog.com/entry/haskell-library-2016>) にも書いたことがあり、孫引きしてしまうと、\n\n&gt;  まず初期にmtl(mtl V1)があり、その後に新機能のtype familiesを用いたmtl-tfが開発されたものの mtlと重複した部分が多く互換性もなかった。 そこで拡張なしの素のHaskell98で動くtransformersが開発され、 その上にmonads-fdとmonads-tfを別々に構築することで互換性の問題は解決された。 しかしその頃にはすでにmtlが広く使われていたため、transformersとmonads-fdからmtlを再構築(mtl V2)することになった、 という経緯のようです。\n\n実際的な違いは、transformers はより古い Haskell で動く、mtl はより洗練された API を持っている、ということになりそうです。",
        "user": "U4M598NHM",
        "type": "message"
    },
    {
        "ts": "1521245351.000002",
        "text": "Extensible Effectが保持するモナド数によらずに定数時間で処理できるのはなぜなんですか?(この記事です <https://konn-san.com/prog/haskell/extensible-effects.html>",
        "user": "U5FTM76CA",
        "type": "message"
    },
    {
        "ts": "1521274227.000077",
        "text": "ありがとうございます。「Haskell入門 関数型プログラミング言語の基礎と実践」読書会に伝えてこちらの slack のことも宣伝しておきます。",
        "user": "U57CGDBMG",
        "type": "message"
    },
    {
        "ts": "1521335256.000057",
        "text": "2つのライブラリーがあって、 `MonadError SomeException m =&gt; m a` な文脈の中で `MonadThrow m =&gt; m a` な関数を使いたくなったんですが、混ぜるハックありますかね？\n```\nfoo :: MonadError SomeException m =&gt; m a\nfoo = do\n  -- ここで使いたい\n  -- 型はライブラリー A で決まってある\n\nbar :: MonadThrow m =&gt; m a\n-- これを使いたい\n-- 型はライブラリー B で決まってある\n```",
        "user": "U4L0B71L1",
        "type": "message"
    },
    {
        "ts": "1521336466.000060",
        "text": "まず、MonadErrorとはmtlのでしょうか？",
        "user": "U57D08Z9U",
        "type": "message"
    },
    {
        "ts": "1521336587.000059",
        "text": "それから、これの意図はMonadThrowのthrowMをMonadErrorのthrowErrorにするようにしたいということでしょうか？",
        "user": "U57D08Z9U",
        "type": "message"
    },
    {
        "ts": "1521341144.000061",
        "text": "&gt; MonadErrorとはmtlのでしょうか？\nそうです\nそれから `MonadThrow` は exceptions のです",
        "user": "U4L0B71L1",
        "type": "message"
    },
    {
        "ts": "1521341190.000068",
        "text": "&gt; これの意図はMonadThrowのthrowMをMonadErrorのthrowErrorにするようにしたいということでしょうか？\nそうですね。例えば一旦捕えて投げ直すとか。",
        "user": "U4L0B71L1",
        "type": "message"
    },
    {
        "ts": "1521341881.000032",
        "text": "MonadErrorはパラメータeが必要な気がするんですが、そこにはSomeExceptionを当てはめる想定ですか？",
        "user": "U57D08Z9U",
        "type": "message"
    },
    {
        "ts": "1521343389.000054",
        "text": "おっとそうでした。元の投稿を直しました。",
        "user": "U4L0B71L1",
        "type": "message"
    },
    {
        "ts": "1521350658.000036",
        "text": "either throwM pure (bar :: Either SomeException a)\n\nor\n\nnewtype MonadThrowWrapper m a = W (m a) deriving (Functor, Applicative, Monad)\ninstance MonadError SomeException m =&gt; MonadThrow (MonadThrowWrapper m) where\n  throwM = W . throwError . toException\nmonadThrowToError :: forall me a. MonadError SomeException me =&gt; (forall mt. MonadThrow mt =&gt; mt a) -&gt; me a\nmonadThrowToError x = coerce (x @(MonadThrowWrapper me))\n\nmonadThrowToError bar",
        "user": "U57D08Z9U",
        "type": "message"
    },
    {
        "ts": "1521350831.000003",
        "text": "とかですかね？",
        "user": "U57D08Z9U",
        "type": "message"
    },
    {
        "ts": "1521367218.000039",
        "text": "下の方を参考にうまくいきましたー！ :muscle:",
        "user": "U4L0B71L1",
        "type": "message"
    },
    {
        "ts": "1521369295.000060",
        "text": "なんかスマフォから打ってめっちゃ間違ってたのと書きかけだったので，いちよ修正しときました",
        "user": "U57D08Z9U",
        "type": "message"
    },
    {
        "ts": "1521449331.000049",
        "text": "論文をちゃんと読んでなくて、実装だけで理解してるので、もしかしたら不正確かもしれませんが…\nたとえば、以下のようにMaybeモナドがたくさん重なったものを考えます。\n\n```\ntype M5 = MaybeT (MaybeT (MaybeT (MaybeT Maybe)))\n```\n\nこれのreturnとbind(&gt;&gt;=)を書き下してやると、重ねたモナドの数だけ型構築や型分解のコストが増えている事が分かります。\n\n```\nreturnM5 :: a -&gt; M5 a\nreturnM5 x= MaybeT $ MaybeT $ MaybeT $ MaybeT $ Just $ Just $ Just $ Just $ Just x\n\nbindM5 :: M5 a -&gt; (a -&gt; M5 b) -&gt; M5 b\nbindM5 x = \n  case x of\n    Nothing -&gt; MaybeT $ MaybeT $ MaybeT $ MaybeT $ Nothing\n    Just x -&gt;\n      case x of\n        Nothing -&gt; MaybeT $ MaybeT $ MaybeT $ MaybeT $ Just $ Nothing\n        Just x -&gt; ...```\n\n一方で、EEではOpen Unionという仕組みを使って、以下のようなデータ型をコンパイル時に生成します。\n\n```\ndata M5' a = Just' a | Nothing1 | Nothing2 | Nothing3 | Nothing4 | Nothing5\n```\n\nこれによって、いくら重ねるモナドが増えても型構築や型分解のコストが増えない、という訳です。",
        "user": "U570660KX",
        "type": "message"
    },
    {
        "ts": "1521449361.000372",
        "text": "モナド→モナド変換子、ですね",
        "user": "U570660KX",
        "type": "message"
    },
    {
        "ts": "1521506318.000196",
        "text": "階層になっていないから深く潜るためのコストがいらないってことですか。open-unionはただのunionとなにか違うんですか?",
        "user": "U5FTM76CA",
        "type": "message"
    },
    {
        "ts": "1521518478.000101",
        "text": "普通のunionというのは、Haskellの普通の和型、data T = A|B|Cのように、宣言の時点で要素を足し算して作る奴の事で、それに対してEE系パッケージに入っているopen-union(単にUnionとかの名前になっている事が多い)は「全体の型を明示せずに構築したりパターンマッチしたりできる」という特徴があります",
        "user": "U570660KX",
        "type": "message"
    },
    {
        "ts": "1521520183.000126",
        "text": "使わないところはプレースホルダーでもおいて使えるんですね。詳しい説明ありがとうございます。",
        "user": "U5FTM76CA",
        "type": "message"
    },
    {
        "ts": "1521528970.000121",
        "text": "集合論･群論の本でわかりやすい本を教えてください。大学数学超初心者です。",
        "user": "U5FTM76CA",
        "type": "message"
    },
    {
        "ts": "1521529603.000275",
        "text": "<#C7Y71415W|math> という部屋がありますので、そちらで聞くといいと思います。\n個人的には、初歩的な分野で書籍数も比較的多いので、書店でパラパラめくって読めそうなものを選んだりamazonのレビュー高い本であればどれでも勉強できるのかなと思いました。",
        "user": "U4MAYDV9C",
        "type": "message"
    },
    {
        "ts": "1521781625.000189",
        "text": "`stack hoogle` コマンドを普通に実行すると、現在開発している（stack.yamlを置いている）プロジェクトのインデックスを生成したいのか、開発中のプロジェクトのビルドを始めます。\nこれを、依存しているパッケージのドキュメントに対するインデックスの生成に限定することはできるでしょうか？\n開発中のプロジェクトは、ビルドが通らない状態になっていることが多いので、開発中のプロジェクトが原因でインデックスを生成できないのはつらいです。",
        "user": "U4LGTMTMK",
        "type": "message"
    },
    {
        "ts": "1521782215.000183",
        "text": "`stack hoogle -- generate base` ?",
        "user": "U98QDF5EJ",
        "type": "message"
    },
    {
        "ts": "1521782590.000016",
        "text": "`stack hoogle -- generate` でいけました！\n（ :thinking_face: さっき手元の環境で `openBinaryFile: invalid argument (Invalid argument)` と出たのは何だったんだろう。。。）\nいずれにしてもありがとうございます！",
        "user": "U4LGTMTMK",
        "type": "message"
    },
    {
        "ts": "1521872215.000048",
        "text": "例えば\n```haskell\nmodule Sonoda.Parser\n#if ON_GHCI\n  ( ParseException (..)\n  , parseExpr\n  , parseType\n  , exprParser\n  , typeParser\n  ) where\n#else\n  where\n#endif\n```\nのようにして、CLIで`stack ghci --on-ghci`みたいな感じ（感じ）でghciを起動したときにだけ\n全てエクスポートしてくれるような方法を探しているのですが、何かないですか？:writing_hand:",
        "user": "U5LV76EJH",
        "type": "message"
    },
    {
        "ts": "1521885679.000041",
        "text": ":load コマンドでそのmoduleを読んだだけではダメなんですかね…\n\nそりゃ敢えてやるとしたら、cabalファイルにflagを書いて、CPPの変数を定義すればできそうな気がしますが…",
        "user": "U4LGTMTMK",
        "type": "message"
    },
    {
        "ts": "1521886841.000082",
        "text": "ついでに，other-modulesでInternalモジュールにしてそこでは全てexportし，exposed-modulesでreexportするのはダメなんですか？",
        "user": "U57D08Z9U",
        "type": "message"
    },
    {
        "ts": "1521896204.000095",
        "text": "&gt; :load コマンドでそのmoduleを読んだだけではダメなんですかね…\n\nおっ、なるほど、:loadってexportされてない関数も読めるんですか！",
        "user": "U5LV76EJH",
        "type": "message"
    },
    {
        "ts": "1521896383.000007",
        "text": "&gt; ついでに，other-modulesでInternalモジュールにしてそこでは全てexportし，exposed-modulesでreexportするのはダメなんですか？\nうーん、考えてみます。\n\nお二人ともありがとうございます！",
        "user": "U5LV76EJH",
        "type": "message"
    },
    {
        "ts": "1521901368.000032",
        "text": "こんにちは。 HaskellでMessagePackのライブラリはどれを使えばよいかご存知の方、教えていただけますか？\n\ndata-msgpackというライブラリが該当するかと思い調べているのですが、 timestampの読み込みで、このコードだと、 2バイト目以降を読んでいるように思うのですが、 msgpackの仕様をみると、2バイト目は“Type”なので、読むなら3バイト目以降じゃないといけない気がしてます。ちゃんとテストすればいいのですが、そもそもこのライブラリでよいのかどうか自信がなく、深入りするまえにおたずねしています。\n\n<https://github.com/TokTok/hs-msgpack/blob/ecfa24d5e237639597797b8e826b37e92efe4fe3/src/Data/MessagePack/Get.hs#L146>\n\n<https://github.com/msgpack/msgpack/blob/master/spec.md#ext-format-family>",
        "user": "U7GSVRQ6S",
        "type": "message"
    },
    {
        "ts": "1521973072.000035",
        "text": "意外と種類ありますね\n<https://hackage.haskell.org/packages/search?terms=messagepack>",
        "user": "U56L7EVNY",
        "type": "message"
    },
    {
        "ts": "1521977301.000033",
        "text": "ほかに同じように使っている人がいればいいんですが、ちょっといなければ深入りするしかなさそうですね。。。 :disappointed:",
        "user": "U4LGTMTMK",
        "type": "message"
    },
    {
        "ts": "1522029223.000192",
        "text": "windowsでHDBC-mysql使っている方いますか？\nこちらの記事やhdbc-mysqlのissueを見ると使うの結構大変そうだなと思ったのですが、どちらもある程度古い記述のため、もしかしたら周辺環境とかで状況変わってないかなと。\n<http://tsubaki.hatenablog.com/entry/20121020/1350734844>",
        "user": "U59TQ3MJ9",
        "type": "message"
    },
    {
        "ts": "1522029492.000165",
        "text": "半年ほど前だったか試してみましたが libmysqlclient をリンカー（？）にうまく探してもらえなくて1日格闘して、諦めて VM にしました",
        "user": "U4L0B71L1",
        "type": "message"
    },
    {
        "ts": "1522029981.000176",
        "text": "<@U4L0B71L1> ありがとうございます！\nなるほど、、かなり苦戦する点ありそうですね。\n格闘する前に感触知れて助かりました。\n（まさにwinで動くように頑張るか、vmにするか検討してる状況でした）",
        "user": "U59TQ3MJ9",
        "type": "message"
    },
    {
        "ts": "1522035227.000187",
        "text": "<@U8X01G6FJ> has left the channel",
        "user": "U8X01G6FJ",
        "type": "message"
    },
    {
        "ts": "1522054664.000183",
        "text": "ソースを非公開のままで Haskell 製のライブラリを提供する方法を探してます。\nソース非公開のパッケージを作る方法（＝ pre built なバイナリ + ヘッダのようなもの）ってありますでしょうか？",
        "user": "U4LNDESN8",
        "type": "message"
    },
    {
        "ts": "1522054972.000096",
        "text": "DLLや.soファイルとして公開するなら GHCの -shared オプションが使えそうですけども、そういう話ではないんですよね。。。",
        "user": "U4LGTMTMK",
        "type": "message"
    },
    {
        "ts": "1522055061.000092",
        "text": "その場合、その .so で提供される関数を Haskell からコールするには、なにかしら FFI をかまさないといけないですよね。",
        "user": "U4LNDESN8",
        "type": "message"
    },
    {
        "ts": "1522055084.000227",
        "text": "そっすね。",
        "user": "U4LGTMTMK",
        "type": "message"
    },
    {
        "ts": "1522055101.000544",
        "text": "参考にするとしたら <http://www.kotha.net/ghcguide_ja/7.0.4/separate-compilation.html> らへんの話ですかね。\n&gt; ソースファイルをコンパイルするとき、GHCはふつう二つのファイルを出力する。オブジェクトファイルとインタフェースファイルである。\n\n&gt; オブジェクトファイルは通常.oで終わり、そのモジュールのコンパイル済みコードを含む。\n\n&gt; インタフェースファイルはふつう.hiで終わり、そのモジュールに依存するモジュールをコンパイルするときに必要な情報を含む。エクスポートされた関数の型や、データ型の定義といったものがこれに含まれる。バイナリ形式なので、読もうとしないように。代わりに—-show-ifaceオプションを使うことができる。",
        "user": "U4LGTMTMK",
        "type": "message"
    },
    {
        "ts": "1522055190.000248",
        "text": "そのドキュメントを読む限りでは、*.hi とバイナリがあれば、いけそうな感じはするんですよね。",
        "user": "U4LNDESN8",
        "type": "message"
    },
    {
        "ts": "1522055433.000034",
        "text": "stack でビルドすると、 `.stack-work/install/` 以下に必要なものが出力されてるっぽいのですが、この中から必要な部分を抜き出して、他の環境にもっていけないかなー、と妄想してます。",
        "user": "U4LNDESN8",
        "type": "message"
    },
    {
        "ts": "1522055481.000560",
        "text": "プラットフォームやアーキテクチャは揃っている、という前提で。",
        "user": "U4LNDESN8",
        "type": "message"
    },
    {
        "ts": "1522055516.000397",
        "text": "ちなみに個人的にはソースコードをNDAを結びつつ渡すのと大差ないだろうと思っているんですが、そこまでしてやりたい理由ってあるんですか？",
        "user": "U4LGTMTMK",
        "type": "message"
    },
    {
        "ts": "1522055648.000185",
        "text": "まさにそこなんですが、提供先にもコードは隠蔽して機能を提供したい、という判断があります。",
        "user": "U4LNDESN8",
        "type": "message"
    },
    {
        "ts": "1522055687.000248",
        "text": "そのコードがビジネスのコアになっている、ということでして。",
        "user": "U4LNDESN8",
        "type": "message"
    },
    {
        "ts": "1522057120.000330",
        "text": "&gt; :loadってexportされてない関数も読める\nそうだったのかー",
        "user": "U4L0B71L1",
        "type": "message"
    },
    {
        "ts": "1522058624.000347",
        "text": "型宣言の中に :~&gt; という記号を見かけることがあるのですが、これは何者なんでしょうか・・・？\nコード例としてはQiitaの以下の記事があります（コメントで質問しているのも私です）\n<https://qiita.com/cyclone_t/items/8443ed5d4a77f87b1f1b>",
        "user": "U87QYA152",
        "type": "message"
    },
    {
        "ts": "1522059451.000046",
        "text": "古い servant で定義されてる型みたいですね(その記事で使われているのは少なくとも)\n<http://hackage.haskell.org/package/servant-server-0.5/docs/Servant-Server-Internal-Enter.html#t::-126--62->",
        "user": "U56L7EVNY",
        "type": "message"
    },
    {
        "ts": "1522059478.000215",
        "text": "changelog をみると 0.7 ぐらいで無くなっているかな？",
        "user": "U56L7EVNY",
        "type": "message"
    },
    {
        "ts": "1522059950.000308",
        "text": "hiのみの公開は仮に可能だったとしてもGHCのバージョンが変わるとビルドできなくなったりするので…隠蔽したい部分だけ.soや.dllにしてFFIで呼ぶのが常道な感じが",
        "user": "U570660KX",
        "type": "message"
    },
    {
        "ts": "1522060058.000044",
        "text": "hiって、詳しくは知りませんが、インライン展開する関数とかの情報が入っているっぽいので、気密保持の観点でそこまで信用できるかなあという印象もあります",
        "user": "U570660KX",
        "type": "message"
    },
    {
        "ts": "1522062253.000285",
        "text": "今自分がやっている分野ですと、 `type f :~&gt; g = forall a. f a -&gt; g a` などのFunctorの自然変換でよく見る type operator に使われていたりします。そちらのQiitaで使われている場合も `(forall a. MyAppHandler a -&gt; ExceptT ServantErr IO a)` の意味で使われているように思えました",
        "user": "U98QDF5EJ",
        "type": "message"
    },
    {
        "ts": "1522063445.000453",
        "text": "`:` で始まる記号はただのコンストラクター（ただし中置演算子）ですよー\nという、そもそもの疑問なのかなと思いました（ロジック上の意味というよりも）\n（違ってるかも",
        "user": "U4L0B71L1",
        "type": "message"
    },
    {
        "ts": "1522074747.000721",
        "text": "なるほど、了解です。",
        "user": "U4LNDESN8",
        "type": "message"
    },
    {
        "ts": "1522074816.000578",
        "text": "順当に so や dll にして FFI で呼ぶ方向で話が進みそうです。",
        "user": "U4LNDESN8",
        "type": "message"
    },
    {
        "ts": "1522102080.000459",
        "text": "型でしたか！特別な演算子かと思いました。\nQiitaの記事は0.9以降に言及されているみたいなので、0.7くらいで廃止されたとするとちょっも不自然な気がします。\n調べてみます。",
        "user": "U87QYA152",
        "type": "message"
    },
    {
        "ts": "1522136692.000144",
        "text": "これ (<http://hackage.haskell.org/package/servant-0.13/docs/Servant-Utils-Enter.html#t::-126--62->) ですね．ちょっと一見複雑なんですが，\n```\nnewtype f :~&gt; g = NT (forall a. f a -&gt; g a)\n```\nみたいな感じです．(実際の定義は， <http://hackage.haskell.org/package/natural-transformation-0.4/docs/src/Control-Natural.html#line-51> にあります)\n\nなお，servant 0.12でbreaking changes (<https://github.com/haskell-servant/servant/pull/824>) があって，現在enterはdeprecatedです．最新のお作法は， <http://haskell-servant.readthedocs.io/en/stable/tutorial/Server.html#using-another-monad-for-your-handlers> にあります．(Servantはかなりbreaking changesがあるので，半年前の資料でも信用できないことがあって辛いですが，上のチュートリアルは少なくとも最新を保っているので，何か食い違いがあれば上のRead the docsを参照するのがいいと思います)",
        "user": "U57D08Z9U",
        "type": "message"
    },
    {
        "ts": "1522147643.000359",
        "text": "フムフム…",
        "user": "U87QYA152",
        "type": "message"
    },
    {
        "ts": "1522161665.000174",
        "text": "と言ったはいいですが、かなり理解の範疇を超えています・・・\n<@U4L0B71L1> さんが書かれている\n「｀:｀ で始まる記号はただのコンストラクター（ただし中置演算子）ですよー」\nというところは、LANGUAGE TypeOperatorが付いているので ` : ` で始まる型を作れるようになっている、と理解しています。",
        "user": "U87QYA152",
        "type": "message"
    },
    {
        "ts": "1522161689.000668",
        "text": "ですので ` :~&gt; ` は型なのだ、というところまでは理解できたと思います。",
        "user": "U87QYA152",
        "type": "message"
    },
    {
        "ts": "1522162034.000572",
        "text": "しかしforallが理解できていないので、<@U98QDF5EJ> さんの説明や <@U57D08Z9U> さんの説明が理解不能です・・・",
        "user": "U87QYA152",
        "type": "message"
    },
    {
        "ts": "1522163412.000308",
        "text": "あ，なるほど．servantのAPIが理解できない話だと思ってました．ちゃんと言ってなかったですが，servant 0.13では `:~&gt;` の使用は非推奨なので，servantを使用する上では気にする必要はないです．その上でですが，この型の理解は具体的な例を考えてみるとなんとなく分かるのではないかと思い，ちょっと書いて見ました\n<https://gist.github.com/mizunashi-mana/0b7db5fb26704d47c42234a377fdd777>",
        "user": "U57D08Z9U",
        "type": "message"
    },
    {
        "ts": "1522163931.000893",
        "text": "一般に， `~&gt;` や `:~&gt;` は型を省略するための記法と思って構いません(まあそれ以上の意味もあるんですが，その辺はnatural transformationで調べてもらう他ないです)．どういう場合に省略できるかというと，型が `f a -&gt; g a` というように最終的に型引数 `a` をとる2つの型に対しての関数型になってる時で，この時 `a` は本質的でない場合が多く `f` と `g` にさえ着目すればいいためそういう場合の省略記号として `f ~&gt; g` というように用いられます",
        "user": "U57D08Z9U",
        "type": "message"
    },
    {
        "ts": "1522164277.000503",
        "text": "`:~&gt;` は `~&gt;` のnewtypeで主にCategory型クラス (<http://hackage.haskell.org/package/base-4.10.1.0/docs/Control-Category.html#t:Category>) というもののインスタンスにするために，わざわざnewtypeにしています．しかし正直ここら辺で益を得てるものは見たことないですね．結局servantでも頑張ってそれを応用したAPIを提供しようとして，結果廃止することにしましたから．",
        "user": "U57D08Z9U",
        "type": "message"
    },
    {
        "ts": "1522164670.000826",
        "text": "で，もっと技術的な部分ですが，ここの `forall` はRank N TypesというGHCの拡張機能で使えるキーワードです．調べて感じここの解説が一番分かりやすそうでしたので，ここを読んでみるといいかもしれません\n<http://sleepomeno.github.io/blog/2014/02/12/Explaining-Haskell-RankNTypes-for-all/>",
        "user": "U57D08Z9U",
        "type": "message"
    },
    {
        "ts": "1522168142.000123",
        "text": "言葉が足りなくてすみません。でも、だいぶ見えてきた気がします。\n元々はservantのAPIを調べていたところ、 ` :~&gt; ` が出てきて「これは型なのか？それともHaskell言語の予約語（？）、つまりは ` -&gt; ` みたいなものなのか？？？」という疑問が出てきて、どこを調べればいいかを見失った、という背景があります。",
        "user": "U87QYA152",
        "type": "message"
    },
    {
        "ts": "1522168199.000267",
        "text": "教えていただいたリンク先を見てみます。",
        "user": "U87QYA152",
        "type": "message"
    },
    {
        "ts": "1522169271.000238",
        "text": "`TypeOperator` は普段 `Foo a b` みたいに宣言する型を、二項演算子記号で表現できる言語拡張なので `:~&gt;` はライブラリで宣言された「型」って認識で大丈夫です。 `GHC.Generics` などに、独自定義された TypeOperator の例が沢山あります（自分も順を追って説明すりゃよかった…）",
        "user": "U98QDF5EJ",
        "type": "message"
    },
    {
        "ts": "1522172253.000347",
        "text": "なるほど！そういうことなのですね。\n最初の私の質問がかなり言葉が足りなかったと反省しています。どこまで分かっているかを、もっと書くべきでした。",
        "user": "U87QYA152",
        "type": "message"
    },
    {
        "ts": "1522192749.000215",
        "text": "あ，ついでにですが， `TypeOperator` (型演算子)は:で始まる必要はありません．今回は，元々の `~&gt;` と区別するために `:~&gt;` になってますが，\n```\ndata a * b = Pair a b\n```\nとかも書けます．混同されやすいですが，:を先頭につける必要があるのは値コンストラクタの方で，\n```\ndata Pair a b = a :* b -- a * b はダメ\n```\nみたいな感じです",
        "user": "U57D08Z9U",
        "type": "message"
    },
    {
        "ts": "1522397997.000234",
        "text": "<@U9XB88DU3> has joined the channel",
        "user": "U9XB88DU3",
        "type": "message"
    },
    {
        "ts": "1522476821.000066",
        "text": "<@U56K09PDY> has joined the channel",
        "user": "U56K09PDY",
        "type": "message"
    },
    {
        "ts": "1522551549.000030",
        "text": "functorの定義にreturnが入っていないのはどうしてですか？(圏論のfunctorの定義的には入って欲しいと思ったんですが)",
        "user": "U8XGRJ3DZ",
        "type": "message"
    },
    {
        "ts": "1522552781.000079",
        "text": "(専門じゃないから間違ってるかもだけど) Hask 圏の対象は型だからじゃない？\n`return` って型じゃなくて値を持ち上げてない？",
        "user": "U56L7EVNY",
        "type": "message"
    },
    {
        "ts": "1522552821.000063",
        "text": "<https://stackoverflow.com/questions/21647659/why-functor-class-has-no-return-function>",
        "user": "U56L7EVNY",
        "type": "message"
    },
    {
        "ts": "1522553164.000025",
        "text": "確かにそうですね(monadのreturnはunitなんですね)\nありがとうございます",
        "user": "U8XGRJ3DZ",
        "type": "message"
    },
    {
        "ts": "1522553842.000038",
        "text": "あ、なるほど、returnは自然変換だから多相関数で表現できてて、確かにこの自然変換は一般の関手に要請されるものじゃないですね",
        "user": "U4KPPQW7K",
        "type": "message"
    },
    {
        "ts": "1522571639.000033",
        "text": "Haskellの型システム上、パラメータを持つ型F、任意の型aについて、F aも型になるので、FがFunctorになる条件の一つは必ず満たされます。だからこそ引っ掛かる人が多いのかも…",
        "user": "U4KUNQF9N",
        "type": "message"
    },
    {
        "ts": "1522660251.000070",
        "text": "<@U9YSSVB88> has joined the channel",
        "user": "U9YSSVB88",
        "type": "message"
    },
    {
        "ts": "1522660470.000130",
        "text": "私も今日気になって調べていたのですが下記のページも若干違うまとめ方がされていてわかりやすかったです。\n<https://wiki.haskell.org/Monad_Transformers>",
        "user": "U9YSSVB88",
        "type": "message"
    },
    {
        "ts": "1522737355.000191",
        "text": "module exportで昔からわからないことがあるんですが\n`import qualified Data.Text as T`\nのようにimportしたものを1つのファイルにまとめてprefixを共通させることは出来ますかね?\nプレフィクスなしのものはmodule exportで出来るんですが…\n`as Import.T`みたいに書いても出来ない",
        "user": "U57CUMWQ6",
        "type": "message"
    },
    {
        "ts": "1522737456.000164",
        "text": "import文だけを書いたヘッダーファイルみたいなのを作ってCPPで `include` すれば一応できます。\n最近作っているプロダクトでは試しています。",
        "user": "U4LGTMTMK",
        "type": "message"
    },
    {
        "ts": "1522738135.000244",
        "text": "なるほどCプリプロセッサですか…1行2行なのでCPPプラグマ追加するのとimport書くのは同じぐらいの行数なので悩みどころですね…",
        "user": "U57CUMWQ6",
        "type": "message"
    },
    {
        "ts": "1522739054.000242",
        "text": "いまいちやりたいことピンと来てないんですが、まとめて reexport は `qualified` ぬけばできません？",
        "user": "U56L7EVNY",
        "type": "message"
    },
    {
        "ts": "1522740441.000376",
        "text": "まとめてreexport自体は出来ているんです\nプレフィクスを維持したままreexportが出来ないんですよね",
        "user": "U57CUMWQ6",
        "type": "message"
    },
    {
        "ts": "1522740785.000088",
        "text": ":point_down: の部分だけをプロジェクトで共通して利用したい、って話ですよね？\n```\nimport qualified Data.Text as T\nimport Other.Module (available, functions)\nimport qualified Qualified.Module as ReusableShortName\n....\n```\n繰り返しになりますが、私が知る限り今それをやる一番簡単な方法はCPPです。",
        "user": "U4LGTMTMK",
        "type": "message"
    },
    {
        "ts": "1522740875.000290",
        "text": "そうです\nありがとうございます",
        "user": "U57CUMWQ6",
        "type": "message"
    },
    {
        "ts": "1522847740.000392",
        "text": "import側で共通のprefixを付けるのでは。。。ダメですか？",
        "user": "U4KU9ABL0",
        "type": "message"
    },
    {
        "ts": "1522883737.000012",
        "text": "今回のようにごく小さなケースではそれで十分かと思いますが、個人的には大きなプロジェクト、特に複数人が関わるようになると難しくなるだろうと考えています（だからCPPを使った方法を試してます）。\n規約を作って守らせるぐらいなら、自動で統一できた方がいいに決まってるし、プロジェクトの中でのコードのコピペしやすさも高まります。",
        "user": "U4LGTMTMK",
        "type": "message"
    },
    {
        "ts": "1522907322.000126",
        "text": "<@UA2J5BXMM> has joined the channel",
        "user": "UA2J5BXMM",
        "type": "message"
    },
    {
        "ts": "1522943810.000501",
        "text": "<https://conscientiousprogrammer.com/blog/2014/08/07/understanding-cloure-transducers-through-types/>\n上記の記事の中で以下のような記載があったので `iteratee` について調べていたのですが、\n関連する資料は 2010 年ごろの物が多く最新の情報などはあまり反映されていないようでした。(気がするだけかも？)\n&gt; well-known types such as foldables, iteratees, lenses, etc.\n\n<https://www.yesodweb.com/blog/2010/09/enumerators-tutorial-part-1>\nこの記事は `enumerator` パッケージにおける実装などについて詳しく書いているのですが肝心の `enumerator` が deprecated になっていました。\n\nこのあたりについてどの辺が参考になるかなど教えていただけると嬉しいです。\nちなみに、オリジナルのものはまだ目を通せていないです。\n<http://okmij.org/ftp/Haskell/Iteratee/index.html)>",
        "user": "U9YSSVB88",
        "type": "message"
    },
    {
        "ts": "1522945573.000668",
        "text": "新しめのライブラリはこちらのベンチが参考になります <http://fumieval.hatenablog.com/entry/2017/10/17/172322> 出来る事が多いpipes、pipesに匹敵する高機能とpipesを遥かに上回る安全性を兼ね備える代わりに若干遅いconduit、それらより機能を制限する代わりに高速なライブラリとして幾つか選択肢が存在する感じです。まだ見てないんですがstreamlyというのも新しくて色々すごいらしいです。",
        "user": "U570660KX",
        "type": "message"
    },
    {
        "ts": "1522965707.000322",
        "text": "各種ライブラリーのベンチマークについては <https://haskell-jp.slack.com/archives/C4M4TT8JJ/p1521628071000253> もどうぞ。",
        "user": "U4LGTMTMK",
        "type": "message"
    },
    {
        "ts": "1523321379.000278",
        "text": "<@UA4PSBSMU> has joined the channel",
        "user": "UA4PSBSMU",
        "type": "message"
    },
    {
        "ts": "1523427578.000039",
        "text": "machinecell の質問です。\nストリームを最後まで `accum` して、その結果を使ってストリームを最初から流し直す、みたいなプロセスってどう書けばよいのでしょうか？\n雰囲気的には、こんな感じのことがやりたいです。\n\n```\n-- |\n-- &gt;&gt;&gt; P.run pa [1 .. 3]\n-- [(1,6),(2,6),(3,6)]\npa :: Monad m =&gt; P.ProcessT m (P.Event Int) (P.Event (Int, Int))\npa = proc x -&gt; do\n  sum' &lt;- P.accum 0 -&lt; (+) &lt;$&gt; x\n  end &lt;- P.onEnd -&lt; x\n  sum'' &lt;- returnA -&lt; sum' &lt;$ end\n  returnA -&lt; (,) &lt;$&gt; x &lt;*&gt; sum''     -- Event a は Applicative でないのでここでエラー\n```",
        "user": "U4LNDESN8",
        "type": "message"
    },
    {
        "ts": "1523428047.000309",
        "text": "Hoppy - C++ FFI Generator for Haskell\n<http://khumba.net/projects/hoppy/>\nを使ってみています。",
        "user": "U4MA78F6X",
        "type": "message"
    },
    {
        "ts": "1523431296.000073",
        "text": "`(&amp;&amp;&amp;)` で分岐して片方で accum すれば、必要なストリームは作れる。\nあとはどうやって合流するか・・・",
        "user": "U4LNDESN8",
        "type": "message"
    },
    {
        "ts": "1523443332.000255",
        "text": "出先なので動作確認できてないんですが、こんなコードでどうでしょうか。\n\n```\npa = P.switch collect combine\n  where\n    collect = proc x -&gt; do\n      lRev &lt;- P.accum [] -&lt; (:) &lt;$&gt; x\n      sum' &lt;- P.accum 0 -&lt; (+) &lt;$&gt; x\n      ed &lt;- P.onEnd -&lt; x\n      P.muted &amp;&amp;&amp; returnA -&lt; (reverse lRev, sum') &lt;$ ed\n  \n    combine (l, sum') = proc _ -&gt; do\n      x &lt;- P.blockingSource l -&lt; P.ZeroEvent\n      returnA -&lt; (, sum') &lt;$&gt; x\n```",
        "user": "U570660KX",
        "type": "message"
    },
    {
        "ts": "1523443479.000201",
        "text": "同じストリームを2度流すという事は必然的に、メモリ上に全要素を保持する事になるので、処理的にあんまりストリームライブラリ向けじゃないんですよね……上のコードでは一個目のaccumで明示的にリストをメモリに保持しています",
        "user": "U570660KX",
        "type": "message"
    },
    {
        "ts": "1523459563.000573",
        "text": "おお、できました！\nありがとうございます！",
        "user": "U4LNDESN8",
        "type": "message"
    },
    {
        "ts": "1523460029.000182",
        "text": "しかし、確かにそうですね。要素を全部リストにしてしまうなら、別にストリーム上で和を算出しなくてもよいような・・・",
        "user": "U4LNDESN8",
        "type": "message"
    },
    {
        "ts": "1523460406.000406",
        "text": "和を作るプロセスとタプル化するプロセスを別々に定義して、同じストリームを順に流す方が自然なのかも。",
        "user": "U4LNDESN8",
        "type": "message"
    },
    {
        "ts": "1523507147.000156",
        "text": "Stackを用いてGHCをインストールしていなくても各OSで実行可能なプログラムを生成する方法ってありますかね。。",
        "user": "U7Z4F723Z",
        "type": "message"
    },
    {
        "ts": "1523507703.000232",
        "text": "Haskell Platformを使うとか、GHCを直接インストールするとか、そういう話でしょうか？",
        "user": "U4LGTMTMK",
        "type": "message"
    },
    {
        "ts": "1523508428.000079",
        "text": "Haskellで書いたプログラムがあって、それをHaskellを実行できる環境が全くないパソコンでもダブルクリックとかで実行可能なものを生成したいんです。",
        "user": "U7Z4F723Z",
        "type": "message"
    },
    {
        "ts": "1523508783.000142",
        "text": "C言語のライブラリーとかに依存していない限り、普通はビルドされた実行ファイルはそのまま、ビルドしたOSと同じOSであればダブルクリックで実行できます。",
        "user": "U4LGTMTMK",
        "type": "message"
    },
    {
        "ts": "1523508865.000134",
        "text": "stackの場合、 `stack --local-build-path=&lt;好きなパス&gt; install` と実行すれば、 `&lt;好きなパス&gt;` にビルドした実行ファイルが作成されます。",
        "user": "U4LGTMTMK",
        "type": "message"
    },
    {
        "ts": "1523509533.000007",
        "text": "ありがとう！できました！ちなみにビルドしたOSとは別のOSの実行ファイルを生成するのって可能ですか。",
        "user": "U7Z4F723Z",
        "type": "message"
    },
    {
        "ts": "1523509708.000045",
        "text": "そういうのはクロスコンパイル機能というのですが、\n残念ながらクロスコンパイル機能は鋭意開発中という感じです（一応使えるけどかなり実験的だし手間もかかる）。\nLinuxの異なるディストリビューション同士ぐらいであればDockerを使うなりstatic binaryにするなりすればできますが。",
        "user": "U4LGTMTMK",
        "type": "message"
    },
    {
        "ts": "1523509836.000194",
        "text": "なるほどー。。ありがとうございます。",
        "user": "U7Z4F723Z",
        "type": "message"
    },
    {
        "ts": "1523535458.000191",
        "text": "どなたか、私の最初の回答でも直らなかったと言うことなので、もしほかに原因に思い当たる節があれば教えてください。 :bow:\n<https://teratail.com/questions/121456>",
        "user": "U4LGTMTMK",
        "type": "message"
    },
    {
        "ts": "1523535485.000359",
        "text": "（もちろん、質問者が何か入力を間違えてしまった可能性も捨てきれませんが...）",
        "user": "U4LGTMTMK",
        "type": "message"
    },
    {
        "ts": "1523537664.000549",
        "text": "<@UA5KF64CS> has joined the channel",
        "user": "UA5KF64CS",
        "type": "message"
    },
    {
        "ts": "1523573105.000043",
        "text": ":heavy_check_mark: 解決してた。やっぱりtypoだったようですね :relieved:",
        "user": "U4LGTMTMK",
        "type": "message"
    },
    {
        "ts": "1523577073.000077",
        "text": "<@UA5JPLRH8> has joined the channel",
        "user": "UA5JPLRH8",
        "type": "message"
    },
    {
        "ts": "1523594601.000186",
        "text": "`blaze-html`を用いて以下のようなものを生成したいのですが、どうすればよいでしょうか\n```\n&lt;p&gt;Hello &lt;span&gt;World&lt;/span&gt;&lt;/p&gt;\n```",
        "user": "U7Z4F723Z",
        "type": "message"
    },
    {
        "ts": "1523608453.000195",
        "text": "blaze-htmlはあまり使ったことないですが、以下の感じでいけそうですね！\n```\n$ stack --resolver nightly-2018-03-18 ghci --package blaze-html\n\n&gt; import Text.Blaze.Html5\n&gt; import Text.Blaze.Html.Renderer.String\n&gt; import Data.Semigroup\n&gt; :set -XOverloadedStrings\n&gt; let inner = \"foo\" &lt;&gt; Text.Blaze.Html5.span \"bar\" &lt;&gt; \"baz\"\n&gt; let html = p inner\n&gt;  renderHtml html\n\"&lt;p&gt;foo&lt;span&gt;bar&lt;/span&gt;baz&lt;/p&gt;\"\n```",
        "user": "U4M5LDXK9",
        "type": "message"
    },
    {
        "ts": "1523625219.000143",
        "text": "なんと！やってみます！ありがとうー！",
        "user": "U7Z4F723Z",
        "type": "message"
    },
    {
        "ts": "1523695421.000001",
        "text": "<@UA2SYG5LH> has joined the channel",
        "user": "UA2SYG5LH",
        "type": "message"
    },
    {
        "ts": "1523925240.000019",
        "text": "stackのtestフォルダー内にあるファイル（例えば`Spec.hs`）で定義した関数をghciを用いてターミナルで実行できるようなコマンドがあったと思うのですが、なんでしたっけ。。\n例えば `Spec.hs`内に`foo :: [Int] -&gt; Bool`という関数があった場合にはghci内で\n`quickCheck foo`\nと呼び出したいのです。",
        "user": "U7Z4F723Z",
        "type": "message"
    },
    {
        "ts": "1523925795.000081",
        "text": "`stack ghci --test` ではダメ？",
        "user": "U56L7EVNY",
        "type": "message"
    },
    {
        "ts": "1523926910.000230",
        "text": "ありがとうございます。\n`stack ghci test/Spec.hs`でいけました!\n`stack ghci test/Spec`では実行できなかったので他に方法があるのかと勘違いしていました。",
        "user": "U7Z4F723Z",
        "type": "message"
    },
    {
        "ts": "1523932993.000188",
        "text": "haddock の質問です。\nモジュールや関数のドキュメントの出力する/しないを、環境変数か何かで切り替えたりするようなことはできますでしょうか？\n内部向け（development）と外部向け（production）で、出力内容を切り替えたいです。",
        "user": "U4LNDESN8",
        "type": "message"
    },
    {
        "ts": "1523933187.000084",
        "text": "ちゃんと試してなくて恐縮ですが、\n<http://haskell-haddock.readthedocs.io/en/latest/markup.html#module-attributes> に書いてある\n```\n{-# OPTIONS_HADDOCK hide, prune, ignore-exports #-}\n```\nとかが捜し物ですかね？ :thinking_face:",
        "user": "U4LGTMTMK",
        "type": "message"
    },
    {
        "ts": "1523938486.000030",
        "text": "返信気が付きませんでした\n基本はimport側で共通のprefixを付けているのですがTextだけはコピペが増えてきたので楽に共通化出来るならやりたかったなと思いました",
        "user": "U57CUMWQ6",
        "type": "message"
    },
    {
        "ts": "1523944563.000191",
        "text": "そのオプションを何らかの条件でオンオフする方法、というのが探しものです。",
        "user": "U4LNDESN8",
        "type": "message"
    },
    {
        "ts": "1523944647.000149",
        "text": "{-# OPTIONS_HADDOCK hide #-}\nすると、そのモジュールが出力されなくなるのは確認しています。",
        "user": "U4LNDESN8",
        "type": "message"
    },
    {
        "ts": "1523944723.000227",
        "text": "やりたいのは気分的には\n\n```\nIF PROD\n{-# OPTIONS_HADDOCK hide #-}\nEND\n```\n\nみたいなことです。",
        "user": "U4LNDESN8",
        "type": "message"
    },
    {
        "ts": "1523952047.000144",
        "text": "機械学習のライブラリで良さげなものを教えてください。",
        "user": "U5FTM76CA",
        "type": "message"
    },
    {
        "ts": "1523955285.000169",
        "text": "重要な一言が抜けてました。あとはcabal のflagとCPPを組み合わせて使えばどうにでもなりそうな気がします。",
        "user": "U4LGTMTMK",
        "type": "message"
    },
    {
        "ts": "1523955907.000016",
        "text": "具体的には <https://guide.aelve.com/haskell/cpp-vww0qd72#item-oh9ytz0p> でやっているようなことです。\ncabalで特定のフラグをONにしたときだけcpp-optionsに-Dオプションを渡して定数を定義して、\nHaskellのソースコード側で\nifdefを使うのです",
        "user": "U4LGTMTMK",
        "type": "message"
    },
    {
        "ts": "1524219730.000124",
        "text": "例えば、FooをFで参照したいのならば、Fという名前のモジュールを作ってその中身でFooを再エクスポートをすれば、F.xxxという形で定義を参照できるようになる、という形でできませんか？",
        "user": "U5LEE6C1J",
        "type": "message"
    },
    {
        "ts": "1524268587.000095",
        "text": "期待する内容と違うかもしれませんが、こういう情報があります。\n<https://github.com/Gabriel439/post-rfc/blob/master/sotu.md#machine-learning>\n\ntensorflowへのバインディングは、最新のtensorflow 1.7にも対応しているようです。\nHLearnは最近は開発が止まってるようです、、、",
        "user": "U55V441FS",
        "type": "message"
    },
    {
        "ts": "1524282504.000015",
        "text": "Hlearnそうなんですか…",
        "user": "U5FTM76CA",
        "type": "message"
    },
    {
        "ts": "1524306252.000017",
        "text": "もったいないですね、、、",
        "user": "U55V441FS",
        "type": "message"
    },
    {
        "ts": "1524367368.000047",
        "text": "同じような質問がStack Overflowにあるみたいで、回答はあきらめるかCPPを使うかといった感じです <https://stackoverflow.com/questions/49940351/what-is-an-alternative-to-a-prelude-with-qualfied-imports>",
        "user": "U5LEE6C1J",
        "type": "message"
    },
    {
        "ts": "1524376568.000057",
        "text": "凄く初歩的な質問で恐縮なのですが、\nText←→Intの変換は、どのような方法が定番なのでしょうか？\n\n今は、プログラム毎に(pack . show)や(read . unpack)で変換しているのですが、\n毎回記述するので、何かライブラリ側で提供されていないのかなぁと思う一方、\ntext-showとData.Text.Readで行うのも対称的じゃないので、どうなんでしょう？と思っている次第です。\nよろしくお願い致します。",
        "user": "U8LLBJ59Q",
        "type": "message"
    },
    {
        "ts": "1524376913.000025",
        "text": "確かに text-show 以外聞いたことがないですね。。。 :disappointed:",
        "user": "U4LGTMTMK",
        "type": "message"
    },
    {
        "ts": "1524377382.000034",
        "text": "そもそもRead自体手を抜きたいとき以外使うな（遅いし、ちゃんとしたのはパーサーを書けばいい）という風潮なので、あまり需要がないのかもしれません",
        "user": "U4LGTMTMK",
        "type": "message"
    },
    {
        "ts": "1524378882.000009",
        "text": "ありがとうございます。\n私の質問が言葉足らずでしたが、\nパーサーを使う程でもない、10数行程度の入門レベルのコンソールアプリのサンプルを作る際に、\n毎回(pack . show)と(read . unpack)で行数がやや膨らむので悩んだところでした。\n\n特に定番的なものがなければ、入門レベルならむしろその方が、追加のライブラリも不要ですし、\n対称的で見栄えも良い、という感じでも問題は無いでしょうか？",
        "user": "U8LLBJ59Q",
        "type": "message"
    },
    {
        "ts": "1524381354.000050",
        "text": "いいと思います。\n個人的には、入門程度のアプリケーションであれば、そもそもTextを使うまでもないかと思います（Textの勉強をしている場合は別ですが。。。）",
        "user": "U4LGTMTMK",
        "type": "message"
    },
    {
        "ts": "1524382426.000067",
        "text": "textはデファクトみたいなもので、\n早いうちから慣れておいた方が後々楽かなぁという思いでした。\n\n自分のやり方があっているのかが不安でしたが、\nHaskellベテランの方のご意見をお伺い出来て安心しました。\nありがとうございました！",
        "user": "U8LLBJ59Q",
        "type": "message"
    },
    {
        "ts": "1524406964.000035",
        "text": "BuilderとLazy版Textを通るのでかなり遠回りですが、<http://hackage.haskell.org/package/text-1.2.3.0/docs/Data-Text-Lazy-Builder-Int.html> というモジュールもあります",
        "user": "U4KUNQF9N",
        "type": "message"
    },
    {
        "ts": "1524407811.000107",
        "text": "ご紹介ありがとうございます！\n\n実は、これにも疑問があったのですが、Lazy版しか提供されていないのは\n何か理由があるのでしょうか？\nストリームから読み込む際に、変換可能なバイト列が揃うまで評価を待ちたいから、\nみたいな事情でしょうか？\n\n更に質問で恐縮ですが、よろしくお願いします。",
        "user": "U8LLBJ59Q",
        "type": "message"
    },
    {
        "ts": "1524408870.000115",
        "text": "私もなぜ正格なBuilderを提供しないのか、実はよくわかっていません。標準のBuilderは特別効率がよいとは言えないです…",
        "user": "U4KUNQF9N",
        "type": "message"
    },
    {
        "ts": "1524410845.000047",
        "text": "正格版があったほうがパフォーマンス的に有難い気もするのですが、\nパフォーマンス気にするならそもそもBuilder以外の方法を使いましょう、\nみたいな方針なのですかね…\n\nご回答ありがとうございました",
        "user": "U8LLBJ59Q",
        "type": "message"
    },
    {
        "ts": "1524436360.000067",
        "text": "多分大きな文字列を組み立てる前提だから、正格に結合するとメモリー消費量がすごく大きくなってしまうという想定でやってるんじゃないっすかね。",
        "user": "U4LGTMTMK",
        "type": "message"
    },
    {
        "ts": "1524440609.000131",
        "text": "扱う文字列の大きさが、(Lazyな)Builderを使うかの判断基準にはなりそうですね\nありがとうございます！",
        "user": "U8LLBJ59Q",
        "type": "message"
    },
    {
        "ts": "1524448493.000059",
        "text": "HDBC-mysqlで、ブロックが発生するクエリを実行した際に、他のスレッドが停止してしまい困っています。\n対処方法などご存知の方いたら教えて下さい。\n（HDBCというより、ffiで一般的な話な気もしますが、調べてもわからず、、）\n```\nmodule Main where\n\nimport Control.Monad\nimport Database.HDBC\nimport Database.HDBC.MySQL\nimport Control.Concurrent\n\nmain = do\n  forkIO $ do  -- quickQuery'でブロックが発生した時点で処理がとまる\n    forM_ [0..10] $ \\i -&gt; do\n      print i\n      threadDelay $ 1000*1000\n  conn &lt;- connectMySQL defaultMySQLConnectInfo {  } \n  withTransaction conn $ \\c -&gt; do\n    quickQuery' c \"select * from hoge where id = 1 for update\" [] -- 別途ロックしてから実行\n  threadDelay $ 10000*1000\n```\n\n```\nghc-options:         -threaded -rtsopts -with-rtsopts=-N -eventlog\n```",
        "user": "U59TQ3MJ9",
        "type": "message"
    },
    {
        "ts": "1524450277.000049",
        "text": "ブロックする可能性のある関数をunsafe ffiで呼び出しているのが原因だと思います。ライブラリ側でsafe ffiに直すか別のパッケージを使う以外方法はないと思います。",
        "user": "U4M9NJ7QE",
        "type": "message"
    },
    {
        "ts": "1524450800.000048",
        "text": "mysqlパッケージの話ですが、基本的に同じなのでここを読むとわかりやすいかと思います。 \n<https://ro-che.info/articles/2015-04-17-safe-concurrent-mysql-haskell>",
        "user": "U4M9NJ7QE",
        "type": "message"
    },
    {
        "ts": "1524451585.000043",
        "text": "ベンチを取ってないので断言はできませんが、入力が短ければtoLazyTextによって作られるlazy textもsingletonになってtoStrictもコピーしないのでそれほど非効率にならないのではないかと思いました。",
        "user": "U4M9NJ7QE",
        "type": "message"
    },
    {
        "ts": "1524480539.000339",
        "text": "リプライありがとうございます。\nBuilderがちょっとしたアプリでも使えそうな感じですが、\n一般的にもBuilferは良く使われるものなのでしょうか？\nLazyに変換するのをサボりたくなって、簡単な文字列変換なら、つい敬遠してshowとappendで済ませてしまいます…",
        "user": "U8LLBJ59Q",
        "type": "message"
    },
    {
        "ts": "1524486296.000224",
        "text": "ケースバイケースじゃないかと思います。時間、空間効率に問題がなければimportも少なくて済むpack.showが楽でしょうし、効率も気になるならBuilderが良いのではないかと思います。Stringは非常に富豪的なデータ構造なので、それが問題になるかを考えれば自ずと決まるのではないかと。",
        "user": "U4M9NJ7QE",
        "type": "message"
    },
    {
        "ts": "1524486809.000009",
        "text": "皆様のお話でBuilderという選択肢が得られて勉強になりました。\nいろいろなご意見ありがとうございました！",
        "user": "U8LLBJ59Q",
        "type": "message"
    },
    {
        "ts": "1524487406.000335",
        "text": "HLearnはたしかsubhaskと併せて野心的なプロジェクトだったんですが、作者が自分の考える最高のコードを書くには、まだGHCが機能不足だという結論にいたって開発が止まったという話だった気がします。",
        "user": "U4M9NJ7QE",
        "type": "message"
    },
    {
        "ts": "1524487459.000212",
        "text": "結局今はPythonを使ってるとredditかどこかで見かけた気がします",
        "user": "U4M9NJ7QE",
        "type": "message"
    },
    {
        "ts": "1524487641.000463",
        "text": "<http://www.datahaskell.org/docs//community/current-environment.html#machine-learning> dataHaskellというコミュニティがライブラリの情報をまとめています",
        "user": "U4M9NJ7QE",
        "type": "message"
    },
    {
        "ts": "1524549790.000338",
        "text": "ありがとうございます",
        "user": "U5FTM76CA",
        "type": "message"
    },
    {
        "ts": "1524635726.000256",
        "text": "<@UACQ9J5D3> has joined the channel",
        "user": "UACQ9J5D3",
        "type": "message"
    },
    {
        "ts": "1524635816.000134",
        "text": "Algebraのことなら、個人的にArtinの本をお勧め\n<https://www.amazon.co.jp/Algebra-Classic-Classics-Advanced-Mathematics/dp/0134689607>",
        "user": "UACQ9J5D3",
        "type": "message"
    },
    {
        "ts": "1524638935.000310",
        "text": "高いですねw",
        "user": "U5FTM76CA",
        "type": "message"
    },
    {
        "ts": "1524665291.000248",
        "text": "<@U4M9NJ7QE> ありがとうございます！\n原因と対応方法まで理解できました。",
        "user": "U59TQ3MJ9",
        "type": "message"
    },
    {
        "ts": "1524704315.000063",
        "text": "大変抽象的な聞き方で申し訳ないのですが。ソースコードを入力にコード規約のような複数のチェックを実施して、その結果を全て返すというような処理を書くとき、haskellの場合どのような書き方をするのが王道なのでしょう。",
        "user": "U55UN00G0",
        "type": "message"
    },
    {
        "ts": "1524704328.000069",
        "text": "まだ詳しく調べ切れてないのですが、heterogeneous listの実装ってなにがおすすめですか？",
        "user": "U4LGTMTMK",
        "type": "message"
    },
    {
        "ts": "1524704616.000198",
        "text": "いまいち何が懸念なのかわかりませんが、\nその要件だけ聞いてざっくり設計するなら:point_down: な型の関数を書きますかね。。。\n```\ntype SourceCode = Text\n\ndata AST = {- ソースコードのASTを表す型 -}\n\ndata AnalysisResult = {- ... 解析結果を表す型 -}\n\nparse :: FilePath -&gt; SourceCode -&gt; AST\n\nanalyze :: AST -&gt; [AnalysisResult]\n```",
        "user": "U4LGTMTMK",
        "type": "message"
    },
    {
        "ts": "1524706881.000122",
        "text": "すみません。具体的な懸念があるということではなく純粋にどういう形になるのが一般的なのかと思いまして。\n\nいただいた例ではテキストを抽象構文木に変換したのちに解析して最終的に解析結果のリストを返すということですね。いまひとつ具体的なイメージがわかないのはanalyze関数の部分です。チェックの内容にもよると思うのですが、複数のチェックを実施する場合、チェックの都度ASTを頭から舐めなおすことになるのかなと。\n\n単純化するためにチェックの内容を特定のインストラクションが含まれているとして、”A\"がある・”B\"がある・”C\"があるの３つのチェックをする場合、ASTに\"A\"が含まれるか→結果を結果リストに追加→ASTに”B\"が・・・→結果リストを戻すというような実装になるのか、それともASTを頭から葉まで一回舐めていくうちに結果を貯めていくような方法とするのか、それらを混在させるのか。\n毎回舐めなおすのはどんなチェックにも対応できそうですが効率が悪いですし、一方舐めるのを一回で済ませようとしても必ずバックトラックが必要なタイプのチェックもあるように思いますし。\n単にOK・NGを返す、もしくは最初にエラーとなった内容を返すだけなら個々のチェックを実施するパーサを連結すればできそうだなというイメージはあるのですが、全てを返す方法がイメージできていません。\n「単一の入力に対して複数のチェックを実施して、その結果を全て返却する」というような処理は私の仕事では頻出のパターンでして、比較的一般的な処理だと思いましたので、良く知られたオーソドックスな方法があるのかも？と思った次第です。全体的に分かりにくくて申し訳ありません。",
        "user": "U55UN00G0",
        "type": "message"
    },
    {
        "ts": "1524709134.000250",
        "text": "もちろん一般論としてなるべくバックトラックが少ない方が効率的なのは間違いないでしょうし、その辺はやってみないとなんとも。。。という感じです。幸いhlintをはじめその手のHaskell製ツールはたくさんOSSで存在するので、読んでみるといいかもしれません。",
        "user": "U4LGTMTMK",
        "type": "message"
    },
    {
        "ts": "1524709428.000213",
        "text": "ぱっと思いつくのは、Haskellのソースコードで言えば、「module単位で行うチェック」、「関数単位で行うチェック」、「型宣言に対して行うチェック」、「式に対して行うチェック」みたいにあらかじめ分類しておいた上で、各単位の頭から都度処理する、みたいなやり方ですかねぇ。\n\n式単位だと当然入れ子になる式が出てくるでしょうから、お話はまだ複雑になりますけども。",
        "user": "U4LGTMTMK",
        "type": "message"
    },
    {
        "ts": "1524780637.000404",
        "text": "コマンドライン引数のオプションの解析、自分で書いたことはありますが「車輪の再発明やめよう」ということでライブラリを使おうと思い調べてみたところ、かなり候補が出てきたのですが、オススメとか避けるべきとかってありますかね\n<https://wiki.haskell.org/Command_line_option_parsers>",
        "user": "U8EJKMNVA",
        "type": "message"
    },
    {
        "ts": "1524781311.000159",
        "text": "ほかとの比較はしたことないですが、optparse-applicativeはよく使われているイメージです。",
        "user": "U4LGTMTMK",
        "type": "message"
    },
    {
        "ts": "1524791060.000198",
        "text": "自分も最近は optparse-applicative をよく使ってます。 ただ、これが理想かというとう～ん……",
        "user": "U4MA78F6X",
        "type": "message"
    },
    {
        "ts": "1524794841.000017",
        "text": "extensible以外のものをお探しでしょうか？",
        "user": "U4KUNQF9N",
        "type": "message"
    },
    {
        "ts": "1524794959.000159",
        "text": "<http://hackage.haskell.org/package/HList> ?",
        "user": "U4MA78F6X",
        "type": "message"
    },
    {
        "ts": "1524796946.000217",
        "text": "そうですね、extensibleも（もちろんいにしえのHListも）含めて見てみます。",
        "user": "U4LGTMTMK",
        "type": "message"
    },
    {
        "ts": "1524797413.000182",
        "text": "この際なのでついでにfumiさんに伺いたいのですが、OverloadedLabelsをextensibleに応用した、\n<https://hackage.haskell.org/package/extensible-0.4.8/docs/Data-Extensible-Label.html>\nを使った場合、どんな使用方法になるのでしょうか？",
        "user": "U4LGTMTMK",
        "type": "message"
    },
    {
        "ts": "1524797600.000180",
        "text": "もしかして、\n<https://www.schoolofhaskell.com/user/fumieval/extensible/extensible-records>\nの\n```\nmkField \"name collective cry\"\n```\nの箇所がなくなって\n```dove :: Animal\ndove = #name @= \"dove\"\n  &lt;: #collective @= \"dule\"\n  &lt;: #cry @= Just \"coo\"\n  &lt;: Nil\n```\nみたいに書けるイメージですかね。",
        "user": "U4LGTMTMK",
        "type": "message"
    },
    {
        "ts": "1524797633.000054",
        "text": "はい、従来はTemplate Haskellで生成したものをラベル記法にそのまま置き換えることができます",
        "user": "U4KUNQF9N",
        "type": "message"
    },
    {
        "ts": "1524804784.000089",
        "text": "リストにないですが tanakh さんの optparse-declarative はそこそこ楽できた覚えがあります",
        "user": "U5ANNFMNZ",
        "type": "message"
    },
    {
        "ts": "1524806263.000227",
        "text": "選択肢を増やすようで申し訳ないですが、optparse-applicativeに対抗されて作られたalternativeです。\n上記のwikiにも載っていません。\n<https://github.com/lspitzner/butcher>",
        "user": "U4LGTMTMK",
        "type": "message"
    },
    {
        "ts": "1524876327.000156",
        "text": "stack new でテンプレートを指定しなかったときデフォルトで使われるファイルを new-template 以外のカスタムテンプレートを使うように簡便に指定できないものでしょうか．",
        "user": "U4KU9ABL0",
        "type": "message"
    },
    {
        "ts": "1524892676.000118",
        "text": "globalのconfig.yamlでdefault-templateを指定すればできるはずです\n<https://docs.haskellstack.org/en/latest/yaml_configuration/#default-template>",
        "user": "U57D08Z9U",
        "type": "message"
    },
    {
        "ts": "1525006040.000091",
        "text": "できました．ありがとうございます:pray:",
        "user": "U4KU9ABL0",
        "type": "message"
    },
    {
        "ts": "1525184336.000503",
        "text": "package.yaml or cabalで,stack testを実行した時に特定のプリプロセッサフラグを有効にする方法は無いでしょうか?\nDEVELOPMENTフラグを有効化してテスト時のみYesod.Auth.Dummyを読み込ませたいのですが…\n一々stack test --flag application:devとタイプするしか無いのでしょうか\nサンプルを見るとtest以下にcpp-options: -DDEVELOPMENTと書けば良いように見えたのですが,どうもそうではないっぽい",
        "user": "U57CUMWQ6",
        "type": "message"
    },
    {
        "ts": "1525192222.000354",
        "text": "-Dオプションはパッケージ単位でしか効かなかった気がします(未確認)",
        "user": "U570660KX",
        "type": "message"
    },
    {
        "ts": "1525192346.000566",
        "text": "<https://github.com/haskell/cabal/issues/2821> これが使えれば、テストスイートからだけフラグを有効にする、という事が可能かと思われますが、採用されるか分からない感じですね",
        "user": "U570660KX",
        "type": "message"
    },
    {
        "ts": "1525224759.000259",
        "text": "なるほど、 cabal の flag はソースコード中でそのようにして参照できるのですね。\nやってみます！",
        "user": "U4LNDESN8",
        "type": "message"
    },
    {
        "ts": "1525326102.000154",
        "text": "ああなるほどそれが議論されているということは普通では無理ということでしょうね\n外部パッケージのためだけかと思ってました",
        "user": "U57CUMWQ6",
        "type": "message"
    },
    {
        "ts": "1525388436.000427",
        "text": "yesod界隈では{fast,monad}-loggerが使われていますが、一般的にロガーを自分で選択するときは何を使っていますか？",
        "user": "U4M9NJ7QE",
        "type": "message"
    },
    {
        "ts": "1525518103.000098",
        "text": "<@UAJV7LY8M> has joined the channel",
        "user": "UAJV7LY8M",
        "type": "message"
    },
    {
        "ts": "1525595344.000028",
        "text": "<@U9U8B3LJV> has joined the channel",
        "user": "U9U8B3LJV",
        "type": "message"
    },
    {
        "ts": "1525602697.000005",
        "text": "syslog使ってます",
        "user": "U74KTAG0N",
        "type": "message"
    },
    {
        "ts": "1525799562.000218",
        "text": "fusion の質問です。Bird の本に頻出する型  f . foldr g a = foldr h b [PoFAD] (pp.34) が良く分かりません。何かもっと詳しい説明・文献がありますでしょうか？\n他の型であれば、例えば \"foldr/build fusion\" や \"destroy/unfoldr fusion\" や \"Church/Cochurch fusion\" ならば以下の文献がありますが、これらとも違いますよね？\n[PoFAD] (2010) \"Pearls of Funcional Algorithm Design\" Bird, R\n[FPCA 1993] \"A Short Cut to Deforestation\" Gill, A. Launchbury, J. Jones, S.L.P.\n[ICFP 2002] \"Shortcut Fusion for Accumulating Parameters &amp; Zip-like Functions\" Svenningsson, J.\n[Oxford 2011] \"Theory and Practice of Fusion,\" Hinze, R. Harper, James, D.W.H.",
        "user": "U584T7GAH",
        "type": "message"
    },
    {
        "ts": "1525820750.000267",
        "text": "hsyslogのことですか？",
        "user": "U4M9NJ7QE",
        "type": "message"
    },
    {
        "ts": "1525829196.000060",
        "text": "そうです。",
        "user": "U74KTAG0N",
        "type": "message"
    },
    {
        "ts": "1525829255.000232",
        "text": "特に理由はありませんが、成り行きでhsyslogを直接使う場合と monad-logger-syslogから使う場合があります。",
        "user": "U74KTAG0N",
        "type": "message"
    },
    {
        "ts": "1525836257.000187",
        "text": "`optparse-applicative`に関する質問です。サブコマンドで定義したhelp文を`--help`コマンドで表示させる方法はあるのでしょうか。以下のようなコマンドを受け付けることを期待しています\n\n```\n:main processTicket --help\n```\n\nコードをGistに掲載しました。\n<https://gist.github.com/HirotoShioi/e88f3d1622d7d7961e906191263d3d31#file-optparse-applicative-L24>",
        "user": "U7Z4F723Z",
        "type": "message"
    },
    {
        "ts": "1525837593.000034",
        "text": "普通に helper が使えたはず\n```\ncommand \"collectEmails\" (info (pure CollectEmails &lt;**&gt; helper)\n            (progDesc \"Collect emails requested by single user\"))\n```",
        "user": "U56L7EVNY",
        "type": "message"
    },
    {
        "ts": "1525838048.000030",
        "text": "できた。。！ありがとうございます！",
        "user": "U7Z4F723Z",
        "type": "message"
    },
    {
        "ts": "1525838232.000081",
        "text": "Hutton の “A tutorial on the universality and expressiveness of fold” <http://www.cs.nott.ac.uk/~pszgmh/fold.pdf> の “3.2 The fusion property of fold” にも解説があります。 \nWadler の “Theorems for free!” <https://people.mpi-sws.org/~dreyer/tor/papers/wadler.pdf>  に Theorems for free の応用として ~ “Figure 1: Examples of Theorems from type” にも解説なしで~ （後から訂正：「3.2 Fold」に）出てきます。",
        "user": "U57CGDBMG",
        "type": "message"
    },
    {
        "ts": "1525839760.000192",
        "text": "subparserの代わりにhsubparserっていうそれに特化したようなのがあったかと思います（今手元で調べられる状況じゃなくて恐縮ですが）。",
        "user": "U4LGTMTMK",
        "type": "message"
    },
    {
        "ts": "1525840855.000147",
        "text": "ありました！",
        "user": "U7Z4F723Z",
        "type": "message"
    },
    {
        "ts": "1525848117.000307",
        "text": "ありがとうございました　特に前者は参考になりました",
        "user": "U584T7GAH",
        "type": "message"
    },
    {
        "ts": "1525852073.000292",
        "text": "全く見当違いかもしれませんが、Cardano-SLはkatipを使いたいとか言ってました。\n<https://hackage.haskell.org/package/katip>\nRunning a program which logs 500k times a simple message using both `katip` and `log-warper` showed that `katip` is much faster and uses less memory than `log-warper`.",
        "user": "U7Z4F723Z",
        "type": "message"
    },
    {
        "ts": "1525856257.000429",
        "text": "64bitの符号なし整数を、次のような形式のJSONで送ってくる（私が直接いじれない）サーバーがあります。\n```\n{ high: &lt;上位32bitを表す符号付き整数&gt;, low: &lt;下位32bitを表す符号付き整数&gt; }\n```\nこの形式のJSONから `Int64` を作り出す方法を考えているのですが、バイナリ力が低くて悩んでおります。\n上位ビットは `shiftL 32` とすればいいのはすぐにわかったですが、下位ビットについてどうすればいいか、教えていただきたいです。\n例:\ninput: `{ high: 177247787, low: -813694976 }`\noutput: `761273451934646272`",
        "user": "U4LGTMTMK",
        "type": "message"
    },
    {
        "ts": "1525856456.000374",
        "text": "このサーバーおかしいだろう。。。",
        "user": "UACQ9J5D3",
        "type": "message"
    },
    {
        "ts": "1525856562.000282",
        "text": "if low &gt; 0 then low else ((low :: Int64) + 2 ^ 32)",
        "user": "UACQ9J5D3",
        "type": "message"
    },
    {
        "ts": "1525856584.000075",
        "text": "Word32にキャストできたような",
        "user": "U8EJKMNVA",
        "type": "message"
    },
    {
        "ts": "1525856595.000055",
        "text": "そう、今同僚と話してたら気づきました。",
        "user": "U4LGTMTMK",
        "type": "message"
    },
    {
        "ts": "1525856605.000433",
        "text": "`fromIntegral (negate 813694976) :: Word32`",
        "user": "U4LGTMTMK",
        "type": "message"
    },
    {
        "ts": "1525856665.000034",
        "text": "&gt; このサーバーおかしいだろう。。。\n\nJSの仕様上64bit整数を直接表現できない故の苦渋の策なんでしょうね。。。",
        "user": "U4LGTMTMK",
        "type": "message"
    },
    {
        "ts": "1525856666.000146",
        "text": "Prelude <http://Data.Int|Data.Int>&gt; (-1 :: Word)\n\n&lt;interactive&gt;:3:3: warning: [-Woverflowed-literals]\n    Literal -1 is out of the Word range 0..18446744073709551615\n18446744073709551615\n\n＝。＝Warningが出るけど",
        "user": "UACQ9J5D3",
        "type": "message"
    },
    {
        "ts": "1525856706.000433",
        "text": "下位はWord32にキャストしてからInt64にキャスト、 `shiftL 32` した上位と足し算、で大丈夫…ですよね？多分",
        "user": "U8EJKMNVA",
        "type": "message"
    },
    {
        "ts": "1525856713.000231",
        "text": "はい、リテラルでやると警告が出ますが明示的に `fromIntegral` する分には問題ないはずです。",
        "user": "U4LGTMTMK",
        "type": "message"
    },
    {
        "ts": "1525856832.000271",
        "text": "Hmmm，Cの強制coercionが欲しい（",
        "user": "UACQ9J5D3",
        "type": "message"
    },
    {
        "ts": "1525856853.000084",
        "text": "そもそもやはりこのサーバーがおかしいと思う＝。＝",
        "user": "UACQ9J5D3",
        "type": "message"
    },
    {
        "ts": "1525856904.000117",
        "text": "```\n177247787 `shiftL` 32 + (fromIntegral (fromIntegral (negate 813694976) :: Word32) :: Word64)\n```",
        "user": "U4LGTMTMK",
        "type": "message"
    },
    {
        "ts": "1525856908.000165",
        "text": "まあ、「JSの仕様上64bit整数を直接表現できない故の苦渋の策」でしょうねぇ",
        "user": "U8EJKMNVA",
        "type": "message"
    },
    {
        "ts": "1525856933.000177",
        "text": "え？？？そうなの？",
        "user": "UACQ9J5D3",
        "type": "message"
    },
    {
        "ts": "1525856953.000277",
        "text": "JavaScriptは浮動小数点数しかございませんので",
        "user": "U8EJKMNVA",
        "type": "message"
    },
    {
        "ts": "1525856971.000099",
        "text": "JSの数値リテラルは全部doubleとして処理されてしまうのです。。。 :disappointed_relieved:",
        "user": "U4LGTMTMK",
        "type": "message"
    },
    {
        "ts": "1525856980.000557",
        "text": "整数は（倍精度浮動小数点の仮数部である）53bitまでしか使えません\n<http://blog.tmyt.jp/entry/20101201/1291166929>",
        "user": "U8EJKMNVA",
        "type": "message"
    },
    {
        "ts": "1525856994.000548",
        "text": "よってこういうことが起こる",
        "user": "U8EJKMNVA",
        "type": "message"
    },
    {
        "ts": "1525857007.000507",
        "text": "これはさすが。。。",
        "user": "UACQ9J5D3",
        "type": "message"
    },
    {
        "ts": "1525857087.000146",
        "text": "なので、高速化のためにJITコンパイラが「こいつはループカウンタとしてしか使われていないから整数に置き換えてもいいな」みたいな推論をしてやる必要があったりします。そういう涙ぐましい努力の結果JavaScriptのあのスピードがあるという感じだそうです",
        "user": "U8EJKMNVA",
        "type": "message"
    },
    {
        "ts": "1525857179.000331",
        "text": "上記の回答でできたっぽいですが `fromIntegral` 2回使っているところが非常に醜いので `TypeApplications` を使ってみました。\n```\n177247787 `shiftL` 32 + (fromIntegral @Word64 (fromIntegral @Word32 (negate 813694976)))\n```",
        "user": "U4LGTMTMK",
        "type": "message"
    },
    {
        "ts": "1525857242.000163",
        "text": ":face_with_monocle:＠ とはなに？",
        "user": "UACQ9J5D3",
        "type": "message"
    },
    {
        "ts": "1525857801.000110",
        "text": "TypeApplicationsは、\n`id` や `const`, 今回の `fromIntegral` のような多相関数を、「どの型に対する関数にするか」を `@&lt;型名&gt;` で明示できるようにしてくれます。\n\n例えば `id` は `a -&gt; a` という型ですが、 `id @Int` のように `@` で `Int` を明示することで、 `Int -&gt; Int` として処理させることができます。\n\nGHCiで試すと :point_down: のようになります。\n```\n&gt; :set -XTypeApplications\n&gt; :t id\nid :: a -&gt; a\n&gt; :t id @Int\nid @Int :: Int -&gt; Int\n```",
        "user": "U4LGTMTMK",
        "type": "message"
    },
    {
        "ts": "1525858600.000210",
        "text": "すみません、 `TypeApplications` を使った方法、間違いでした（最初の方でうまくいったように見えた理由がいまいちわかりませんが）。正しくは :point_down: です。\n```\n177247787 `shiftL` 32 + (fromIntegral @Word32 @Word64 (fromIntegral @Int32 @Word32 (negate 813694976)))\n```\n却って冗長になってしまいましたね。。。 :disappointed:",
        "user": "U4LGTMTMK",
        "type": "message"
    },
    {
        "ts": "1525858663.000168",
        "text": "私の回答はこれです `shiftL 177247787 32 .|. 0xffffffff .&amp;. (-813694976)`",
        "user": "U4KUNQF9N",
        "type": "message"
    },
    {
        "ts": "1525858737.000477",
        "text": "確かに。足し算しなくても `.|.` でいいのか。",
        "user": "U4LGTMTMK",
        "type": "message"
    },
    {
        "ts": "1525858817.000406",
        "text": "なるほど。よく考えたら元はJSONなんだから `Integer` として処理してしまったもいいんですね。",
        "user": "U4LGTMTMK",
        "type": "message"
    },
    {
        "ts": "1525859323.000385",
        "text": "`.|.` と `+` ってどっちが「善」なんでしょうかね（ill-definedな問）",
        "user": "U8EJKMNVA",
        "type": "message"
    },
    {
        "ts": "1525859451.000196",
        "text": "今回の場合 `.|.` の方が理にかなっていると思いますよ `+` の場合桁上がりを考慮しないといけない分わずかに処理が遅くなる可能性もありますが、今回のような計算の場合、起こりえないことがあらかじめわかっていますし。",
        "user": "U4LGTMTMK",
        "type": "message"
    },
    {
        "ts": "1525860103.000540",
        "text": "CPUのサイクル数はほとんど同じのはずですが、ビット演算の文脈なので.|.の方がいいと思います(なおxorも可といえば可)",
        "user": "U4KUNQF9N",
        "type": "message"
    },
    {
        "ts": "1525863618.000470",
        "text": "大きな整数はStringで返ってくるような仕様もあるようです（サーバーは変えられないとの事ですが、正しい仕様は何かという議論について参考までに） <https://github.com/syucream/hastodon/issues/9>",
        "user": "U570660KX",
        "type": "message"
    },
    {
        "ts": "1525921279.000178",
        "text": "64bitの符号なし整数をInt64では1bitたりない気がします。",
        "user": "U74KTAG0N",
        "type": "message"
    },
    {
        "ts": "1525921326.000250",
        "text": "64bitの符号あり整数ならいいでしょうが。",
        "user": "U74KTAG0N",
        "type": "message"
    },
    {
        "ts": "1525921948.000185",
        "text": "64bitの符号なし整数はInt64でなくてWord64をつかうのですね。",
        "user": "U74KTAG0N",
        "type": "message"
    },
    {
        "ts": "1525921948.000207",
        "text": "はい、なので実際のコードでは `Word64` にしています。\n実際のところは正確にわからないので本当は `Integer` のほうがいいのかもしれませんが。",
        "user": "U4LGTMTMK",
        "type": "message"
    },
    {
        "ts": "1525922227.000062",
        "text": "ありがとうございます。katipは何かのライブラリで使われているのをみたことがあります。",
        "user": "U4M9NJ7QE",
        "type": "message"
    },
    {
        "ts": "1525924006.000224",
        "text": "わかりやすさの観点は別にして、Theorems for free の方は型の情報だけから fusion が導かれるのが興味深こうございました。",
        "user": "U57CGDBMG",
        "type": "message"
    },
    {
        "ts": "1525924331.000023",
        "text": "圏論的には fold はF代数の catamorphism なのでそのユニーク性から融合法則を導く方法も多分あると思います。ググったところでは cata-fusion と呼ぶみたいです。",
        "user": "U57CGDBMG",
        "type": "message"
    },
    {
        "ts": "1525936270.000048",
        "text": "皆さんPreludeは何を使っていますか。できれば使用感なども知りたいです。。！\n<https://github.com/sdiehl/protolude>\n<https://github.com/commercialhaskell/rio>\n<https://github.com/serokell/universum>\n今日 `universum` を使ってみたんですけど、第一印象は「かゆいところに手が届かない」Preludeでした。",
        "user": "U7Z4F723Z",
        "type": "message"
    },
    {
        "ts": "1525936601.000142",
        "text": "<@U4M5LDXK9> ずいぶん前にどこかで聞いた気がするんですが、デニスさんはたしか <https://hackage.haskell.org/package/classy-prelude> でしたっけ？",
        "user": "U4LGTMTMK",
        "type": "message"
    },
    {
        "ts": "1525937334.000401",
        "text": "さいきんは rio であそんでます\nlens 系演算子がもっと欲しいなぁって思う",
        "user": "U56L7EVNY",
        "type": "message"
    },
    {
        "ts": "1525937862.000174",
        "text": "rioはちょっと気になってるので勉強用で作ってるリポで遊んでみようかなと思ってます。\nUniversumすごく気まぐれなんですよね。。前のバージョンでは`containers`使えなかったのに今日触ったのは入ってたし、次のバージョンでは`text-format`が丸々削除されるらしくて、DevOpsが泣いてました。",
        "user": "U7Z4F723Z",
        "type": "message"
    },
    {
        "ts": "1525938825.000322",
        "text": "ごめんなさいやっぱり`containers`使えませんでした。\n僕がなにか勘違いしてるんですかね。。<https://hackage.haskell.org/package/universum-1.2.0/docs/Universum-Container-Reexport.html>\n`type SomeMap = Map String int `\nこれは`Map`を明示的にインポートしなくても定義できるのに、`Map`に関する関数は一切使えないんですよね。あと\n`import Data.Map.Strict`ができないんです。",
        "user": "U7Z4F723Z",
        "type": "message"
    },
    {
        "ts": "1525954536.000350",
        "text": "そうですね、classy-preludeを結構使っています。いろいろ便利な機能を提供していて、mono-traversableの関数をexportしているので使いやすいという印象です。",
        "user": "U4M5LDXK9",
        "type": "message"
    },
    {
        "ts": "1525966783.000746",
        "text": "<@UAMGYKUP5> has joined the channel",
        "user": "UAMGYKUP5",
        "type": "message"
    },
    {
        "ts": "1526008760.000063",
        "text": "Yesod開発者なのでclassy-preludeをよく使ってますがstackもrio行ったし移行するのかなあ",
        "user": "U57CUMWQ6",
        "type": "message"
    },
    {
        "ts": "1526029737.000188",
        "text": "classy-prelude，最近もsafe-exceptions -&gt; UnliftIO.Exceptionの移行があったり，かなりAPI破壊してくるのが辛いですね",
        "user": "U57D08Z9U",
        "type": "message"
    },
    {
        "ts": "1526030366.000478",
        "text": "classy-preludeは、以前よりはマシになったとはいえ、リエクスポートも過剰で正直出来が悪いと思います",
        "user": "U4KUNQF9N",
        "type": "message"
    },
    {
        "ts": "1526031211.000072",
        "text": "個人的には，プロジェクトでかなり使用頻度の高い関数群や要請(保守性が高い方がいい/関数が所属してるモジュールの検索性は悪くてもいいので，Utilityが欲しい/dependencyが少ない方がいい)がかなり異なるので，プロジェクトごとにclassy-preludeなりbase-preludeなりをベースにPreludeモジュール作るのが好みですね",
        "user": "U57D08Z9U",
        "type": "message"
    },
    {
        "ts": "1526176535.000051",
        "text": "基本は普通のPreludeなんですが、idと(.)はControl.Categoryの奴が使いたくて毎回hidingしてますね……自分に合う奴を探した方がいいのでしょうか",
        "user": "U570660KX",
        "type": "message"
    },
    {
        "ts": "1526193310.000027",
        "text": "なるほど　後者は歯が立たないと思ったのは拙速でした　腰を据えて読み返してみれば　記法が異なるだけで `3.2 Fold` は確かに Parametricity と代数の可換性から自然に fusion が導かれているのが分かりました　重ねてご教示有難うございました",
        "user": "U584T7GAH",
        "type": "message"
    },
    {
        "ts": "1526200938.000058",
        "text": "<@UAN607HTJ> has joined the channel",
        "user": "UAN607HTJ",
        "type": "message"
    },
    {
        "ts": "1526277321.000233",
        "text": "カスタムPreludeは潜在的にバグとなりうる関数、型クラスと取り除いてるので安全なコードが書けるというのが１つの利点だと思います。(UniversumではShowの型クラスインスタンスを定義できない（導出のみ）し、NonEmptyのリストのみhead,tail等ができる）RIOに関してはいえばReaderTパターン（変換子の中でも鉄板パターン）をベースにいれています。\nただ地雷Preludeもあるので注意しないといけません。。！",
        "user": "U7Z4F723Z",
        "type": "message"
    },
    {
        "ts": "1526433975.000231",
        "text": "昨日の <https://haskell-jp.slack.com/archives/C4M4TT8JJ/p1526345560000259> で、fumiさんから助言を受けて、「型レベルリストから要素を取り除く型族Remove :: k -&gt; [k] -&gt; [k]」を書いているところなんです。\n値レベルの関数を割と愚直に翻訳してこんな :point_down: ところまで書きました（よそのライブラリーで実装済みじゃないのか、という気もしますが）。\n```\ntype family ConsUnless (b :: Bool) (x :: k) (xs :: [k]) :: [k] where\n  ConsUnless False x xs = (x ': xs)\n  ConsUnless True _ xs = xs\n\ntype family Reject (p :: (k -&gt; Bool)) (xs :: [k]) :: [k] where\n  Reject p '[] = '[]\n  Reject p (x ': xs) = ConsUnless (p x) x (Reject p xs)\n\ntype family Same (x :: k) (y :: k) :: Bool where\n  Same x x = 'True\n  Same x y = 'False\n\ntype family Without (x :: k) (xs :: [k]) :: [k] where\n  Without x xs = Reject (Same x) xs\n```\nで、コンパイルするとなぜか\n```\n    • The type family ‘Same’ should have 2 arguments, but has been given 1\n    • In the equations for closed type family ‘Without’\n      In the type family declaration for ‘Without’\n```\nというエラーが出ます。 `Same` が2つ引数をとるのはいいとして、 `Reject` の第一引数が引数を1つとる型族をとるよう宣言しているので、 `Same x` とすればいいんじゃないかと思えるのですが、なんでエラーになってしまうのでしょうか？",
        "user": "U4LGTMTMK",
        "type": "message"
    },
    {
        "ts": "1526434199.000320",
        "text": "補足: 名前が紛らわしくて申し訳ないんですが、 fumiさんのおっしゃる  `Remove` に相当するのは `Without` と呼んでいます。",
        "user": "U4LGTMTMK",
        "type": "message"
    },
    {
        "ts": "1526434824.000034",
        "text": "型族ってカリー化みたいなのできたっけ？",
        "user": "U56L7EVNY",
        "type": "message"
    },
    {
        "ts": "1526435256.000091",
        "text": "っぽいことが書いてある？\n<http://www.kotha.net/ghcguide_ja/latest/type-families.html#type-family-declarations>",
        "user": "U56L7EVNY",
        "type": "message"
    },
    {
        "ts": "1526440483.000050",
        "text": "僕はあんまり詳しく無いですが、確かこの論文に色々書いてあったような\nPromoting Functions to Type Families in Haskell\n<https://repository.brynmawr.edu/cgi/viewcontent.cgi?referer=&amp;httpsredir=1&amp;article=1000&amp;context=compsci_pubs>",
        "user": "U5B3EGEFQ",
        "type": "message"
    },
    {
        "ts": "1526449957.000060",
        "text": "型族は常に引数を飽和させる必要があります。エレガントさは損なわれますが、Withoutは直接定義することになると思います",
        "user": "U4KUNQF9N",
        "type": "message"
    },
    {
        "ts": "1526577909.000217",
        "text": "<@UADFT2WQ6> has joined the channel",
        "user": "UADFT2WQ6",
        "type": "message"
    },
    {
        "ts": "1526606658.000243",
        "text": "毎度ありがとうございます。\n「レコードから指定したキーの要素を取り除いたレコードを返す関数」作りの続きです。\n:point_down: のような、closedな型族と型クラスを組み合わせて、レコードが空の場合とそうでない場合とで実装をわけられるようにしました。\nが、残念ながら今度は実装で思わぬコンパイルエラーになってしまいます（エラーメッセージは後ほどコメントに張ります）\nおそらくもう一歩なところだと思うので、助言をいただきたく！\n```\ntype family Result (x :: k) (xs :: [k]) :: [k] where\n  Result x '[] = '[]\n  Result x (x ': xs) = Result x xs\n  Result x (y ': ys) = y ': Result x ys\n\nclass Without (x :: k) (xs :: [k]) where\n  without :: Membership xs x -&gt; (h :* xs) -&gt; (h :* Result x xs)\n\ninstance Without x '[] where\n  without _ _ = nil\n\ninstance Without x (x ': xs) where\n  without key rec =\n    let (_, ys) = huncons $ toHList rec\n    in without key (fromHList ys)\n\ninstance Without x (y ': ys) where\n  without key rec =\n    let (y, ys) = huncons $ toHList rec\n    in y &lt;: without key (fromHList ys)\n\nhuncons :: HList h (x ': xs) -&gt; (h x, HList h xs)\nhuncons (HCons hx hxs) = (hx, hxs)\n```",
        "user": "U4LGTMTMK",
        "type": "message"
    },
    {
        "ts": "1526606686.000117",
        "text": "エラーメッセージです :point_down: \n```\napp\\Main.hs:41:21: error:\n    ? Couldn't match type ‘xs’ with ‘x : xs’\n      ‘xs’ is a rigid type variable bound by\n        the instance declaration at app\\Main.hs:38:10-28\n      Expected type: h :* (x : xs)\n        Actual type: h :* xs\n    ? In the second argument of ‘without’, namely ‘(fromHList ys)’\n      In the expression: without key (fromHList ys)\n      In the expression:\n        let (_, ys) = huncons $ toHList rec in without key (fromHList ys)\n    ? Relevant bindings include\n        ys :: HList h xs (bound at app\\Main.hs:40:13)\n        rec :: h :* (x : xs) (bound at app\\Main.hs:39:15)\n        key :: Membership (x : xs) x (bound at app\\Main.hs:39:11)\n        without :: Membership (x : xs) x\n                   -&gt; (h :* (x : xs)) -&gt; h :* Result x (x : xs)\n          (bound at app\\Main.hs:39:3)\n   |\n41 |     in without key (fromHList ys)\n   |                     ^^^^^^^^^^^^\n\napp\\Main.hs:46:26: error:\n    ? Couldn't match type ‘ys’ with ‘y : ys’\n      ‘ys’ is a rigid type variable bound by\n        the instance declaration at app\\Main.hs:43:10-28\n      Expected type: h :* (y : ys)\n        Actual type: h :* ys\n    ? In the second argument of ‘without’, namely ‘(fromHList ys)’\n      In the second argument of ‘(&lt;:)’, namely\n        ‘without key (fromHList ys)’\n      In the expression: y &lt;: without key (fromHList ys)\n    ? Relevant bindings include\n        y :: h y (bound at app\\Main.hs:45:10)\n        ys :: HList h ys (bound at app\\Main.hs:45:13)\n        rec :: h :* (y : ys) (bound at app\\Main.hs:44:15)\n        key :: Membership (y : ys) x (bound at app\\Main.hs:44:11)\n        without :: Membership (y : ys) x\n                   -&gt; (h :* (y : ys)) -&gt; h :* Result x (y : ys)\n          (bound at app\\Main.hs:44:3)\n   |\n46 |     in y &lt;: without key (fromHList ys)\n```",
        "user": "U4LGTMTMK",
        "type": "message"
    },
    {
        "ts": "1526607469.000052",
        "text": "質問があります。\n\n練習のために、 stack resolver lts-11.9 の環境で数独に関するライブラリを作っています。\nいま、一つのセルの状態を表現するために Maybe を使おうと思ってます。\n例えば、あるセルに 1 が入っていれば Maybe 1 、空ならば Nothing という具合です。\n\nただ、そのままでは show した時に Maybe や Nothing が表示されてしまうので、\nこの表示を変えたいと思っています。\n例えば、 Maybe 1 ならば 1 、 Nothing ならば _ が出力されるという具合にです。\n出来れば read も同じように出来ると嬉しいです。\n\nMaybe 関連のライブラリ関数を使いたいので、さしあたって show と read の振る舞いだけ変えたいのです。\nこういった、ほとんど同じなんだけど、ほんの少し振る舞いが異なる型を表現したいときはどうしたら良いのでしょうか。\n\nよろしくお願いします。",
        "user": "UADFT2WQ6",
        "type": "message"
    },
    {
        "ts": "1526607546.000279",
        "text": "```\nnewtype Cell = Cell (Maybe Int)\n```\nですねぱっと思いつくのは。\n\n`newtype` とすることで、 `Cell` はまさにおっしゃるような、 「 `Maybe Int` と ほとんど同じなんだけど、ほんの少し振る舞いが異なる型」として定義できます。",
        "user": "U4LGTMTMK",
        "type": "message"
    },
    {
        "ts": "1526607966.000024",
        "text": "ただ、個人的には `Show` はあくまでもデバッグ用の文字列に変換するものとして使ったほうがよいのではないかと考えています。\nなので、 `newtype` でセル専用の型を用意するにせよしないにせよ、\n`Show` や `Read` のインスタンスを無理に書き換えずに、文字列からパースして作成したり文字列に変換する用の関数は独立して作った方がいいんじゃないかと思います。",
        "user": "U4LGTMTMK",
        "type": "message"
    },
    {
        "ts": "1526608361.000125",
        "text": "あんまりよくわかってないですが，\n```\ninstance Without x ys =&gt; Without x (y:ys) where\n```\nが正しいのではないでしょうか？(Overlappingしそうですが)",
        "user": "U57D08Z9U",
        "type": "message"
    },
    {
        "ts": "1526609227.000251",
        "text": "prettyprinter <https://hackage.haskell.org/package/prettyprinter> は、名前の通りShowよりも小奇麗に表示するのに適しています。整列表示などもできるのでお試しあれ",
        "user": "U4KUNQF9N",
        "type": "message"
    },
    {
        "ts": "1526611655.000184",
        "text": "<@U4LGTMTMK> pinned a message to this channel.",
        "user": "U4LGTMTMK",
        "type": "message"
    },
    {
        "ts": "1526612591.000094",
        "text": "文脈を把握してきたんですけど，うーん僕はあまり型レベルプログラミングには詳しくないんですが，hFilterは結構実装難しいんじゃないんですかね？上のエラーは，`Without x xs =&gt;` の制約がないため，xsに対してxのwithoutメソッドを呼べないエラーですが，おそらく呼べるようにしてみても\n```\ntype family Result (x :: k) (xs :: [k]) :: [k] where\n  Result x '[] = '[]\n  Result x (x ': xs) = Result x xs\n  Result x (y ': ys) = y ': Result x ys\n```\nのResult x (y ’: ys)の部分がかなり怪しくって，こいつをpolymorphicなままで呼び出すのはかなり技巧が必要だと思いますね",
        "user": "U57D08Z9U",
        "type": "message"
    },
    {
        "ts": "1526613189.000065",
        "text": "まあ少なくとも，上の例ほど単純には書けないんじゃないかな？と思います(なんらかの，type equalityをラップする処理が必要なんじゃないかなと思います)",
        "user": "U57D08Z9U",
        "type": "message"
    },
    {
        "ts": "1526619855.000021",
        "text": "ありがとうございます。newtype 使うといい感じに書けました。\n\n&gt; ただ、個人的には ｀Show｀ はあくまでもデバッグ用の文字列に変換するものとして使ったほうがよいのではないかと考えています。\n\nこれはなぜなんですかね? なんとなく Show や Read は標準のリーダ/ライタなのかなと思っていたのですが。\n\nprettyprinter ありがとうございます。見てみます。",
        "user": "UADFT2WQ6",
        "type": "message"
    },
    {
        "ts": "1526621056.000251",
        "text": "なんか，知識が錆びついてたみたいですね．昔は一苦労必要だった気がするんですが， <https://hackage.haskell.org/package/base-4.10.1.0/docs/Data-Type-Equality.html#t:-61--61-> を使えば結構簡単にいけましたね．FunctionalDependenciesを使うといけると思います(HListがその方式っぽいですね)",
        "user": "U57D08Z9U",
        "type": "message"
    },
    {
        "ts": "1526621270.000191",
        "text": "いちよ，書いたやつを置いときます(ただHListを参考にやって見た方が，分かりやすいかもしれません．あと，extensibleよく知らないんですがMembershipが内部で持ってる位置をfilter後に移してやる必要があったりするんじゃないんですかね？)\n<https://gist.github.com/mizunashi-mana/df1d54e87a9901b9f225f1ed658bdff6>",
        "user": "U57D08Z9U",
        "type": "message"
    },
    {
        "ts": "1526622308.000106",
        "text": "コードがちょっとミスってたんで，微修正しました",
        "user": "U57D08Z9U",
        "type": "message"
    },
    {
        "ts": "1526622632.000050",
        "text": "絶対にそうした方がいいというつもりではないですが、\n例えば `String` の `show` 関数は、受け取った文字列をそのまま返すのではなく、\nダブルクォートで囲ったり、エスケープシーケンスがわかりやすくなるように変換したりして返すようになっています。\nこれと同じように、大概の `Show` のインスタンスは、\n変換後の文字列から、何の型の値を変換したかがわかりやすいように作られています。\n`traceShowId` など `Show` のインスタンスをデバッグ用に使う関数に渡して表示させた際、（特に何カ所も出力させた場合に）どの型の値を出力したのか区別できるようにした方が、視認性が上がるためでしょう。\nなので、自前で定義するにしても、何の型の値から変換された文字列かがわかりやすいように作った方がよいかと思います。",
        "user": "U4LGTMTMK",
        "type": "message"
    },
    {
        "ts": "1526627317.000013",
        "text": "なるほど。 Show と Read はあくまで ghci 用だと考えたほうが良いってことですね。確かにそんな気がしてきました。ありがとうございます。",
        "user": "UADFT2WQ6",
        "type": "message"
    },
    {
        "ts": "1526961523.000255",
        "text": "Readを自前実装しようとするとその型のリストをRead対応させるのがめっちゃ面倒という問題もあります",
        "user": "U57CUMWQ6",
        "type": "message"
    },
    {
        "ts": "1526965523.000272",
        "text": "そうなんですよねぇ。\nただ、（おそらく）今回のように1アプリケーションでしか使わないデータ型であれば、あえて `Read` のインスタンスにする必要はないだろうな、と思って触れてませんでした。",
        "user": "U4LGTMTMK",
        "type": "message"
    },
    {
        "ts": "1527990588.000004",
        "text": "ライフゲームを作りたいんですが、そのためのGUIライブラリでいいものはありますか？",
        "user": "U5LEE6C1J",
        "type": "message"
    },
    {
        "ts": "1527990811.000086",
        "text": "僕はglossをよく使ってます！\n<https://hackage.haskell.org/package/gloss>\nライフゲームならこの simulate って関数を使えば楽に実装できるんじゃないかなと思います~!\n<https://hackage.haskell.org/package/gloss-1.12.0.0/docs/Graphics-Gloss.html#v:simulate>",
        "user": "U4KPPQW7K",
        "type": "message"
    },
    {
        "ts": "1527991129.000018",
        "text": "早い返信ありがとうございます！想定している機能は停止/再開ボタンとクリックによるセルの反転が含まれているので すが、それもまた play で実現できそうですね！",
        "user": "U5LEE6C1J",
        "type": "message"
    },
    {
        "ts": "1527991162.000072",
        "text": "はい、playで実現できると思います :raised_hands:",
        "user": "U4KPPQW7K",
        "type": "message"
    },
    {
        "ts": "1528066580.000111",
        "text": "glossを依存関係に加えた後にビルドしようとしたら、freeglutをインストールしていなかったために推移依存関係によるGLUTのビルド時に何かが壊れたようで、precompiled packageが全部読み込めなくなったみたいです。",
        "user": "U5LEE6C1J",
        "type": "message"
    },
    {
        "ts": "1528066600.000063",
        "text": "glossを依存関係に加えたプロジェクトをstack buildでビルドした後に実行しようとしたらuser error (unknown GLUT entry glutInit)が出たため調べたらglutのインストールがいるよと出たため、一旦やめて他のプロジェクトをstack buildでビルドしようとしたら",
        "user": "U5LEE6C1J",
        "type": "message"
    },
    {
        "ts": "1528066615.000083",
        "text": "ghc-paths-0.1.0.9: using precompiled package\nghc-pkg.EXE: cannot find package ghc-paths-0.1.0.9",
        "user": "U5LEE6C1J",
        "type": "message"
    },
    {
        "ts": "1528066631.000114",
        "text": "このようなエラーメッセージが出てきまして、他のプロジェクトでも同様の状況でした。",
        "user": "U5LEE6C1J",
        "type": "message"
    },
    {
        "ts": "1528066660.000092",
        "text": "TravisCI上でも再現しました <https://travis-ci.org/Hexirp/hasga/jobs/387543428#L449>",
        "user": "U5LEE6C1J",
        "type": "message"
    },
    {
        "ts": "1528068062.000020",
        "text": "とりあえず .stack-work を消したり\n~/.stack/ を消してみる、ですかね。。。",
        "user": "U4LGTMTMK",
        "type": "message"
    },
    {
        "ts": "1528084166.000064",
        "text": "アドバイスありがとうございます。色々試してみたところ <https://haskell.e-bigmoon.com/stack/tips/full-rebuild.html> の一番下で直りました",
        "user": "U5LEE6C1J",
        "type": "message"
    },
    {
        "ts": "1528162418.000100",
        "text": "extensibleについて再び質問です。\n`Associate k v xs =&gt; FieldName k -&gt; Record xs -&gt; v`\nという型の関数を書くにはどうすればよいでしょうか？\n`FieldName k` はざっくりいうと `Optic` の 型シノニムなので普通のlensや `mkField` で作られたフィールドらしく\n`record ^. field` みたいな式で取り出せるかな、と思ったのですが、\n```\napp\\record-placeholder.hs:53:23: error:\n    • Couldn't match type ‘LabelPhantom\n                             k1\n                             (Inextensible (Field Proxy) '[k1 ':&gt; ()])\n                             (Proxy (Inextensible (Field Proxy) '[k1 ':&gt; ()]))’\n                     with ‘Record xs -&gt; Const a0 (Record xs)’\n      Expected type: Control.Lens.Getter.Getting a0 (Record xs) a0\n        Actual type: FieldName k1\n```\nという内容のコンパイルエラーで怒られてしまいました :disappointed:",
        "user": "U4LGTMTMK",
        "type": "message"
    },
    {
        "ts": "1528162496.000252",
        "text": "OverloadedLabels を使わずに？",
        "user": "U56L7EVNY",
        "type": "message"
    },
    {
        "ts": "1528162929.000044",
        "text": "使っています。\nで、 `FieldName` は `#field` のように `OverloadedLables` で多相化された状態ではなく、 `field :: FieldName k` という型の変数として渡されます。\nそこを `FieldName k` 以外の型にした方がいいんだろうか...",
        "user": "U4LGTMTMK",
        "type": "message"
    },
    {
        "ts": "1528163053.000057",
        "text": "FieldNameは`FieldOptic`の特殊な場合で、Proxyと基本的に同じ役割を持ちます。`FieldOptic`の方はLensの機能を持っています",
        "user": "U4KUNQF9N",
        "type": "message"
    },
    {
        "ts": "1528163331.000138",
        "text": "もしかして謎の `訊` <https://hackage.haskell.org/package/extensible-0.4.9/docs/Data-Extensible-Label.html#v:-35338-> \nで変換するのが正解なんでしょうか？",
        "user": "U4LGTMTMK",
        "type": "message"
    },
    {
        "ts": "1528171038.000017",
        "text": "引数がFieldNameでないといけないなら、itemAssoc(訊)で変換する必要がありますが、そうでない場合型をFieldOpticにすれば大丈夫だと思います",
        "user": "U4KUNQF9N",
        "type": "message"
    },
    {
        "ts": "1528285816.000488",
        "text": "<@UB2C2BN2G> has joined the channel",
        "user": "UB2C2BN2G",
        "type": "message"
    },
    {
        "ts": "1528355863.000138",
        "text": "言い忘れていましたが 、オプティックを多相なまま引数に取るのはアンチパターンと考えられているようです(ALensなどがあるのはそのため)。そこを考慮すると、 `FieldName k` を引数に取って、 `hlookup (associate :: Membership xs (k ':&gt; v)` と書くのがよさそうです",
        "user": "U4KUNQF9N",
        "type": "message"
    },
    {
        "ts": "1528356351.000309",
        "text": "ありがとうございます。\n報告が遅くなりましたが、私の用途で `FieldOptic k` を引数にすると `v` の型がうまく定まらないのかコンパイルエラーになってしまったので、\n`rec ^. itemAssoc (Proxy :: Proxy k)` と書いて解決しました。\n（ `Associate k v xs =&gt;` というコンテキストだったので）",
        "user": "U4LGTMTMK",
        "type": "message"
    },
    {
        "ts": "1528552108.000042",
        "text": "<@UB5NQ764F> has joined the channel",
        "user": "UB5NQ764F",
        "type": "message"
    },
    {
        "ts": "1528683298.000064",
        "text": "Is there a way to inspect the definition of derived instances?\nSay:\n```data Free f a = Pure a | Free (f (Free f a)) deriving Functor```",
        "user": "UACQ9J5D3",
        "type": "message"
    },
    {
        "ts": "1528683717.000158",
        "text": "you can use the -ddump-deriv option: <https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/debugging.html?highlight=#ghc-flag--ddump-deriv>",
        "user": "U4M9NJ7QE",
        "type": "message"
    },
    {
        "ts": "1528683781.000054",
        "text": "Thanks!",
        "user": "UACQ9J5D3",
        "type": "message"
    },
    {
        "ts": "1529254455.000129",
        "text": "```\ndata Tree a = Node a Tree Tree | Leaf a\n```\nのような循環した構造をextensibleで宣言するにはどうすればいいでしょうか？typeで愚直に宣言すると循環していると言ってエラーが出てしまったのですが……",
        "user": "U56G77VM1",
        "type": "message"
    },
    {
        "ts": "1529283483.000115",
        "text": "```data T a = N a (T a) (T a) | L a```\n多分こういう意味では？",
        "user": "UACQ9J5D3",
        "type": "message"
    },
    {
        "ts": "1529283573.000201",
        "text": "data constructor fields の kind は `*` が必要",
        "user": "UACQ9J5D3",
        "type": "message"
    },
    {
        "ts": "1529292139.000068",
        "text": "newtypeするのが無難です。data familyを活用して、再帰する為のラッパーを作るという力技もできなくはないです",
        "user": "U4KUNQF9N",
        "type": "message"
    },
    {
        "ts": "1529304365.000096",
        "text": "ありがとうございます！",
        "user": "U56G77VM1",
        "type": "message"
    },
    {
        "ts": "1529466454.000056",
        "text": "Equality constraintsに関する質問です。型変数aはFoo型もしくはBar型であるって制約を課すことは可能なのでしょうか。。`someFun :: (a ~ (Foo || Bar), Monad m) =&gt; m a` みたいな",
        "user": "U7Z4F723Z",
        "type": "message"
    },
    {
        "ts": "1529476423.000236",
        "text": "実行環境ないので試してないのですが\n```\nimport Data.Type.Bool\nimport Data.Type.Equality\n\nsomeFun :: (a == Foo || a == Bar) ~ True =&gt; ...\n```\nとかはどうでしょう？",
        "user": "U57D08Z9U",
        "type": "message"
    },
    {
        "ts": "1529479081.000043",
        "text": "閉じた型族を使えば実現できます。\n```\n{-# LANGUAGE ConstraintKinds, TypeFamilies #-}\nimport Data.Constraint\ndata Foo\ndata Bar\n\ntype family IsFooOrBar x :: Constraint where\n  IsFooOrBar Foo = ()\n  IsFooOrBar Bar = ()\n  IsFooOrBar x = Bottom\n\nsomeFun :: (IsFooOrBar a, Monad m) =&gt; m a\nsomeFun = undefined\n```",
        "user": "U4KUNQF9N",
        "type": "message"
    },
    {
        "ts": "1529479221.000099",
        "text": "わーありがとう。やってみます！",
        "user": "U7Z4F723Z",
        "type": "message"
    },
    {
        "ts": "1529629607.000072",
        "text": "でも、その制約をしたら、後からどうやってFooとBarの型に取れるの？",
        "user": "UACQ9J5D3",
        "type": "message"
    },
    {
        "ts": "1529660416.000597",
        "text": "open-unionを使うのが実用的で手っ取り早い解?\nしかしこれもliftUnionを通すので引数そのまま渡すわけではないですね…\nHaskellのジェネリクスは異種変換ではないですし,Rustのトレイトオブジェクトみたいなのを導入してしまったら結局は動的ディスパッチになる\nパターンマッチとかで型によって静的分岐出来たらそれは実質的な関数オーバーロードですね\nHaskellに関数オーバーロード入れてしまって良いんだっけ…?",
        "user": "U57CUMWQ6",
        "type": "message"
    },
    {
        "ts": "1529661544.000209",
        "text": "<@UBD63QPAS> has joined the channel",
        "user": "UBD63QPAS",
        "type": "message"
    },
    {
        "ts": "1529698010.000096",
        "text": "<https://gist.github.com/notogawa/2fbf7b24cd4697d70dc70dc46c91bd04>",
        "user": "U5G2BCVBN",
        "type": "message"
    },
    {
        "ts": "1529737751.000045",
        "text": "ansi-wl-pprint -&gt; prettyprinter + prettyprinter-ansi-terminalの話が出てますが，ansi-wl-pprintのDocをprettyprinter + prettyprinter-ansi-terminalのDoc AnsiStyleに変換する関数って誰か作ってたりしますかね？(諸事情で変換したくて自分では書きたくないのですが)\n<https://github.com/ekmett/ansi-wl-pprint/issues/18>",
        "user": "U57D08Z9U",
        "type": "message"
    },
    {
        "ts": "1529743351.000032",
        "text": "ありがとうございます、解決しました！\nざっくり説明しますと、\n- サポートデスクからユーザー及び送られてきたチケットを解析するアプリを開発している。\n- サポートデスクのAPIでチケットをフェッチすると以下のデータが得られる。\nチケット\n```\n{ \"tickets\":[],\n  \"next_page\": some_url\n}\n```\nユーザー\n```\n{ \"users\":[],\n  \"next_page\": some_url\n}\n```\n最初別々の関数で取得してたけど、一般化させようって話になった。\nこれがその結果です。発送はnotogawaさんが教えてくれたものと似ていると思います。\n(`iteratePages`が取得関数です。)\n<https://github.com/input-output-hk/log-classifier/pull/19/commits/ef7b8e54df080e476053df1fdb3c9909bfd8f340>",
        "user": "U7Z4F723Z",
        "type": "message"
    }
]