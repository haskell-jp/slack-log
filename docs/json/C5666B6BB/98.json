[
    {
        "ts": "1626744914.004600",
        "text": "<@U028RHBT7TN> has joined the channel",
        "user": "U028RHBT7TN",
        "type": "message"
    },
    {
        "ts": "1626746071.010100",
        "text": "persistentについて、というよりデータベースについての質問です。\n直和型のデータをデータベースに保存したい場合、どのデータベースを使うのがいいのでしょうか？\n\npersistentだとpersistValue型に直和を表すものがなく、というよりそもそもRDBでは直和型を直接サポートしていない(RDBの元となった関係モデルでは演算として直和を考慮していないと思われる)ので、Maybe型などを使って無理やり表現する以外に方法がないように思えるのですが、\nRDB以外のデータベースならサポートしているのかなと。\n\n何か意見をいただければ幸いです。",
        "user": "U01R1UNMVT5",
        "type": "message"
    },
    {
        "ts": "1627123361.013400",
        "text": "<@U029FC0MNSD> has joined the channel",
        "user": "U029FC0MNSD",
        "type": "message"
    },
    {
        "ts": "1627477751.014200",
        "text": "<@U029TR373Q9> has joined the channel",
        "user": "U029TR373Q9",
        "type": "message"
    },
    {
        "ts": "1627495619.014400",
        "text": "<@U02A69TE1NU> has joined the channel",
        "user": "U02A69TE1NU",
        "type": "message"
    },
    {
        "ts": "1627983207.003000",
        "text": "上の質問の直和型をデータベースに保存する話ですが、返答いただいた方法と別の方法(私がやりたかった方法)を見つけたので、Qiitaで記事にしてみました。\nこの方法ならHaskell上で自然に直和型が扱えると思います。\nぜひ、ご意見などいただけると幸いです。\n<https://qiita.com/nekonibox/items/297c1d2d44b273be2571>",
        "user": "U01R1UNMVT5",
        "type": "message"
    },
    {
        "ts": "1628448546.006000",
        "text": "<@U02AXB3D9T3> has joined the channel",
        "user": "U02AXB3D9T3",
        "type": "message"
    },
    {
        "ts": "1628844222.006400",
        "text": "<@U02B9UAPCQ4> has joined the channel",
        "user": "U02B9UAPCQ4",
        "type": "message"
    },
    {
        "ts": "1628948307.013400",
        "text": "<@U02B78W3F7U> has joined the channel",
        "user": "U02B78W3F7U",
        "type": "message"
    },
    {
        "ts": "1629203519.013600",
        "text": "<@U02C4FQFQSC> has joined the channel",
        "user": "U02C4FQFQSC",
        "type": "message"
    },
    {
        "ts": "1629382086.013800",
        "text": "<@U02CE9YGEAU> has joined the channel",
        "user": "U02CE9YGEAU",
        "type": "message"
    },
    {
        "ts": "1629445493.014000",
        "text": "<@U02BM7FC8HL> has joined the channel",
        "user": "U02BM7FC8HL",
        "type": "message"
    },
    {
        "ts": "1629447450.023800",
        "text": "はじめまして、Kasshiと申します。\nある時Free Arrowをつかいたくなって次のようなコードを書いてみたのですが、\n`{-# LANGUAGE RankNTypes #-}`\n`import Control.Category hiding (id ,(.))`\n`import qualified Control.Category as Cat`\n\n`newtype A f a b = Arr {unA :: forall r. Arrow r =&gt; (forall x y. f x y -&gt; r x y) -&gt; r a b}`\n`instance Category (A f) where`\n   `id = Arr $ const Cat.id`\n   `Arr g . Arr f = Arr $ \\p -&gt; f p &gt;&gt;&gt; g p`\nCategoryのidのconst関数のところでGHCに\n&gt; Couldn't match type 'b0' with 'forall x y. f x y -&gt; r x y'\nと怒られてしまいました。\n\nそこで`const Cat.id` を`\\ _ -&gt; Cat.id` と書き換えるとコンパイルが通りました。\n多相関数がうまく型推論されていないことが原因と思われますが、これは仕様なのかバグなのかが分かりません。\n知見をお持ちの方はご意見頂けると幸いです。",
        "user": "U02BM7FC8HL",
        "type": "message"
    },
    {
        "ts": "1629445493.014000",
        "text": "<@U02BM7FC8HL> has joined the channel",
        "user": "U02BM7FC8HL",
        "type": "message"
    },
    {
        "ts": "1629447450.023800",
        "text": "はじめまして、Kasshiと申します。\nある時Free Arrowをつかいたくなって次のようなコードを書いてみたのですが、\n`{-# LANGUAGE RankNTypes #-}`\n`import Control.Category hiding (id ,(.))`\n`import qualified Control.Category as Cat`\n\n`newtype A f a b = Arr {unA :: forall r. Arrow r =&gt; (forall x y. f x y -&gt; r x y) -&gt; r a b}`\n`instance Category (A f) where`\n   `id = Arr $ const Cat.id`\n   `Arr g . Arr f = Arr $ \\p -&gt; f p &gt;&gt;&gt; g p`\nCategoryのidのconst関数のところでGHCに\n&gt; Couldn't match type 'b0' with 'forall x y. f x y -&gt; r x y'\nと怒られてしまいました。\n\nそこで`const Cat.id` を`\\ _ -&gt; Cat.id` と書き換えるとコンパイルが通りました。\n多相関数がうまく型推論されていないことが原因と思われますが、これは仕様なのかバグなのかが分かりません。\n知見をお持ちの方はご意見頂けると幸いです。",
        "user": "U02BM7FC8HL",
        "type": "message"
    },
    {
        "ts": "1629622740.025700",
        "text": "<@U02BHPK5FC7> has joined the channel",
        "user": "U02BHPK5FC7",
        "type": "message"
    },
    {
        "ts": "1629627147.025900",
        "text": "<@U02BHQWT7FH> has joined the channel",
        "user": "U02BHQWT7FH",
        "type": "message"
    },
    {
        "ts": "1629960259.000200",
        "text": "<@U02CEDPRE2F> has joined the channel",
        "user": "U02CEDPRE2F",
        "type": "message"
    },
    {
        "ts": "1630058889.000400",
        "text": "<@U02CYC28073> has joined the channel",
        "user": "U02CYC28073",
        "type": "message"
    },
    {
        "ts": "1630128883.000600",
        "text": "<@U55U5BL3A> has joined the channel",
        "user": "U55U5BL3A",
        "type": "message"
    },
    {
        "ts": "1630432098.002600",
        "text": "<@U02D4U38VA8> has joined the channel",
        "user": "U02D4U38VA8",
        "type": "message"
    },
    {
        "ts": "1630833330.002800",
        "text": "<@U02DU0C2JEM> has joined the channel",
        "user": "U02DU0C2JEM",
        "type": "message"
    },
    {
        "ts": "1630956334.008400",
        "text": "お疲れ様です。\npythonとかのfor文 とbreak / continue / returnのコード（for ループから脱出するコード）をhaskellに持ってくる場合に\n再帰をつかわないならthrow, catchしかないですかね。\n（それで置き換えている人はひとはみたことがないですが。）\n初学者ではよく変数の代入が問題になりますが、\nこのあたり(for文)を初学者は悩んでないのか、どう折り合いをつけているのか気になっております。\nocamlさんもscalaさんもfor ループから脱出するという概念がないようですね。\n<https://ocaml.org/learn/tutorials/if_statements_loops_and_recursion.ja.html>\n<https://scala-text.github.io/scala_text/control-syntax.html>\nfor文を再帰に置き換えるテンプレとかあるのでしょう？",
        "user": "U74KTAG0N",
        "type": "message"
    },
    {
        "ts": "1631025477.010600",
        "text": "<@U02DJEVKQ2Z> has joined the channel",
        "user": "U02DJEVKQ2Z",
        "type": "message"
    }
]